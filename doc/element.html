<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>odfdo.element API documentation</title>
<meta name="description" content="Element, super class of all ODF classes" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>odfdo.element</code></h1>
</header>
<section id="section-intro">
<p>Element, super class of all ODF classes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2018-2023 Jérôme Dumonteil
# Copyright (c) 2009-2013 Ars Aperta, Itaapy, Pierlis, Talend.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Authors (odfdo project): jerome.dumonteil@gmail.com
# The odfdo project is a derivative work of the lpod-python project:
# https://github.com/lpod/lpod-python
# Authors: Hervé Cauwelier &lt;herve@itaapy.com&gt;
#          Romain Gauthier &lt;romain@itaapy.com&gt;
#          Jerome Dumonteil &lt;jerome.dumonteil@itaapy.com&gt;
&#34;&#34;&#34;Element, super class of all ODF classes
&#34;&#34;&#34;
import contextlib
import re
import sys
from copy import deepcopy

from lxml.etree import Element as lxml_Element
from lxml.etree import (
    XPath,
    _Element,
    _ElementStringResult,
    _ElementUnicodeResult,
    fromstring,
    tostring,
)

from .datatype import Boolean, DateTime
from .utils import (
    FAMILY_ODF_STD,
    _family_style_tagname,
    _get_element,
    _get_elements,
    get_value,
    to_bytes,
    to_str,
)

ODF_NAMESPACES = {
    &#34;anim&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:animation:1.0&#34;,
    &#34;calcext&#34;: &#34;urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0&#34;,
    &#34;chart&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:chart:1.0&#34;,
    &#34;config&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:config:1.0&#34;,
    &#34;css3t&#34;: &#34;http://www.w3.org/TR/css3-text/&#34;,
    &#34;dc&#34;: &#34;http://purl.org/dc/elements/1.1/&#34;,
    &#34;dom&#34;: &#34;http://www.w3.org/2001/xml-events&#34;,
    &#34;dr3d&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0&#34;,
    &#34;draw&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:drawing:1.0&#34;,
    &#34;drawooo&#34;: &#34;http://openoffice.org/2010/draw&#34;,
    &#34;field&#34;: &#34;urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0&#34;,
    &#34;fo&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0&#34;,
    &#34;form&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:form:1.0&#34;,
    &#34;formx&#34;: &#34;urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0&#34;,
    &#34;grddl&#34;: &#34;http://www.w3.org/2003/g/data-view#&#34;,
    &#34;loext&#34;: &#34;urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0&#34;,
    &#34;manifest&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:manifest:1.0&#34;,
    &#34;math&#34;: &#34;http://www.w3.org/1998/Math/MathML&#34;,
    &#34;meta&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:meta:1.0&#34;,
    &#34;number&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0&#34;,
    &#34;of&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:of:1.2&#34;,
    &#34;office&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:office:1.0&#34;,
    &#34;officeooo&#34;: &#34;http://openoffice.org/2009/office&#34;,
    &#34;ooo&#34;: &#34;http://openoffice.org/2004/office&#34;,
    &#34;oooc&#34;: &#34;http://openoffice.org/2004/calc&#34;,
    &#34;ooow&#34;: &#34;http://openoffice.org/2004/writer&#34;,
    &#34;presentation&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:presentation:1.0&#34;,
    &#34;rdfa&#34;: &#34;http://docs.oasis-open.org/opendocument/meta/rdfa#&#34;,
    &#34;rpt&#34;: &#34;http://openoffice.org/2005/report&#34;,
    &#34;script&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:script:1.0&#34;,
    &#34;smil&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:smil-compatible:1.0&#34;,
    &#34;style&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:style:1.0&#34;,
    &#34;svg&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0&#34;,
    &#34;table&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:table:1.0&#34;,
    &#34;tableooo&#34;: &#34;http://openoffice.org/2009/table&#34;,
    &#34;text&#34;: &#34;urn:oasis:names:tc:opendocument:xmlns:text:1.0&#34;,
    &#34;xforms&#34;: &#34;http://www.w3.org/2002/xforms&#34;,
    &#34;xlink&#34;: &#34;http://www.w3.org/1999/xlink&#34;,
    &#34;xml&#34;: &#34;http://www.w3.org/XML/1998/namespace&#34;,
    &#34;xsd&#34;: &#34;http://www.w3.org/2001/XMLSchema&#34;,
    &#34;xsi&#34;: &#34;http://www.w3.org/2001/XMLSchema-instance&#34;,
}
FIRST_CHILD = 0
LAST_CHILD = 1
NEXT_SIBLING = 2
PREV_SIBLING = 3
STOPMARKER = 5

ns_stripper = re.compile(r&#39; xmlns:\w*=&#34;[\w:\-\/\.#]*&#34;&#39;)

__xpath_query_cache = {}

# An empty XML document with all namespaces declared
NAMESPACES_XML = b&#34;&#34;&#34;&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;office:document
  xmlns:office=&#34;urn:oasis:names:tc:opendocument:xmlns:office:1.0&#34;
  xmlns:style=&#34;urn:oasis:names:tc:opendocument:xmlns:style:1.0&#34;
  xmlns:text=&#34;urn:oasis:names:tc:opendocument:xmlns:text:1.0&#34;
  xmlns:table=&#34;urn:oasis:names:tc:opendocument:xmlns:table:1.0&#34;
  xmlns:draw=&#34;urn:oasis:names:tc:opendocument:xmlns:drawing:1.0&#34;
  xmlns:fo=&#34;urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0&#34;
  xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;
  xmlns:dc=&#34;http://purl.org/dc/elements/1.1/&#34;
  xmlns:meta=&#34;urn:oasis:names:tc:opendocument:xmlns:meta:1.0&#34;
  xmlns:number=&#34;urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0&#34;
  xmlns:presentation=&#34;urn:oasis:names:tc:opendocument:xmlns:presentation:1.0&#34;
  xmlns:svg=&#34;urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0&#34;
  xmlns:chart=&#34;urn:oasis:names:tc:opendocument:xmlns:chart:1.0&#34;
  xmlns:dr3d=&#34;urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0&#34;
  xmlns:math=&#34;http://www.w3.org/1998/Math/MathML&#34;
  xmlns:form=&#34;urn:oasis:names:tc:opendocument:xmlns:form:1.0&#34;
  xmlns:script=&#34;urn:oasis:names:tc:opendocument:xmlns:script:1.0&#34;
  xmlns:ooo=&#34;http://openoffice.org/2004/office&#34;
  xmlns:oooc=&#34;http://openoffice.org/2004/calc&#34;
  xmlns:ooow=&#34;http://openoffice.org/2004/writer&#34;
  xmlns:xforms=&#34;http://www.w3.org/2002/xforms&#34;
  xmlns:xsd=&#34;http://www.w3.org/2001/XMLSchema&#34;
  xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
  xmlns:smil=&#34;urn:oasis:names:tc:opendocument:xmlns:smil-compatible:1.0&#34;
  xmlns:anim=&#34;urn:oasis:names:tc:opendocument:xmlns:animation:1.0&#34;
  xmlns:rpt=&#34;http://openoffice.org/2005/report&#34;
  xmlns:of=&#34;urn:oasis:names:tc:opendocument:xmlns:of:1.2&#34;
  xmlns:xhtml=&#34;http://www.w3.org/1999/xhtml&#34;
  xmlns:grddl=&#34;http://www.w3.org/2003/g/data-view#&#34;
  xmlns:officeooo=&#34;http://openoffice.org/2009/office&#34;
  xmlns:tableooo=&#34;http://openoffice.org/2009/table&#34;
  xmlns:drawooo=&#34;http://openoffice.org/2010/draw&#34;
  xmlns:calcext=&#34;urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0&#34;
  xmlns:loext=&#34;urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0&#34;
  xmlns:field=&#34;urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0&#34;
  xmlns:formx=&#34;urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0&#34;
  xmlns:css3t=&#34;http://www.w3.org/TR/css3-text/&#34;
  xmlns:config=&#34;urn:oasis:names:tc:opendocument:xmlns:config:1.0&#34;
  xmlns:dom=&#34;http://www.w3.org/2001/xml-events&#34;
  xmlns:manifest=&#34;urn:oasis:names:tc:opendocument:xmlns:manifest:1.0&#34;
  xmlns:rdfa=&#34;http://docs.oasis-open.org/opendocument/meta/rdfa#&#34;
  office:version=&#34;1.1&#34;&gt;%s&lt;/office:document&gt;
&#34;&#34;&#34;


def _decode_qname(qname):
    &#34;&#34;&#34;Turn a prefixed qualified name to a (uri, name) pair.&#34;&#34;&#34;
    qname = to_str(qname)
    if &#34;:&#34; in qname:
        prefix, name = qname.split(&#34;:&#34;)
        try:
            uri = ODF_NAMESPACES[prefix]
        except KeyError as e:
            raise ValueError(f&#39;XML prefix &#34;{prefix}&#34; is unknown&#39;) from e
        return uri, name
    return None, qname


def _uri_to_prefix(uri):
    &#34;&#34;&#34;Find the prefix associated to the given URI.&#34;&#34;&#34;
    for key, value in ODF_NAMESPACES.items():
        if value == uri:
            return key
    raise ValueError(&#39;uri &#34;%s&#34; not found&#39; % uri)


def _get_prefixed_name(tag):
    &#34;&#34;&#34;Replace lxml &#34;{uri}name&#34; syntax with &#34;prefix:name&#34; one.&#34;&#34;&#34;
    uri, name = to_str(tag).split(&#34;}&#34;, 1)
    prefix = _uri_to_prefix(uri[1:])
    return f&#34;{prefix}:{name}&#34;


def _get_lxml_tag(qname):
    &#34;&#34;&#34;Replace &#34;prefix:name&#34; syntax with lxml &#34;{uri}name&#34; one.&#34;&#34;&#34;
    return &#34;{%s}%s&#34; % _decode_qname(qname)  # noqa:UP031


def _xpath_compile(path):
    return XPath(to_str(path), namespaces=ODF_NAMESPACES, regexp=False)


def _find_query_in_cache(query):
    xpath = __xpath_query_cache.get(query, None)
    if xpath is None:
        xpath = _xpath_compile(query)
        __xpath_query_cache[query] = xpath
    return xpath


_xpath_text = _find_query_in_cache(&#34;//text()&#34;)  #  descendant and self
_xpath_text_descendant = _find_query_in_cache(&#34;descendant::text()&#34;)
_xpath_text_main = _find_query_in_cache(&#34;//*[not (parent::office:annotation)]/text()&#34;)
_xpath_text_main_descendant = _find_query_in_cache(
    &#34;descendant::text()[not (parent::office:annotation)]&#34;
)

_class_registry = {}


def register_element_class(cls, tag_list=None):
    &#34;&#34;&#34;Associate a qualified element name to a Python class that handles this
    type of element.

    Getting the right Python class when loading an existing ODF document is
    then transparent. Unassociated elements will be handled by the base
    Element class.

    Most styles use the &#34;style:style&#34; qualified name and only differ by their
    &#34;style:family&#34; attribute. So the &#34;family&#34; attribute was added to register
    specialized style classes.

    Arguments:

        cls -- Python class

        qname -- (optionnal) iterable of qname tag for the class
    &#34;&#34;&#34;
    # Turn tag name into what lxml is expecting
    if not tag_list:
        tag_list = [cls._tag]
    for k in tag_list:
        tag = _get_lxml_tag(k)
        if tag not in _class_registry:
            _class_registry[tag] = cls


# TODO remove some day
def _debug_element(tag_or_elem):
    return repr(Element(tag_or_elem=tag_or_elem).serialize(pretty=True))


def _debug_registry():
    for k, v in _class_registry.items():
        print(&#34;%50s&#34; % v, _get_prefixed_name(k))


class Text(str):
    &#34;&#34;&#34;Representation of an XML text node. Created to hide the specifics of
    lxml in searching text nodes using XPath.

    Constructed like any str object but only accepts lxml text objects.
    &#34;&#34;&#34;

    # There&#39;s some black magic in inheriting from str
    def __init__(self, text_result):
        self.__parent = text_result.getparent()
        self.__is_text = text_result.is_text
        self.__is_tail = text_result.is_tail

    @property
    def parent(self):
        parent = self.__parent
        # XXX happens just because of the unit test
        if parent is None:
            return None
        return Element.from_tag(tag_or_elem=parent)

    def is_text(self):
        return self.__is_text

    def is_tail(self):
        return self.__is_tail


class Element:
    &#34;&#34;&#34;Super class of all ODF classes. Representation of an XML element.
    Abstraction of the XML library behind.
    &#34;&#34;&#34;

    _tag = None
    _caching = False

    def __init__(self, **kwargs):
        tag_or_elem = kwargs.pop(&#34;tag_or_elem&#34;, None)
        if tag_or_elem is None:
            # Instance for newly created object: create new lxml element and
            # continue by subclass __init__
            # If the tag key word exists, make a custom element
            self._do_init = True
            tag = kwargs.pop(&#34;tag&#34;, self._tag)
            self.__element = self.make_etree_element(tag)
        else:
            # called with an existing lxml element, sould be a result of
            # from_tag() casting, do not execute the subclass __ini__
            if not isinstance(tag_or_elem, _Element):
                raise TypeError(&#39;&#34;%s&#34; is not an element node&#39; % type(tag_or_elem))
            self._do_init = False
            self.__element = tag_or_elem

    @classmethod
    def from_tag(cls, tag_or_elem):
        &#34;&#34;&#34;Element class and subclass factory. Turn an lxml Element or ODF
        string tag into an ODF XML Element from the relevant class.

        Arguments:

            tag_or_elem -- ODF str tag or lxml.Element

        Return: Element (or subclass) instance
        &#34;&#34;&#34;
        if not isinstance(tag_or_elem, _Element):
            # assume the argument is a prefix:name tag
            tag_or_elem = cls.make_etree_element(tag_or_elem)
        tag = to_str(tag_or_elem.tag)
        klass = _class_registry.get(tag, cls)
        return klass(tag_or_elem=tag_or_elem)

    @classmethod
    def from_tag_for_clone(cls, tag_or_elem, cache):
        tag = to_str(tag_or_elem.tag)
        klass = _class_registry.get(tag, cls)
        element = klass(tag_or_elem=tag_or_elem)
        if cache and element._caching:
            element._tmap = cache[0]
            element._cmap = cache[1]
            if len(cache) == 3:
                element._rmap = cache[2]
        return element

    @staticmethod
    def make_etree_element(tag):
        if not isinstance(tag, (str, bytes)):
            raise TypeError(&#34;tag is not str or bytes: %s&#34; % tag)
        tag = to_bytes(tag).strip()
        if not tag:
            raise ValueError(&#34;tag is empty&#34;)
        if b&#34;&lt;&#34; not in tag:
            # Qualified name
            # XXX don&#39;t build the element from scratch or lxml will pollute with
            # repeated namespace declarations
            tag = b&#34;&lt;%s/&gt;&#34; % tag
        # XML fragment
        root = fromstring(NAMESPACES_XML % tag)  # noqa:S320
        return root[0]

    def __str__(self):
        return f&#39;{self!r} &#34;{self.tag}&#34;&#39;

    @staticmethod
    def _generic_attrib_getter(attr_name, family=None):
        name = _get_lxml_tag(attr_name)

        def getter(self):
            if family and self.family != family:
                return None
            value = self.__element.get(name)
            if value is None:
                return None
            elif value in (&#34;true&#34;, &#34;false&#34;):
                return Boolean.decode(value)
            return str(value)

        return getter

    @staticmethod
    def _generic_attrib_setter(attr_name, family=None):
        name = _get_lxml_tag(attr_name)

        def setter(self, value):
            if family and self.family != family:
                return None
            if value is None:
                with contextlib.suppress(KeyError):
                    del self.__element.attrib[name]
                return
            if isinstance(value, bool):
                value = Boolean.encode(value)
            self.__element.set(name, str(value))

        return setter

    @classmethod
    def _define_attribut_property(cls):
        for tpl in cls._properties:
            name = tpl[0]
            attr = tpl[1]
            if len(tpl) == 3:
                family = tpl[2]
            else:
                family = None
            setattr(
                cls,
                name,
                property(
                    cls._generic_attrib_getter(attr, family),
                    cls._generic_attrib_setter(attr, family),
                    None,
                    f&#34;Get/set the attribute {attr}&#34;,
                ),
            )

    def _insert_before_after(
        self,
        current,
        element,
        before,
        after,
        position,
        main_text,
        xpath_text,
    ):
        # 1) before xor after is not None
        if before is not None:
            regex = re.compile(before)
        else:
            regex = re.compile(after)

        # position = -1
        if position &lt; 0:
            # Found the last text that matches the regex
            text = None
            for a_text in xpath_text(current):
                if regex.search(a_text) is not None:
                    text = a_text
            if text is None:
                raise ValueError(&#34;text not found&#34;)
            sre = list(regex.finditer(text))[-1]
        # position &gt;= 0
        else:
            count = 0
            for text in xpath_text(current):
                found_nb = len(regex.findall(text))
                if found_nb + count &gt;= position + 1:
                    break
                count += found_nb
            else:
                raise ValueError(&#34;text not found&#34;)
            sre = list(regex.finditer(text))[position - count]
        # Compute pos
        pos = sre.start() if before is not None else sre.end()
        return pos, text

    def _insert_find_text(
        self,
        current,
        element,
        before,
        after,
        position,
        main_text,
        xpath_text,
    ):
        # Found the text
        count = 0
        for text in xpath_text(current):
            found_nb = len(text)
            if found_nb + count &gt;= position:
                break
            count += found_nb
        else:
            raise ValueError(&#34;text not found&#34;)
        # We insert before the character
        pos = position - count
        return pos, text

    def _insert(self, element, before=None, after=None, position=0, main_text=False):
        &#34;&#34;&#34;Insert an element before or after the characters in the text which
        match the regex before/after. When the regex matches more of one part
        of the text, position can be set to choice which part must be used. If
        before and after are None, we use only position that is the number of
        characters. If position is positive and before=after=None, we insert
        before the position character. But if position=-1, we insert after the
        last character.

        if main_text is True, filter out the annotations texts in computation.

        Arguments:

        element -- Element

        before -- str regex

        after -- str regex

        position -- int

        main_text -- boolean
        &#34;&#34;&#34;
        current = self.__element
        element = element.__element

        if main_text:
            xpath_text = _xpath_text_main_descendant
        else:
            xpath_text = _xpath_text_descendant

        # 1) before xor after is not None
        if (before is not None) ^ (after is not None):
            pos, text = self._insert_before_after(
                current,
                element,
                before,
                after,
                position,
                main_text,
                xpath_text,
            )
        # 2) before=after=None =&gt; only with position
        elif before is None and after is None:
            # Hack if position is negative =&gt; quickly
            if position &lt; 0:
                current.append(element)
                return
            pos, text = self._insert_find_text(
                current,
                element,
                before,
                after,
                position,
                main_text,
                xpath_text,
            )
        else:
            raise ValueError(&#34;bad combination of arguments&#34;)

        # Compute new texts
        text_before = text[:pos] if text[:pos] else None
        text_after = text[pos:] if text[pos:] else None

        # Insert!
        parent = text.getparent()
        if text.is_text:
            parent.text = text_before
            element.tail = text_after
            parent.insert(0, element)
        else:
            parent.addnext(element)
            parent.tail = text_before
            element.tail = text_after

    def _insert_between(self, element, from_, to):
        &#34;&#34;&#34;Insert the given empty element to wrap the text beginning with
        &#34;from_&#34; and ending with &#34;to&#34;.

        Example 1: &#39;&lt;p&gt;toto tata titi&lt;/p&gt;

        We want to insert a link around &#34;tata&#34;.

        Result 1: &#39;&lt;p&gt;toto &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;

        Example 2: &#39;&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; tata titi&lt;/p&gt;

        We want to insert a link around &#34;tata&#34;.

        Result 2: &#39;&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;

        Example 3: &#39;&lt;p&gt;toto &lt;span&gt; tata &lt;/span&gt; titi&lt;/p&gt;&#39;

        We want to insert a link from &#34;tata&#34; to &#34;titi&#34; included.

        Result 3: &#39;&lt;p&gt;toto &lt;span&gt; &lt;/span&gt;&#39;
                  &#39;&lt;a&gt;&lt;span&gt;tata &lt;/span&gt; titi&lt;/a&gt;&lt;/p&gt;&#39;

        Example 4: &#39;&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; tutu&lt;/p&gt;&#39;

        We want to insert a link from &#34;titi&#34; to &#34;tutu&#34;

        Result 4: &#39;&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;/a&gt;&#39;
                  &#39;&lt;a&gt; tutu&lt;/a&gt;&lt;/p&gt;&#39;

        Example 5: &#39;&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; &#39;
                   &#39;&lt;span&gt;tutu tyty&lt;/span&gt;&lt;/p&gt;&#39;

        We want to insert a link from &#34;titi&#34; to &#34;tutu&#34;

        Result 5: &#39;&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;a&gt; &#39;
                  &#39;&lt;a&gt; &lt;span&gt;tutu&lt;/span&gt;&lt;/a&gt;&lt;span&gt; tyty&lt;/span&gt;&lt;/p&gt;&#39;
        &#34;&#34;&#34;
        current = self.__element
        wrapper = element.__element
        for text in _xpath_text_descendant(current):
            if from_ not in text:
                continue
            from_index = text.index(from_)
            text_before = text[:from_index]
            text_after = text[from_index:]
            from_container = text.getparent()
            # Include from_index to match a single word
            to_index = text.find(to, from_index)
            if to_index &gt;= 0:
                # Simple case: &#34;from&#34; and &#34;to&#34; in the same element
                to_end = to_index + len(to)
                if text.is_text:
                    from_container.text = text_before
                    wrapper.text = text[to_index:to_end]
                    wrapper.tail = text[to_end:]
                    from_container.insert(0, wrapper)
                else:
                    from_container.tail = text_before
                    wrapper.text = text[to_index:to_end]
                    wrapper.tail = text[to_end:]
                    parent = from_container.getparent()
                    index = parent.index(from_container)
                    parent.insert(index + 1, wrapper)
                return
            else:
                # Exit to the second part where we search for the end text
                break
        else:
            raise ValueError(&#34;start text not found&#34;)
        # The container is split in two
        container2 = deepcopy(from_container)
        if text.is_text:
            from_container.text = text_before
            from_container.tail = None
            container2.text = text_after
            from_container.tail = None
        else:
            from_container.tail = text_before
            container2.tail = text_after
        # Stack the copy into the surrounding element
        wrapper.append(container2)
        parent = from_container.getparent()
        index = parent.index(from_container)
        parent.insert(index + 1, wrapper)
        for text in _xpath_text_descendant(wrapper):
            if to not in text:
                continue
            to_end = text.index(to) + len(to)
            text_before = text[:to_end]
            text_after = text[to_end:]
            container_to = text.getparent()
            if text.is_text:
                container_to.text = text_before
                container_to.tail = text_after
            else:
                container_to.tail = text_before
                next_one = container_to.getnext()
                if next_one is None:
                    next_one = container_to.getparent()
                next_one.tail = text_after
            return
        raise ValueError(&#34;end text not found&#34;)

    @property
    def tag(self):
        &#34;&#34;&#34;Get/set the underlying xml tag with the given qualified name.

        Warning: direct change of tag does not change the element class.

        Arguments:

            qname -- str (e.g. &#34;text:span&#34;)
        &#34;&#34;&#34;
        return _get_prefixed_name(self.__element.tag)

    @tag.setter
    def tag(self, qname):
        self.__element.tag = to_bytes(_get_lxml_tag(qname))

    def elements_repeated_sequence(self, xpath_instance, name):
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
        element = self.__element
        sub_elements = xpath_instance(element)
        result = []
        idx = -1
        for sub_element in sub_elements:
            idx += 1
            value = sub_element.get(name)
            if value is None:
                result.append((idx, 1))
                continue
            try:
                value = int(value)
            except ValueError:
                value = 1
            result.append((idx, max(value, 1)))
        return result

    def get_elements(self, xpath_query):
        element = self.__element
        if isinstance(xpath_query, XPath):
            result = xpath_query(element)
        else:
            new_xpath_query = _find_query_in_cache(to_bytes(xpath_query))
            result = new_xpath_query(element)
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                cache = (self._tmap, self._cmap, self._rmap)
            else:
                cache = (self._tmap, self._cmap)
        else:
            cache = None
        return [Element.from_tag_for_clone(e, cache) for e in result]

    # fixme : need original get_element as wrapper of get_elements

    def get_element(self, xpath_query):
        element = self.__element
        result = element.xpath(&#34;(%s)[1]&#34; % xpath_query, namespaces=ODF_NAMESPACES)
        if result:
            return Element.from_tag(result[0])
        return None

    def _get_element_idx(self, xpath_query, idx):
        element = self.__element
        result = element.xpath(f&#34;({xpath_query})[{idx + 1}]&#34;, namespaces=ODF_NAMESPACES)
        if result:
            return Element.from_tag(result[0])
        return None

    def _get_element_idx2(self, xpath_instance, idx):
        element = self.__element
        result = xpath_instance(element, idx=idx + 1)
        if result:
            return Element.from_tag(result[0])
        return None

    @property
    def attributes(self):
        e = self.__element
        return {_get_prefixed_name(k): v for k, v in e.attrib.items()}

    def get_attribute(self, name):
        element = self.__element
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
        value = element.get(name)
        if value is None:
            return None
        elif value in (&#34;true&#34;, &#34;false&#34;):
            return Boolean.decode(value)
        return str(value)

    def get_attribute_integer(self, name):
        atr = self.get_attribute(name)
        if atr is None:
            return atr
        try:
            return int(atr)
        except ValueError:
            return None

    def set_attribute(self, name, value):
        element = self.__element
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031

        if isinstance(value, bool):
            value = Boolean.encode(value)
        elif value is None:
            with contextlib.suppress(KeyError):
                del element.attrib[name]
            return
        element.set(name, str(value))

    def set_style_attribute(self, name, value):
        &#34;&#34;&#34;Shortcut to accept a style object as a value.&#34;&#34;&#34;
        if isinstance(value, Element):
            value = value.name
        return self.set_attribute(name, value)

    def del_attribute(self, name):
        element = self.__element
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
        del element.attrib[name]

    @property
    def text(self):
        &#34;&#34;&#34;Get / set the text content of the element.&#34;&#34;&#34;
        return self.__element.text or &#34;&#34;

    @text.setter
    def text(self, text):
        if text is None:
            text = &#34;&#34;
        try:
            self.__element.text = to_str(text)
        except TypeError as e:
            raise TypeError(f&#39;str type expected: &#34;{type(text)}&#34;&#39;) from e

    @property
    def text_recursive(self):
        return &#34;&#34;.join(self.__element.itertext())

    @property
    def tail(self):
        &#34;&#34;&#34;Get / set the text immediately following the element.&#34;&#34;&#34;
        return self.__element.tail

    @tail.setter
    def tail(self, text):
        self.__element.tail = text or &#34;&#34;

    def search(self, pattern):
        &#34;&#34;&#34;Return the first position of the pattern in the text content of
        the element, or None if not found.

        Python regular expression syntax applies.

        Arguments:

            pattern -- str

        Return: int or None
        &#34;&#34;&#34;
        match = re.search(pattern, self.text_recursive)
        if match is None:
            return None
        return match.start()

    def match(self, pattern):
        &#34;&#34;&#34;return True if the pattern is found one or more times anywhere in
        the text content of the element.

        Python regular expression syntax applies.

        Arguments:

            pattern -- str

        Return: bool
        &#34;&#34;&#34;
        return self.search(pattern) is not None

    def replace(self, pattern, new=None):
        &#34;&#34;&#34;Replace the pattern with the given text, or delete if text is an
        empty string, and return the number of replacements. By default, only
        return the number of occurences that would be replaced.

        It cannot replace patterns found across several element, like a word
        split into two consecutive spans.

        Python regular expression syntax applies.

        Arguments:

            pattern -- str

            new -- str

        Return: int
        &#34;&#34;&#34;
        if not isinstance(pattern, str):
            # Fail properly if the pattern is an non-ascii bytestring
            pattern = str(pattern)
        cpattern = re.compile(pattern)
        count = 0
        for text in self.xpath(&#34;descendant::text()&#34;):
            if new is None:
                count += len(cpattern.findall(text))
            else:
                new_text, number = cpattern.subn(new, text)
                container = text.parent
                if text.is_text():
                    container.text = new_text
                else:
                    container.tail = new_text
                count += number
        return count

    @property
    def root(self):
        element = self.__element
        tree = element.getroottree()
        root = tree.getroot()
        return Element.from_tag(root)

    @property
    def parent(self):
        element = self.__element
        parent = element.getparent()
        if parent is None:
            # Already at root
            return None
        return Element.from_tag(parent)

    # def get_next_sibling(self):
    #     element = self.__element
    #     next_one = element.getnext()
    #     if next_one is None:
    #         return None
    #     return Element.from_tag(next_one)
    #
    # def get_prev_sibling(self):
    #     element = self.__element
    #     prev = element.getprevious()
    #     if prev is None:
    #         return None
    #     return Element.from_tag(prev)

    @property
    def children(self):
        element = self.__element
        return [Element.from_tag(e) for e in element.getchildren()]

    def index(self, child):
        &#34;&#34;&#34;Return the position of the child in this element.

        Inspired by lxml
        &#34;&#34;&#34;
        return self.__element.index(child.__element)

    @property
    def text_content(self):
        &#34;&#34;&#34;Get / set the text of the embedded paragraph, including embeded
        annotations, cells...

        Set create a paragraph if missing
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(
            child.text_recursive for child in self.get_elements(&#34;descendant::text:p&#34;)
        )

    @text_content.setter
    def text_content(self, text):
        paragraphs = self.get_elements(&#34;text:p&#34;)
        if not paragraphs:
            # E.g., text:p in draw:text-box in draw:frame
            paragraphs = self.get_elements(&#34;*/text:p&#34;)
        if paragraphs:
            paragraph = paragraphs.pop(0)
            for obsolete in paragraphs:
                obsolete.delete()
        else:
            paragraph = Element.from_tag(&#34;text:p&#34;)
            self.insert(paragraph, FIRST_CHILD)
        # As &#34;text_content&#34; returned all text nodes, &#34;text_content&#34;
        # will overwrite all text nodes and children that may contain them
        element = paragraph.__element
        # Clear but the attributes
        del element[:]
        element.text = text

    def _erase_text_content(self):
        paragraphs = self.get_elements(&#34;text:p&#34;)
        if not paragraphs:
            # E.g., text:p in draw:text-box in draw:frame
            paragraphs = self.get_elements(&#34;*/text:p&#34;)
        if paragraphs:
            paragraphs.pop(0)
            for obsolete in paragraphs:
                obsolete.delete()

    def is_empty(self):
        &#34;&#34;&#34;Check if the element is empty : no text, no children, no tail

        Return: Boolean
        &#34;&#34;&#34;
        element = self.__element
        if element.tail is not None:
            return False
        if element.text is not None:
            return False
        if element.getchildren():
            return False
        return True

    def _get_successor(self, target):
        element = self.__element
        next_one = element.getnext()
        if next_one is not None:
            return Element.from_tag(next_one), target
        parent = self.parent
        if parent is None:
            return None, None
        return parent._get_successor(target.parent)

    def _get_between_base(self, tag1, tag2):  # noqa:C901
        def find_any_id(tag):
            stag = tag.tag
            for attribute in (
                &#34;text:id&#34;,
                &#34;text:change-id&#34;,
                &#34;text:name&#34;,
                &#34;office:name&#34;,
                &#34;text:ref-name&#34;,
                &#34;xml:id&#34;,
            ):
                idx = tag.get_attribute(attribute)
                if idx is not None:
                    return stag, attribute, idx
            raise ValueError(&#34;No Id found in %s&#34; % tag.serialize())

        def common_ancestor(t1, a1, v1, t2, a2, v2):
            root = self.root
            request1 = f&#39;descendant::{t1}[@{a1}=&#34;{v1}&#34;]&#39;
            request2 = f&#39;descendant::{t2}[@{a2}=&#34;{v2}&#34;]&#39;
            up = root.xpath(request1)[0]
            while True:
                # print &#34;up&#34;,
                up = up.parent
                has_tag2 = up.xpath(request2)
                if not has_tag2:
                    continue
                # print &#39;found&#39;
                break
            # print up.serialize()
            return up

        t1, a1, v1 = find_any_id(tag1)
        t2, a2, v2 = find_any_id(tag2)
        ancestor = common_ancestor(t1, a1, v1, t2, a2, v2).clone
        r1 = f&#39;{t1}[@{a1}=&#34;{v1}&#34;]&#39;
        r2 = f&#39;{t2}[@{a2}=&#34;{v2}&#34;]&#39;
        resu = ancestor.clone
        for child in resu.children:
            resu.delete(child)
        resu.text = &#34;&#34;
        resu.tail = &#34;&#34;
        target = resu
        current = ancestor.children[0]
        state = 0
        while True:
            # print &#39;current&#39;, state, current.serialize()
            if state == 0:  # before tag 1
                if current.xpath(f&#34;descendant-or-self::{r1}&#34;):
                    if current.xpath(f&#34;self::{r1}&#34;):
                        tail = current.tail
                        if tail:
                            # got a tail =&gt; the parent should be either t:p or t:h
                            target.text = tail
                        current, target = current._get_successor(target)
                        state = 1
                        continue
                    # got T1 in chidren, need further analysis
                    new_target = current.clone
                    for child in new_target.children:
                        new_target.delete(child)
                    new_target.text = &#34;&#34;
                    new_target.tail = &#34;&#34;
                    target.append(new_target)
                    target = new_target
                    current = current.children[0]
                    continue
                else:
                    # before tag1 : forget element, go to next one
                    current, target = current._get_successor(target)
                    continue
            elif state == 1:  # collect elements
                further = False
                if current.xpath(f&#34;descendant-or-self::{r2}&#34;):
                    if current.xpath(f&#34;self::{r2}&#34;):
                        # end of trip
                        break
                    # got T2 in chidren, need further analysis
                    further = True
                # further analysis needed :
                if further:
                    new_target = current.clone
                    for child in new_target.children:
                        new_target.delete(child)
                    new_target.text = &#34;&#34;
                    new_target.tail = &#34;&#34;
                    target.append(new_target)
                    target = new_target
                    current = current.children[0]
                    continue
                # collect
                target.append(current.clone)
                current, target = current._get_successor(target)
                continue
        # Now resu should be the &#34;parent&#34; of inserted parts
        # - a text:h or text:p sigle item (simple case)
        # - a upper element, with some text:p, text:h in it =&gt; need to be
        #   stripped to have a list of text:p, text:h
        if resu.tag in {&#34;text:p&#34;, &#34;text:h&#34;}:
            inner = [resu]
        else:
            inner = resu.children
        return inner

    def get_between(self, tag1, tag2, as_text=False, clean=True, no_header=True):
        &#34;&#34;&#34;Returns elements between tag1 and tag2, tag1 and tag2 shall
        be unique and having an id attribute.
        (WARN: buggy if tag1/tag2 defines a malformed odf xml.)
        If as_text is True: returns the text content.
        If clean is True: suppress unwanted tags (deletions marks, ...)
        If no_header is True: existing text:h are changed in text:p
        By default: returns a list of Element, cleaned and without headers.

        Implementation and standard retrictions:
        Only text:h and text:p sould be &#39;cut&#39; by an insert tag, so inner parts
        of insert tags are:

            - any text:h, text:p or sub tag of these

            - some text, part of a parent text:h or text:p

        Arguments:

            tag1 -- Element

            tag2 -- Element

            as_text -- boolean

            clean -- boolean

            no_header -- boolean

        Return: list of odf_paragraph or odf_header
        &#34;&#34;&#34;
        inner = self._get_between_base(tag1, tag2)

        if clean:
            clean_tags = (
                &#34;text:change&#34;,
                &#34;text:change-start&#34;,
                &#34;text:change-end&#34;,
                &#34;text:reference-mark&#34;,
                &#34;text:reference-mark-start&#34;,
                &#34;text:reference-mark-end&#34;,
            )
            request_self = &#34; | &#34;.join([&#34;self::%s&#34; % c for c in clean_tags])
            inner = [e for e in inner if not e.xpath(request_self)]
            request = &#34; | &#34;.join([&#34;descendant::%s&#34; % c for c in clean_tags])
            for element in inner:
                to_del = element.xpath(request)
                for e in to_del:
                    element.delete(e)
        if no_header:  # crude replace t:h by t:p
            new_inner = []
            for element in inner:
                if element.tag == &#34;text:h&#34;:
                    children = element.children
                    text = element.__element.text
                    para = Element.from_tag(&#34;text:p&#34;)
                    para.text = text
                    for c in children:
                        para.append(c)
                    new_inner.append(para)
                else:
                    new_inner.append(element)
            inner = new_inner
        if as_text:
            return &#34;\n&#34;.join([e.get_formatted_text() for e in inner])
        else:
            return inner

    def insert(self, element, xmlposition=None, position=None, start=False):
        &#34;&#34;&#34;Insert an element relatively to ourself.

        Insert either using DOM vocabulary or by numeric position.
        If text start is True, insert the element before any existing text.

        Position start at 0.

        Arguments:

            element -- Element

            xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING
                           or PREV_SIBLING

            start -- Boolean

            position -- int
        &#34;&#34;&#34;
        # child_tag = element.tag
        current = self.__element
        element = element.__element
        if start:
            text = current.text
            if text is not None:
                current.text = None
                tail = element.tail
                if tail is None:
                    tail = text
                else:
                    tail = tail + text
                element.tail = tail
            position = 0
        if position is not None:
            current.insert(position, element)
        elif xmlposition is FIRST_CHILD:
            current.insert(0, element)
        elif xmlposition is LAST_CHILD:
            current.append(element)
        elif xmlposition is NEXT_SIBLING:
            parent = current.getparent()
            index = parent.index(current)
            parent.insert(index + 1, element)
        elif xmlposition is PREV_SIBLING:
            parent = current.getparent()
            index = parent.index(current)
            parent.insert(index, element)
        else:
            raise ValueError(&#34;(xml)position must be defined&#34;)

    def extend(self, odf_elements):
        &#34;&#34;&#34;Fast append elements at the end of ourself using extend.&#34;&#34;&#34;
        if odf_elements:
            current = self.__element
            elements = [element.__element for element in odf_elements]
            current.extend(elements)

    def append(self, str_or_element):
        &#34;&#34;&#34;Insert element or text in the last position.&#34;&#34;&#34;
        current = self.__element

        # Unicode ?
        if isinstance(str_or_element, str):
            # Has children ?
            children = current.getchildren()
            if children:
                # Append to tail of the last child
                last_child = children[-1]
                text = last_child.tail
                text = text if text is not None else &#34;&#34;
                text += str_or_element
                last_child.tail = text
            else:
                # Append to text of the element
                text = current.text
                text = text if text is not None else &#34;&#34;
                text += str_or_element
                current.text = text
        elif isinstance(str_or_element, Element):
            current.append(str_or_element.__element)
        else:
            raise TypeError(
                &#39;Element or unicode expected, not &#34;%s&#34;&#39; % (type(str_or_element))
            )

    def delete(self, child=None, keep_tail=True):
        &#34;&#34;&#34;Delete the given element from the XML tree. If no element is given,
        &#34;self&#34; is deleted. The XML library may allow to continue to use an
        element now &#34;orphan&#34; as long as you have a reference to it.

        if keep_tail is True (default), the tail text is not erased.

        Arguments:

            child -- Element

            keep_tail -- boolean (default to True), True for most usages.
        &#34;&#34;&#34;
        if child is None:
            parent = self.parent
            if parent is None:
                info = self.serialize()
                raise ValueError(&#34;cannot delete the root element\n%s&#34; % info)
            child = self
        else:
            parent = self
        if keep_tail and child.__element.tail is not None:
            current = child.__element
            tail = current.tail
            current.tail = None
            prev = current.getprevious()
            if prev is not None:
                if prev.tail is None:
                    prev.tail = tail
                else:
                    prev.tail += tail
            else:
                if parent.__element.text is None:
                    parent.__element.text = tail
                else:
                    parent.__element.text += tail
        parent.__element.remove(child.__element)

    def replace_element(self, old_element, new_element):
        &#34;&#34;&#34;Replaces in place a sub element with the element passed as second
        argument.

        Warning : no clone for old element.
        &#34;&#34;&#34;
        current = self.__element
        current.replace(old_element.__element, new_element.__element)

    def strip_elements(self, sub_elements):
        &#34;&#34;&#34;Remove the tags of provided elements, keeping inner childs and text.

        Return : the striped element.

        Warning : no clone in sub_elements list.

        Arguments:

            sub_elements -- Element or list of Element
        &#34;&#34;&#34;
        if not sub_elements:
            return self
        if isinstance(sub_elements, Element):
            sub_elements = (sub_elements,)
        replacer = to_bytes(_get_lxml_tag(&#34;text:this-will-be-removed&#34;))
        for element in sub_elements:
            element.__element.tag = replacer
        strip = (&#34;text:this-will-be-removed&#34;,)
        return self.strip_tags(strip=strip, default=None)

    def strip_tags(self, strip=None, protect=None, default=&#34;text:p&#34;):
        &#34;&#34;&#34;Remove the tags listed in strip, recursively, keeping inner childs
        and text. Tags listed in protect stop the removal one level depth. If
        the first level element is stripped, default is used to embed the
        content in the default element. If default is None and first level is
        striped, a list of text and children is returned. Return : the striped
        element.

        strip_tags should be used by on purpose methods (strip_span ...)
        (Method name taken from lxml).

        Arguments:

            strip -- iterable list of str odf tags, or None

            protect -- iterable list of str odf tags, or None

            default -- str odf tag, or None

        Return:

            Element or list.
        &#34;&#34;&#34;
        if not strip:
            return self
        if not protect:
            protect = ()
        protected = False
        element, modified = Element._strip_tags(self, strip, protect, protected)
        if modified and isinstance(element, list) and default:
            new = Element.from_tag(default)
            for content in element:
                if isinstance(content, Element):
                    new.append(content)
                else:
                    new.text = content
            element = new
        return element

    @staticmethod
    def _strip_tags(element, strip, protect, protected):  # noqa: C901
        &#34;&#34;&#34;sub method for strip_tags()&#34;&#34;&#34;
        copy = element.clone
        modified = False
        children = []
        if protect and element.tag in protect:
            protect_below = True
        else:
            protect_below = False
        for child in copy.children:
            striped_child, is_modified = Element._strip_tags(
                child, strip, protect, protect_below
            )
            if is_modified:
                modified = True
            if isinstance(striped_child, list):
                children.extend(striped_child)
            else:
                children.append(striped_child)
        if not protected and strip and element.tag in strip:
            element = []
            modified = True
        else:
            if not modified:
                return (element, False)
            element.clear()
            try:
                for key, value in copy.attributes.items():
                    element.set_attribute(key, value)
            except ValueError:
                sys.stderr.write(&#34;strip_tags(): bad attribute in %s\n&#34; % copy)
        text = copy.text
        tail = copy.tail
        if text is not None:
            element.append(text)
        for child in children:
            element.append(child)
        if tail is not None:
            if isinstance(element, list):
                element.append(tail)
            else:
                element.tail = tail
        return (element, True)

    def xpath(self, xpath_query):
        &#34;&#34;&#34;Apply XPath query to the element and its subtree. Return list of
        Element or Text instances translated from the nodes found.
        &#34;&#34;&#34;
        element = self.__element
        xpath_instance = _find_query_in_cache(xpath_query)
        elements = xpath_instance(element)
        result = []
        for obj in elements:
            if isinstance(obj, (_ElementStringResult, _ElementUnicodeResult)):
                result.append(Text(obj))
            elif isinstance(obj, _Element):
                result.append(Element.from_tag(obj))
            else:
                result.append(obj)
        return result

    def clear(self):
        &#34;&#34;&#34;Remove text, children and attributes from the element.&#34;&#34;&#34;
        self.__element.clear()
        if hasattr(self, &#34;_tmap&#34;):
            self._tmap = []
        if hasattr(self, &#34;_cmap&#34;):
            self._cmap = []
        if hasattr(self, &#34;_rmap&#34;):
            self._rmap = []
        if hasattr(self, &#34;_indexes&#34;):
            remember = False
            if &#34;_rmap&#34; in self._indexes:
                remember = True
            self._indexes = {}
            self._indexes[&#34;_cmap&#34;] = {}
            self._indexes[&#34;_tmap&#34;] = {}
            if remember:
                self._indexes[&#34;_rmap&#34;] = {}

    @property
    def clone(self):
        clone = deepcopy(self.__element)
        root = lxml_Element(&#34;ROOT&#34;, nsmap=ODF_NAMESPACES)
        root.append(clone)
        return self.from_tag(clone)

        # slow data = tostring(self.__element, encoding=&#39;unicode&#39;)
        # return self.from_tag(data)

    def serialize(self, pretty=False, with_ns=False):
        # This copy bypasses serialization side-effects in lxml
        native = deepcopy(self.__element)
        data = tostring(
            native, with_tail=False, pretty_print=pretty, encoding=&#34;unicode&#34;
        )
        if not with_ns:
            # Remove namespaces
            data = ns_stripper.sub(&#34;&#34;, data)
        return data

    def serialize2(self, pretty=False, with_ns=False):
        # This copy bypasses serialization side-effects in lxml
        native = deepcopy(self.__element)
        data = tostring(
            native, with_tail=False, pretty_print=pretty, encoding=&#34;unicode&#34;
        )
        if not with_ns:
            # Remove namespaces
            data = ns_stripper.sub(&#34;&#34;, data)
        return data + str(len(data))

    # Element helpers usable from any context

    @property
    def document_body(self):
        &#34;&#34;&#34;Return the document body : &#39;office:body&#39;&#34;&#34;&#34;
        return self.get_element(&#34;//office:body/*[1]&#34;)

    @document_body.setter
    def document_body(self, new_body):
        &#34;&#34;&#34;Change in place the full document body content.&#34;&#34;&#34;
        body = self.document_body
        tail = body.tail
        body.clear()
        for item in new_body.children:
            body.append(item)
        if tail:
            body.tail = tail

    def get_formatted_text(self, context):
        &#34;&#34;&#34;This function must return a beautiful version of the text&#34;&#34;&#34;
        return &#34;&#34;

    def get_styled_elements(self, name=&#34;&#34;):
        &#34;&#34;&#34;Brute-force to find paragraphs, tables, etc. using the given style
        name (or all by default).

        Arguments:

            name -- str

        Return: list
        &#34;&#34;&#34;
        # FIXME incomplete (and possibly inaccurate)
        return (
            _get_elements(self, &#34;descendant::*&#34;, text_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, draw_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, draw_text_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, table_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, page_layout=name)
            + _get_elements(self, &#34;descendant::*&#34;, master_page=name)
            + _get_elements(self, &#34;descendant::*&#34;, parent_style=name)
        )

    # Common attributes

    def _get_inner_text(self, tag):
        element = self.get_element(tag)
        if element is None:
            return None
        return element.text

    def _set_inner_text(self, tag, text):
        element = self.get_element(tag)
        if element is None:
            element = Element.from_tag(tag)
            self.append(element)
        element.text = text

    # Dublin core

    @property
    def dc_creator(self):
        &#34;&#34;&#34;Get dc:creator value.

        Return: str (or None if inexistant)
        &#34;&#34;&#34;
        return self._get_inner_text(&#34;dc:creator&#34;)

    @dc_creator.setter
    def dc_creator(self, creator):
        &#34;&#34;&#34;Set dc:creator value.

        Arguments:

            creator -- str
        &#34;&#34;&#34;
        self._set_inner_text(&#34;dc:creator&#34;, creator)

    @property
    def dc_date(self):
        &#34;&#34;&#34;Get the dc:date value.

        Return: datetime (or None if inexistant)
        &#34;&#34;&#34;
        date = self._get_inner_text(&#34;dc:date&#34;)
        if date is None:
            return None
        return DateTime.decode(date)

    @dc_date.setter
    def dc_date(self, date):
        &#34;&#34;&#34;Set the dc:date value.

        Arguments:

            darz -- DateTime
        &#34;&#34;&#34;
        self._set_inner_text(&#34;dc:date&#34;, DateTime.encode(date))

    # SVG

    @property
    def svg_title(self):
        return self._get_inner_text(&#34;svg:title&#34;)

    @svg_title.setter
    def svg_title(self, title):
        self._set_inner_text(&#34;svg:title&#34;, title)

    @property
    def svg_description(self):
        return self._get_inner_text(&#34;svg:desc&#34;)

    @svg_description.setter
    def svg_description(self, description):
        self._set_inner_text(&#34;svg:desc&#34;, description)

    # Sections

    def get_sections(self, style=None, content=None):
        &#34;&#34;&#34;Return all the sections that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;text:section&#34;, text_style=style, content=content)

    def get_section(self, position=0, content=None):
        &#34;&#34;&#34;Return the section that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:section&#34;, position, content=content)

    # Paragraphs

    def get_paragraphs(self, style=None, content=None):
        &#34;&#34;&#34;Return all the paragraphs that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Paragraph
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:p&#34;, text_style=style, content=content
        )

    def get_paragraph(self, position=0, content=None):
        &#34;&#34;&#34;Return the paragraph that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Paragraph or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:p&#34;, position, content=content)

    # Span

    def get_spans(self, style=None, content=None):
        &#34;&#34;&#34;Return all the spans that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Span
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:span&#34;, text_style=style, content=content
        )

    def get_span(self, position=0, content=None):
        &#34;&#34;&#34;Return the span that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Span or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:span&#34;, position, content=content)

    # Headers

    def get_headers(self, style=None, outline_level=None, content=None):
        &#34;&#34;&#34;Return all the Headers that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Header
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::text:h&#34;,
            text_style=style,
            outline_level=outline_level,
            content=content,
        )

    def get_header(self, position=0, outline_level=None, content=None):
        &#34;&#34;&#34;Return the Header that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Header or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::text:h&#34;,
            position,
            outline_level=outline_level,
            content=content,
        )

    # Lists

    def get_lists(self, style=None, content=None):
        &#34;&#34;&#34;Return all the lists that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of List
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:list&#34;, text_style=style, content=content
        )

    def get_list(self, position=0, content=None):
        &#34;&#34;&#34;Return the list that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: List or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:list&#34;, position, content=content)

    # Frames

    def get_frames(
        self,
        presentation_class=None,
        style=None,
        title=None,
        description=None,
        content=None,
    ):
        &#34;&#34;&#34;Return all the frames that match the criteria.

        Arguments:

            style -- str

            title -- str regex

            description -- str regex

            content -- str regex

        Return: list of Frame
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:frame&#34;,
            presentation_class=presentation_class,
            draw_style=style,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    def get_frame(
        self,
        position=0,
        name=None,
        presentation_class=None,
        title=None,
        description=None,
        content=None,
    ):
        &#34;&#34;&#34;Return the section that matches the criteria.

        Arguments:

            position -- int

            title -- str regex

            description -- str regex

            content -- str regex

        Return: Frame or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::draw:frame&#34;,
            position,
            draw_name=name,
            presentation_class=presentation_class,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    # Images

    def get_images(self, style=None, url=None, content=None):
        &#34;&#34;&#34;Return all the images matching the criteria.

        Arguments:

            style -- str

            url -- str regex

            content -- str regex

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::draw:image&#34;, text_style=style, url=url, content=content
        )

    def get_image(self, position=0, name=None, url=None, content=None):
        &#34;&#34;&#34;Return the image matching the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Element or None if not found
        &#34;&#34;&#34;
        # The frame is holding the name
        if name is not None:
            frame = _get_element(
                self, &#34;descendant::draw:frame&#34;, position=position, draw_name=name
            )
            if frame is None:
                return None
            # The name is supposedly unique
            return frame.get_element(&#34;draw:image&#34;)
        return _get_element(
            self, &#34;descendant::draw:image&#34;, position, url=url, content=content
        )

    # Tables

    def get_tables(self, style=None, content=None):
        &#34;&#34;&#34;Return all the tables that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Table
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::table:table&#34;, table_style=style, content=content
        )

    def get_table(self, position=0, name=None, content=None):
        &#34;&#34;&#34;Return the table that matches the criteria.

        Arguments:

            position -- int

            name -- str

            content -- str regex

        Return: Table or None if not found
        &#34;&#34;&#34;
        if name is None and content is None:
            result = self._get_element_idx(&#34;descendant::table:table&#34;, position)
        else:
            result = _get_element(
                self,
                &#34;descendant::table:table&#34;,
                position,
                table_name=name,
                content=content,
            )
        return result

    # Named Range

    def get_named_ranges(self):
        &#34;&#34;&#34;Return all the tables named ranges.

        Return: list of odf_named_range
        &#34;&#34;&#34;
        named_ranges = self.get_elements(
            &#34;descendant::table:named-expressions/table:named-range&#34;
        )
        return named_ranges

    def get_named_range(self, name):
        &#34;&#34;&#34;Return the named range of specified name, or None if not found.

        Arguments:

            name -- str

        Return: NamedRange
        &#34;&#34;&#34;
        named_range = self.get_elements(
            &#39;descendant::table:named-expressions/table:named-range[@table:name=&#34;%s&#34;][1]&#39;
            % name
        )
        if named_range:
            return named_range[0]
        else:
            return None

    def append_named_range(self, named_range):
        &#34;&#34;&#34;Append the named range to the spreadsheet, replacing existing named
        range of same name if any.

        Arguments:

            named_range --  NamedRange
        &#34;&#34;&#34;
        if self.tag != &#34;office:spreadsheet&#34;:
            raise ValueError(&#34;Element is no &#39;office:spreadsheet&#39; : %s&#34; % self.tag)
        named_expressions = self.get_element(&#34;table:named-expressions&#34;)
        if not named_expressions:
            named_expressions = Element.from_tag(&#34;table:named-expressions&#34;)
            self.append(named_expressions)
        # exists ?
        current = named_expressions.get_element(
            &#39;table:named-range[@table:name=&#34;%s&#34;][1]&#39; % named_range.name
        )
        if current:
            named_expressions.delete(current)
        named_expressions.append(named_range)

    def delete_named_range(self, name):
        &#34;&#34;&#34;Delete the Named Range of specified name from the spreadsheet.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        if self.tag != &#34;office:spreadsheet&#34;:
            raise ValueError(&#34;Element is no &#39;office:spreadsheet&#39; : %s&#34; % self.tag)
        named_range = self.get_named_range(name)
        if not named_range:
            return
        named_range.delete()
        named_expressions = self.get_element(&#34;table:named-expressions&#34;)
        element = named_expressions.__element
        children = len(element.getchildren())
        if not children:
            self.delete(named_expressions)

    # Notes

    def get_notes(self, note_class=None, content=None):
        &#34;&#34;&#34;Return all the notes that match the criteria.

        Arguments:

            note_class -- &#39;footnote&#39; or &#39;endnote&#39;

            content -- str regex

        Return: list of Note
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:note&#34;, note_class=note_class, content=content
        )

    def get_note(self, position=0, note_id=None, note_class=None, content=None):
        &#34;&#34;&#34;Return the note that matches the criteria.

        Arguments:

            position -- int

            note_id -- str

            note_class -- &#39;footnote&#39; or &#39;endnote&#39;

            content -- str regex

        Return: Note or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::text:note&#34;,
            position,
            text_id=note_id,
            note_class=note_class,
            content=content,
        )

    # Annotations

    def get_annotations(
        self, creator=None, start_date=None, end_date=None, content=None
    ):
        &#34;&#34;&#34;Return all the annotations that match the criteria.

        Arguments:

            creator -- str

            start_date -- date object

            end_date -- date object

            content -- str regex

        Return: list of Annotation
        &#34;&#34;&#34;
        annotations = []
        for annotation in _get_elements(
            self, &#34;descendant::office:annotation&#34;, content=content
        ):
            if creator is not None and creator != annotation.dc_creator:
                continue
            date = annotation.dc_date
            if start_date is not None and date &lt; start_date:
                continue
            if end_date is not None and date &gt;= end_date:
                continue
            annotations.append(annotation)
        return annotations

    def get_annotation(
        self,
        position=0,
        creator=None,
        start_date=None,
        end_date=None,
        content=None,
        name=None,
    ):
        &#34;&#34;&#34;Return the annotation that matches the criteria.

        Arguments:

            position -- int

            creator -- str

            start_date -- date object

            end_date -- date object

            content -- str regex

            name -- str

        Return: Annotation or None if not found
        &#34;&#34;&#34;
        if name is not None:
            return _get_element(
                self, &#34;descendant::office:annotation&#34;, 0, office_name=name
            )
        annotations = self.get_annotations(
            creator=creator, start_date=start_date, end_date=end_date, content=content
        )
        if not annotations:
            return None
        try:
            return annotations[position]
        except IndexError:
            return None

    def get_annotation_ends(self):
        &#34;&#34;&#34;Return all the annotation ends.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::office:annotation-end&#34;)

    def get_annotation_end(self, position=0, name=None):
        &#34;&#34;&#34;Return the annotation end that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::office:annotation-end&#34;, position, office_name=name
        )

    # office:names

    def get_office_names(self):
        &#34;&#34;&#34;Return all the used office:name tags values of the element.

        Return: list of unique str
        &#34;&#34;&#34;
        name_xpath_query = _find_query_in_cache(&#34;//@office:name&#34;)
        names = name_xpath_query(self.__element)
        uniq_names = list(set(names))
        return uniq_names

    # Variables

    def get_variable_decls(self):
        &#34;&#34;&#34;Return the container for variable declarations. Created if not
        found.

        Return: Element
        &#34;&#34;&#34;
        variable_decls = self.get_element(&#34;//text:variable-decls&#34;)
        if variable_decls is None:
            body = self.document_body
            body.insert(Element.from_tag(&#34;text:variable-decls&#34;), FIRST_CHILD)
            variable_decls = body.get_element(&#34;//text:variable-decls&#34;)

        return variable_decls

    def get_variable_decl_list(self):
        &#34;&#34;&#34;Return all the variable declarations.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:variable-decl&#34;)

    def get_variable_decl(self, name, position=0):
        &#34;&#34;&#34;return the variable declaration for the given name.

        return: Element or none if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:variable-decl&#34;, position, text_name=name
        )

    def get_variable_sets(self, name=None):
        &#34;&#34;&#34;Return all the variable sets that match the criteria.

        Arguments:

            name -- str

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:variable-set&#34;, text_name=name)

    def get_variable_set(self, name, position=-1):
        &#34;&#34;&#34;Return the variable set for the given name (last one by default).

        Arguments:

            name -- str

            position -- int

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:variable-set&#34;, position, text_name=name
        )

    def get_variable_set_value(self, name, value_type=None):
        &#34;&#34;&#34;Return the last value of the given variable name.

        Arguments:

            name -- str

            value_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;,
                          &#39;percentage&#39;, &#39;string&#39;, &#39;time&#39; or automatic

        Return: most appropriate Python type
        &#34;&#34;&#34;
        variable_set = self.get_variable_set(name)
        if not variable_set:
            return None
        return get_value(variable_set, value_type)

    # User fields

    def get_user_field_decls(self):
        &#34;&#34;&#34;Return the container for user field declarations. Created if not
        found.

        Return: Element
        &#34;&#34;&#34;
        user_field_decls = self.get_element(&#34;//text:user-field-decls&#34;)
        if user_field_decls is None:
            body = self.document_body
            body.insert(Element.from_tag(&#34;text:user-field-decls&#34;), FIRST_CHILD)
            user_field_decls = body.get_element(&#34;//text:user-field-decls&#34;)

        return user_field_decls

    def get_user_field_decl_list(self):
        &#34;&#34;&#34;Return all the user field declarations.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:user-field-decl&#34;)

    def get_user_field_decl(self, name, position=0):
        &#34;&#34;&#34;return the user field declaration for the given name.

        return: Element or none if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:user-field-decl&#34;, position, text_name=name
        )

    def get_user_field_value(self, name, value_type=None):
        &#34;&#34;&#34;Return the value of the given user field name.

        Arguments:

            name -- str

            value_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;,
                          &#39;percentage&#39;, &#39;string&#39;, &#39;time&#39; or automatic

        Return: most appropriate Python type
        &#34;&#34;&#34;
        user_field_decl = self.get_user_field_decl(name)
        if user_field_decl is None:
            return None
        return get_value(user_field_decl, value_type)

    # User defined fields
    # They are fields who should contain a copy of a user defined medtadata

    def get_user_defined_list(self):
        &#34;&#34;&#34;Return all the user defined field declarations.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:user-defined&#34;)

    def get_user_defined(self, name, position=0):
        &#34;&#34;&#34;return the user defined declaration for the given name.

        return: Element or none if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:user-defined&#34;, position, text_name=name
        )

    def get_user_defined_value(self, name, value_type=None):
        &#34;&#34;&#34;Return the value of the given user defined field name.

        Arguments:

            name -- str

            value_type -- &#39;boolean&#39;, &#39;date&#39;, &#39;float&#39;,
                          &#39;string&#39;, &#39;time&#39; or automatic

        Return: most appropriate Python type
        &#34;&#34;&#34;
        user_defined = self.get_user_defined(name)
        if user_defined is None:
            return None
        return get_value(user_defined, value_type)

    # Draw Pages

    def get_draw_pages(self, style=None, content=None):
        &#34;&#34;&#34;Return all the draw pages that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of DrawPage
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::draw:page&#34;, draw_style=style, content=content
        )

    def get_draw_page(self, position=0, name=None, content=None):
        &#34;&#34;&#34;Return the draw page that matches the criteria.

        Arguments:

            position -- int

            name -- str

            content -- str regex

        Return: DrawPage or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:page&#34;, position, draw_name=name, content=content
        )

    # Links

    def get_links(self, name=None, title=None, url=None, content=None):
        &#34;&#34;&#34;Return all the links that match the criteria.

        Arguments:

            name -- str

            title -- str

            url -- str regex

            content -- str regex

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::text:a&#34;,
            office_name=name,
            office_title=title,
            url=url,
            content=content,
        )

    def get_link(self, position=0, name=None, title=None, url=None, content=None):
        &#34;&#34;&#34;Return the link that matches the criteria.

        Arguments:

            position -- int

            name -- str

            title -- str

            url -- str regex

            content -- str regex

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::text:a&#34;,
            position,
            office_name=name,
            office_title=title,
            url=url,
            content=content,
        )

    # Bookmarks

    def get_bookmarks(self):
        &#34;&#34;&#34;Return all the bookmarks.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:bookmark&#34;)

    def get_bookmark(self, position=0, name=None):
        &#34;&#34;&#34;Return the bookmark that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Bookmark or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:bookmark&#34;, position, text_name=name)

    def get_bookmark_starts(self):
        &#34;&#34;&#34;Return all the bookmark starts.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:bookmark-start&#34;)

    def get_bookmark_start(self, position=0, name=None):
        &#34;&#34;&#34;Return the bookmark start that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:bookmark-start&#34;, position, text_name=name
        )

    def get_bookmark_ends(self):
        &#34;&#34;&#34;Return all the bookmark ends.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:bookmark-end&#34;)

    def get_bookmark_end(self, position=0, name=None):
        &#34;&#34;&#34;Return the bookmark end that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:bookmark-end&#34;, position, text_name=name
        )

    # Reference marks

    def get_reference_marks_single(self):
        &#34;&#34;&#34;Return all the reference marks. Search only the tags
        text:reference-mark.
        Consider using : get_reference_marks()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:reference-mark&#34;)

    def get_reference_mark_single(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark that matches the criteria. Search only the
        tags text:reference-mark.
        Consider using : get_reference_mark()

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:reference-mark&#34;, position, text_name=name
        )

    def get_reference_mark_starts(self):
        &#34;&#34;&#34;Return all the reference mark starts. Search only the tags
        text:reference-mark-start.
        Consider using : get_reference_marks()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:reference-mark-start&#34;)

    def get_reference_mark_start(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark start that matches the criteria. Search
        only the tags text:reference-mark-start.
        Consider using : get_reference_mark()

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:reference-mark-start&#34;, position, text_name=name
        )

    def get_reference_mark_ends(self):
        &#34;&#34;&#34;Return all the reference mark ends. Search only the tags
        text:reference-mark-end.
        Consider using : get_reference_marks()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:reference-mark-end&#34;)

    def get_reference_mark_end(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark end that matches the criteria. Search only
        the tags text:reference-mark-end.
        Consider using : get_reference_marks()

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:reference-mark-end&#34;, position, text_name=name
        )

    def get_reference_marks(self):
        &#34;&#34;&#34;Return all the reference marks, either single position reference
        (text:reference-mark) or start of range reference
        (text:reference-mark-start).

        Return: list of Element
        &#34;&#34;&#34;
        request = (
            &#34;descendant::text:reference-mark-start | descendant::text:reference-mark&#34;
        )
        return _get_elements(self, request)

    def get_reference_mark(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark that match the criteria. Either single
        position reference mark (text:reference-mark) or start of range
        reference (text:reference-mark-start).

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        name = to_str(name)
        if name:
            request = (
                f&#34;descendant::text:reference-mark-start&#34;
                f&#39;[@text:name=&#34;{name}&#34;] &#39;
                f&#34;| descendant::text:reference-mark&#34;
                f&#39;[@text:name=&#34;{name}&#34;]&#39;
            )
            return _get_element(self, request, position=0)
        request = (
            &#34;descendant::text:reference-mark-start | descendant::text:reference-mark&#34;
        )
        return _get_element(self, request, position)

    def get_references(self, name=None):
        &#34;&#34;&#34;Return all the references (text:reference-ref). If name is
        provided, returns the references of that name.

        Return: list of Element

        Arguments:

            name -- str or None
        &#34;&#34;&#34;
        if name is None:
            return _get_elements(self, &#34;descendant::text:reference-ref&#34;)
        request = &#39;descendant::text:reference-ref[@text:ref-name=&#34;%s&#34;]&#39; % to_bytes(name)
        return _get_elements(self, request)

    # Shapes elements

    # Groups

    def get_draw_groups(self, title=None, description=None, content=None):
        return _get_elements(
            self,
            &#34;descendant::draw:g&#34;,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    def get_draw_group(
        self, position=0, name=None, title=None, description=None, content=None
    ):
        return _get_element(
            self,
            &#34;descendant::draw:g&#34;,
            position,
            draw_name=name,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    # Lines

    def get_draw_lines(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw lines that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:line&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_line(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw line that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:line&#34;, position, draw_id=id, content=content
        )

    # Rectangles

    def get_draw_rectangles(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw rectangles that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:rect&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_rectangle(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw rectangle that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:rect&#34;, position, draw_id=id, content=content
        )

    # Ellipse

    def get_draw_ellipses(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw ellipses that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:ellipse&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_ellipse(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw ellipse that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:ellipse&#34;, position, draw_id=id, content=content
        )

    # Connectors

    def get_draw_connectors(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw connectors that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:connector&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_connector(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw connector that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:connector&#34;, position, draw_id=id, content=content
        )

    def get_orphan_draw_connectors(self):
        &#34;&#34;&#34;Return a list of connectors which don&#39;t have any shape connected
        to them.
        &#34;&#34;&#34;
        connectors = []
        for connector in self.get_draw_connectors():
            start_shape = connector.get_attribute(&#34;draw:start-shape&#34;)
            end_shape = connector.get_attribute(&#34;draw:end-shape&#34;)
            if start_shape is None and end_shape is None:
                connectors.append(connector)
        return connectors

    # Tracked changes and text change

    def get_tracked_changes(self):
        &#34;&#34;&#34;Return the tracked-changes part in the text body.&#34;&#34;&#34;
        return self.get_element(&#34;//text:tracked-changes&#34;)

    def get_changes_ids(self):
        &#34;&#34;&#34;Return a list of ids that refers to a change region in the tracked
        changes list.
        &#34;&#34;&#34;
        # Insertion changes
        xpath_query = &#34;descendant::text:change-start/@text:change-id&#34;
        # Deletion changes
        xpath_query += &#34; | descendant::text:change/@text:change-id&#34;
        return self.xpath(xpath_query)

    def get_text_change_deletions(self):
        &#34;&#34;&#34;Return all the text changes of deletion kind: the tags text:change.
        Consider using : get_text_changes()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:text:change&#34;)

    def get_text_change_deletion(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change of deletion kind that matches the criteria.
        Search only for the tags text:change.
        Consider using : get_text_change()

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:change&#34;, position, change_id=idx)

    def get_text_change_starts(self):
        &#34;&#34;&#34;Return all the text change-start. Search only for the tags
        text:change-start.
        Consider using : get_text_changes()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:change-start&#34;)

    def get_text_change_start(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change-start that matches the criteria. Search
        only the tags text:change-start.
        Consider using : get_text_change()

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:change-start&#34;, position, change_id=idx
        )

    def get_text_change_ends(self):
        &#34;&#34;&#34;Return all the text change-end. Search only the tags
        text:change-end.
        Consider using : get_text_changes()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:change-end&#34;)

    def get_text_change_end(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change-end that matches the criteria. Search only
        the tags text:change-end.
        Consider using : get_text_change()

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:change-end&#34;, position, change_id=idx
        )

    def get_text_changes(self):
        &#34;&#34;&#34;Return all the text changes, either single deletion
        (text:change) or start of range of changes (text:change-start).

        Return: list of Element
        &#34;&#34;&#34;
        request = &#34;descendant::text:change-start | descendant::text:change&#34;
        return _get_elements(self, request)

    def get_text_change(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change that matches the criteria. Either single
        deletion (text:change) or start of range of changes (text:change-start).
        position : index of the element to retrieve if several matches, default
        is 0.
        idx : change-id of the element.

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        if idx:
            request = (
                f&#39;descendant::text:change-start[@text:change-id=&#34;{idx}&#34;] &#39;
                f&#39;| descendant::text:change[@text:change-id=&#34;{idx}&#34;]&#39;
            )
            return _get_element(self, request, position=0)
        request = &#34;descendant::text:change-start | descendant::text:change&#34;
        return _get_element(self, request, position)

    # Table Of Content

    def get_tocs(self):
        &#34;&#34;&#34;Return all the tables of contents.

        Return: list of odf_toc
        &#34;&#34;&#34;
        return _get_elements(self, &#34;text:table-of-content&#34;)

    def get_toc(self, position=0, content=None):
        &#34;&#34;&#34;Return the table of contents that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: odf_toc or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;text:table-of-content&#34;, position, content=content)

    # Styles

    @staticmethod
    def _get_style_tagname(family, is_default=False):
        &#34;&#34;&#34;Widely match possible tag names given the family (or not).&#34;&#34;&#34;
        if not family:
            tagname = (
                &#34;(&#34;
                + &#34;|&#34;.join(
                    [
                        &#34;style:default-style&#34;,
                        &#34;*[@style:name]&#34;,
                        &#34;draw:fill-image&#34;,
                        &#34;draw:marker&#34;,
                    ]
                )
                + &#34;)&#34;
            )
        elif is_default:
            # Default style
            tagname = &#34;style:default-style&#34;
        else:
            tagname = _family_style_tagname(family)
            # if famattr:
            #    # Include family default style
            #    tagname = &#39;(%s|style:default-style)&#39; % tagname
            if family in FAMILY_ODF_STD:
                # Include family default style
                tagname = &#34;(%s|style:default-style)&#34; % tagname
        return tagname

    def get_styles(self, family=None):
        # Both common and default styles
        tagname = self._get_style_tagname(family)
        return _get_elements(self, tagname, family=family)

    def get_style(self, family, name_or_element=None, display_name=None):
        &#34;&#34;&#34;Return the style uniquely identified by the family/name pair. If
        the argument is already a style object, it will return it.

        If the name is not the internal name but the name you gave in the
        desktop application, use display_name instead.

        Arguments:

            family -- &#39;paragraph&#39;, &#39;text&#39;, &#39;graphic&#39;, &#39;table&#39;, &#39;list&#39;,
                      &#39;number&#39;

            name_or_element -- str or Style

            display_name -- str

        Return: odf_style or None if not found
        &#34;&#34;&#34;
        if isinstance(name_or_element, Element):
            name = self.get_attribute(&#34;style:name&#34;)
            if name is not None:
                return name_or_element
            else:
                raise ValueError(&#34;Not a odf_style ?  %s&#34; % name_or_element)
        style_name = name_or_element
        is_default = not (style_name or display_name)
        tagname = self._get_style_tagname(family, is_default=is_default)
        # famattr became None if no &#34;style:family&#34; attribute
        if family:
            return _get_element(
                self,
                tagname,
                0,
                style_name=style_name,
                display_name=display_name,
                family=family,
            )
        else:
            return _get_element(
                self,
                tagname,
                0,
                draw_name=style_name or display_name,
                family=family,
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="odfdo.element.register_element_class"><code class="name flex">
<span>def <span class="ident">register_element_class</span></span>(<span>cls, tag_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Associate a qualified element name to a Python class that handles this
type of element.</p>
<p>Getting the right Python class when loading an existing ODF document is
then transparent. Unassociated elements will be handled by the base
Element class.</p>
<p>Most styles use the "style:style" qualified name and only differ by their
"style:family" attribute. So the "family" attribute was added to register
specialized style classes.</p>
<h2 id="arguments">Arguments</h2>
<p>cls &ndash; Python class</p>
<p>qname &ndash; (optionnal) iterable of qname tag for the class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_element_class(cls, tag_list=None):
    &#34;&#34;&#34;Associate a qualified element name to a Python class that handles this
    type of element.

    Getting the right Python class when loading an existing ODF document is
    then transparent. Unassociated elements will be handled by the base
    Element class.

    Most styles use the &#34;style:style&#34; qualified name and only differ by their
    &#34;style:family&#34; attribute. So the &#34;family&#34; attribute was added to register
    specialized style classes.

    Arguments:

        cls -- Python class

        qname -- (optionnal) iterable of qname tag for the class
    &#34;&#34;&#34;
    # Turn tag name into what lxml is expecting
    if not tag_list:
        tag_list = [cls._tag]
    for k in tag_list:
        tag = _get_lxml_tag(k)
        if tag not in _class_registry:
            _class_registry[tag] = cls</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="odfdo.element.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of all ODF classes. Representation of an XML element.
Abstraction of the XML library behind.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element:
    &#34;&#34;&#34;Super class of all ODF classes. Representation of an XML element.
    Abstraction of the XML library behind.
    &#34;&#34;&#34;

    _tag = None
    _caching = False

    def __init__(self, **kwargs):
        tag_or_elem = kwargs.pop(&#34;tag_or_elem&#34;, None)
        if tag_or_elem is None:
            # Instance for newly created object: create new lxml element and
            # continue by subclass __init__
            # If the tag key word exists, make a custom element
            self._do_init = True
            tag = kwargs.pop(&#34;tag&#34;, self._tag)
            self.__element = self.make_etree_element(tag)
        else:
            # called with an existing lxml element, sould be a result of
            # from_tag() casting, do not execute the subclass __ini__
            if not isinstance(tag_or_elem, _Element):
                raise TypeError(&#39;&#34;%s&#34; is not an element node&#39; % type(tag_or_elem))
            self._do_init = False
            self.__element = tag_or_elem

    @classmethod
    def from_tag(cls, tag_or_elem):
        &#34;&#34;&#34;Element class and subclass factory. Turn an lxml Element or ODF
        string tag into an ODF XML Element from the relevant class.

        Arguments:

            tag_or_elem -- ODF str tag or lxml.Element

        Return: Element (or subclass) instance
        &#34;&#34;&#34;
        if not isinstance(tag_or_elem, _Element):
            # assume the argument is a prefix:name tag
            tag_or_elem = cls.make_etree_element(tag_or_elem)
        tag = to_str(tag_or_elem.tag)
        klass = _class_registry.get(tag, cls)
        return klass(tag_or_elem=tag_or_elem)

    @classmethod
    def from_tag_for_clone(cls, tag_or_elem, cache):
        tag = to_str(tag_or_elem.tag)
        klass = _class_registry.get(tag, cls)
        element = klass(tag_or_elem=tag_or_elem)
        if cache and element._caching:
            element._tmap = cache[0]
            element._cmap = cache[1]
            if len(cache) == 3:
                element._rmap = cache[2]
        return element

    @staticmethod
    def make_etree_element(tag):
        if not isinstance(tag, (str, bytes)):
            raise TypeError(&#34;tag is not str or bytes: %s&#34; % tag)
        tag = to_bytes(tag).strip()
        if not tag:
            raise ValueError(&#34;tag is empty&#34;)
        if b&#34;&lt;&#34; not in tag:
            # Qualified name
            # XXX don&#39;t build the element from scratch or lxml will pollute with
            # repeated namespace declarations
            tag = b&#34;&lt;%s/&gt;&#34; % tag
        # XML fragment
        root = fromstring(NAMESPACES_XML % tag)  # noqa:S320
        return root[0]

    def __str__(self):
        return f&#39;{self!r} &#34;{self.tag}&#34;&#39;

    @staticmethod
    def _generic_attrib_getter(attr_name, family=None):
        name = _get_lxml_tag(attr_name)

        def getter(self):
            if family and self.family != family:
                return None
            value = self.__element.get(name)
            if value is None:
                return None
            elif value in (&#34;true&#34;, &#34;false&#34;):
                return Boolean.decode(value)
            return str(value)

        return getter

    @staticmethod
    def _generic_attrib_setter(attr_name, family=None):
        name = _get_lxml_tag(attr_name)

        def setter(self, value):
            if family and self.family != family:
                return None
            if value is None:
                with contextlib.suppress(KeyError):
                    del self.__element.attrib[name]
                return
            if isinstance(value, bool):
                value = Boolean.encode(value)
            self.__element.set(name, str(value))

        return setter

    @classmethod
    def _define_attribut_property(cls):
        for tpl in cls._properties:
            name = tpl[0]
            attr = tpl[1]
            if len(tpl) == 3:
                family = tpl[2]
            else:
                family = None
            setattr(
                cls,
                name,
                property(
                    cls._generic_attrib_getter(attr, family),
                    cls._generic_attrib_setter(attr, family),
                    None,
                    f&#34;Get/set the attribute {attr}&#34;,
                ),
            )

    def _insert_before_after(
        self,
        current,
        element,
        before,
        after,
        position,
        main_text,
        xpath_text,
    ):
        # 1) before xor after is not None
        if before is not None:
            regex = re.compile(before)
        else:
            regex = re.compile(after)

        # position = -1
        if position &lt; 0:
            # Found the last text that matches the regex
            text = None
            for a_text in xpath_text(current):
                if regex.search(a_text) is not None:
                    text = a_text
            if text is None:
                raise ValueError(&#34;text not found&#34;)
            sre = list(regex.finditer(text))[-1]
        # position &gt;= 0
        else:
            count = 0
            for text in xpath_text(current):
                found_nb = len(regex.findall(text))
                if found_nb + count &gt;= position + 1:
                    break
                count += found_nb
            else:
                raise ValueError(&#34;text not found&#34;)
            sre = list(regex.finditer(text))[position - count]
        # Compute pos
        pos = sre.start() if before is not None else sre.end()
        return pos, text

    def _insert_find_text(
        self,
        current,
        element,
        before,
        after,
        position,
        main_text,
        xpath_text,
    ):
        # Found the text
        count = 0
        for text in xpath_text(current):
            found_nb = len(text)
            if found_nb + count &gt;= position:
                break
            count += found_nb
        else:
            raise ValueError(&#34;text not found&#34;)
        # We insert before the character
        pos = position - count
        return pos, text

    def _insert(self, element, before=None, after=None, position=0, main_text=False):
        &#34;&#34;&#34;Insert an element before or after the characters in the text which
        match the regex before/after. When the regex matches more of one part
        of the text, position can be set to choice which part must be used. If
        before and after are None, we use only position that is the number of
        characters. If position is positive and before=after=None, we insert
        before the position character. But if position=-1, we insert after the
        last character.

        if main_text is True, filter out the annotations texts in computation.

        Arguments:

        element -- Element

        before -- str regex

        after -- str regex

        position -- int

        main_text -- boolean
        &#34;&#34;&#34;
        current = self.__element
        element = element.__element

        if main_text:
            xpath_text = _xpath_text_main_descendant
        else:
            xpath_text = _xpath_text_descendant

        # 1) before xor after is not None
        if (before is not None) ^ (after is not None):
            pos, text = self._insert_before_after(
                current,
                element,
                before,
                after,
                position,
                main_text,
                xpath_text,
            )
        # 2) before=after=None =&gt; only with position
        elif before is None and after is None:
            # Hack if position is negative =&gt; quickly
            if position &lt; 0:
                current.append(element)
                return
            pos, text = self._insert_find_text(
                current,
                element,
                before,
                after,
                position,
                main_text,
                xpath_text,
            )
        else:
            raise ValueError(&#34;bad combination of arguments&#34;)

        # Compute new texts
        text_before = text[:pos] if text[:pos] else None
        text_after = text[pos:] if text[pos:] else None

        # Insert!
        parent = text.getparent()
        if text.is_text:
            parent.text = text_before
            element.tail = text_after
            parent.insert(0, element)
        else:
            parent.addnext(element)
            parent.tail = text_before
            element.tail = text_after

    def _insert_between(self, element, from_, to):
        &#34;&#34;&#34;Insert the given empty element to wrap the text beginning with
        &#34;from_&#34; and ending with &#34;to&#34;.

        Example 1: &#39;&lt;p&gt;toto tata titi&lt;/p&gt;

        We want to insert a link around &#34;tata&#34;.

        Result 1: &#39;&lt;p&gt;toto &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;

        Example 2: &#39;&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; tata titi&lt;/p&gt;

        We want to insert a link around &#34;tata&#34;.

        Result 2: &#39;&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;

        Example 3: &#39;&lt;p&gt;toto &lt;span&gt; tata &lt;/span&gt; titi&lt;/p&gt;&#39;

        We want to insert a link from &#34;tata&#34; to &#34;titi&#34; included.

        Result 3: &#39;&lt;p&gt;toto &lt;span&gt; &lt;/span&gt;&#39;
                  &#39;&lt;a&gt;&lt;span&gt;tata &lt;/span&gt; titi&lt;/a&gt;&lt;/p&gt;&#39;

        Example 4: &#39;&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; tutu&lt;/p&gt;&#39;

        We want to insert a link from &#34;titi&#34; to &#34;tutu&#34;

        Result 4: &#39;&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;/a&gt;&#39;
                  &#39;&lt;a&gt; tutu&lt;/a&gt;&lt;/p&gt;&#39;

        Example 5: &#39;&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; &#39;
                   &#39;&lt;span&gt;tutu tyty&lt;/span&gt;&lt;/p&gt;&#39;

        We want to insert a link from &#34;titi&#34; to &#34;tutu&#34;

        Result 5: &#39;&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;a&gt; &#39;
                  &#39;&lt;a&gt; &lt;span&gt;tutu&lt;/span&gt;&lt;/a&gt;&lt;span&gt; tyty&lt;/span&gt;&lt;/p&gt;&#39;
        &#34;&#34;&#34;
        current = self.__element
        wrapper = element.__element
        for text in _xpath_text_descendant(current):
            if from_ not in text:
                continue
            from_index = text.index(from_)
            text_before = text[:from_index]
            text_after = text[from_index:]
            from_container = text.getparent()
            # Include from_index to match a single word
            to_index = text.find(to, from_index)
            if to_index &gt;= 0:
                # Simple case: &#34;from&#34; and &#34;to&#34; in the same element
                to_end = to_index + len(to)
                if text.is_text:
                    from_container.text = text_before
                    wrapper.text = text[to_index:to_end]
                    wrapper.tail = text[to_end:]
                    from_container.insert(0, wrapper)
                else:
                    from_container.tail = text_before
                    wrapper.text = text[to_index:to_end]
                    wrapper.tail = text[to_end:]
                    parent = from_container.getparent()
                    index = parent.index(from_container)
                    parent.insert(index + 1, wrapper)
                return
            else:
                # Exit to the second part where we search for the end text
                break
        else:
            raise ValueError(&#34;start text not found&#34;)
        # The container is split in two
        container2 = deepcopy(from_container)
        if text.is_text:
            from_container.text = text_before
            from_container.tail = None
            container2.text = text_after
            from_container.tail = None
        else:
            from_container.tail = text_before
            container2.tail = text_after
        # Stack the copy into the surrounding element
        wrapper.append(container2)
        parent = from_container.getparent()
        index = parent.index(from_container)
        parent.insert(index + 1, wrapper)
        for text in _xpath_text_descendant(wrapper):
            if to not in text:
                continue
            to_end = text.index(to) + len(to)
            text_before = text[:to_end]
            text_after = text[to_end:]
            container_to = text.getparent()
            if text.is_text:
                container_to.text = text_before
                container_to.tail = text_after
            else:
                container_to.tail = text_before
                next_one = container_to.getnext()
                if next_one is None:
                    next_one = container_to.getparent()
                next_one.tail = text_after
            return
        raise ValueError(&#34;end text not found&#34;)

    @property
    def tag(self):
        &#34;&#34;&#34;Get/set the underlying xml tag with the given qualified name.

        Warning: direct change of tag does not change the element class.

        Arguments:

            qname -- str (e.g. &#34;text:span&#34;)
        &#34;&#34;&#34;
        return _get_prefixed_name(self.__element.tag)

    @tag.setter
    def tag(self, qname):
        self.__element.tag = to_bytes(_get_lxml_tag(qname))

    def elements_repeated_sequence(self, xpath_instance, name):
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
        element = self.__element
        sub_elements = xpath_instance(element)
        result = []
        idx = -1
        for sub_element in sub_elements:
            idx += 1
            value = sub_element.get(name)
            if value is None:
                result.append((idx, 1))
                continue
            try:
                value = int(value)
            except ValueError:
                value = 1
            result.append((idx, max(value, 1)))
        return result

    def get_elements(self, xpath_query):
        element = self.__element
        if isinstance(xpath_query, XPath):
            result = xpath_query(element)
        else:
            new_xpath_query = _find_query_in_cache(to_bytes(xpath_query))
            result = new_xpath_query(element)
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                cache = (self._tmap, self._cmap, self._rmap)
            else:
                cache = (self._tmap, self._cmap)
        else:
            cache = None
        return [Element.from_tag_for_clone(e, cache) for e in result]

    # fixme : need original get_element as wrapper of get_elements

    def get_element(self, xpath_query):
        element = self.__element
        result = element.xpath(&#34;(%s)[1]&#34; % xpath_query, namespaces=ODF_NAMESPACES)
        if result:
            return Element.from_tag(result[0])
        return None

    def _get_element_idx(self, xpath_query, idx):
        element = self.__element
        result = element.xpath(f&#34;({xpath_query})[{idx + 1}]&#34;, namespaces=ODF_NAMESPACES)
        if result:
            return Element.from_tag(result[0])
        return None

    def _get_element_idx2(self, xpath_instance, idx):
        element = self.__element
        result = xpath_instance(element, idx=idx + 1)
        if result:
            return Element.from_tag(result[0])
        return None

    @property
    def attributes(self):
        e = self.__element
        return {_get_prefixed_name(k): v for k, v in e.attrib.items()}

    def get_attribute(self, name):
        element = self.__element
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
        value = element.get(name)
        if value is None:
            return None
        elif value in (&#34;true&#34;, &#34;false&#34;):
            return Boolean.decode(value)
        return str(value)

    def get_attribute_integer(self, name):
        atr = self.get_attribute(name)
        if atr is None:
            return atr
        try:
            return int(atr)
        except ValueError:
            return None

    def set_attribute(self, name, value):
        element = self.__element
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031

        if isinstance(value, bool):
            value = Boolean.encode(value)
        elif value is None:
            with contextlib.suppress(KeyError):
                del element.attrib[name]
            return
        element.set(name, str(value))

    def set_style_attribute(self, name, value):
        &#34;&#34;&#34;Shortcut to accept a style object as a value.&#34;&#34;&#34;
        if isinstance(value, Element):
            value = value.name
        return self.set_attribute(name, value)

    def del_attribute(self, name):
        element = self.__element
        uri, name = _decode_qname(name)
        if uri is not None:
            name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
        del element.attrib[name]

    @property
    def text(self):
        &#34;&#34;&#34;Get / set the text content of the element.&#34;&#34;&#34;
        return self.__element.text or &#34;&#34;

    @text.setter
    def text(self, text):
        if text is None:
            text = &#34;&#34;
        try:
            self.__element.text = to_str(text)
        except TypeError as e:
            raise TypeError(f&#39;str type expected: &#34;{type(text)}&#34;&#39;) from e

    @property
    def text_recursive(self):
        return &#34;&#34;.join(self.__element.itertext())

    @property
    def tail(self):
        &#34;&#34;&#34;Get / set the text immediately following the element.&#34;&#34;&#34;
        return self.__element.tail

    @tail.setter
    def tail(self, text):
        self.__element.tail = text or &#34;&#34;

    def search(self, pattern):
        &#34;&#34;&#34;Return the first position of the pattern in the text content of
        the element, or None if not found.

        Python regular expression syntax applies.

        Arguments:

            pattern -- str

        Return: int or None
        &#34;&#34;&#34;
        match = re.search(pattern, self.text_recursive)
        if match is None:
            return None
        return match.start()

    def match(self, pattern):
        &#34;&#34;&#34;return True if the pattern is found one or more times anywhere in
        the text content of the element.

        Python regular expression syntax applies.

        Arguments:

            pattern -- str

        Return: bool
        &#34;&#34;&#34;
        return self.search(pattern) is not None

    def replace(self, pattern, new=None):
        &#34;&#34;&#34;Replace the pattern with the given text, or delete if text is an
        empty string, and return the number of replacements. By default, only
        return the number of occurences that would be replaced.

        It cannot replace patterns found across several element, like a word
        split into two consecutive spans.

        Python regular expression syntax applies.

        Arguments:

            pattern -- str

            new -- str

        Return: int
        &#34;&#34;&#34;
        if not isinstance(pattern, str):
            # Fail properly if the pattern is an non-ascii bytestring
            pattern = str(pattern)
        cpattern = re.compile(pattern)
        count = 0
        for text in self.xpath(&#34;descendant::text()&#34;):
            if new is None:
                count += len(cpattern.findall(text))
            else:
                new_text, number = cpattern.subn(new, text)
                container = text.parent
                if text.is_text():
                    container.text = new_text
                else:
                    container.tail = new_text
                count += number
        return count

    @property
    def root(self):
        element = self.__element
        tree = element.getroottree()
        root = tree.getroot()
        return Element.from_tag(root)

    @property
    def parent(self):
        element = self.__element
        parent = element.getparent()
        if parent is None:
            # Already at root
            return None
        return Element.from_tag(parent)

    # def get_next_sibling(self):
    #     element = self.__element
    #     next_one = element.getnext()
    #     if next_one is None:
    #         return None
    #     return Element.from_tag(next_one)
    #
    # def get_prev_sibling(self):
    #     element = self.__element
    #     prev = element.getprevious()
    #     if prev is None:
    #         return None
    #     return Element.from_tag(prev)

    @property
    def children(self):
        element = self.__element
        return [Element.from_tag(e) for e in element.getchildren()]

    def index(self, child):
        &#34;&#34;&#34;Return the position of the child in this element.

        Inspired by lxml
        &#34;&#34;&#34;
        return self.__element.index(child.__element)

    @property
    def text_content(self):
        &#34;&#34;&#34;Get / set the text of the embedded paragraph, including embeded
        annotations, cells...

        Set create a paragraph if missing
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(
            child.text_recursive for child in self.get_elements(&#34;descendant::text:p&#34;)
        )

    @text_content.setter
    def text_content(self, text):
        paragraphs = self.get_elements(&#34;text:p&#34;)
        if not paragraphs:
            # E.g., text:p in draw:text-box in draw:frame
            paragraphs = self.get_elements(&#34;*/text:p&#34;)
        if paragraphs:
            paragraph = paragraphs.pop(0)
            for obsolete in paragraphs:
                obsolete.delete()
        else:
            paragraph = Element.from_tag(&#34;text:p&#34;)
            self.insert(paragraph, FIRST_CHILD)
        # As &#34;text_content&#34; returned all text nodes, &#34;text_content&#34;
        # will overwrite all text nodes and children that may contain them
        element = paragraph.__element
        # Clear but the attributes
        del element[:]
        element.text = text

    def _erase_text_content(self):
        paragraphs = self.get_elements(&#34;text:p&#34;)
        if not paragraphs:
            # E.g., text:p in draw:text-box in draw:frame
            paragraphs = self.get_elements(&#34;*/text:p&#34;)
        if paragraphs:
            paragraphs.pop(0)
            for obsolete in paragraphs:
                obsolete.delete()

    def is_empty(self):
        &#34;&#34;&#34;Check if the element is empty : no text, no children, no tail

        Return: Boolean
        &#34;&#34;&#34;
        element = self.__element
        if element.tail is not None:
            return False
        if element.text is not None:
            return False
        if element.getchildren():
            return False
        return True

    def _get_successor(self, target):
        element = self.__element
        next_one = element.getnext()
        if next_one is not None:
            return Element.from_tag(next_one), target
        parent = self.parent
        if parent is None:
            return None, None
        return parent._get_successor(target.parent)

    def _get_between_base(self, tag1, tag2):  # noqa:C901
        def find_any_id(tag):
            stag = tag.tag
            for attribute in (
                &#34;text:id&#34;,
                &#34;text:change-id&#34;,
                &#34;text:name&#34;,
                &#34;office:name&#34;,
                &#34;text:ref-name&#34;,
                &#34;xml:id&#34;,
            ):
                idx = tag.get_attribute(attribute)
                if idx is not None:
                    return stag, attribute, idx
            raise ValueError(&#34;No Id found in %s&#34; % tag.serialize())

        def common_ancestor(t1, a1, v1, t2, a2, v2):
            root = self.root
            request1 = f&#39;descendant::{t1}[@{a1}=&#34;{v1}&#34;]&#39;
            request2 = f&#39;descendant::{t2}[@{a2}=&#34;{v2}&#34;]&#39;
            up = root.xpath(request1)[0]
            while True:
                # print &#34;up&#34;,
                up = up.parent
                has_tag2 = up.xpath(request2)
                if not has_tag2:
                    continue
                # print &#39;found&#39;
                break
            # print up.serialize()
            return up

        t1, a1, v1 = find_any_id(tag1)
        t2, a2, v2 = find_any_id(tag2)
        ancestor = common_ancestor(t1, a1, v1, t2, a2, v2).clone
        r1 = f&#39;{t1}[@{a1}=&#34;{v1}&#34;]&#39;
        r2 = f&#39;{t2}[@{a2}=&#34;{v2}&#34;]&#39;
        resu = ancestor.clone
        for child in resu.children:
            resu.delete(child)
        resu.text = &#34;&#34;
        resu.tail = &#34;&#34;
        target = resu
        current = ancestor.children[0]
        state = 0
        while True:
            # print &#39;current&#39;, state, current.serialize()
            if state == 0:  # before tag 1
                if current.xpath(f&#34;descendant-or-self::{r1}&#34;):
                    if current.xpath(f&#34;self::{r1}&#34;):
                        tail = current.tail
                        if tail:
                            # got a tail =&gt; the parent should be either t:p or t:h
                            target.text = tail
                        current, target = current._get_successor(target)
                        state = 1
                        continue
                    # got T1 in chidren, need further analysis
                    new_target = current.clone
                    for child in new_target.children:
                        new_target.delete(child)
                    new_target.text = &#34;&#34;
                    new_target.tail = &#34;&#34;
                    target.append(new_target)
                    target = new_target
                    current = current.children[0]
                    continue
                else:
                    # before tag1 : forget element, go to next one
                    current, target = current._get_successor(target)
                    continue
            elif state == 1:  # collect elements
                further = False
                if current.xpath(f&#34;descendant-or-self::{r2}&#34;):
                    if current.xpath(f&#34;self::{r2}&#34;):
                        # end of trip
                        break
                    # got T2 in chidren, need further analysis
                    further = True
                # further analysis needed :
                if further:
                    new_target = current.clone
                    for child in new_target.children:
                        new_target.delete(child)
                    new_target.text = &#34;&#34;
                    new_target.tail = &#34;&#34;
                    target.append(new_target)
                    target = new_target
                    current = current.children[0]
                    continue
                # collect
                target.append(current.clone)
                current, target = current._get_successor(target)
                continue
        # Now resu should be the &#34;parent&#34; of inserted parts
        # - a text:h or text:p sigle item (simple case)
        # - a upper element, with some text:p, text:h in it =&gt; need to be
        #   stripped to have a list of text:p, text:h
        if resu.tag in {&#34;text:p&#34;, &#34;text:h&#34;}:
            inner = [resu]
        else:
            inner = resu.children
        return inner

    def get_between(self, tag1, tag2, as_text=False, clean=True, no_header=True):
        &#34;&#34;&#34;Returns elements between tag1 and tag2, tag1 and tag2 shall
        be unique and having an id attribute.
        (WARN: buggy if tag1/tag2 defines a malformed odf xml.)
        If as_text is True: returns the text content.
        If clean is True: suppress unwanted tags (deletions marks, ...)
        If no_header is True: existing text:h are changed in text:p
        By default: returns a list of Element, cleaned and without headers.

        Implementation and standard retrictions:
        Only text:h and text:p sould be &#39;cut&#39; by an insert tag, so inner parts
        of insert tags are:

            - any text:h, text:p or sub tag of these

            - some text, part of a parent text:h or text:p

        Arguments:

            tag1 -- Element

            tag2 -- Element

            as_text -- boolean

            clean -- boolean

            no_header -- boolean

        Return: list of odf_paragraph or odf_header
        &#34;&#34;&#34;
        inner = self._get_between_base(tag1, tag2)

        if clean:
            clean_tags = (
                &#34;text:change&#34;,
                &#34;text:change-start&#34;,
                &#34;text:change-end&#34;,
                &#34;text:reference-mark&#34;,
                &#34;text:reference-mark-start&#34;,
                &#34;text:reference-mark-end&#34;,
            )
            request_self = &#34; | &#34;.join([&#34;self::%s&#34; % c for c in clean_tags])
            inner = [e for e in inner if not e.xpath(request_self)]
            request = &#34; | &#34;.join([&#34;descendant::%s&#34; % c for c in clean_tags])
            for element in inner:
                to_del = element.xpath(request)
                for e in to_del:
                    element.delete(e)
        if no_header:  # crude replace t:h by t:p
            new_inner = []
            for element in inner:
                if element.tag == &#34;text:h&#34;:
                    children = element.children
                    text = element.__element.text
                    para = Element.from_tag(&#34;text:p&#34;)
                    para.text = text
                    for c in children:
                        para.append(c)
                    new_inner.append(para)
                else:
                    new_inner.append(element)
            inner = new_inner
        if as_text:
            return &#34;\n&#34;.join([e.get_formatted_text() for e in inner])
        else:
            return inner

    def insert(self, element, xmlposition=None, position=None, start=False):
        &#34;&#34;&#34;Insert an element relatively to ourself.

        Insert either using DOM vocabulary or by numeric position.
        If text start is True, insert the element before any existing text.

        Position start at 0.

        Arguments:

            element -- Element

            xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING
                           or PREV_SIBLING

            start -- Boolean

            position -- int
        &#34;&#34;&#34;
        # child_tag = element.tag
        current = self.__element
        element = element.__element
        if start:
            text = current.text
            if text is not None:
                current.text = None
                tail = element.tail
                if tail is None:
                    tail = text
                else:
                    tail = tail + text
                element.tail = tail
            position = 0
        if position is not None:
            current.insert(position, element)
        elif xmlposition is FIRST_CHILD:
            current.insert(0, element)
        elif xmlposition is LAST_CHILD:
            current.append(element)
        elif xmlposition is NEXT_SIBLING:
            parent = current.getparent()
            index = parent.index(current)
            parent.insert(index + 1, element)
        elif xmlposition is PREV_SIBLING:
            parent = current.getparent()
            index = parent.index(current)
            parent.insert(index, element)
        else:
            raise ValueError(&#34;(xml)position must be defined&#34;)

    def extend(self, odf_elements):
        &#34;&#34;&#34;Fast append elements at the end of ourself using extend.&#34;&#34;&#34;
        if odf_elements:
            current = self.__element
            elements = [element.__element for element in odf_elements]
            current.extend(elements)

    def append(self, str_or_element):
        &#34;&#34;&#34;Insert element or text in the last position.&#34;&#34;&#34;
        current = self.__element

        # Unicode ?
        if isinstance(str_or_element, str):
            # Has children ?
            children = current.getchildren()
            if children:
                # Append to tail of the last child
                last_child = children[-1]
                text = last_child.tail
                text = text if text is not None else &#34;&#34;
                text += str_or_element
                last_child.tail = text
            else:
                # Append to text of the element
                text = current.text
                text = text if text is not None else &#34;&#34;
                text += str_or_element
                current.text = text
        elif isinstance(str_or_element, Element):
            current.append(str_or_element.__element)
        else:
            raise TypeError(
                &#39;Element or unicode expected, not &#34;%s&#34;&#39; % (type(str_or_element))
            )

    def delete(self, child=None, keep_tail=True):
        &#34;&#34;&#34;Delete the given element from the XML tree. If no element is given,
        &#34;self&#34; is deleted. The XML library may allow to continue to use an
        element now &#34;orphan&#34; as long as you have a reference to it.

        if keep_tail is True (default), the tail text is not erased.

        Arguments:

            child -- Element

            keep_tail -- boolean (default to True), True for most usages.
        &#34;&#34;&#34;
        if child is None:
            parent = self.parent
            if parent is None:
                info = self.serialize()
                raise ValueError(&#34;cannot delete the root element\n%s&#34; % info)
            child = self
        else:
            parent = self
        if keep_tail and child.__element.tail is not None:
            current = child.__element
            tail = current.tail
            current.tail = None
            prev = current.getprevious()
            if prev is not None:
                if prev.tail is None:
                    prev.tail = tail
                else:
                    prev.tail += tail
            else:
                if parent.__element.text is None:
                    parent.__element.text = tail
                else:
                    parent.__element.text += tail
        parent.__element.remove(child.__element)

    def replace_element(self, old_element, new_element):
        &#34;&#34;&#34;Replaces in place a sub element with the element passed as second
        argument.

        Warning : no clone for old element.
        &#34;&#34;&#34;
        current = self.__element
        current.replace(old_element.__element, new_element.__element)

    def strip_elements(self, sub_elements):
        &#34;&#34;&#34;Remove the tags of provided elements, keeping inner childs and text.

        Return : the striped element.

        Warning : no clone in sub_elements list.

        Arguments:

            sub_elements -- Element or list of Element
        &#34;&#34;&#34;
        if not sub_elements:
            return self
        if isinstance(sub_elements, Element):
            sub_elements = (sub_elements,)
        replacer = to_bytes(_get_lxml_tag(&#34;text:this-will-be-removed&#34;))
        for element in sub_elements:
            element.__element.tag = replacer
        strip = (&#34;text:this-will-be-removed&#34;,)
        return self.strip_tags(strip=strip, default=None)

    def strip_tags(self, strip=None, protect=None, default=&#34;text:p&#34;):
        &#34;&#34;&#34;Remove the tags listed in strip, recursively, keeping inner childs
        and text. Tags listed in protect stop the removal one level depth. If
        the first level element is stripped, default is used to embed the
        content in the default element. If default is None and first level is
        striped, a list of text and children is returned. Return : the striped
        element.

        strip_tags should be used by on purpose methods (strip_span ...)
        (Method name taken from lxml).

        Arguments:

            strip -- iterable list of str odf tags, or None

            protect -- iterable list of str odf tags, or None

            default -- str odf tag, or None

        Return:

            Element or list.
        &#34;&#34;&#34;
        if not strip:
            return self
        if not protect:
            protect = ()
        protected = False
        element, modified = Element._strip_tags(self, strip, protect, protected)
        if modified and isinstance(element, list) and default:
            new = Element.from_tag(default)
            for content in element:
                if isinstance(content, Element):
                    new.append(content)
                else:
                    new.text = content
            element = new
        return element

    @staticmethod
    def _strip_tags(element, strip, protect, protected):  # noqa: C901
        &#34;&#34;&#34;sub method for strip_tags()&#34;&#34;&#34;
        copy = element.clone
        modified = False
        children = []
        if protect and element.tag in protect:
            protect_below = True
        else:
            protect_below = False
        for child in copy.children:
            striped_child, is_modified = Element._strip_tags(
                child, strip, protect, protect_below
            )
            if is_modified:
                modified = True
            if isinstance(striped_child, list):
                children.extend(striped_child)
            else:
                children.append(striped_child)
        if not protected and strip and element.tag in strip:
            element = []
            modified = True
        else:
            if not modified:
                return (element, False)
            element.clear()
            try:
                for key, value in copy.attributes.items():
                    element.set_attribute(key, value)
            except ValueError:
                sys.stderr.write(&#34;strip_tags(): bad attribute in %s\n&#34; % copy)
        text = copy.text
        tail = copy.tail
        if text is not None:
            element.append(text)
        for child in children:
            element.append(child)
        if tail is not None:
            if isinstance(element, list):
                element.append(tail)
            else:
                element.tail = tail
        return (element, True)

    def xpath(self, xpath_query):
        &#34;&#34;&#34;Apply XPath query to the element and its subtree. Return list of
        Element or Text instances translated from the nodes found.
        &#34;&#34;&#34;
        element = self.__element
        xpath_instance = _find_query_in_cache(xpath_query)
        elements = xpath_instance(element)
        result = []
        for obj in elements:
            if isinstance(obj, (_ElementStringResult, _ElementUnicodeResult)):
                result.append(Text(obj))
            elif isinstance(obj, _Element):
                result.append(Element.from_tag(obj))
            else:
                result.append(obj)
        return result

    def clear(self):
        &#34;&#34;&#34;Remove text, children and attributes from the element.&#34;&#34;&#34;
        self.__element.clear()
        if hasattr(self, &#34;_tmap&#34;):
            self._tmap = []
        if hasattr(self, &#34;_cmap&#34;):
            self._cmap = []
        if hasattr(self, &#34;_rmap&#34;):
            self._rmap = []
        if hasattr(self, &#34;_indexes&#34;):
            remember = False
            if &#34;_rmap&#34; in self._indexes:
                remember = True
            self._indexes = {}
            self._indexes[&#34;_cmap&#34;] = {}
            self._indexes[&#34;_tmap&#34;] = {}
            if remember:
                self._indexes[&#34;_rmap&#34;] = {}

    @property
    def clone(self):
        clone = deepcopy(self.__element)
        root = lxml_Element(&#34;ROOT&#34;, nsmap=ODF_NAMESPACES)
        root.append(clone)
        return self.from_tag(clone)

        # slow data = tostring(self.__element, encoding=&#39;unicode&#39;)
        # return self.from_tag(data)

    def serialize(self, pretty=False, with_ns=False):
        # This copy bypasses serialization side-effects in lxml
        native = deepcopy(self.__element)
        data = tostring(
            native, with_tail=False, pretty_print=pretty, encoding=&#34;unicode&#34;
        )
        if not with_ns:
            # Remove namespaces
            data = ns_stripper.sub(&#34;&#34;, data)
        return data

    def serialize2(self, pretty=False, with_ns=False):
        # This copy bypasses serialization side-effects in lxml
        native = deepcopy(self.__element)
        data = tostring(
            native, with_tail=False, pretty_print=pretty, encoding=&#34;unicode&#34;
        )
        if not with_ns:
            # Remove namespaces
            data = ns_stripper.sub(&#34;&#34;, data)
        return data + str(len(data))

    # Element helpers usable from any context

    @property
    def document_body(self):
        &#34;&#34;&#34;Return the document body : &#39;office:body&#39;&#34;&#34;&#34;
        return self.get_element(&#34;//office:body/*[1]&#34;)

    @document_body.setter
    def document_body(self, new_body):
        &#34;&#34;&#34;Change in place the full document body content.&#34;&#34;&#34;
        body = self.document_body
        tail = body.tail
        body.clear()
        for item in new_body.children:
            body.append(item)
        if tail:
            body.tail = tail

    def get_formatted_text(self, context):
        &#34;&#34;&#34;This function must return a beautiful version of the text&#34;&#34;&#34;
        return &#34;&#34;

    def get_styled_elements(self, name=&#34;&#34;):
        &#34;&#34;&#34;Brute-force to find paragraphs, tables, etc. using the given style
        name (or all by default).

        Arguments:

            name -- str

        Return: list
        &#34;&#34;&#34;
        # FIXME incomplete (and possibly inaccurate)
        return (
            _get_elements(self, &#34;descendant::*&#34;, text_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, draw_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, draw_text_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, table_style=name)
            + _get_elements(self, &#34;descendant::*&#34;, page_layout=name)
            + _get_elements(self, &#34;descendant::*&#34;, master_page=name)
            + _get_elements(self, &#34;descendant::*&#34;, parent_style=name)
        )

    # Common attributes

    def _get_inner_text(self, tag):
        element = self.get_element(tag)
        if element is None:
            return None
        return element.text

    def _set_inner_text(self, tag, text):
        element = self.get_element(tag)
        if element is None:
            element = Element.from_tag(tag)
            self.append(element)
        element.text = text

    # Dublin core

    @property
    def dc_creator(self):
        &#34;&#34;&#34;Get dc:creator value.

        Return: str (or None if inexistant)
        &#34;&#34;&#34;
        return self._get_inner_text(&#34;dc:creator&#34;)

    @dc_creator.setter
    def dc_creator(self, creator):
        &#34;&#34;&#34;Set dc:creator value.

        Arguments:

            creator -- str
        &#34;&#34;&#34;
        self._set_inner_text(&#34;dc:creator&#34;, creator)

    @property
    def dc_date(self):
        &#34;&#34;&#34;Get the dc:date value.

        Return: datetime (or None if inexistant)
        &#34;&#34;&#34;
        date = self._get_inner_text(&#34;dc:date&#34;)
        if date is None:
            return None
        return DateTime.decode(date)

    @dc_date.setter
    def dc_date(self, date):
        &#34;&#34;&#34;Set the dc:date value.

        Arguments:

            darz -- DateTime
        &#34;&#34;&#34;
        self._set_inner_text(&#34;dc:date&#34;, DateTime.encode(date))

    # SVG

    @property
    def svg_title(self):
        return self._get_inner_text(&#34;svg:title&#34;)

    @svg_title.setter
    def svg_title(self, title):
        self._set_inner_text(&#34;svg:title&#34;, title)

    @property
    def svg_description(self):
        return self._get_inner_text(&#34;svg:desc&#34;)

    @svg_description.setter
    def svg_description(self, description):
        self._set_inner_text(&#34;svg:desc&#34;, description)

    # Sections

    def get_sections(self, style=None, content=None):
        &#34;&#34;&#34;Return all the sections that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;text:section&#34;, text_style=style, content=content)

    def get_section(self, position=0, content=None):
        &#34;&#34;&#34;Return the section that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:section&#34;, position, content=content)

    # Paragraphs

    def get_paragraphs(self, style=None, content=None):
        &#34;&#34;&#34;Return all the paragraphs that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Paragraph
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:p&#34;, text_style=style, content=content
        )

    def get_paragraph(self, position=0, content=None):
        &#34;&#34;&#34;Return the paragraph that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Paragraph or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:p&#34;, position, content=content)

    # Span

    def get_spans(self, style=None, content=None):
        &#34;&#34;&#34;Return all the spans that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Span
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:span&#34;, text_style=style, content=content
        )

    def get_span(self, position=0, content=None):
        &#34;&#34;&#34;Return the span that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Span or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:span&#34;, position, content=content)

    # Headers

    def get_headers(self, style=None, outline_level=None, content=None):
        &#34;&#34;&#34;Return all the Headers that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Header
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::text:h&#34;,
            text_style=style,
            outline_level=outline_level,
            content=content,
        )

    def get_header(self, position=0, outline_level=None, content=None):
        &#34;&#34;&#34;Return the Header that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Header or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::text:h&#34;,
            position,
            outline_level=outline_level,
            content=content,
        )

    # Lists

    def get_lists(self, style=None, content=None):
        &#34;&#34;&#34;Return all the lists that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of List
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:list&#34;, text_style=style, content=content
        )

    def get_list(self, position=0, content=None):
        &#34;&#34;&#34;Return the list that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: List or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:list&#34;, position, content=content)

    # Frames

    def get_frames(
        self,
        presentation_class=None,
        style=None,
        title=None,
        description=None,
        content=None,
    ):
        &#34;&#34;&#34;Return all the frames that match the criteria.

        Arguments:

            style -- str

            title -- str regex

            description -- str regex

            content -- str regex

        Return: list of Frame
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:frame&#34;,
            presentation_class=presentation_class,
            draw_style=style,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    def get_frame(
        self,
        position=0,
        name=None,
        presentation_class=None,
        title=None,
        description=None,
        content=None,
    ):
        &#34;&#34;&#34;Return the section that matches the criteria.

        Arguments:

            position -- int

            title -- str regex

            description -- str regex

            content -- str regex

        Return: Frame or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::draw:frame&#34;,
            position,
            draw_name=name,
            presentation_class=presentation_class,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    # Images

    def get_images(self, style=None, url=None, content=None):
        &#34;&#34;&#34;Return all the images matching the criteria.

        Arguments:

            style -- str

            url -- str regex

            content -- str regex

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::draw:image&#34;, text_style=style, url=url, content=content
        )

    def get_image(self, position=0, name=None, url=None, content=None):
        &#34;&#34;&#34;Return the image matching the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: Element or None if not found
        &#34;&#34;&#34;
        # The frame is holding the name
        if name is not None:
            frame = _get_element(
                self, &#34;descendant::draw:frame&#34;, position=position, draw_name=name
            )
            if frame is None:
                return None
            # The name is supposedly unique
            return frame.get_element(&#34;draw:image&#34;)
        return _get_element(
            self, &#34;descendant::draw:image&#34;, position, url=url, content=content
        )

    # Tables

    def get_tables(self, style=None, content=None):
        &#34;&#34;&#34;Return all the tables that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of Table
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::table:table&#34;, table_style=style, content=content
        )

    def get_table(self, position=0, name=None, content=None):
        &#34;&#34;&#34;Return the table that matches the criteria.

        Arguments:

            position -- int

            name -- str

            content -- str regex

        Return: Table or None if not found
        &#34;&#34;&#34;
        if name is None and content is None:
            result = self._get_element_idx(&#34;descendant::table:table&#34;, position)
        else:
            result = _get_element(
                self,
                &#34;descendant::table:table&#34;,
                position,
                table_name=name,
                content=content,
            )
        return result

    # Named Range

    def get_named_ranges(self):
        &#34;&#34;&#34;Return all the tables named ranges.

        Return: list of odf_named_range
        &#34;&#34;&#34;
        named_ranges = self.get_elements(
            &#34;descendant::table:named-expressions/table:named-range&#34;
        )
        return named_ranges

    def get_named_range(self, name):
        &#34;&#34;&#34;Return the named range of specified name, or None if not found.

        Arguments:

            name -- str

        Return: NamedRange
        &#34;&#34;&#34;
        named_range = self.get_elements(
            &#39;descendant::table:named-expressions/table:named-range[@table:name=&#34;%s&#34;][1]&#39;
            % name
        )
        if named_range:
            return named_range[0]
        else:
            return None

    def append_named_range(self, named_range):
        &#34;&#34;&#34;Append the named range to the spreadsheet, replacing existing named
        range of same name if any.

        Arguments:

            named_range --  NamedRange
        &#34;&#34;&#34;
        if self.tag != &#34;office:spreadsheet&#34;:
            raise ValueError(&#34;Element is no &#39;office:spreadsheet&#39; : %s&#34; % self.tag)
        named_expressions = self.get_element(&#34;table:named-expressions&#34;)
        if not named_expressions:
            named_expressions = Element.from_tag(&#34;table:named-expressions&#34;)
            self.append(named_expressions)
        # exists ?
        current = named_expressions.get_element(
            &#39;table:named-range[@table:name=&#34;%s&#34;][1]&#39; % named_range.name
        )
        if current:
            named_expressions.delete(current)
        named_expressions.append(named_range)

    def delete_named_range(self, name):
        &#34;&#34;&#34;Delete the Named Range of specified name from the spreadsheet.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        if self.tag != &#34;office:spreadsheet&#34;:
            raise ValueError(&#34;Element is no &#39;office:spreadsheet&#39; : %s&#34; % self.tag)
        named_range = self.get_named_range(name)
        if not named_range:
            return
        named_range.delete()
        named_expressions = self.get_element(&#34;table:named-expressions&#34;)
        element = named_expressions.__element
        children = len(element.getchildren())
        if not children:
            self.delete(named_expressions)

    # Notes

    def get_notes(self, note_class=None, content=None):
        &#34;&#34;&#34;Return all the notes that match the criteria.

        Arguments:

            note_class -- &#39;footnote&#39; or &#39;endnote&#39;

            content -- str regex

        Return: list of Note
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::text:note&#34;, note_class=note_class, content=content
        )

    def get_note(self, position=0, note_id=None, note_class=None, content=None):
        &#34;&#34;&#34;Return the note that matches the criteria.

        Arguments:

            position -- int

            note_id -- str

            note_class -- &#39;footnote&#39; or &#39;endnote&#39;

            content -- str regex

        Return: Note or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::text:note&#34;,
            position,
            text_id=note_id,
            note_class=note_class,
            content=content,
        )

    # Annotations

    def get_annotations(
        self, creator=None, start_date=None, end_date=None, content=None
    ):
        &#34;&#34;&#34;Return all the annotations that match the criteria.

        Arguments:

            creator -- str

            start_date -- date object

            end_date -- date object

            content -- str regex

        Return: list of Annotation
        &#34;&#34;&#34;
        annotations = []
        for annotation in _get_elements(
            self, &#34;descendant::office:annotation&#34;, content=content
        ):
            if creator is not None and creator != annotation.dc_creator:
                continue
            date = annotation.dc_date
            if start_date is not None and date &lt; start_date:
                continue
            if end_date is not None and date &gt;= end_date:
                continue
            annotations.append(annotation)
        return annotations

    def get_annotation(
        self,
        position=0,
        creator=None,
        start_date=None,
        end_date=None,
        content=None,
        name=None,
    ):
        &#34;&#34;&#34;Return the annotation that matches the criteria.

        Arguments:

            position -- int

            creator -- str

            start_date -- date object

            end_date -- date object

            content -- str regex

            name -- str

        Return: Annotation or None if not found
        &#34;&#34;&#34;
        if name is not None:
            return _get_element(
                self, &#34;descendant::office:annotation&#34;, 0, office_name=name
            )
        annotations = self.get_annotations(
            creator=creator, start_date=start_date, end_date=end_date, content=content
        )
        if not annotations:
            return None
        try:
            return annotations[position]
        except IndexError:
            return None

    def get_annotation_ends(self):
        &#34;&#34;&#34;Return all the annotation ends.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::office:annotation-end&#34;)

    def get_annotation_end(self, position=0, name=None):
        &#34;&#34;&#34;Return the annotation end that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::office:annotation-end&#34;, position, office_name=name
        )

    # office:names

    def get_office_names(self):
        &#34;&#34;&#34;Return all the used office:name tags values of the element.

        Return: list of unique str
        &#34;&#34;&#34;
        name_xpath_query = _find_query_in_cache(&#34;//@office:name&#34;)
        names = name_xpath_query(self.__element)
        uniq_names = list(set(names))
        return uniq_names

    # Variables

    def get_variable_decls(self):
        &#34;&#34;&#34;Return the container for variable declarations. Created if not
        found.

        Return: Element
        &#34;&#34;&#34;
        variable_decls = self.get_element(&#34;//text:variable-decls&#34;)
        if variable_decls is None:
            body = self.document_body
            body.insert(Element.from_tag(&#34;text:variable-decls&#34;), FIRST_CHILD)
            variable_decls = body.get_element(&#34;//text:variable-decls&#34;)

        return variable_decls

    def get_variable_decl_list(self):
        &#34;&#34;&#34;Return all the variable declarations.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:variable-decl&#34;)

    def get_variable_decl(self, name, position=0):
        &#34;&#34;&#34;return the variable declaration for the given name.

        return: Element or none if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:variable-decl&#34;, position, text_name=name
        )

    def get_variable_sets(self, name=None):
        &#34;&#34;&#34;Return all the variable sets that match the criteria.

        Arguments:

            name -- str

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:variable-set&#34;, text_name=name)

    def get_variable_set(self, name, position=-1):
        &#34;&#34;&#34;Return the variable set for the given name (last one by default).

        Arguments:

            name -- str

            position -- int

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:variable-set&#34;, position, text_name=name
        )

    def get_variable_set_value(self, name, value_type=None):
        &#34;&#34;&#34;Return the last value of the given variable name.

        Arguments:

            name -- str

            value_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;,
                          &#39;percentage&#39;, &#39;string&#39;, &#39;time&#39; or automatic

        Return: most appropriate Python type
        &#34;&#34;&#34;
        variable_set = self.get_variable_set(name)
        if not variable_set:
            return None
        return get_value(variable_set, value_type)

    # User fields

    def get_user_field_decls(self):
        &#34;&#34;&#34;Return the container for user field declarations. Created if not
        found.

        Return: Element
        &#34;&#34;&#34;
        user_field_decls = self.get_element(&#34;//text:user-field-decls&#34;)
        if user_field_decls is None:
            body = self.document_body
            body.insert(Element.from_tag(&#34;text:user-field-decls&#34;), FIRST_CHILD)
            user_field_decls = body.get_element(&#34;//text:user-field-decls&#34;)

        return user_field_decls

    def get_user_field_decl_list(self):
        &#34;&#34;&#34;Return all the user field declarations.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:user-field-decl&#34;)

    def get_user_field_decl(self, name, position=0):
        &#34;&#34;&#34;return the user field declaration for the given name.

        return: Element or none if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:user-field-decl&#34;, position, text_name=name
        )

    def get_user_field_value(self, name, value_type=None):
        &#34;&#34;&#34;Return the value of the given user field name.

        Arguments:

            name -- str

            value_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;,
                          &#39;percentage&#39;, &#39;string&#39;, &#39;time&#39; or automatic

        Return: most appropriate Python type
        &#34;&#34;&#34;
        user_field_decl = self.get_user_field_decl(name)
        if user_field_decl is None:
            return None
        return get_value(user_field_decl, value_type)

    # User defined fields
    # They are fields who should contain a copy of a user defined medtadata

    def get_user_defined_list(self):
        &#34;&#34;&#34;Return all the user defined field declarations.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:user-defined&#34;)

    def get_user_defined(self, name, position=0):
        &#34;&#34;&#34;return the user defined declaration for the given name.

        return: Element or none if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:user-defined&#34;, position, text_name=name
        )

    def get_user_defined_value(self, name, value_type=None):
        &#34;&#34;&#34;Return the value of the given user defined field name.

        Arguments:

            name -- str

            value_type -- &#39;boolean&#39;, &#39;date&#39;, &#39;float&#39;,
                          &#39;string&#39;, &#39;time&#39; or automatic

        Return: most appropriate Python type
        &#34;&#34;&#34;
        user_defined = self.get_user_defined(name)
        if user_defined is None:
            return None
        return get_value(user_defined, value_type)

    # Draw Pages

    def get_draw_pages(self, style=None, content=None):
        &#34;&#34;&#34;Return all the draw pages that match the criteria.

        Arguments:

            style -- str

            content -- str regex

        Return: list of DrawPage
        &#34;&#34;&#34;
        return _get_elements(
            self, &#34;descendant::draw:page&#34;, draw_style=style, content=content
        )

    def get_draw_page(self, position=0, name=None, content=None):
        &#34;&#34;&#34;Return the draw page that matches the criteria.

        Arguments:

            position -- int

            name -- str

            content -- str regex

        Return: DrawPage or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:page&#34;, position, draw_name=name, content=content
        )

    # Links

    def get_links(self, name=None, title=None, url=None, content=None):
        &#34;&#34;&#34;Return all the links that match the criteria.

        Arguments:

            name -- str

            title -- str

            url -- str regex

            content -- str regex

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::text:a&#34;,
            office_name=name,
            office_title=title,
            url=url,
            content=content,
        )

    def get_link(self, position=0, name=None, title=None, url=None, content=None):
        &#34;&#34;&#34;Return the link that matches the criteria.

        Arguments:

            position -- int

            name -- str

            title -- str

            url -- str regex

            content -- str regex

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self,
            &#34;descendant::text:a&#34;,
            position,
            office_name=name,
            office_title=title,
            url=url,
            content=content,
        )

    # Bookmarks

    def get_bookmarks(self):
        &#34;&#34;&#34;Return all the bookmarks.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:bookmark&#34;)

    def get_bookmark(self, position=0, name=None):
        &#34;&#34;&#34;Return the bookmark that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Bookmark or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:bookmark&#34;, position, text_name=name)

    def get_bookmark_starts(self):
        &#34;&#34;&#34;Return all the bookmark starts.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:bookmark-start&#34;)

    def get_bookmark_start(self, position=0, name=None):
        &#34;&#34;&#34;Return the bookmark start that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:bookmark-start&#34;, position, text_name=name
        )

    def get_bookmark_ends(self):
        &#34;&#34;&#34;Return all the bookmark ends.

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:bookmark-end&#34;)

    def get_bookmark_end(self, position=0, name=None):
        &#34;&#34;&#34;Return the bookmark end that matches the criteria.

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:bookmark-end&#34;, position, text_name=name
        )

    # Reference marks

    def get_reference_marks_single(self):
        &#34;&#34;&#34;Return all the reference marks. Search only the tags
        text:reference-mark.
        Consider using : get_reference_marks()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:reference-mark&#34;)

    def get_reference_mark_single(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark that matches the criteria. Search only the
        tags text:reference-mark.
        Consider using : get_reference_mark()

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:reference-mark&#34;, position, text_name=name
        )

    def get_reference_mark_starts(self):
        &#34;&#34;&#34;Return all the reference mark starts. Search only the tags
        text:reference-mark-start.
        Consider using : get_reference_marks()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:reference-mark-start&#34;)

    def get_reference_mark_start(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark start that matches the criteria. Search
        only the tags text:reference-mark-start.
        Consider using : get_reference_mark()

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:reference-mark-start&#34;, position, text_name=name
        )

    def get_reference_mark_ends(self):
        &#34;&#34;&#34;Return all the reference mark ends. Search only the tags
        text:reference-mark-end.
        Consider using : get_reference_marks()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:reference-mark-end&#34;)

    def get_reference_mark_end(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark end that matches the criteria. Search only
        the tags text:reference-mark-end.
        Consider using : get_reference_marks()

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:reference-mark-end&#34;, position, text_name=name
        )

    def get_reference_marks(self):
        &#34;&#34;&#34;Return all the reference marks, either single position reference
        (text:reference-mark) or start of range reference
        (text:reference-mark-start).

        Return: list of Element
        &#34;&#34;&#34;
        request = (
            &#34;descendant::text:reference-mark-start | descendant::text:reference-mark&#34;
        )
        return _get_elements(self, request)

    def get_reference_mark(self, position=0, name=None):
        &#34;&#34;&#34;Return the reference mark that match the criteria. Either single
        position reference mark (text:reference-mark) or start of range
        reference (text:reference-mark-start).

        Arguments:

            position -- int

            name -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        name = to_str(name)
        if name:
            request = (
                f&#34;descendant::text:reference-mark-start&#34;
                f&#39;[@text:name=&#34;{name}&#34;] &#39;
                f&#34;| descendant::text:reference-mark&#34;
                f&#39;[@text:name=&#34;{name}&#34;]&#39;
            )
            return _get_element(self, request, position=0)
        request = (
            &#34;descendant::text:reference-mark-start | descendant::text:reference-mark&#34;
        )
        return _get_element(self, request, position)

    def get_references(self, name=None):
        &#34;&#34;&#34;Return all the references (text:reference-ref). If name is
        provided, returns the references of that name.

        Return: list of Element

        Arguments:

            name -- str or None
        &#34;&#34;&#34;
        if name is None:
            return _get_elements(self, &#34;descendant::text:reference-ref&#34;)
        request = &#39;descendant::text:reference-ref[@text:ref-name=&#34;%s&#34;]&#39; % to_bytes(name)
        return _get_elements(self, request)

    # Shapes elements

    # Groups

    def get_draw_groups(self, title=None, description=None, content=None):
        return _get_elements(
            self,
            &#34;descendant::draw:g&#34;,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    def get_draw_group(
        self, position=0, name=None, title=None, description=None, content=None
    ):
        return _get_element(
            self,
            &#34;descendant::draw:g&#34;,
            position,
            draw_name=name,
            svg_title=title,
            svg_desc=description,
            content=content,
        )

    # Lines

    def get_draw_lines(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw lines that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:line&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_line(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw line that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:line&#34;, position, draw_id=id, content=content
        )

    # Rectangles

    def get_draw_rectangles(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw rectangles that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:rect&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_rectangle(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw rectangle that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:rect&#34;, position, draw_id=id, content=content
        )

    # Ellipse

    def get_draw_ellipses(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw ellipses that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:ellipse&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_ellipse(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw ellipse that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:ellipse&#34;, position, draw_id=id, content=content
        )

    # Connectors

    def get_draw_connectors(self, draw_style=None, draw_text_style=None, content=None):
        &#34;&#34;&#34;Return all the draw connectors that match the criteria.

        Arguments:

            draw_style -- str

            draw_text_style -- str

            content -- str regex

        Return: list of odf_shape
        &#34;&#34;&#34;
        return _get_elements(
            self,
            &#34;descendant::draw:connector&#34;,
            draw_style=draw_style,
            draw_text_style=draw_text_style,
            content=content,
        )

    def get_draw_connector(self, position=0, id=None, content=None):  # noqa: A002
        &#34;&#34;&#34;Return the draw connector that matches the criteria.

        Arguments:

            position -- int

            id -- str

            content -- str regex

        Return: odf_shape or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::draw:connector&#34;, position, draw_id=id, content=content
        )

    def get_orphan_draw_connectors(self):
        &#34;&#34;&#34;Return a list of connectors which don&#39;t have any shape connected
        to them.
        &#34;&#34;&#34;
        connectors = []
        for connector in self.get_draw_connectors():
            start_shape = connector.get_attribute(&#34;draw:start-shape&#34;)
            end_shape = connector.get_attribute(&#34;draw:end-shape&#34;)
            if start_shape is None and end_shape is None:
                connectors.append(connector)
        return connectors

    # Tracked changes and text change

    def get_tracked_changes(self):
        &#34;&#34;&#34;Return the tracked-changes part in the text body.&#34;&#34;&#34;
        return self.get_element(&#34;//text:tracked-changes&#34;)

    def get_changes_ids(self):
        &#34;&#34;&#34;Return a list of ids that refers to a change region in the tracked
        changes list.
        &#34;&#34;&#34;
        # Insertion changes
        xpath_query = &#34;descendant::text:change-start/@text:change-id&#34;
        # Deletion changes
        xpath_query += &#34; | descendant::text:change/@text:change-id&#34;
        return self.xpath(xpath_query)

    def get_text_change_deletions(self):
        &#34;&#34;&#34;Return all the text changes of deletion kind: the tags text:change.
        Consider using : get_text_changes()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:text:change&#34;)

    def get_text_change_deletion(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change of deletion kind that matches the criteria.
        Search only for the tags text:change.
        Consider using : get_text_change()

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;descendant::text:change&#34;, position, change_id=idx)

    def get_text_change_starts(self):
        &#34;&#34;&#34;Return all the text change-start. Search only for the tags
        text:change-start.
        Consider using : get_text_changes()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:change-start&#34;)

    def get_text_change_start(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change-start that matches the criteria. Search
        only the tags text:change-start.
        Consider using : get_text_change()

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:change-start&#34;, position, change_id=idx
        )

    def get_text_change_ends(self):
        &#34;&#34;&#34;Return all the text change-end. Search only the tags
        text:change-end.
        Consider using : get_text_changes()

        Return: list of Element
        &#34;&#34;&#34;
        return _get_elements(self, &#34;descendant::text:change-end&#34;)

    def get_text_change_end(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change-end that matches the criteria. Search only
        the tags text:change-end.
        Consider using : get_text_change()

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        return _get_element(
            self, &#34;descendant::text:change-end&#34;, position, change_id=idx
        )

    def get_text_changes(self):
        &#34;&#34;&#34;Return all the text changes, either single deletion
        (text:change) or start of range of changes (text:change-start).

        Return: list of Element
        &#34;&#34;&#34;
        request = &#34;descendant::text:change-start | descendant::text:change&#34;
        return _get_elements(self, request)

    def get_text_change(self, position=0, idx=None):
        &#34;&#34;&#34;Return the text change that matches the criteria. Either single
        deletion (text:change) or start of range of changes (text:change-start).
        position : index of the element to retrieve if several matches, default
        is 0.
        idx : change-id of the element.

        Arguments:

            position -- int

            idx -- str

        Return: Element or None if not found
        &#34;&#34;&#34;
        if idx:
            request = (
                f&#39;descendant::text:change-start[@text:change-id=&#34;{idx}&#34;] &#39;
                f&#39;| descendant::text:change[@text:change-id=&#34;{idx}&#34;]&#39;
            )
            return _get_element(self, request, position=0)
        request = &#34;descendant::text:change-start | descendant::text:change&#34;
        return _get_element(self, request, position)

    # Table Of Content

    def get_tocs(self):
        &#34;&#34;&#34;Return all the tables of contents.

        Return: list of odf_toc
        &#34;&#34;&#34;
        return _get_elements(self, &#34;text:table-of-content&#34;)

    def get_toc(self, position=0, content=None):
        &#34;&#34;&#34;Return the table of contents that matches the criteria.

        Arguments:

            position -- int

            content -- str regex

        Return: odf_toc or None if not found
        &#34;&#34;&#34;
        return _get_element(self, &#34;text:table-of-content&#34;, position, content=content)

    # Styles

    @staticmethod
    def _get_style_tagname(family, is_default=False):
        &#34;&#34;&#34;Widely match possible tag names given the family (or not).&#34;&#34;&#34;
        if not family:
            tagname = (
                &#34;(&#34;
                + &#34;|&#34;.join(
                    [
                        &#34;style:default-style&#34;,
                        &#34;*[@style:name]&#34;,
                        &#34;draw:fill-image&#34;,
                        &#34;draw:marker&#34;,
                    ]
                )
                + &#34;)&#34;
            )
        elif is_default:
            # Default style
            tagname = &#34;style:default-style&#34;
        else:
            tagname = _family_style_tagname(family)
            # if famattr:
            #    # Include family default style
            #    tagname = &#39;(%s|style:default-style)&#39; % tagname
            if family in FAMILY_ODF_STD:
                # Include family default style
                tagname = &#34;(%s|style:default-style)&#34; % tagname
        return tagname

    def get_styles(self, family=None):
        # Both common and default styles
        tagname = self._get_style_tagname(family)
        return _get_elements(self, tagname, family=family)

    def get_style(self, family, name_or_element=None, display_name=None):
        &#34;&#34;&#34;Return the style uniquely identified by the family/name pair. If
        the argument is already a style object, it will return it.

        If the name is not the internal name but the name you gave in the
        desktop application, use display_name instead.

        Arguments:

            family -- &#39;paragraph&#39;, &#39;text&#39;, &#39;graphic&#39;, &#39;table&#39;, &#39;list&#39;,
                      &#39;number&#39;

            name_or_element -- str or Style

            display_name -- str

        Return: odf_style or None if not found
        &#34;&#34;&#34;
        if isinstance(name_or_element, Element):
            name = self.get_attribute(&#34;style:name&#34;)
            if name is not None:
                return name_or_element
            else:
                raise ValueError(&#34;Not a odf_style ?  %s&#34; % name_or_element)
        style_name = name_or_element
        is_default = not (style_name or display_name)
        tagname = self._get_style_tagname(family, is_default=is_default)
        # famattr became None if no &#34;style:family&#34; attribute
        if family:
            return _get_element(
                self,
                tagname,
                0,
                style_name=style_name,
                display_name=display_name,
                family=family,
            )
        else:
            return _get_element(
                self,
                tagname,
                0,
                draw_name=style_name or display_name,
                family=family,
            )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odfdo.bookmark.Bookmark" href="bookmark.html#odfdo.bookmark.Bookmark">Bookmark</a></li>
<li><a title="odfdo.bookmark.BookmarkEnd" href="bookmark.html#odfdo.bookmark.BookmarkEnd">BookmarkEnd</a></li>
<li><a title="odfdo.bookmark.BookmarkStart" href="bookmark.html#odfdo.bookmark.BookmarkStart">BookmarkStart</a></li>
<li><a title="odfdo.draw_page.DrawPage" href="draw_page.html#odfdo.draw_page.DrawPage">DrawPage</a></li>
<li><a title="odfdo.frame.Frame" href="frame.html#odfdo.frame.Frame">Frame</a></li>
<li><a title="odfdo.image.DrawImage" href="image.html#odfdo.image.DrawImage">DrawImage</a></li>
<li><a title="odfdo.list.List" href="list.html#odfdo.list.List">List</a></li>
<li><a title="odfdo.list.ListItem" href="list.html#odfdo.list.ListItem">ListItem</a></li>
<li><a title="odfdo.note.Annotation" href="note.html#odfdo.note.Annotation">Annotation</a></li>
<li><a title="odfdo.note.AnnotationEnd" href="note.html#odfdo.note.AnnotationEnd">AnnotationEnd</a></li>
<li><a title="odfdo.note.Note" href="note.html#odfdo.note.Note">Note</a></li>
<li><a title="odfdo.paragraph_base.LineBreak" href="paragraph_base.html#odfdo.paragraph_base.LineBreak">LineBreak</a></li>
<li><a title="odfdo.paragraph_base.ParagraphBase" href="paragraph_base.html#odfdo.paragraph_base.ParagraphBase">ParagraphBase</a></li>
<li><a title="odfdo.paragraph_base.Spacer" href="paragraph_base.html#odfdo.paragraph_base.Spacer">Spacer</a></li>
<li><a title="odfdo.paragraph_base.Tab" href="paragraph_base.html#odfdo.paragraph_base.Tab">Tab</a></li>
<li><a title="odfdo.reference.Reference" href="reference.html#odfdo.reference.Reference">Reference</a></li>
<li><a title="odfdo.reference.ReferenceMark" href="reference.html#odfdo.reference.ReferenceMark">ReferenceMark</a></li>
<li><a title="odfdo.reference.ReferenceMarkEnd" href="reference.html#odfdo.reference.ReferenceMarkEnd">ReferenceMarkEnd</a></li>
<li><a title="odfdo.reference.ReferenceMarkStart" href="reference.html#odfdo.reference.ReferenceMarkStart">ReferenceMarkStart</a></li>
<li><a title="odfdo.section.Section" href="section.html#odfdo.section.Section">Section</a></li>
<li><a title="odfdo.shapes.DrawGroup" href="shapes.html#odfdo.shapes.DrawGroup">DrawGroup</a></li>
<li><a title="odfdo.shapes.ShapeBase" href="shapes.html#odfdo.shapes.ShapeBase">ShapeBase</a></li>
<li><a title="odfdo.smil.AnimPar" href="smil.html#odfdo.smil.AnimPar">AnimPar</a></li>
<li><a title="odfdo.smil.AnimSeq" href="smil.html#odfdo.smil.AnimSeq">AnimSeq</a></li>
<li><a title="odfdo.smil.AnimTransFilter" href="smil.html#odfdo.smil.AnimTransFilter">AnimTransFilter</a></li>
<li><a title="odfdo.style.Style" href="style.html#odfdo.style.Style">Style</a></li>
<li><a title="odfdo.table.Cell" href="table.html#odfdo.table.Cell">Cell</a></li>
<li><a title="odfdo.table.Column" href="table.html#odfdo.table.Column">Column</a></li>
<li><a title="odfdo.table.HeaderRows" href="table.html#odfdo.table.HeaderRows">HeaderRows</a></li>
<li><a title="odfdo.table.NamedRange" href="table.html#odfdo.table.NamedRange">NamedRange</a></li>
<li><a title="odfdo.table.Row" href="table.html#odfdo.table.Row">Row</a></li>
<li><a title="odfdo.table.RowGroup" href="table.html#odfdo.table.RowGroup">RowGroup</a></li>
<li><a title="odfdo.table.Table" href="table.html#odfdo.table.Table">Table</a></li>
<li><a title="odfdo.toc.IndexTitle" href="toc.html#odfdo.toc.IndexTitle">IndexTitle</a></li>
<li><a title="odfdo.toc.IndexTitleTemplate" href="toc.html#odfdo.toc.IndexTitleTemplate">IndexTitleTemplate</a></li>
<li><a title="odfdo.toc.TOC" href="toc.html#odfdo.toc.TOC">TOC</a></li>
<li><a title="odfdo.toc.TabStopStyle" href="toc.html#odfdo.toc.TabStopStyle">TabStopStyle</a></li>
<li><a title="odfdo.toc.TocEntryTemplate" href="toc.html#odfdo.toc.TocEntryTemplate">TocEntryTemplate</a></li>
<li><a title="odfdo.tracked_changes.ChangeInfo" href="tracked_changes.html#odfdo.tracked_changes.ChangeInfo">ChangeInfo</a></li>
<li><a title="odfdo.tracked_changes.TextChange" href="tracked_changes.html#odfdo.tracked_changes.TextChange">TextChange</a></li>
<li><a title="odfdo.tracked_changes.TextChangedRegion" href="tracked_changes.html#odfdo.tracked_changes.TextChangedRegion">TextChangedRegion</a></li>
<li><a title="odfdo.tracked_changes.TextInsertion" href="tracked_changes.html#odfdo.tracked_changes.TextInsertion">TextInsertion</a></li>
<li><a title="odfdo.tracked_changes.TrackedChanges" href="tracked_changes.html#odfdo.tracked_changes.TrackedChanges">TrackedChanges</a></li>
<li><a title="odfdo.variable.UserDefined" href="variable.html#odfdo.variable.UserDefined">UserDefined</a></li>
<li><a title="odfdo.variable.UserFieldDecl" href="variable.html#odfdo.variable.UserFieldDecl">UserFieldDecl</a></li>
<li><a title="odfdo.variable.UserFieldDecls" href="variable.html#odfdo.variable.UserFieldDecls">UserFieldDecls</a></li>
<li><a title="odfdo.variable.UserFieldGet" href="variable.html#odfdo.variable.UserFieldGet">UserFieldGet</a></li>
<li><a title="odfdo.variable.VarChapter" href="variable.html#odfdo.variable.VarChapter">VarChapter</a></li>
<li><a title="odfdo.variable.VarCreationDate" href="variable.html#odfdo.variable.VarCreationDate">VarCreationDate</a></li>
<li><a title="odfdo.variable.VarCreationTime" href="variable.html#odfdo.variable.VarCreationTime">VarCreationTime</a></li>
<li><a title="odfdo.variable.VarDate" href="variable.html#odfdo.variable.VarDate">VarDate</a></li>
<li><a title="odfdo.variable.VarDecl" href="variable.html#odfdo.variable.VarDecl">VarDecl</a></li>
<li><a title="odfdo.variable.VarDecls" href="variable.html#odfdo.variable.VarDecls">VarDecls</a></li>
<li><a title="odfdo.variable.VarFileName" href="variable.html#odfdo.variable.VarFileName">VarFileName</a></li>
<li><a title="odfdo.variable.VarGet" href="variable.html#odfdo.variable.VarGet">VarGet</a></li>
<li><a title="odfdo.variable.VarInitialCreator" href="variable.html#odfdo.variable.VarInitialCreator">VarInitialCreator</a></li>
<li><a title="odfdo.variable.VarPageCount" href="variable.html#odfdo.variable.VarPageCount">VarPageCount</a></li>
<li><a title="odfdo.variable.VarPageNumber" href="variable.html#odfdo.variable.VarPageNumber">VarPageNumber</a></li>
<li><a title="odfdo.variable.VarSet" href="variable.html#odfdo.variable.VarSet">VarSet</a></li>
<li><a title="odfdo.variable.VarTime" href="variable.html#odfdo.variable.VarTime">VarTime</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="odfdo.element.Element.from_tag"><code class="name flex">
<span>def <span class="ident">from_tag</span></span>(<span>tag_or_elem)</span>
</code></dt>
<dd>
<div class="desc"><p>Element class and subclass factory. Turn an lxml Element or ODF
string tag into an ODF XML Element from the relevant class.</p>
<h2 id="arguments">Arguments</h2>
<p>tag_or_elem &ndash; ODF str tag or lxml.Element</p>
<p>Return: Element (or subclass) instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_tag(cls, tag_or_elem):
    &#34;&#34;&#34;Element class and subclass factory. Turn an lxml Element or ODF
    string tag into an ODF XML Element from the relevant class.

    Arguments:

        tag_or_elem -- ODF str tag or lxml.Element

    Return: Element (or subclass) instance
    &#34;&#34;&#34;
    if not isinstance(tag_or_elem, _Element):
        # assume the argument is a prefix:name tag
        tag_or_elem = cls.make_etree_element(tag_or_elem)
    tag = to_str(tag_or_elem.tag)
    klass = _class_registry.get(tag, cls)
    return klass(tag_or_elem=tag_or_elem)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.from_tag_for_clone"><code class="name flex">
<span>def <span class="ident">from_tag_for_clone</span></span>(<span>tag_or_elem, cache)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_tag_for_clone(cls, tag_or_elem, cache):
    tag = to_str(tag_or_elem.tag)
    klass = _class_registry.get(tag, cls)
    element = klass(tag_or_elem=tag_or_elem)
    if cache and element._caching:
        element._tmap = cache[0]
        element._cmap = cache[1]
        if len(cache) == 3:
            element._rmap = cache[2]
    return element</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.make_etree_element"><code class="name flex">
<span>def <span class="ident">make_etree_element</span></span>(<span>tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_etree_element(tag):
    if not isinstance(tag, (str, bytes)):
        raise TypeError(&#34;tag is not str or bytes: %s&#34; % tag)
    tag = to_bytes(tag).strip()
    if not tag:
        raise ValueError(&#34;tag is empty&#34;)
    if b&#34;&lt;&#34; not in tag:
        # Qualified name
        # XXX don&#39;t build the element from scratch or lxml will pollute with
        # repeated namespace declarations
        tag = b&#34;&lt;%s/&gt;&#34; % tag
    # XML fragment
    root = fromstring(NAMESPACES_XML % tag)  # noqa:S320
    return root[0]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.element.Element.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attributes(self):
    e = self.__element
    return {_get_prefixed_name(k): v for k, v in e.attrib.items()}</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    element = self.__element
    return [Element.from_tag(e) for e in element.getchildren()]</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.clone"><code class="name">var <span class="ident">clone</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clone(self):
    clone = deepcopy(self.__element)
    root = lxml_Element(&#34;ROOT&#34;, nsmap=ODF_NAMESPACES)
    root.append(clone)
    return self.from_tag(clone)

    # slow data = tostring(self.__element, encoding=&#39;unicode&#39;)
    # return self.from_tag(data)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.dc_creator"><code class="name">var <span class="ident">dc_creator</span></code></dt>
<dd>
<div class="desc"><p>Get dc:creator value.</p>
<p>Return: str (or None if inexistant)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dc_creator(self):
    &#34;&#34;&#34;Get dc:creator value.

    Return: str (or None if inexistant)
    &#34;&#34;&#34;
    return self._get_inner_text(&#34;dc:creator&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.dc_date"><code class="name">var <span class="ident">dc_date</span></code></dt>
<dd>
<div class="desc"><p>Get the dc:date value.</p>
<p>Return: datetime (or None if inexistant)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dc_date(self):
    &#34;&#34;&#34;Get the dc:date value.

    Return: datetime (or None if inexistant)
    &#34;&#34;&#34;
    date = self._get_inner_text(&#34;dc:date&#34;)
    if date is None:
        return None
    return DateTime.decode(date)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.document_body"><code class="name">var <span class="ident">document_body</span></code></dt>
<dd>
<div class="desc"><p>Return the document body : 'office:body'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def document_body(self):
    &#34;&#34;&#34;Return the document body : &#39;office:body&#39;&#34;&#34;&#34;
    return self.get_element(&#34;//office:body/*[1]&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    element = self.__element
    parent = element.getparent()
    if parent is None:
        # Already at root
        return None
    return Element.from_tag(parent)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def root(self):
    element = self.__element
    tree = element.getroottree()
    root = tree.getroot()
    return Element.from_tag(root)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.svg_description"><code class="name">var <span class="ident">svg_description</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def svg_description(self):
    return self._get_inner_text(&#34;svg:desc&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.svg_title"><code class="name">var <span class="ident">svg_title</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def svg_title(self):
    return self._get_inner_text(&#34;svg:title&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.tag"><code class="name">var <span class="ident">tag</span></code></dt>
<dd>
<div class="desc"><p>Get/set the underlying xml tag with the given qualified name.</p>
<p>Warning: direct change of tag does not change the element class.</p>
<h2 id="arguments">Arguments</h2>
<p>qname &ndash; str (e.g. "text:span")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tag(self):
    &#34;&#34;&#34;Get/set the underlying xml tag with the given qualified name.

    Warning: direct change of tag does not change the element class.

    Arguments:

        qname -- str (e.g. &#34;text:span&#34;)
    &#34;&#34;&#34;
    return _get_prefixed_name(self.__element.tag)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.tail"><code class="name">var <span class="ident">tail</span></code></dt>
<dd>
<div class="desc"><p>Get / set the text immediately following the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tail(self):
    &#34;&#34;&#34;Get / set the text immediately following the element.&#34;&#34;&#34;
    return self.__element.tail</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Get / set the text content of the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;Get / set the text content of the element.&#34;&#34;&#34;
    return self.__element.text or &#34;&#34;</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.text_content"><code class="name">var <span class="ident">text_content</span></code></dt>
<dd>
<div class="desc"><p>Get / set the text of the embedded paragraph, including embeded
annotations, cells&hellip;</p>
<p>Set create a paragraph if missing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text_content(self):
    &#34;&#34;&#34;Get / set the text of the embedded paragraph, including embeded
    annotations, cells...

    Set create a paragraph if missing
    &#34;&#34;&#34;
    return &#34;\n&#34;.join(
        child.text_recursive for child in self.get_elements(&#34;descendant::text:p&#34;)
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.text_recursive"><code class="name">var <span class="ident">text_recursive</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text_recursive(self):
    return &#34;&#34;.join(self.__element.itertext())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.element.Element.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, str_or_element)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert element or text in the last position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, str_or_element):
    &#34;&#34;&#34;Insert element or text in the last position.&#34;&#34;&#34;
    current = self.__element

    # Unicode ?
    if isinstance(str_or_element, str):
        # Has children ?
        children = current.getchildren()
        if children:
            # Append to tail of the last child
            last_child = children[-1]
            text = last_child.tail
            text = text if text is not None else &#34;&#34;
            text += str_or_element
            last_child.tail = text
        else:
            # Append to text of the element
            text = current.text
            text = text if text is not None else &#34;&#34;
            text += str_or_element
            current.text = text
    elif isinstance(str_or_element, Element):
        current.append(str_or_element.__element)
    else:
        raise TypeError(
            &#39;Element or unicode expected, not &#34;%s&#34;&#39; % (type(str_or_element))
        )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.append_named_range"><code class="name flex">
<span>def <span class="ident">append_named_range</span></span>(<span>self, named_range)</span>
</code></dt>
<dd>
<div class="desc"><p>Append the named range to the spreadsheet, replacing existing named
range of same name if any.</p>
<h2 id="arguments">Arguments</h2>
<p>named_range &ndash;
NamedRange</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_named_range(self, named_range):
    &#34;&#34;&#34;Append the named range to the spreadsheet, replacing existing named
    range of same name if any.

    Arguments:

        named_range --  NamedRange
    &#34;&#34;&#34;
    if self.tag != &#34;office:spreadsheet&#34;:
        raise ValueError(&#34;Element is no &#39;office:spreadsheet&#39; : %s&#34; % self.tag)
    named_expressions = self.get_element(&#34;table:named-expressions&#34;)
    if not named_expressions:
        named_expressions = Element.from_tag(&#34;table:named-expressions&#34;)
        self.append(named_expressions)
    # exists ?
    current = named_expressions.get_element(
        &#39;table:named-range[@table:name=&#34;%s&#34;][1]&#39; % named_range.name
    )
    if current:
        named_expressions.delete(current)
    named_expressions.append(named_range)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove text, children and attributes from the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Remove text, children and attributes from the element.&#34;&#34;&#34;
    self.__element.clear()
    if hasattr(self, &#34;_tmap&#34;):
        self._tmap = []
    if hasattr(self, &#34;_cmap&#34;):
        self._cmap = []
    if hasattr(self, &#34;_rmap&#34;):
        self._rmap = []
    if hasattr(self, &#34;_indexes&#34;):
        remember = False
        if &#34;_rmap&#34; in self._indexes:
            remember = True
        self._indexes = {}
        self._indexes[&#34;_cmap&#34;] = {}
        self._indexes[&#34;_tmap&#34;] = {}
        if remember:
            self._indexes[&#34;_rmap&#34;] = {}</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.del_attribute"><code class="name flex">
<span>def <span class="ident">del_attribute</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_attribute(self, name):
    element = self.__element
    uri, name = _decode_qname(name)
    if uri is not None:
        name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
    del element.attrib[name]</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, child=None, keep_tail=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the given element from the XML tree. If no element is given,
"self" is deleted. The XML library may allow to continue to use an
element now "orphan" as long as you have a reference to it.</p>
<p>if keep_tail is True (default), the tail text is not erased.</p>
<h2 id="arguments">Arguments</h2>
<p>child &ndash; Element</p>
<p>keep_tail &ndash; boolean (default to True), True for most usages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, child=None, keep_tail=True):
    &#34;&#34;&#34;Delete the given element from the XML tree. If no element is given,
    &#34;self&#34; is deleted. The XML library may allow to continue to use an
    element now &#34;orphan&#34; as long as you have a reference to it.

    if keep_tail is True (default), the tail text is not erased.

    Arguments:

        child -- Element

        keep_tail -- boolean (default to True), True for most usages.
    &#34;&#34;&#34;
    if child is None:
        parent = self.parent
        if parent is None:
            info = self.serialize()
            raise ValueError(&#34;cannot delete the root element\n%s&#34; % info)
        child = self
    else:
        parent = self
    if keep_tail and child.__element.tail is not None:
        current = child.__element
        tail = current.tail
        current.tail = None
        prev = current.getprevious()
        if prev is not None:
            if prev.tail is None:
                prev.tail = tail
            else:
                prev.tail += tail
        else:
            if parent.__element.text is None:
                parent.__element.text = tail
            else:
                parent.__element.text += tail
    parent.__element.remove(child.__element)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.delete_named_range"><code class="name flex">
<span>def <span class="ident">delete_named_range</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the Named Range of specified name from the spreadsheet.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_named_range(self, name):
    &#34;&#34;&#34;Delete the Named Range of specified name from the spreadsheet.

    Arguments:

        name -- str
    &#34;&#34;&#34;
    if self.tag != &#34;office:spreadsheet&#34;:
        raise ValueError(&#34;Element is no &#39;office:spreadsheet&#39; : %s&#34; % self.tag)
    named_range = self.get_named_range(name)
    if not named_range:
        return
    named_range.delete()
    named_expressions = self.get_element(&#34;table:named-expressions&#34;)
    element = named_expressions.__element
    children = len(element.getchildren())
    if not children:
        self.delete(named_expressions)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.elements_repeated_sequence"><code class="name flex">
<span>def <span class="ident">elements_repeated_sequence</span></span>(<span>self, xpath_instance, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elements_repeated_sequence(self, xpath_instance, name):
    uri, name = _decode_qname(name)
    if uri is not None:
        name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
    element = self.__element
    sub_elements = xpath_instance(element)
    result = []
    idx = -1
    for sub_element in sub_elements:
        idx += 1
        value = sub_element.get(name)
        if value is None:
            result.append((idx, 1))
            continue
        try:
            value = int(value)
        except ValueError:
            value = 1
        result.append((idx, max(value, 1)))
    return result</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, odf_elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Fast append elements at the end of ourself using extend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, odf_elements):
    &#34;&#34;&#34;Fast append elements at the end of ourself using extend.&#34;&#34;&#34;
    if odf_elements:
        current = self.__element
        elements = [element.__element for element in odf_elements]
        current.extend(elements)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_annotation"><code class="name flex">
<span>def <span class="ident">get_annotation</span></span>(<span>self, position=0, creator=None, start_date=None, end_date=None, content=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the annotation that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>creator &ndash; str</p>
<p>start_date &ndash; date object</p>
<p>end_date &ndash; date object</p>
<p>content &ndash; str regex</p>
<p>name &ndash; str</p>
<p>Return: Annotation or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotation(
    self,
    position=0,
    creator=None,
    start_date=None,
    end_date=None,
    content=None,
    name=None,
):
    &#34;&#34;&#34;Return the annotation that matches the criteria.

    Arguments:

        position -- int

        creator -- str

        start_date -- date object

        end_date -- date object

        content -- str regex

        name -- str

    Return: Annotation or None if not found
    &#34;&#34;&#34;
    if name is not None:
        return _get_element(
            self, &#34;descendant::office:annotation&#34;, 0, office_name=name
        )
    annotations = self.get_annotations(
        creator=creator, start_date=start_date, end_date=end_date, content=content
    )
    if not annotations:
        return None
    try:
        return annotations[position]
    except IndexError:
        return None</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_annotation_end"><code class="name flex">
<span>def <span class="ident">get_annotation_end</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the annotation end that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotation_end(self, position=0, name=None):
    &#34;&#34;&#34;Return the annotation end that matches the criteria.

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::office:annotation-end&#34;, position, office_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_annotation_ends"><code class="name flex">
<span>def <span class="ident">get_annotation_ends</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the annotation ends.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotation_ends(self):
    &#34;&#34;&#34;Return all the annotation ends.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::office:annotation-end&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_annotations"><code class="name flex">
<span>def <span class="ident">get_annotations</span></span>(<span>self, creator=None, start_date=None, end_date=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the annotations that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>creator &ndash; str</p>
<p>start_date &ndash; date object</p>
<p>end_date &ndash; date object</p>
<p>content &ndash; str regex</p>
<p>Return: list of Annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotations(
    self, creator=None, start_date=None, end_date=None, content=None
):
    &#34;&#34;&#34;Return all the annotations that match the criteria.

    Arguments:

        creator -- str

        start_date -- date object

        end_date -- date object

        content -- str regex

    Return: list of Annotation
    &#34;&#34;&#34;
    annotations = []
    for annotation in _get_elements(
        self, &#34;descendant::office:annotation&#34;, content=content
    ):
        if creator is not None and creator != annotation.dc_creator:
            continue
        date = annotation.dc_date
        if start_date is not None and date &lt; start_date:
            continue
        if end_date is not None and date &gt;= end_date:
            continue
        annotations.append(annotation)
    return annotations</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_attribute"><code class="name flex">
<span>def <span class="ident">get_attribute</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute(self, name):
    element = self.__element
    uri, name = _decode_qname(name)
    if uri is not None:
        name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031
    value = element.get(name)
    if value is None:
        return None
    elif value in (&#34;true&#34;, &#34;false&#34;):
        return Boolean.decode(value)
    return str(value)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_attribute_integer"><code class="name flex">
<span>def <span class="ident">get_attribute_integer</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute_integer(self, name):
    atr = self.get_attribute(name)
    if atr is None:
        return atr
    try:
        return int(atr)
    except ValueError:
        return None</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_between"><code class="name flex">
<span>def <span class="ident">get_between</span></span>(<span>self, tag1, tag2, as_text=False, clean=True, no_header=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns elements between tag1 and tag2, tag1 and tag2 shall
be unique and having an id attribute.
(WARN: buggy if tag1/tag2 defines a malformed odf xml.)
If as_text is True: returns the text content.
If clean is True: suppress unwanted tags (deletions marks, &hellip;)
If no_header is True: existing text:h are changed in text:p
By default: returns a list of Element, cleaned and without headers.</p>
<p>Implementation and standard retrictions:
Only text:h and text:p sould be 'cut' by an insert tag, so inner parts
of insert tags are:</p>
<pre><code>- any text:h, text:p or sub tag of these

- some text, part of a parent text:h or text:p
</code></pre>
<h2 id="arguments">Arguments</h2>
<p>tag1 &ndash; Element</p>
<p>tag2 &ndash; Element</p>
<p>as_text &ndash; boolean</p>
<p>clean &ndash; boolean</p>
<p>no_header &ndash; boolean</p>
<p>Return: list of odf_paragraph or odf_header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_between(self, tag1, tag2, as_text=False, clean=True, no_header=True):
    &#34;&#34;&#34;Returns elements between tag1 and tag2, tag1 and tag2 shall
    be unique and having an id attribute.
    (WARN: buggy if tag1/tag2 defines a malformed odf xml.)
    If as_text is True: returns the text content.
    If clean is True: suppress unwanted tags (deletions marks, ...)
    If no_header is True: existing text:h are changed in text:p
    By default: returns a list of Element, cleaned and without headers.

    Implementation and standard retrictions:
    Only text:h and text:p sould be &#39;cut&#39; by an insert tag, so inner parts
    of insert tags are:

        - any text:h, text:p or sub tag of these

        - some text, part of a parent text:h or text:p

    Arguments:

        tag1 -- Element

        tag2 -- Element

        as_text -- boolean

        clean -- boolean

        no_header -- boolean

    Return: list of odf_paragraph or odf_header
    &#34;&#34;&#34;
    inner = self._get_between_base(tag1, tag2)

    if clean:
        clean_tags = (
            &#34;text:change&#34;,
            &#34;text:change-start&#34;,
            &#34;text:change-end&#34;,
            &#34;text:reference-mark&#34;,
            &#34;text:reference-mark-start&#34;,
            &#34;text:reference-mark-end&#34;,
        )
        request_self = &#34; | &#34;.join([&#34;self::%s&#34; % c for c in clean_tags])
        inner = [e for e in inner if not e.xpath(request_self)]
        request = &#34; | &#34;.join([&#34;descendant::%s&#34; % c for c in clean_tags])
        for element in inner:
            to_del = element.xpath(request)
            for e in to_del:
                element.delete(e)
    if no_header:  # crude replace t:h by t:p
        new_inner = []
        for element in inner:
            if element.tag == &#34;text:h&#34;:
                children = element.children
                text = element.__element.text
                para = Element.from_tag(&#34;text:p&#34;)
                para.text = text
                for c in children:
                    para.append(c)
                new_inner.append(para)
            else:
                new_inner.append(element)
        inner = new_inner
    if as_text:
        return &#34;\n&#34;.join([e.get_formatted_text() for e in inner])
    else:
        return inner</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_bookmark"><code class="name flex">
<span>def <span class="ident">get_bookmark</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bookmark that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Bookmark or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bookmark(self, position=0, name=None):
    &#34;&#34;&#34;Return the bookmark that matches the criteria.

    Arguments:

        position -- int

        name -- str

    Return: Bookmark or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;descendant::text:bookmark&#34;, position, text_name=name)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_bookmark_end"><code class="name flex">
<span>def <span class="ident">get_bookmark_end</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bookmark end that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bookmark_end(self, position=0, name=None):
    &#34;&#34;&#34;Return the bookmark end that matches the criteria.

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:bookmark-end&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_bookmark_ends"><code class="name flex">
<span>def <span class="ident">get_bookmark_ends</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the bookmark ends.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bookmark_ends(self):
    &#34;&#34;&#34;Return all the bookmark ends.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:bookmark-end&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_bookmark_start"><code class="name flex">
<span>def <span class="ident">get_bookmark_start</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bookmark start that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bookmark_start(self, position=0, name=None):
    &#34;&#34;&#34;Return the bookmark start that matches the criteria.

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:bookmark-start&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_bookmark_starts"><code class="name flex">
<span>def <span class="ident">get_bookmark_starts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the bookmark starts.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bookmark_starts(self):
    &#34;&#34;&#34;Return all the bookmark starts.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:bookmark-start&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_bookmarks"><code class="name flex">
<span>def <span class="ident">get_bookmarks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the bookmarks.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bookmarks(self):
    &#34;&#34;&#34;Return all the bookmarks.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:bookmark&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_changes_ids"><code class="name flex">
<span>def <span class="ident">get_changes_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of ids that refers to a change region in the tracked
changes list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_changes_ids(self):
    &#34;&#34;&#34;Return a list of ids that refers to a change region in the tracked
    changes list.
    &#34;&#34;&#34;
    # Insertion changes
    xpath_query = &#34;descendant::text:change-start/@text:change-id&#34;
    # Deletion changes
    xpath_query += &#34; | descendant::text:change/@text:change-id&#34;
    return self.xpath(xpath_query)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_connector"><code class="name flex">
<span>def <span class="ident">get_draw_connector</span></span>(<span>self, position=0, id=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the draw connector that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>id &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: odf_shape or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_connector(self, position=0, id=None, content=None):  # noqa: A002
    &#34;&#34;&#34;Return the draw connector that matches the criteria.

    Arguments:

        position -- int

        id -- str

        content -- str regex

    Return: odf_shape or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::draw:connector&#34;, position, draw_id=id, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_connectors"><code class="name flex">
<span>def <span class="ident">get_draw_connectors</span></span>(<span>self, draw_style=None, draw_text_style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the draw connectors that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>draw_style &ndash; str</p>
<p>draw_text_style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of odf_shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_connectors(self, draw_style=None, draw_text_style=None, content=None):
    &#34;&#34;&#34;Return all the draw connectors that match the criteria.

    Arguments:

        draw_style -- str

        draw_text_style -- str

        content -- str regex

    Return: list of odf_shape
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::draw:connector&#34;,
        draw_style=draw_style,
        draw_text_style=draw_text_style,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_ellipse"><code class="name flex">
<span>def <span class="ident">get_draw_ellipse</span></span>(<span>self, position=0, id=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the draw ellipse that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>id &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: odf_shape or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_ellipse(self, position=0, id=None, content=None):  # noqa: A002
    &#34;&#34;&#34;Return the draw ellipse that matches the criteria.

    Arguments:

        position -- int

        id -- str

        content -- str regex

    Return: odf_shape or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::draw:ellipse&#34;, position, draw_id=id, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_ellipses"><code class="name flex">
<span>def <span class="ident">get_draw_ellipses</span></span>(<span>self, draw_style=None, draw_text_style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the draw ellipses that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>draw_style &ndash; str</p>
<p>draw_text_style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of odf_shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_ellipses(self, draw_style=None, draw_text_style=None, content=None):
    &#34;&#34;&#34;Return all the draw ellipses that match the criteria.

    Arguments:

        draw_style -- str

        draw_text_style -- str

        content -- str regex

    Return: list of odf_shape
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::draw:ellipse&#34;,
        draw_style=draw_style,
        draw_text_style=draw_text_style,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_group"><code class="name flex">
<span>def <span class="ident">get_draw_group</span></span>(<span>self, position=0, name=None, title=None, description=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_group(
    self, position=0, name=None, title=None, description=None, content=None
):
    return _get_element(
        self,
        &#34;descendant::draw:g&#34;,
        position,
        draw_name=name,
        svg_title=title,
        svg_desc=description,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_groups"><code class="name flex">
<span>def <span class="ident">get_draw_groups</span></span>(<span>self, title=None, description=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_groups(self, title=None, description=None, content=None):
    return _get_elements(
        self,
        &#34;descendant::draw:g&#34;,
        svg_title=title,
        svg_desc=description,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_line"><code class="name flex">
<span>def <span class="ident">get_draw_line</span></span>(<span>self, position=0, id=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the draw line that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>id &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: odf_shape or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_line(self, position=0, id=None, content=None):  # noqa: A002
    &#34;&#34;&#34;Return the draw line that matches the criteria.

    Arguments:

        position -- int

        id -- str

        content -- str regex

    Return: odf_shape or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::draw:line&#34;, position, draw_id=id, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_lines"><code class="name flex">
<span>def <span class="ident">get_draw_lines</span></span>(<span>self, draw_style=None, draw_text_style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the draw lines that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>draw_style &ndash; str</p>
<p>draw_text_style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of odf_shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_lines(self, draw_style=None, draw_text_style=None, content=None):
    &#34;&#34;&#34;Return all the draw lines that match the criteria.

    Arguments:

        draw_style -- str

        draw_text_style -- str

        content -- str regex

    Return: list of odf_shape
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::draw:line&#34;,
        draw_style=draw_style,
        draw_text_style=draw_text_style,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_page"><code class="name flex">
<span>def <span class="ident">get_draw_page</span></span>(<span>self, position=0, name=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the draw page that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: DrawPage or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_page(self, position=0, name=None, content=None):
    &#34;&#34;&#34;Return the draw page that matches the criteria.

    Arguments:

        position -- int

        name -- str

        content -- str regex

    Return: DrawPage or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::draw:page&#34;, position, draw_name=name, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_pages"><code class="name flex">
<span>def <span class="ident">get_draw_pages</span></span>(<span>self, style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the draw pages that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of DrawPage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_pages(self, style=None, content=None):
    &#34;&#34;&#34;Return all the draw pages that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of DrawPage
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::draw:page&#34;, draw_style=style, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_rectangle"><code class="name flex">
<span>def <span class="ident">get_draw_rectangle</span></span>(<span>self, position=0, id=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the draw rectangle that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>id &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: odf_shape or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_rectangle(self, position=0, id=None, content=None):  # noqa: A002
    &#34;&#34;&#34;Return the draw rectangle that matches the criteria.

    Arguments:

        position -- int

        id -- str

        content -- str regex

    Return: odf_shape or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::draw:rect&#34;, position, draw_id=id, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_draw_rectangles"><code class="name flex">
<span>def <span class="ident">get_draw_rectangles</span></span>(<span>self, draw_style=None, draw_text_style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the draw rectangles that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>draw_style &ndash; str</p>
<p>draw_text_style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of odf_shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_draw_rectangles(self, draw_style=None, draw_text_style=None, content=None):
    &#34;&#34;&#34;Return all the draw rectangles that match the criteria.

    Arguments:

        draw_style -- str

        draw_text_style -- str

        content -- str regex

    Return: list of odf_shape
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::draw:rect&#34;,
        draw_style=draw_style,
        draw_text_style=draw_text_style,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, xpath_query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, xpath_query):
    element = self.__element
    result = element.xpath(&#34;(%s)[1]&#34; % xpath_query, namespaces=ODF_NAMESPACES)
    if result:
        return Element.from_tag(result[0])
    return None</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_elements"><code class="name flex">
<span>def <span class="ident">get_elements</span></span>(<span>self, xpath_query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements(self, xpath_query):
    element = self.__element
    if isinstance(xpath_query, XPath):
        result = xpath_query(element)
    else:
        new_xpath_query = _find_query_in_cache(to_bytes(xpath_query))
        result = new_xpath_query(element)
    if hasattr(self, &#34;_tmap&#34;):
        if hasattr(self, &#34;_rmap&#34;):
            cache = (self._tmap, self._cmap, self._rmap)
        else:
            cache = (self._tmap, self._cmap)
    else:
        cache = None
    return [Element.from_tag_for_clone(e, cache) for e in result]</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_formatted_text"><code class="name flex">
<span>def <span class="ident">get_formatted_text</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must return a beautiful version of the text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_formatted_text(self, context):
    &#34;&#34;&#34;This function must return a beautiful version of the text&#34;&#34;&#34;
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>self, position=0, name=None, presentation_class=None, title=None, description=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the section that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>title &ndash; str regex</p>
<p>description &ndash; str regex</p>
<p>content &ndash; str regex</p>
<p>Return: Frame or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame(
    self,
    position=0,
    name=None,
    presentation_class=None,
    title=None,
    description=None,
    content=None,
):
    &#34;&#34;&#34;Return the section that matches the criteria.

    Arguments:

        position -- int

        title -- str regex

        description -- str regex

        content -- str regex

    Return: Frame or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self,
        &#34;descendant::draw:frame&#34;,
        position,
        draw_name=name,
        presentation_class=presentation_class,
        svg_title=title,
        svg_desc=description,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_frames"><code class="name flex">
<span>def <span class="ident">get_frames</span></span>(<span>self, presentation_class=None, style=None, title=None, description=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the frames that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>title &ndash; str regex</p>
<p>description &ndash; str regex</p>
<p>content &ndash; str regex</p>
<p>Return: list of Frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames(
    self,
    presentation_class=None,
    style=None,
    title=None,
    description=None,
    content=None,
):
    &#34;&#34;&#34;Return all the frames that match the criteria.

    Arguments:

        style -- str

        title -- str regex

        description -- str regex

        content -- str regex

    Return: list of Frame
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::draw:frame&#34;,
        presentation_class=presentation_class,
        draw_style=style,
        svg_title=title,
        svg_desc=description,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_header"><code class="name flex">
<span>def <span class="ident">get_header</span></span>(<span>self, position=0, outline_level=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the Header that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: Header or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_header(self, position=0, outline_level=None, content=None):
    &#34;&#34;&#34;Return the Header that matches the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: Header or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self,
        &#34;descendant::text:h&#34;,
        position,
        outline_level=outline_level,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_headers"><code class="name flex">
<span>def <span class="ident">get_headers</span></span>(<span>self, style=None, outline_level=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the Headers that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of Header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_headers(self, style=None, outline_level=None, content=None):
    &#34;&#34;&#34;Return all the Headers that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of Header
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::text:h&#34;,
        text_style=style,
        outline_level=outline_level,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self, position=0, name=None, url=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the image matching the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image(self, position=0, name=None, url=None, content=None):
    &#34;&#34;&#34;Return the image matching the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: Element or None if not found
    &#34;&#34;&#34;
    # The frame is holding the name
    if name is not None:
        frame = _get_element(
            self, &#34;descendant::draw:frame&#34;, position=position, draw_name=name
        )
        if frame is None:
            return None
        # The name is supposedly unique
        return frame.get_element(&#34;draw:image&#34;)
    return _get_element(
        self, &#34;descendant::draw:image&#34;, position, url=url, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_images"><code class="name flex">
<span>def <span class="ident">get_images</span></span>(<span>self, style=None, url=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the images matching the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>url &ndash; str regex</p>
<p>content &ndash; str regex</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_images(self, style=None, url=None, content=None):
    &#34;&#34;&#34;Return all the images matching the criteria.

    Arguments:

        style -- str

        url -- str regex

        content -- str regex

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::draw:image&#34;, text_style=style, url=url, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_link"><code class="name flex">
<span>def <span class="ident">get_link</span></span>(<span>self, position=0, name=None, title=None, url=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the link that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>title &ndash; str</p>
<p>url &ndash; str regex</p>
<p>content &ndash; str regex</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_link(self, position=0, name=None, title=None, url=None, content=None):
    &#34;&#34;&#34;Return the link that matches the criteria.

    Arguments:

        position -- int

        name -- str

        title -- str

        url -- str regex

        content -- str regex

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self,
        &#34;descendant::text:a&#34;,
        position,
        office_name=name,
        office_title=title,
        url=url,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_links"><code class="name flex">
<span>def <span class="ident">get_links</span></span>(<span>self, name=None, title=None, url=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the links that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>title &ndash; str</p>
<p>url &ndash; str regex</p>
<p>content &ndash; str regex</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_links(self, name=None, title=None, url=None, content=None):
    &#34;&#34;&#34;Return all the links that match the criteria.

    Arguments:

        name -- str

        title -- str

        url -- str regex

        content -- str regex

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(
        self,
        &#34;descendant::text:a&#34;,
        office_name=name,
        office_title=title,
        url=url,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, position=0, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: List or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(self, position=0, content=None):
    &#34;&#34;&#34;Return the list that matches the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: List or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;descendant::text:list&#34;, position, content=content)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_lists"><code class="name flex">
<span>def <span class="ident">get_lists</span></span>(<span>self, style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the lists that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of List</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lists(self, style=None, content=None):
    &#34;&#34;&#34;Return all the lists that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of List
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::text:list&#34;, text_style=style, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_named_range"><code class="name flex">
<span>def <span class="ident">get_named_range</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the named range of specified name, or None if not found.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>Return: NamedRange</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_named_range(self, name):
    &#34;&#34;&#34;Return the named range of specified name, or None if not found.

    Arguments:

        name -- str

    Return: NamedRange
    &#34;&#34;&#34;
    named_range = self.get_elements(
        &#39;descendant::table:named-expressions/table:named-range[@table:name=&#34;%s&#34;][1]&#39;
        % name
    )
    if named_range:
        return named_range[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_named_ranges"><code class="name flex">
<span>def <span class="ident">get_named_ranges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the tables named ranges.</p>
<p>Return: list of odf_named_range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_named_ranges(self):
    &#34;&#34;&#34;Return all the tables named ranges.

    Return: list of odf_named_range
    &#34;&#34;&#34;
    named_ranges = self.get_elements(
        &#34;descendant::table:named-expressions/table:named-range&#34;
    )
    return named_ranges</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_note"><code class="name flex">
<span>def <span class="ident">get_note</span></span>(<span>self, position=0, note_id=None, note_class=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the note that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>note_id &ndash; str</p>
<p>note_class &ndash; 'footnote' or 'endnote'</p>
<p>content &ndash; str regex</p>
<p>Return: Note or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_note(self, position=0, note_id=None, note_class=None, content=None):
    &#34;&#34;&#34;Return the note that matches the criteria.

    Arguments:

        position -- int

        note_id -- str

        note_class -- &#39;footnote&#39; or &#39;endnote&#39;

        content -- str regex

    Return: Note or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self,
        &#34;descendant::text:note&#34;,
        position,
        text_id=note_id,
        note_class=note_class,
        content=content,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_notes"><code class="name flex">
<span>def <span class="ident">get_notes</span></span>(<span>self, note_class=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the notes that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>note_class &ndash; 'footnote' or 'endnote'</p>
<p>content &ndash; str regex</p>
<p>Return: list of Note</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notes(self, note_class=None, content=None):
    &#34;&#34;&#34;Return all the notes that match the criteria.

    Arguments:

        note_class -- &#39;footnote&#39; or &#39;endnote&#39;

        content -- str regex

    Return: list of Note
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::text:note&#34;, note_class=note_class, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_office_names"><code class="name flex">
<span>def <span class="ident">get_office_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the used office:name tags values of the element.</p>
<p>Return: list of unique str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_office_names(self):
    &#34;&#34;&#34;Return all the used office:name tags values of the element.

    Return: list of unique str
    &#34;&#34;&#34;
    name_xpath_query = _find_query_in_cache(&#34;//@office:name&#34;)
    names = name_xpath_query(self.__element)
    uniq_names = list(set(names))
    return uniq_names</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_orphan_draw_connectors"><code class="name flex">
<span>def <span class="ident">get_orphan_draw_connectors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of connectors which don't have any shape connected
to them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_orphan_draw_connectors(self):
    &#34;&#34;&#34;Return a list of connectors which don&#39;t have any shape connected
    to them.
    &#34;&#34;&#34;
    connectors = []
    for connector in self.get_draw_connectors():
        start_shape = connector.get_attribute(&#34;draw:start-shape&#34;)
        end_shape = connector.get_attribute(&#34;draw:end-shape&#34;)
        if start_shape is None and end_shape is None:
            connectors.append(connector)
    return connectors</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_paragraph"><code class="name flex">
<span>def <span class="ident">get_paragraph</span></span>(<span>self, position=0, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the paragraph that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: Paragraph or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paragraph(self, position=0, content=None):
    &#34;&#34;&#34;Return the paragraph that matches the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: Paragraph or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;descendant::text:p&#34;, position, content=content)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_paragraphs"><code class="name flex">
<span>def <span class="ident">get_paragraphs</span></span>(<span>self, style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the paragraphs that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of Paragraph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paragraphs(self, style=None, content=None):
    &#34;&#34;&#34;Return all the paragraphs that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of Paragraph
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::text:p&#34;, text_style=style, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_mark"><code class="name flex">
<span>def <span class="ident">get_reference_mark</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the reference mark that match the criteria. Either single
position reference mark (text:reference-mark) or start of range
reference (text:reference-mark-start).</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_mark(self, position=0, name=None):
    &#34;&#34;&#34;Return the reference mark that match the criteria. Either single
    position reference mark (text:reference-mark) or start of range
    reference (text:reference-mark-start).

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    name = to_str(name)
    if name:
        request = (
            f&#34;descendant::text:reference-mark-start&#34;
            f&#39;[@text:name=&#34;{name}&#34;] &#39;
            f&#34;| descendant::text:reference-mark&#34;
            f&#39;[@text:name=&#34;{name}&#34;]&#39;
        )
        return _get_element(self, request, position=0)
    request = (
        &#34;descendant::text:reference-mark-start | descendant::text:reference-mark&#34;
    )
    return _get_element(self, request, position)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_mark_end"><code class="name flex">
<span>def <span class="ident">get_reference_mark_end</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the reference mark end that matches the criteria. Search only
the tags text:reference-mark-end.
Consider using : get_reference_marks()</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_mark_end(self, position=0, name=None):
    &#34;&#34;&#34;Return the reference mark end that matches the criteria. Search only
    the tags text:reference-mark-end.
    Consider using : get_reference_marks()

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:reference-mark-end&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_mark_ends"><code class="name flex">
<span>def <span class="ident">get_reference_mark_ends</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the reference mark ends. Search only the tags
text:reference-mark-end.
Consider using : get_reference_marks()</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_mark_ends(self):
    &#34;&#34;&#34;Return all the reference mark ends. Search only the tags
    text:reference-mark-end.
    Consider using : get_reference_marks()

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:reference-mark-end&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_mark_single"><code class="name flex">
<span>def <span class="ident">get_reference_mark_single</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the reference mark that matches the criteria. Search only the
tags text:reference-mark.
Consider using : get_reference_mark()</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_mark_single(self, position=0, name=None):
    &#34;&#34;&#34;Return the reference mark that matches the criteria. Search only the
    tags text:reference-mark.
    Consider using : get_reference_mark()

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:reference-mark&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_mark_start"><code class="name flex">
<span>def <span class="ident">get_reference_mark_start</span></span>(<span>self, position=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the reference mark start that matches the criteria. Search
only the tags text:reference-mark-start.
Consider using : get_reference_mark()</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_mark_start(self, position=0, name=None):
    &#34;&#34;&#34;Return the reference mark start that matches the criteria. Search
    only the tags text:reference-mark-start.
    Consider using : get_reference_mark()

    Arguments:

        position -- int

        name -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:reference-mark-start&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_mark_starts"><code class="name flex">
<span>def <span class="ident">get_reference_mark_starts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the reference mark starts. Search only the tags
text:reference-mark-start.
Consider using : get_reference_marks()</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_mark_starts(self):
    &#34;&#34;&#34;Return all the reference mark starts. Search only the tags
    text:reference-mark-start.
    Consider using : get_reference_marks()

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:reference-mark-start&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_marks"><code class="name flex">
<span>def <span class="ident">get_reference_marks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the reference marks, either single position reference
(text:reference-mark) or start of range reference
(text:reference-mark-start).</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_marks(self):
    &#34;&#34;&#34;Return all the reference marks, either single position reference
    (text:reference-mark) or start of range reference
    (text:reference-mark-start).

    Return: list of Element
    &#34;&#34;&#34;
    request = (
        &#34;descendant::text:reference-mark-start | descendant::text:reference-mark&#34;
    )
    return _get_elements(self, request)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_reference_marks_single"><code class="name flex">
<span>def <span class="ident">get_reference_marks_single</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the reference marks. Search only the tags
text:reference-mark.
Consider using : get_reference_marks()</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_marks_single(self):
    &#34;&#34;&#34;Return all the reference marks. Search only the tags
    text:reference-mark.
    Consider using : get_reference_marks()

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:reference-mark&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_references"><code class="name flex">
<span>def <span class="ident">get_references</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the references (text:reference-ref). If name is
provided, returns the references of that name.</p>
<p>Return: list of Element</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_references(self, name=None):
    &#34;&#34;&#34;Return all the references (text:reference-ref). If name is
    provided, returns the references of that name.

    Return: list of Element

    Arguments:

        name -- str or None
    &#34;&#34;&#34;
    if name is None:
        return _get_elements(self, &#34;descendant::text:reference-ref&#34;)
    request = &#39;descendant::text:reference-ref[@text:ref-name=&#34;%s&#34;]&#39; % to_bytes(name)
    return _get_elements(self, request)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_section"><code class="name flex">
<span>def <span class="ident">get_section</span></span>(<span>self, position=0, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the section that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_section(self, position=0, content=None):
    &#34;&#34;&#34;Return the section that matches the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;descendant::text:section&#34;, position, content=content)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_sections"><code class="name flex">
<span>def <span class="ident">get_sections</span></span>(<span>self, style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the sections that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sections(self, style=None, content=None):
    &#34;&#34;&#34;Return all the sections that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;text:section&#34;, text_style=style, content=content)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_span"><code class="name flex">
<span>def <span class="ident">get_span</span></span>(<span>self, position=0, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the span that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: Span or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_span(self, position=0, content=None):
    &#34;&#34;&#34;Return the span that matches the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: Span or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;descendant::text:span&#34;, position, content=content)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_spans"><code class="name flex">
<span>def <span class="ident">get_spans</span></span>(<span>self, style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the spans that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of Span</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spans(self, style=None, content=None):
    &#34;&#34;&#34;Return all the spans that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of Span
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::text:span&#34;, text_style=style, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_style"><code class="name flex">
<span>def <span class="ident">get_style</span></span>(<span>self, family, name_or_element=None, display_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the style uniquely identified by the family/name pair. If
the argument is already a style object, it will return it.</p>
<p>If the name is not the internal name but the name you gave in the
desktop application, use display_name instead.</p>
<h2 id="arguments">Arguments</h2>
<p>family &ndash; 'paragraph', 'text', 'graphic', 'table', 'list',
'number'</p>
<p>name_or_element &ndash; str or Style</p>
<p>display_name &ndash; str</p>
<p>Return: odf_style or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_style(self, family, name_or_element=None, display_name=None):
    &#34;&#34;&#34;Return the style uniquely identified by the family/name pair. If
    the argument is already a style object, it will return it.

    If the name is not the internal name but the name you gave in the
    desktop application, use display_name instead.

    Arguments:

        family -- &#39;paragraph&#39;, &#39;text&#39;, &#39;graphic&#39;, &#39;table&#39;, &#39;list&#39;,
                  &#39;number&#39;

        name_or_element -- str or Style

        display_name -- str

    Return: odf_style or None if not found
    &#34;&#34;&#34;
    if isinstance(name_or_element, Element):
        name = self.get_attribute(&#34;style:name&#34;)
        if name is not None:
            return name_or_element
        else:
            raise ValueError(&#34;Not a odf_style ?  %s&#34; % name_or_element)
    style_name = name_or_element
    is_default = not (style_name or display_name)
    tagname = self._get_style_tagname(family, is_default=is_default)
    # famattr became None if no &#34;style:family&#34; attribute
    if family:
        return _get_element(
            self,
            tagname,
            0,
            style_name=style_name,
            display_name=display_name,
            family=family,
        )
    else:
        return _get_element(
            self,
            tagname,
            0,
            draw_name=style_name or display_name,
            family=family,
        )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_styled_elements"><code class="name flex">
<span>def <span class="ident">get_styled_elements</span></span>(<span>self, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Brute-force to find paragraphs, tables, etc. using the given style
name (or all by default).</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>Return: list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_styled_elements(self, name=&#34;&#34;):
    &#34;&#34;&#34;Brute-force to find paragraphs, tables, etc. using the given style
    name (or all by default).

    Arguments:

        name -- str

    Return: list
    &#34;&#34;&#34;
    # FIXME incomplete (and possibly inaccurate)
    return (
        _get_elements(self, &#34;descendant::*&#34;, text_style=name)
        + _get_elements(self, &#34;descendant::*&#34;, draw_style=name)
        + _get_elements(self, &#34;descendant::*&#34;, draw_text_style=name)
        + _get_elements(self, &#34;descendant::*&#34;, table_style=name)
        + _get_elements(self, &#34;descendant::*&#34;, page_layout=name)
        + _get_elements(self, &#34;descendant::*&#34;, master_page=name)
        + _get_elements(self, &#34;descendant::*&#34;, parent_style=name)
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_styles"><code class="name flex">
<span>def <span class="ident">get_styles</span></span>(<span>self, family=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_styles(self, family=None):
    # Both common and default styles
    tagname = self._get_style_tagname(family)
    return _get_elements(self, tagname, family=family)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_table"><code class="name flex">
<span>def <span class="ident">get_table</span></span>(<span>self, position=0, name=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the table that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>name &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: Table or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_table(self, position=0, name=None, content=None):
    &#34;&#34;&#34;Return the table that matches the criteria.

    Arguments:

        position -- int

        name -- str

        content -- str regex

    Return: Table or None if not found
    &#34;&#34;&#34;
    if name is None and content is None:
        result = self._get_element_idx(&#34;descendant::table:table&#34;, position)
    else:
        result = _get_element(
            self,
            &#34;descendant::table:table&#34;,
            position,
            table_name=name,
            content=content,
        )
    return result</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_tables"><code class="name flex">
<span>def <span class="ident">get_tables</span></span>(<span>self, style=None, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the tables that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; str</p>
<p>content &ndash; str regex</p>
<p>Return: list of Table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tables(self, style=None, content=None):
    &#34;&#34;&#34;Return all the tables that match the criteria.

    Arguments:

        style -- str

        content -- str regex

    Return: list of Table
    &#34;&#34;&#34;
    return _get_elements(
        self, &#34;descendant::table:table&#34;, table_style=style, content=content
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change"><code class="name flex">
<span>def <span class="ident">get_text_change</span></span>(<span>self, position=0, idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the text change that matches the criteria. Either single
deletion (text:change) or start of range of changes (text:change-start).
position : index of the element to retrieve if several matches, default
is 0.
idx : change-id of the element.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>idx &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change(self, position=0, idx=None):
    &#34;&#34;&#34;Return the text change that matches the criteria. Either single
    deletion (text:change) or start of range of changes (text:change-start).
    position : index of the element to retrieve if several matches, default
    is 0.
    idx : change-id of the element.

    Arguments:

        position -- int

        idx -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    if idx:
        request = (
            f&#39;descendant::text:change-start[@text:change-id=&#34;{idx}&#34;] &#39;
            f&#39;| descendant::text:change[@text:change-id=&#34;{idx}&#34;]&#39;
        )
        return _get_element(self, request, position=0)
    request = &#34;descendant::text:change-start | descendant::text:change&#34;
    return _get_element(self, request, position)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change_deletion"><code class="name flex">
<span>def <span class="ident">get_text_change_deletion</span></span>(<span>self, position=0, idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the text change of deletion kind that matches the criteria.
Search only for the tags text:change.
Consider using : get_text_change()</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>idx &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change_deletion(self, position=0, idx=None):
    &#34;&#34;&#34;Return the text change of deletion kind that matches the criteria.
    Search only for the tags text:change.
    Consider using : get_text_change()

    Arguments:

        position -- int

        idx -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;descendant::text:change&#34;, position, change_id=idx)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change_deletions"><code class="name flex">
<span>def <span class="ident">get_text_change_deletions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the text changes of deletion kind: the tags text:change.
Consider using : get_text_changes()</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change_deletions(self):
    &#34;&#34;&#34;Return all the text changes of deletion kind: the tags text:change.
    Consider using : get_text_changes()

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:text:change&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change_end"><code class="name flex">
<span>def <span class="ident">get_text_change_end</span></span>(<span>self, position=0, idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the text change-end that matches the criteria. Search only
the tags text:change-end.
Consider using : get_text_change()</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>idx &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change_end(self, position=0, idx=None):
    &#34;&#34;&#34;Return the text change-end that matches the criteria. Search only
    the tags text:change-end.
    Consider using : get_text_change()

    Arguments:

        position -- int

        idx -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:change-end&#34;, position, change_id=idx
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change_ends"><code class="name flex">
<span>def <span class="ident">get_text_change_ends</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the text change-end. Search only the tags
text:change-end.
Consider using : get_text_changes()</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change_ends(self):
    &#34;&#34;&#34;Return all the text change-end. Search only the tags
    text:change-end.
    Consider using : get_text_changes()

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:change-end&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change_start"><code class="name flex">
<span>def <span class="ident">get_text_change_start</span></span>(<span>self, position=0, idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the text change-start that matches the criteria. Search
only the tags text:change-start.
Consider using : get_text_change()</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>idx &ndash; str</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change_start(self, position=0, idx=None):
    &#34;&#34;&#34;Return the text change-start that matches the criteria. Search
    only the tags text:change-start.
    Consider using : get_text_change()

    Arguments:

        position -- int

        idx -- str

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:change-start&#34;, position, change_id=idx
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_change_starts"><code class="name flex">
<span>def <span class="ident">get_text_change_starts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the text change-start. Search only for the tags
text:change-start.
Consider using : get_text_changes()</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_change_starts(self):
    &#34;&#34;&#34;Return all the text change-start. Search only for the tags
    text:change-start.
    Consider using : get_text_changes()

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:change-start&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_text_changes"><code class="name flex">
<span>def <span class="ident">get_text_changes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the text changes, either single deletion
(text:change) or start of range of changes (text:change-start).</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_changes(self):
    &#34;&#34;&#34;Return all the text changes, either single deletion
    (text:change) or start of range of changes (text:change-start).

    Return: list of Element
    &#34;&#34;&#34;
    request = &#34;descendant::text:change-start | descendant::text:change&#34;
    return _get_elements(self, request)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_toc"><code class="name flex">
<span>def <span class="ident">get_toc</span></span>(<span>self, position=0, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the table of contents that matches the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>position &ndash; int</p>
<p>content &ndash; str regex</p>
<p>Return: odf_toc or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_toc(self, position=0, content=None):
    &#34;&#34;&#34;Return the table of contents that matches the criteria.

    Arguments:

        position -- int

        content -- str regex

    Return: odf_toc or None if not found
    &#34;&#34;&#34;
    return _get_element(self, &#34;text:table-of-content&#34;, position, content=content)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_tocs"><code class="name flex">
<span>def <span class="ident">get_tocs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the tables of contents.</p>
<p>Return: list of odf_toc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tocs(self):
    &#34;&#34;&#34;Return all the tables of contents.

    Return: list of odf_toc
    &#34;&#34;&#34;
    return _get_elements(self, &#34;text:table-of-content&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_tracked_changes"><code class="name flex">
<span>def <span class="ident">get_tracked_changes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the tracked-changes part in the text body.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tracked_changes(self):
    &#34;&#34;&#34;Return the tracked-changes part in the text body.&#34;&#34;&#34;
    return self.get_element(&#34;//text:tracked-changes&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_defined"><code class="name flex">
<span>def <span class="ident">get_user_defined</span></span>(<span>self, name, position=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return the user defined declaration for the given name.</p>
<p>return: Element or none if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_defined(self, name, position=0):
    &#34;&#34;&#34;return the user defined declaration for the given name.

    return: Element or none if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:user-defined&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_defined_list"><code class="name flex">
<span>def <span class="ident">get_user_defined_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the user defined field declarations.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_defined_list(self):
    &#34;&#34;&#34;Return all the user defined field declarations.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:user-defined&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_defined_value"><code class="name flex">
<span>def <span class="ident">get_user_defined_value</span></span>(<span>self, name, value_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the given user defined field name.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>value_type &ndash; 'boolean', 'date', 'float',
'string', 'time' or automatic</p>
<p>Return: most appropriate Python type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_defined_value(self, name, value_type=None):
    &#34;&#34;&#34;Return the value of the given user defined field name.

    Arguments:

        name -- str

        value_type -- &#39;boolean&#39;, &#39;date&#39;, &#39;float&#39;,
                      &#39;string&#39;, &#39;time&#39; or automatic

    Return: most appropriate Python type
    &#34;&#34;&#34;
    user_defined = self.get_user_defined(name)
    if user_defined is None:
        return None
    return get_value(user_defined, value_type)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_field_decl"><code class="name flex">
<span>def <span class="ident">get_user_field_decl</span></span>(<span>self, name, position=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return the user field declaration for the given name.</p>
<p>return: Element or none if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_field_decl(self, name, position=0):
    &#34;&#34;&#34;return the user field declaration for the given name.

    return: Element or none if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:user-field-decl&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_field_decl_list"><code class="name flex">
<span>def <span class="ident">get_user_field_decl_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the user field declarations.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_field_decl_list(self):
    &#34;&#34;&#34;Return all the user field declarations.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:user-field-decl&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_field_decls"><code class="name flex">
<span>def <span class="ident">get_user_field_decls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the container for user field declarations. Created if not
found.</p>
<p>Return: Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_field_decls(self):
    &#34;&#34;&#34;Return the container for user field declarations. Created if not
    found.

    Return: Element
    &#34;&#34;&#34;
    user_field_decls = self.get_element(&#34;//text:user-field-decls&#34;)
    if user_field_decls is None:
        body = self.document_body
        body.insert(Element.from_tag(&#34;text:user-field-decls&#34;), FIRST_CHILD)
        user_field_decls = body.get_element(&#34;//text:user-field-decls&#34;)

    return user_field_decls</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_user_field_value"><code class="name flex">
<span>def <span class="ident">get_user_field_value</span></span>(<span>self, name, value_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the given user field name.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>value_type &ndash; 'boolean', 'currency', 'date', 'float',
'percentage', 'string', 'time' or automatic</p>
<p>Return: most appropriate Python type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_field_value(self, name, value_type=None):
    &#34;&#34;&#34;Return the value of the given user field name.

    Arguments:

        name -- str

        value_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;,
                      &#39;percentage&#39;, &#39;string&#39;, &#39;time&#39; or automatic

    Return: most appropriate Python type
    &#34;&#34;&#34;
    user_field_decl = self.get_user_field_decl(name)
    if user_field_decl is None:
        return None
    return get_value(user_field_decl, value_type)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_variable_decl"><code class="name flex">
<span>def <span class="ident">get_variable_decl</span></span>(<span>self, name, position=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return the variable declaration for the given name.</p>
<p>return: Element or none if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_decl(self, name, position=0):
    &#34;&#34;&#34;return the variable declaration for the given name.

    return: Element or none if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:variable-decl&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_variable_decl_list"><code class="name flex">
<span>def <span class="ident">get_variable_decl_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the variable declarations.</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_decl_list(self):
    &#34;&#34;&#34;Return all the variable declarations.

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:variable-decl&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_variable_decls"><code class="name flex">
<span>def <span class="ident">get_variable_decls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the container for variable declarations. Created if not
found.</p>
<p>Return: Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_decls(self):
    &#34;&#34;&#34;Return the container for variable declarations. Created if not
    found.

    Return: Element
    &#34;&#34;&#34;
    variable_decls = self.get_element(&#34;//text:variable-decls&#34;)
    if variable_decls is None:
        body = self.document_body
        body.insert(Element.from_tag(&#34;text:variable-decls&#34;), FIRST_CHILD)
        variable_decls = body.get_element(&#34;//text:variable-decls&#34;)

    return variable_decls</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_variable_set"><code class="name flex">
<span>def <span class="ident">get_variable_set</span></span>(<span>self, name, position=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the variable set for the given name (last one by default).</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>position &ndash; int</p>
<p>Return: Element or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_set(self, name, position=-1):
    &#34;&#34;&#34;Return the variable set for the given name (last one by default).

    Arguments:

        name -- str

        position -- int

    Return: Element or None if not found
    &#34;&#34;&#34;
    return _get_element(
        self, &#34;descendant::text:variable-set&#34;, position, text_name=name
    )</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_variable_set_value"><code class="name flex">
<span>def <span class="ident">get_variable_set_value</span></span>(<span>self, name, value_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the last value of the given variable name.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>value_type &ndash; 'boolean', 'currency', 'date', 'float',
'percentage', 'string', 'time' or automatic</p>
<p>Return: most appropriate Python type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_set_value(self, name, value_type=None):
    &#34;&#34;&#34;Return the last value of the given variable name.

    Arguments:

        name -- str

        value_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;,
                      &#39;percentage&#39;, &#39;string&#39;, &#39;time&#39; or automatic

    Return: most appropriate Python type
    &#34;&#34;&#34;
    variable_set = self.get_variable_set(name)
    if not variable_set:
        return None
    return get_value(variable_set, value_type)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.get_variable_sets"><code class="name flex">
<span>def <span class="ident">get_variable_sets</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the variable sets that match the criteria.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>Return: list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_sets(self, name=None):
    &#34;&#34;&#34;Return all the variable sets that match the criteria.

    Arguments:

        name -- str

    Return: list of Element
    &#34;&#34;&#34;
    return _get_elements(self, &#34;descendant::text:variable-set&#34;, text_name=name)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, child)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the position of the child in this element.</p>
<p>Inspired by lxml</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, child):
    &#34;&#34;&#34;Return the position of the child in this element.

    Inspired by lxml
    &#34;&#34;&#34;
    return self.__element.index(child.__element)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, element, xmlposition=None, position=None, start=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert an element relatively to ourself.</p>
<p>Insert either using DOM vocabulary or by numeric position.
If text start is True, insert the element before any existing text.</p>
<p>Position start at 0.</p>
<h2 id="arguments">Arguments</h2>
<p>element &ndash; Element</p>
<p>xmlposition &ndash; FIRST_CHILD, LAST_CHILD, NEXT_SIBLING
or PREV_SIBLING</p>
<p>start &ndash; Boolean</p>
<p>position &ndash; int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, element, xmlposition=None, position=None, start=False):
    &#34;&#34;&#34;Insert an element relatively to ourself.

    Insert either using DOM vocabulary or by numeric position.
    If text start is True, insert the element before any existing text.

    Position start at 0.

    Arguments:

        element -- Element

        xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING
                       or PREV_SIBLING

        start -- Boolean

        position -- int
    &#34;&#34;&#34;
    # child_tag = element.tag
    current = self.__element
    element = element.__element
    if start:
        text = current.text
        if text is not None:
            current.text = None
            tail = element.tail
            if tail is None:
                tail = text
            else:
                tail = tail + text
            element.tail = tail
        position = 0
    if position is not None:
        current.insert(position, element)
    elif xmlposition is FIRST_CHILD:
        current.insert(0, element)
    elif xmlposition is LAST_CHILD:
        current.append(element)
    elif xmlposition is NEXT_SIBLING:
        parent = current.getparent()
        index = parent.index(current)
        parent.insert(index + 1, element)
    elif xmlposition is PREV_SIBLING:
        parent = current.getparent()
        index = parent.index(current)
        parent.insert(index, element)
    else:
        raise ValueError(&#34;(xml)position must be defined&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the element is empty : no text, no children, no tail</p>
<p>Return: Boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    &#34;&#34;&#34;Check if the element is empty : no text, no children, no tail

    Return: Boolean
    &#34;&#34;&#34;
    element = self.__element
    if element.tail is not None:
        return False
    if element.text is not None:
        return False
    if element.getchildren():
        return False
    return True</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>return True if the pattern is found one or more times anywhere in
the text content of the element.</p>
<p>Python regular expression syntax applies.</p>
<h2 id="arguments">Arguments</h2>
<p>pattern &ndash; str</p>
<p>Return: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, pattern):
    &#34;&#34;&#34;return True if the pattern is found one or more times anywhere in
    the text content of the element.

    Python regular expression syntax applies.

    Arguments:

        pattern -- str

    Return: bool
    &#34;&#34;&#34;
    return self.search(pattern) is not None</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, pattern, new=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the pattern with the given text, or delete if text is an
empty string, and return the number of replacements. By default, only
return the number of occurences that would be replaced.</p>
<p>It cannot replace patterns found across several element, like a word
split into two consecutive spans.</p>
<p>Python regular expression syntax applies.</p>
<h2 id="arguments">Arguments</h2>
<p>pattern &ndash; str</p>
<p>new &ndash; str</p>
<p>Return: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, pattern, new=None):
    &#34;&#34;&#34;Replace the pattern with the given text, or delete if text is an
    empty string, and return the number of replacements. By default, only
    return the number of occurences that would be replaced.

    It cannot replace patterns found across several element, like a word
    split into two consecutive spans.

    Python regular expression syntax applies.

    Arguments:

        pattern -- str

        new -- str

    Return: int
    &#34;&#34;&#34;
    if not isinstance(pattern, str):
        # Fail properly if the pattern is an non-ascii bytestring
        pattern = str(pattern)
    cpattern = re.compile(pattern)
    count = 0
    for text in self.xpath(&#34;descendant::text()&#34;):
        if new is None:
            count += len(cpattern.findall(text))
        else:
            new_text, number = cpattern.subn(new, text)
            container = text.parent
            if text.is_text():
                container.text = new_text
            else:
                container.tail = new_text
            count += number
    return count</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.replace_element"><code class="name flex">
<span>def <span class="ident">replace_element</span></span>(<span>self, old_element, new_element)</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces in place a sub element with the element passed as second
argument.</p>
<p>Warning : no clone for old element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_element(self, old_element, new_element):
    &#34;&#34;&#34;Replaces in place a sub element with the element passed as second
    argument.

    Warning : no clone for old element.
    &#34;&#34;&#34;
    current = self.__element
    current.replace(old_element.__element, new_element.__element)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first position of the pattern in the text content of
the element, or None if not found.</p>
<p>Python regular expression syntax applies.</p>
<h2 id="arguments">Arguments</h2>
<p>pattern &ndash; str</p>
<p>Return: int or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, pattern):
    &#34;&#34;&#34;Return the first position of the pattern in the text content of
    the element, or None if not found.

    Python regular expression syntax applies.

    Arguments:

        pattern -- str

    Return: int or None
    &#34;&#34;&#34;
    match = re.search(pattern, self.text_recursive)
    if match is None:
        return None
    return match.start()</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, pretty=False, with_ns=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, pretty=False, with_ns=False):
    # This copy bypasses serialization side-effects in lxml
    native = deepcopy(self.__element)
    data = tostring(
        native, with_tail=False, pretty_print=pretty, encoding=&#34;unicode&#34;
    )
    if not with_ns:
        # Remove namespaces
        data = ns_stripper.sub(&#34;&#34;, data)
    return data</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.serialize2"><code class="name flex">
<span>def <span class="ident">serialize2</span></span>(<span>self, pretty=False, with_ns=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize2(self, pretty=False, with_ns=False):
    # This copy bypasses serialization side-effects in lxml
    native = deepcopy(self.__element)
    data = tostring(
        native, with_tail=False, pretty_print=pretty, encoding=&#34;unicode&#34;
    )
    if not with_ns:
        # Remove namespaces
        data = ns_stripper.sub(&#34;&#34;, data)
    return data + str(len(data))</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.set_attribute"><code class="name flex">
<span>def <span class="ident">set_attribute</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attribute(self, name, value):
    element = self.__element
    uri, name = _decode_qname(name)
    if uri is not None:
        name = &#34;{%s}%s&#34; % (uri, name)  # noqa: UP031

    if isinstance(value, bool):
        value = Boolean.encode(value)
    elif value is None:
        with contextlib.suppress(KeyError):
            del element.attrib[name]
        return
    element.set(name, str(value))</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.set_style_attribute"><code class="name flex">
<span>def <span class="ident">set_style_attribute</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to accept a style object as a value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_style_attribute(self, name, value):
    &#34;&#34;&#34;Shortcut to accept a style object as a value.&#34;&#34;&#34;
    if isinstance(value, Element):
        value = value.name
    return self.set_attribute(name, value)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.strip_elements"><code class="name flex">
<span>def <span class="ident">strip_elements</span></span>(<span>self, sub_elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the tags of provided elements, keeping inner childs and text.</p>
<p>Return : the striped element.</p>
<p>Warning : no clone in sub_elements list.</p>
<h2 id="arguments">Arguments</h2>
<p>sub_elements &ndash; Element or list of Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_elements(self, sub_elements):
    &#34;&#34;&#34;Remove the tags of provided elements, keeping inner childs and text.

    Return : the striped element.

    Warning : no clone in sub_elements list.

    Arguments:

        sub_elements -- Element or list of Element
    &#34;&#34;&#34;
    if not sub_elements:
        return self
    if isinstance(sub_elements, Element):
        sub_elements = (sub_elements,)
    replacer = to_bytes(_get_lxml_tag(&#34;text:this-will-be-removed&#34;))
    for element in sub_elements:
        element.__element.tag = replacer
    strip = (&#34;text:this-will-be-removed&#34;,)
    return self.strip_tags(strip=strip, default=None)</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.strip_tags"><code class="name flex">
<span>def <span class="ident">strip_tags</span></span>(<span>self, strip=None, protect=None, default='text:p')</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the tags listed in strip, recursively, keeping inner childs
and text. Tags listed in protect stop the removal one level depth. If
the first level element is stripped, default is used to embed the
content in the default element. If default is None and first level is
striped, a list of text and children is returned. Return : the striped
element.</p>
<p>strip_tags should be used by on purpose methods (strip_span &hellip;)
(Method name taken from lxml).</p>
<h2 id="arguments">Arguments</h2>
<p>strip &ndash; iterable list of str odf tags, or None</p>
<p>protect &ndash; iterable list of str odf tags, or None</p>
<p>default &ndash; str odf tag, or None</p>
<h2 id="return">Return</h2>
<p>Element or list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_tags(self, strip=None, protect=None, default=&#34;text:p&#34;):
    &#34;&#34;&#34;Remove the tags listed in strip, recursively, keeping inner childs
    and text. Tags listed in protect stop the removal one level depth. If
    the first level element is stripped, default is used to embed the
    content in the default element. If default is None and first level is
    striped, a list of text and children is returned. Return : the striped
    element.

    strip_tags should be used by on purpose methods (strip_span ...)
    (Method name taken from lxml).

    Arguments:

        strip -- iterable list of str odf tags, or None

        protect -- iterable list of str odf tags, or None

        default -- str odf tag, or None

    Return:

        Element or list.
    &#34;&#34;&#34;
    if not strip:
        return self
    if not protect:
        protect = ()
    protected = False
    element, modified = Element._strip_tags(self, strip, protect, protected)
    if modified and isinstance(element, list) and default:
        new = Element.from_tag(default)
        for content in element:
            if isinstance(content, Element):
                new.append(content)
            else:
                new.text = content
        element = new
    return element</code></pre>
</details>
</dd>
<dt id="odfdo.element.Element.xpath"><code class="name flex">
<span>def <span class="ident">xpath</span></span>(<span>self, xpath_query)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply XPath query to the element and its subtree. Return list of
Element or Text instances translated from the nodes found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xpath(self, xpath_query):
    &#34;&#34;&#34;Apply XPath query to the element and its subtree. Return list of
    Element or Text instances translated from the nodes found.
    &#34;&#34;&#34;
    element = self.__element
    xpath_instance = _find_query_in_cache(xpath_query)
    elements = xpath_instance(element)
    result = []
    for obj in elements:
        if isinstance(obj, (_ElementStringResult, _ElementUnicodeResult)):
            result.append(Text(obj))
        elif isinstance(obj, _Element):
            result.append(Element.from_tag(obj))
        else:
            result.append(obj)
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="odfdo.element.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>text_result)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation of an XML text node. Created to hide the specifics of
lxml in searching text nodes using XPath.</p>
<p>Constructed like any str object but only accepts lxml text objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text(str):
    &#34;&#34;&#34;Representation of an XML text node. Created to hide the specifics of
    lxml in searching text nodes using XPath.

    Constructed like any str object but only accepts lxml text objects.
    &#34;&#34;&#34;

    # There&#39;s some black magic in inheriting from str
    def __init__(self, text_result):
        self.__parent = text_result.getparent()
        self.__is_text = text_result.is_text
        self.__is_tail = text_result.is_tail

    @property
    def parent(self):
        parent = self.__parent
        # XXX happens just because of the unit test
        if parent is None:
            return None
        return Element.from_tag(tag_or_elem=parent)

    def is_text(self):
        return self.__is_text

    def is_tail(self):
        return self.__is_tail</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.element.Text.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    parent = self.__parent
    # XXX happens just because of the unit test
    if parent is None:
        return None
    return Element.from_tag(tag_or_elem=parent)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.element.Text.is_tail"><code class="name flex">
<span>def <span class="ident">is_tail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_tail(self):
    return self.__is_tail</code></pre>
</details>
</dd>
<dt id="odfdo.element.Text.is_text"><code class="name flex">
<span>def <span class="ident">is_text</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_text(self):
    return self.__is_text</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="odfdo" href="index.html">odfdo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="odfdo.element.register_element_class" href="#odfdo.element.register_element_class">register_element_class</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="odfdo.element.Element" href="#odfdo.element.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="odfdo.element.Element.append" href="#odfdo.element.Element.append">append</a></code></li>
<li><code><a title="odfdo.element.Element.append_named_range" href="#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.attributes" href="#odfdo.element.Element.attributes">attributes</a></code></li>
<li><code><a title="odfdo.element.Element.children" href="#odfdo.element.Element.children">children</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.clone" href="#odfdo.element.Element.clone">clone</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.del_attribute" href="#odfdo.element.Element.del_attribute">del_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag_for_clone" href="#odfdo.element.Element.from_tag_for_clone">from_tag_for_clone</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_group" href="#odfdo.element.Element.get_draw_group">get_draw_group</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_groups" href="#odfdo.element.Element.get_draw_groups">get_draw_groups</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_element" href="#odfdo.element.Element.get_element">get_element</a></code></li>
<li><code><a title="odfdo.element.Element.get_elements" href="#odfdo.element.Element.get_elements">get_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_styles" href="#odfdo.element.Element.get_styles">get_styles</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.is_empty" href="#odfdo.element.Element.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.element.Element.make_etree_element" href="#odfdo.element.Element.make_etree_element">make_etree_element</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.parent" href="#odfdo.element.Element.parent">parent</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.root" href="#odfdo.element.Element.root">root</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.serialize" href="#odfdo.element.Element.serialize">serialize</a></code></li>
<li><code><a title="odfdo.element.Element.serialize2" href="#odfdo.element.Element.serialize2">serialize2</a></code></li>
<li><code><a title="odfdo.element.Element.set_attribute" href="#odfdo.element.Element.set_attribute">set_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.svg_description" href="#odfdo.element.Element.svg_description">svg_description</a></code></li>
<li><code><a title="odfdo.element.Element.svg_title" href="#odfdo.element.Element.svg_title">svg_title</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.text_recursive" href="#odfdo.element.Element.text_recursive">text_recursive</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odfdo.element.Text" href="#odfdo.element.Text">Text</a></code></h4>
<ul class="">
<li><code><a title="odfdo.element.Text.is_tail" href="#odfdo.element.Text.is_tail">is_tail</a></code></li>
<li><code><a title="odfdo.element.Text.is_text" href="#odfdo.element.Text.is_text">is_text</a></code></li>
<li><code><a title="odfdo.element.Text.parent" href="#odfdo.element.Text.parent">parent</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>