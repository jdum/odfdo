<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>odfdo.row API documentation</title>
<meta name="description" content="Table class for &#34;table:table&#34; and HeaderRows, Cell, Row, Column,
NamedRange related classes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>odfdo.row</code></h1>
</header>
<section id="section-intro">
<p>Table class for "table:table" and HeaderRows, Cell, Row, Column,
NamedRange related classes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2018-2024 Jérôme Dumonteil
# Copyright (c) 2009-2012 Ars Aperta, Itaapy, Pierlis, Talend.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Authors (odfdo project): jerome.dumonteil@gmail.com
# The odfdo project is a derivative work of the lpod-python project:
# https://github.com/lpod/lpod-python
# Authors: David Versmisse &lt;david.versmisse@itaapy.com&gt;
#          Hervé Cauwelier &lt;herve@itaapy.com&gt;
#          Romain Gauthier &lt;romain@itaapy.com&gt;
#          Jerome Dumonteil &lt;jerome.dumonteil@itaapy.com&gt;
&#34;&#34;&#34;Table class for &#34;table:table&#34; and HeaderRows, Cell, Row, Column,
NamedRange related classes.
&#34;&#34;&#34;
from __future__ import annotations

import contextlib
from collections.abc import Iterable, Iterator
from typing import Any

from .cell import Cell
from .element import Element, register_element_class, xpath_compile
from .utils import (
    convert_coordinates,
    delete_item_in_vault,
    find_odf_idx,
    increment,
    insert_item_in_vault,
    insert_map_once,
    make_cache_map,
    set_item_in_vault,
    translate_from_any,
)

_xpath_cell = xpath_compile(&#34;(table:table-cell|table:covered-table-cell)&#34;)
_xpath_cell_idx = xpath_compile(&#34;(table:table-cell|table:covered-table-cell)[$idx]&#34;)


class Row(Element):
    &#34;&#34;&#34;ODF table row &#34;table:table-row&#34; &#34;&#34;&#34;

    _tag = &#34;table:table-row&#34;
    _caching = True
    _append = Element.append

    def __init__(
        self,
        width: int | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;create a Row, optionally filled with &#34;width&#34; number of cells.

        Rows contain cells, their number determine the number of columns.

        You don&#39;t generally have to create rows by hand, use the Table API.

        Arguments:

            width -- int

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.y = None
        if not hasattr(self, &#34;_indexes&#34;):
            self._indexes = {}
            self._indexes[&#34;_rmap&#34;] = {}
        if not hasattr(self, &#34;_rmap&#34;):
            self._compute_row_cache()
            if not hasattr(self, &#34;_tmap&#34;):
                self._tmap = []
                self._cmap = []
        if self._do_init:
            if width is not None:
                for _i in range(width):
                    self.append(Cell())  # type:ignore
            if repeated:
                self.repeated = repeated
            if style is not None:
                self.style = style
            self._compute_row_cache()

    def _get_cells(self) -&gt; list[Element]:
        return self.get_elements(_xpath_cell)

    def _translate_row_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, int | None]:
        xyzt = convert_coordinates(coord)
        if len(xyzt) == 2:
            x, z = xyzt
        else:
            x, _, z, __ = xyzt
        if x and x &lt; 0:
            x = increment(x, self.width)
        if z and z &lt; 0:
            z = increment(z, self.width)
        return (x, z)

    def _compute_row_cache(self) -&gt; None:
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_cell, &#34;table:number-columns-repeated&#34;
        )
        self._rmap = make_cache_map(idx_repeated_seq)

    # Public API

    @property
    def clone(self) -&gt; Row:
        clone = Element.clone.fget(self)  # type: ignore
        clone.y = self.y
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the numnber of times the row is repeated, or
        None to delete it. Without changing cache.

        Arguments:

            repeated -- int
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-rows-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-rows-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get / set the number of times the row is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-rows-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        current: Element = self
        while True:
            # look for Table, parent may be group of rows
            upper = current.parent
            if not upper:
                # lonely row
                return
            # parent may be group of rows, not table
            if isinstance(upper, Element) and upper._tag == &#34;table:table&#34;:
                break
            current = upper
        # fixme : need to optimize this
        if isinstance(upper, Element) and upper._tag == &#34;table:table&#34;:
            upper._compute_table_cache()
            if hasattr(self, &#34;_tmap&#34;):
                del self._tmap[:]
                self._tmap.extend(upper._tmap)
            else:
                self._tmap = upper._tmap

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get /set the style of the row itself.

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute(&#34;table:style-name&#34;)  # type: ignore

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Get the number of expected cells in the row, i.e. addition
        repetitions.

        Return: int
        &#34;&#34;&#34;
        try:
            value = self._rmap[-1] + 1
        except Exception:
            value = 0
        return value

    def _translate_x_from_any(self, x: str | int) -&gt; int:
        return translate_from_any(x, self.width, 0)

    def traverse(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Cell]:
        &#34;&#34;&#34;Yield as many cell elements as expected cells in the row, i.e.
        expand repetitions by returning the same cell as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_cell() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        x = 0
        cell: Cell
        if start is None and end is None:
            for juska in self._rmap:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    if cell is None:
                        cell = Cell()
                    else:
                        cell = cell.clone
                        if repeated &gt; 1:
                            cell.repeated = None
                    cell.y = self.y
                    cell.x = x
                    x += 1
                    yield cell
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._rmap[-1]
                except Exception:
                    end = -1
            start_map = find_odf_idx(self._rmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._rmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            x = start
            for juska in self._rmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if x &lt;= end:
                        if cell is None:
                            cell = Cell()
                        else:
                            cell = cell.clone
                            if repeated &gt; 1 or (x == start and start &gt; 0):
                                cell.repeated = None
                        cell.y = self.y
                        cell.x = x
                        x += 1
                        yield cell

    def get_cells(
        self,
        coord: str | tuple | None = None,
        style: str | None = None,
        content: str | None = None,
        cell_type: str | None = None,
    ) -&gt; list[Cell]:
        &#34;&#34;&#34;Get the list of cells matching the criteria.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.

        Filter by coordinates will retrieve the amount of cells defined by
        &#39;coord&#39;, minus the other filters.

        Arguments:

            coord -- str or tuple of int : coordinates

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

        Return: list of Cell
        &#34;&#34;&#34;
        # fixme : not clones ?
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
        cells: list[Cell] = []
        for cell in self.traverse(start=x, end=z):
            # Filter the cells by cell_type
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    continue
            # Filter the cells with the regex
            if content and not cell.match(content):
                continue
            # Filter the cells with the style
            if style and style != cell.style:
                continue
            cells.append(cell)
        return cells

    def _get_cell2(self, x: int, clone: bool = True) -&gt; Cell | None:
        if x &gt;= self.width:
            return Cell()
        if clone:
            return self._get_cell2_base(x).clone  # type: ignore
        else:
            return self._get_cell2_base(x)

    def _get_cell2_base(self, x: int) -&gt; Cell | None:
        idx = find_odf_idx(self._rmap, x)
        cell: Cell
        if idx is not None:
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                self._indexes[&#34;_rmap&#34;][idx] = cell
            return cell
        return None

    def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:
        &#34;&#34;&#34;Get the cell at position &#34;x&#34; starting from 0. Alphabetical
        positions like &#34;D&#34; are accepted.

        A  copy is returned, use set_cell() to push it back.

        Arguments:

            x -- int or str

        Return: Cell | None
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        cell = self._get_cell2(x, clone=clone)
        if not cell:
            return None
        cell.y = self.y
        cell.x = x
        return cell

    def get_value(
        self,
        x: int | str,
        get_type: bool = False,
    ) -&gt; Any | tuple[Any, str]:
        &#34;&#34;&#34;Shortcut to get the value of the cell at position &#34;x&#34;.
        If get_type is True, returns the tuples (value, ODF type).

        If the cell is empty, returns None or (None, None)

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        if get_type:
            x = self._translate_x_from_any(x)
            cell = self._get_cell2_base(x)
            if cell is None:
                return (None, None)
            return cell.get_value(get_type=get_type)
        x = self._translate_x_from_any(x)
        cell = self._get_cell2_base(x)
        if cell is None:
            return None
        return cell.get_value()

    def set_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Push the cell back in the row at position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Arguments:

            x -- int or str

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
            repeated = 1
            clone = False
        else:
            repeated = cell.repeated or 1
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff == 0:
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        elif diff &gt; 0:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        else:
            # Inside the defined row
            set_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;, clone=clone)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        return cell_back

    def set_value(
        self,
        x: int | str,
        value: Any,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of the cell at position &#34;x&#34;.

        Arguments:

            x -- int or str

            value -- Python type

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        self.set_cell(
            x,
            Cell(value, style=style, cell_type=cell_type, currency=currency),
            clone=False,
        )

    def insert_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Insert the given cell at position &#34;x&#34; starting from 0. If no cell
        is given, an empty one is created.

        Alphabetical positions like &#34;D&#34; are accepted.

        Do not use when working on a table, use Table.insert_cell().

        Arguments:

            x -- int or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff &lt; 0:
            insert_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        elif diff == 0:
            cell_back = self.append_cell(cell, clone=clone)
        else:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, clone=clone)
        return cell_back

    def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:
        if cells is None:
            cells = []
        self.extend(cells)
        self._compute_row_cache()

    def append_cell(
        self,
        cell: Cell | None = None,
        clone: bool = True,
        _repeated: int | None = None,
    ) -&gt; Cell:
        &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
        accepted. If no cell is given, an empty one is created.

        Do not use when working on a table, use Table.append_cell().

        Arguments:

            cell -- Cell

            _repeated -- (optional), repeated value of the row

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        self._append(cell)
        if _repeated is None:
            _repeated = cell.repeated or 1
        self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)
        cell.x = self.width - 1
        cell.y = self.y
        return cell

    # fix for unit test and typos
    append = append_cell  # type: ignore

    def delete_cell(self, x: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the cell at the given position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Cells on the right will be shifted to the left. In a table, other
        rows remain unaffected.

        Arguments:

            x -- int or str
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if x &gt;= self.width:
            return
        delete_item_in_vault(x, self, _xpath_cell_idx, &#34;_rmap&#34;)

    def get_values(
        self,
        coord: str | tuple | None = None,
        cell_type: str | None = None,
        complete: bool = False,
        get_type: bool = False,
    ) -&gt; list[Any | tuple[Any, Any]]:
        &#34;&#34;&#34;Shortcut to get the cell values in this row.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type is used and complete is True, missing values are
        replaced by None.
        If cell_type is None, complete is always True : with no cell type
        queried, get_values() returns None for each empty cell, the length
        of the list is equal to the length of the row (depending on
        coordinates use).

        If get_type is True, returns a tuple (value, ODF type of value), or
        (None, None) for empty cells if complete is True.

        Filter by coordinates will retrieve the amount of cells defined by
        coordinates with None for empty cells, except when using cell_type.


        Arguments:

            coord -- str or tuple of int : coordinates in row

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of Python types, or list of tuples.
        &#34;&#34;&#34;
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
            values: list[Any | tuple[Any, Any]] = []
            for cell in self.traverse(start=x, end=z):
                # Filter the cells by cell_type
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        if get_type:
                            values.append((None, None))
                        else:
                            values.append(None)
                    continue
                values.append(cell.get_value(get_type=get_type))
            return values
        else:
            return [
                cell.get_value(get_type=get_type)
                for cell in self.traverse(start=x, end=z)
            ]

    def set_cells(
        self,
        cells: list[Cell] | tuple[Cell] | None = None,
        start: int | str = 0,
        clone: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cells in the row, from the &#39;start&#39; column.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            cells -- list of cells

            start -- int or str
        &#34;&#34;&#34;
        if cells is None:
            cells = []
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and clone is False and (len(cells) &gt;= self.width):
            self.clear()
            self.extend_cells(cells)
        else:
            x = start
            for cell in cells:
                self.set_cell(x, cell, clone=clone)
                if cell:
                    x += cell.repeated or 1
                else:
                    x += 1

    def set_values(
        self,
        values: list[Any],
        start: int | str = 0,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of cells in the row, from the &#39;start&#39;
        column vith values.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            values -- list of Python types

            start -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39; or &#39;percentage&#39;

            currency -- three-letter str

            style -- cell style
        &#34;&#34;&#34;
        # fixme : if values n, n+ are same, use repeat
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and (len(values) &gt;= self.width):
            self.clear()
            cells = [
                Cell(value, style=style, cell_type=cell_type, currency=currency)
                for value in values
            ]
            self.extend_cells(cells)
        else:
            x = start
            for value in values:
                self.set_cell(
                    x,
                    Cell(value, style=style, cell_type=cell_type, currency=currency),
                    clone=False,
                )
                x += 1

    def rstrip(self, aggressive: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove *in-place* empty cells at the right of the row. An empty
        cell has no value but can have style. If &#34;aggressive&#34; is True, style
        is ignored.

        Arguments:

            aggressive -- bool
        &#34;&#34;&#34;
        for cell in reversed(self._get_cells()):
            if not cell.is_empty(aggressive=aggressive):  # type: ignore
                break
            self.delete(cell)
        self._compute_row_cache()
        self._indexes[&#34;_rmap&#34;] = {}

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return whether every cell in the row has no value or the value
        evaluates to False (empty string), and no style.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            aggressive -- bool

        Return: bool
        &#34;&#34;&#34;
        return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore


register_element_class(Row)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="odfdo.row.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>width: int | None = None, repeated: int | None = None, style: str | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>ODF table row "table:table-row" </p>
<p>create a Row, optionally filled with "width" number of cells.</p>
<p>Rows contain cells, their number determine the number of columns.</p>
<p>You don't generally have to create rows by hand, use the Table API.</p>
<h2 id="arguments">Arguments</h2>
<p>width &ndash; int</p>
<p>repeated &ndash; int</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Row(Element):
    &#34;&#34;&#34;ODF table row &#34;table:table-row&#34; &#34;&#34;&#34;

    _tag = &#34;table:table-row&#34;
    _caching = True
    _append = Element.append

    def __init__(
        self,
        width: int | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;create a Row, optionally filled with &#34;width&#34; number of cells.

        Rows contain cells, their number determine the number of columns.

        You don&#39;t generally have to create rows by hand, use the Table API.

        Arguments:

            width -- int

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.y = None
        if not hasattr(self, &#34;_indexes&#34;):
            self._indexes = {}
            self._indexes[&#34;_rmap&#34;] = {}
        if not hasattr(self, &#34;_rmap&#34;):
            self._compute_row_cache()
            if not hasattr(self, &#34;_tmap&#34;):
                self._tmap = []
                self._cmap = []
        if self._do_init:
            if width is not None:
                for _i in range(width):
                    self.append(Cell())  # type:ignore
            if repeated:
                self.repeated = repeated
            if style is not None:
                self.style = style
            self._compute_row_cache()

    def _get_cells(self) -&gt; list[Element]:
        return self.get_elements(_xpath_cell)

    def _translate_row_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, int | None]:
        xyzt = convert_coordinates(coord)
        if len(xyzt) == 2:
            x, z = xyzt
        else:
            x, _, z, __ = xyzt
        if x and x &lt; 0:
            x = increment(x, self.width)
        if z and z &lt; 0:
            z = increment(z, self.width)
        return (x, z)

    def _compute_row_cache(self) -&gt; None:
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_cell, &#34;table:number-columns-repeated&#34;
        )
        self._rmap = make_cache_map(idx_repeated_seq)

    # Public API

    @property
    def clone(self) -&gt; Row:
        clone = Element.clone.fget(self)  # type: ignore
        clone.y = self.y
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the numnber of times the row is repeated, or
        None to delete it. Without changing cache.

        Arguments:

            repeated -- int
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-rows-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-rows-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get / set the number of times the row is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-rows-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        current: Element = self
        while True:
            # look for Table, parent may be group of rows
            upper = current.parent
            if not upper:
                # lonely row
                return
            # parent may be group of rows, not table
            if isinstance(upper, Element) and upper._tag == &#34;table:table&#34;:
                break
            current = upper
        # fixme : need to optimize this
        if isinstance(upper, Element) and upper._tag == &#34;table:table&#34;:
            upper._compute_table_cache()
            if hasattr(self, &#34;_tmap&#34;):
                del self._tmap[:]
                self._tmap.extend(upper._tmap)
            else:
                self._tmap = upper._tmap

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get /set the style of the row itself.

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute(&#34;table:style-name&#34;)  # type: ignore

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Get the number of expected cells in the row, i.e. addition
        repetitions.

        Return: int
        &#34;&#34;&#34;
        try:
            value = self._rmap[-1] + 1
        except Exception:
            value = 0
        return value

    def _translate_x_from_any(self, x: str | int) -&gt; int:
        return translate_from_any(x, self.width, 0)

    def traverse(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Cell]:
        &#34;&#34;&#34;Yield as many cell elements as expected cells in the row, i.e.
        expand repetitions by returning the same cell as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_cell() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        x = 0
        cell: Cell
        if start is None and end is None:
            for juska in self._rmap:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    if cell is None:
                        cell = Cell()
                    else:
                        cell = cell.clone
                        if repeated &gt; 1:
                            cell.repeated = None
                    cell.y = self.y
                    cell.x = x
                    x += 1
                    yield cell
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._rmap[-1]
                except Exception:
                    end = -1
            start_map = find_odf_idx(self._rmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._rmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            x = start
            for juska in self._rmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if x &lt;= end:
                        if cell is None:
                            cell = Cell()
                        else:
                            cell = cell.clone
                            if repeated &gt; 1 or (x == start and start &gt; 0):
                                cell.repeated = None
                        cell.y = self.y
                        cell.x = x
                        x += 1
                        yield cell

    def get_cells(
        self,
        coord: str | tuple | None = None,
        style: str | None = None,
        content: str | None = None,
        cell_type: str | None = None,
    ) -&gt; list[Cell]:
        &#34;&#34;&#34;Get the list of cells matching the criteria.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.

        Filter by coordinates will retrieve the amount of cells defined by
        &#39;coord&#39;, minus the other filters.

        Arguments:

            coord -- str or tuple of int : coordinates

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

        Return: list of Cell
        &#34;&#34;&#34;
        # fixme : not clones ?
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
        cells: list[Cell] = []
        for cell in self.traverse(start=x, end=z):
            # Filter the cells by cell_type
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    continue
            # Filter the cells with the regex
            if content and not cell.match(content):
                continue
            # Filter the cells with the style
            if style and style != cell.style:
                continue
            cells.append(cell)
        return cells

    def _get_cell2(self, x: int, clone: bool = True) -&gt; Cell | None:
        if x &gt;= self.width:
            return Cell()
        if clone:
            return self._get_cell2_base(x).clone  # type: ignore
        else:
            return self._get_cell2_base(x)

    def _get_cell2_base(self, x: int) -&gt; Cell | None:
        idx = find_odf_idx(self._rmap, x)
        cell: Cell
        if idx is not None:
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                self._indexes[&#34;_rmap&#34;][idx] = cell
            return cell
        return None

    def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:
        &#34;&#34;&#34;Get the cell at position &#34;x&#34; starting from 0. Alphabetical
        positions like &#34;D&#34; are accepted.

        A  copy is returned, use set_cell() to push it back.

        Arguments:

            x -- int or str

        Return: Cell | None
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        cell = self._get_cell2(x, clone=clone)
        if not cell:
            return None
        cell.y = self.y
        cell.x = x
        return cell

    def get_value(
        self,
        x: int | str,
        get_type: bool = False,
    ) -&gt; Any | tuple[Any, str]:
        &#34;&#34;&#34;Shortcut to get the value of the cell at position &#34;x&#34;.
        If get_type is True, returns the tuples (value, ODF type).

        If the cell is empty, returns None or (None, None)

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        if get_type:
            x = self._translate_x_from_any(x)
            cell = self._get_cell2_base(x)
            if cell is None:
                return (None, None)
            return cell.get_value(get_type=get_type)
        x = self._translate_x_from_any(x)
        cell = self._get_cell2_base(x)
        if cell is None:
            return None
        return cell.get_value()

    def set_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Push the cell back in the row at position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Arguments:

            x -- int or str

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
            repeated = 1
            clone = False
        else:
            repeated = cell.repeated or 1
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff == 0:
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        elif diff &gt; 0:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        else:
            # Inside the defined row
            set_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;, clone=clone)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        return cell_back

    def set_value(
        self,
        x: int | str,
        value: Any,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of the cell at position &#34;x&#34;.

        Arguments:

            x -- int or str

            value -- Python type

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        self.set_cell(
            x,
            Cell(value, style=style, cell_type=cell_type, currency=currency),
            clone=False,
        )

    def insert_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Insert the given cell at position &#34;x&#34; starting from 0. If no cell
        is given, an empty one is created.

        Alphabetical positions like &#34;D&#34; are accepted.

        Do not use when working on a table, use Table.insert_cell().

        Arguments:

            x -- int or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff &lt; 0:
            insert_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        elif diff == 0:
            cell_back = self.append_cell(cell, clone=clone)
        else:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, clone=clone)
        return cell_back

    def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:
        if cells is None:
            cells = []
        self.extend(cells)
        self._compute_row_cache()

    def append_cell(
        self,
        cell: Cell | None = None,
        clone: bool = True,
        _repeated: int | None = None,
    ) -&gt; Cell:
        &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
        accepted. If no cell is given, an empty one is created.

        Do not use when working on a table, use Table.append_cell().

        Arguments:

            cell -- Cell

            _repeated -- (optional), repeated value of the row

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        self._append(cell)
        if _repeated is None:
            _repeated = cell.repeated or 1
        self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)
        cell.x = self.width - 1
        cell.y = self.y
        return cell

    # fix for unit test and typos
    append = append_cell  # type: ignore

    def delete_cell(self, x: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the cell at the given position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Cells on the right will be shifted to the left. In a table, other
        rows remain unaffected.

        Arguments:

            x -- int or str
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if x &gt;= self.width:
            return
        delete_item_in_vault(x, self, _xpath_cell_idx, &#34;_rmap&#34;)

    def get_values(
        self,
        coord: str | tuple | None = None,
        cell_type: str | None = None,
        complete: bool = False,
        get_type: bool = False,
    ) -&gt; list[Any | tuple[Any, Any]]:
        &#34;&#34;&#34;Shortcut to get the cell values in this row.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type is used and complete is True, missing values are
        replaced by None.
        If cell_type is None, complete is always True : with no cell type
        queried, get_values() returns None for each empty cell, the length
        of the list is equal to the length of the row (depending on
        coordinates use).

        If get_type is True, returns a tuple (value, ODF type of value), or
        (None, None) for empty cells if complete is True.

        Filter by coordinates will retrieve the amount of cells defined by
        coordinates with None for empty cells, except when using cell_type.


        Arguments:

            coord -- str or tuple of int : coordinates in row

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of Python types, or list of tuples.
        &#34;&#34;&#34;
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
            values: list[Any | tuple[Any, Any]] = []
            for cell in self.traverse(start=x, end=z):
                # Filter the cells by cell_type
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        if get_type:
                            values.append((None, None))
                        else:
                            values.append(None)
                    continue
                values.append(cell.get_value(get_type=get_type))
            return values
        else:
            return [
                cell.get_value(get_type=get_type)
                for cell in self.traverse(start=x, end=z)
            ]

    def set_cells(
        self,
        cells: list[Cell] | tuple[Cell] | None = None,
        start: int | str = 0,
        clone: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cells in the row, from the &#39;start&#39; column.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            cells -- list of cells

            start -- int or str
        &#34;&#34;&#34;
        if cells is None:
            cells = []
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and clone is False and (len(cells) &gt;= self.width):
            self.clear()
            self.extend_cells(cells)
        else:
            x = start
            for cell in cells:
                self.set_cell(x, cell, clone=clone)
                if cell:
                    x += cell.repeated or 1
                else:
                    x += 1

    def set_values(
        self,
        values: list[Any],
        start: int | str = 0,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of cells in the row, from the &#39;start&#39;
        column vith values.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            values -- list of Python types

            start -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39; or &#39;percentage&#39;

            currency -- three-letter str

            style -- cell style
        &#34;&#34;&#34;
        # fixme : if values n, n+ are same, use repeat
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and (len(values) &gt;= self.width):
            self.clear()
            cells = [
                Cell(value, style=style, cell_type=cell_type, currency=currency)
                for value in values
            ]
            self.extend_cells(cells)
        else:
            x = start
            for value in values:
                self.set_cell(
                    x,
                    Cell(value, style=style, cell_type=cell_type, currency=currency),
                    clone=False,
                )
                x += 1

    def rstrip(self, aggressive: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove *in-place* empty cells at the right of the row. An empty
        cell has no value but can have style. If &#34;aggressive&#34; is True, style
        is ignored.

        Arguments:

            aggressive -- bool
        &#34;&#34;&#34;
        for cell in reversed(self._get_cells()):
            if not cell.is_empty(aggressive=aggressive):  # type: ignore
                break
            self.delete(cell)
        self._compute_row_cache()
        self._indexes[&#34;_rmap&#34;] = {}

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return whether every cell in the row has no value or the value
        evaluates to False (empty string), and no style.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            aggressive -- bool

        Return: bool
        &#34;&#34;&#34;
        return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
<li><a title="odfdo.utils.cached_element.CachedElement" href="utils/cached_element.html#odfdo.utils.cached_element.CachedElement">CachedElement</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.row.Row.clone"><code class="name">var <span class="ident">clone</span> : <a title="odfdo.row.Row" href="#odfdo.row.Row">Row</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clone(self) -&gt; Row:
    clone = Element.clone.fget(self)  # type: ignore
    clone.y = self.y
    if hasattr(self, &#34;_tmap&#34;):
        if hasattr(self, &#34;_rmap&#34;):
            clone._rmap = self._rmap[:]
        clone._tmap = self._tmap[:]
        clone._cmap = self._cmap[:]
    return clone</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.repeated"><code class="name">var <span class="ident">repeated</span> : int | None</code></dt>
<dd>
<div class="desc"><p>Get / set the number of times the row is repeated.</p>
<p>Always None when using the table API.</p>
<p>Return: int or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def repeated(self) -&gt; int | None:
    &#34;&#34;&#34;Get / set the number of times the row is repeated.

    Always None when using the table API.

    Return: int or None
    &#34;&#34;&#34;
    repeated = self.get_attribute(&#34;table:number-rows-repeated&#34;)
    if repeated is None:
        return None
    return int(repeated)</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.style"><code class="name">var <span class="ident">style</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get /set the style of the row itself.</p>
<p>Return: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def style(self) -&gt; str | None:
    &#34;&#34;&#34;Get /set the style of the row itself.

    Return: str
    &#34;&#34;&#34;
    return self.get_attribute(&#34;table:style-name&#34;)  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the number of expected cells in the row, i.e. addition
repetitions.</p>
<p>Return: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;Get the number of expected cells in the row, i.e. addition
    repetitions.

    Return: int
    &#34;&#34;&#34;
    try:
        value = self._rmap[-1] + 1
    except Exception:
        value = 0
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.row.Row.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cell: Cell | None = None, clone: bool = True) ‑> <a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the given cell at the end of the row. Repeated cells are
accepted. If no cell is given, an empty one is created.</p>
<p>Do not use when working on a table, use Table.append_cell().</p>
<h2 id="arguments">Arguments</h2>
<p>cell &ndash; Cell</p>
<p>_repeated &ndash; (optional), repeated value of the row</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_cell(
    self,
    cell: Cell | None = None,
    clone: bool = True,
    _repeated: int | None = None,
) -&gt; Cell:
    &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
    accepted. If no cell is given, an empty one is created.

    Do not use when working on a table, use Table.append_cell().

    Arguments:

        cell -- Cell

        _repeated -- (optional), repeated value of the row

    returns the cell with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    if clone:
        cell = cell.clone
    self._append(cell)
    if _repeated is None:
        _repeated = cell.repeated or 1
    self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)
    cell.x = self.width - 1
    cell.y = self.y
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.append_cell"><code class="name flex">
<span>def <span class="ident">append_cell</span></span>(<span>self, cell: Cell | None = None, clone: bool = True) ‑> <a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the given cell at the end of the row. Repeated cells are
accepted. If no cell is given, an empty one is created.</p>
<p>Do not use when working on a table, use Table.append_cell().</p>
<h2 id="arguments">Arguments</h2>
<p>cell &ndash; Cell</p>
<p>_repeated &ndash; (optional), repeated value of the row</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_cell(
    self,
    cell: Cell | None = None,
    clone: bool = True,
    _repeated: int | None = None,
) -&gt; Cell:
    &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
    accepted. If no cell is given, an empty one is created.

    Do not use when working on a table, use Table.append_cell().

    Arguments:

        cell -- Cell

        _repeated -- (optional), repeated value of the row

    returns the cell with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    if clone:
        cell = cell.clone
    self._append(cell)
    if _repeated is None:
        _repeated = cell.repeated or 1
    self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)
    cell.x = self.width - 1
    cell.y = self.y
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.delete_cell"><code class="name flex">
<span>def <span class="ident">delete_cell</span></span>(<span>self, x: int | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the cell at the given position "x" starting from 0.
Alphabetical positions like "D" are accepted.</p>
<p>Cells on the right will be shifted to the left. In a table, other
rows remain unaffected.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_cell(self, x: int | str) -&gt; None:
    &#34;&#34;&#34;Delete the cell at the given position &#34;x&#34; starting from 0.
    Alphabetical positions like &#34;D&#34; are accepted.

    Cells on the right will be shifted to the left. In a table, other
    rows remain unaffected.

    Arguments:

        x -- int or str
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    if x &gt;= self.width:
        return
    delete_item_in_vault(x, self, _xpath_cell_idx, &#34;_rmap&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.extend_cells"><code class="name flex">
<span>def <span class="ident">extend_cells</span></span>(<span>self, cells: Iterable[Cell] | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:
    if cells is None:
        cells = []
    self.extend(cells)
    self._compute_row_cache()</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.get_cell"><code class="name flex">
<span>def <span class="ident">get_cell</span></span>(<span>self, x: int, clone: bool = True) ‑> <a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a> | None</span>
</code></dt>
<dd>
<div class="desc"><p>Get the cell at position "x" starting from 0. Alphabetical
positions like "D" are accepted.</p>
<p>A
copy is returned, use set_cell() to push it back.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>Return: Cell | None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:
    &#34;&#34;&#34;Get the cell at position &#34;x&#34; starting from 0. Alphabetical
    positions like &#34;D&#34; are accepted.

    A  copy is returned, use set_cell() to push it back.

    Arguments:

        x -- int or str

    Return: Cell | None
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    cell = self._get_cell2(x, clone=clone)
    if not cell:
        return None
    cell.y = self.y
    cell.x = x
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.get_cells"><code class="name flex">
<span>def <span class="ident">get_cells</span></span>(<span>self, coord: str | tuple | None = None, style: str | None = None, content: str | None = None, cell_type: str | None = None) ‑> list[<a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of cells matching the criteria.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.</p>
<p>Filter by coordinates will retrieve the amount of cells defined by
'coord', minus the other filters.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>content &ndash; str regex</p>
<p>style &ndash; str</p>
<p>Return: list of Cell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells(
    self,
    coord: str | tuple | None = None,
    style: str | None = None,
    content: str | None = None,
    cell_type: str | None = None,
) -&gt; list[Cell]:
    &#34;&#34;&#34;Get the list of cells matching the criteria.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.

    Filter by coordinates will retrieve the amount of cells defined by
    &#39;coord&#39;, minus the other filters.

    Arguments:

        coord -- str or tuple of int : coordinates

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        content -- str regex

        style -- str

    Return: list of Cell
    &#34;&#34;&#34;
    # fixme : not clones ?
    if coord:
        x, z = self._translate_row_coordinates(coord)
    else:
        x = None
        z = None
    if cell_type:
        cell_type = cell_type.lower().strip()
    cells: list[Cell] = []
    for cell in self.traverse(start=x, end=z):
        # Filter the cells by cell_type
        if cell_type:
            ctype = cell.type
            if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                continue
        # Filter the cells with the regex
        if content and not cell.match(content):
            continue
        # Filter the cells with the style
        if style and style != cell.style:
            continue
        cells.append(cell)
    return cells</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, x: int | str, get_type: bool = False) ‑> typing.Any | tuple[typing.Any, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the value of the cell at position "x".
If get_type is True, returns the tuples (value, ODF type).</p>
<p>If the cell is empty, returns None or (None, None)</p>
<p>See get_cell() and Cell.get_value().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(
    self,
    x: int | str,
    get_type: bool = False,
) -&gt; Any | tuple[Any, str]:
    &#34;&#34;&#34;Shortcut to get the value of the cell at position &#34;x&#34;.
    If get_type is True, returns the tuples (value, ODF type).

    If the cell is empty, returns None or (None, None)

    See get_cell() and Cell.get_value().
    &#34;&#34;&#34;
    if get_type:
        x = self._translate_x_from_any(x)
        cell = self._get_cell2_base(x)
        if cell is None:
            return (None, None)
        return cell.get_value(get_type=get_type)
    x = self._translate_x_from_any(x)
    cell = self._get_cell2_base(x)
    if cell is None:
        return None
    return cell.get_value()</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self, coord: str | tuple | None = None, cell_type: str | None = None, complete: bool = False, get_type: bool = False) ‑> list[typing.Any | tuple[typing.Any, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the cell values in this row.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.
If cell_type is used and complete is True, missing values are
replaced by None.
If cell_type is None, complete is always True : with no cell type
queried, get_values() returns None for each empty cell, the length
of the list is equal to the length of the row (depending on
coordinates use).</p>
<p>If get_type is True, returns a tuple (value, ODF type of value), or
(None, None) for empty cells if complete is True.</p>
<p>Filter by coordinates will retrieve the amount of cells defined by
coordinates with None for empty cells, except when using cell_type.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates in row</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>complete &ndash; boolean</p>
<p>get_type &ndash; boolean</p>
<p>Return: list of Python types, or list of tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(
    self,
    coord: str | tuple | None = None,
    cell_type: str | None = None,
    complete: bool = False,
    get_type: bool = False,
) -&gt; list[Any | tuple[Any, Any]]:
    &#34;&#34;&#34;Shortcut to get the cell values in this row.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.
    If cell_type is used and complete is True, missing values are
    replaced by None.
    If cell_type is None, complete is always True : with no cell type
    queried, get_values() returns None for each empty cell, the length
    of the list is equal to the length of the row (depending on
    coordinates use).

    If get_type is True, returns a tuple (value, ODF type of value), or
    (None, None) for empty cells if complete is True.

    Filter by coordinates will retrieve the amount of cells defined by
    coordinates with None for empty cells, except when using cell_type.


    Arguments:

        coord -- str or tuple of int : coordinates in row

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        complete -- boolean

        get_type -- boolean

    Return: list of Python types, or list of tuples.
    &#34;&#34;&#34;
    if coord:
        x, z = self._translate_row_coordinates(coord)
    else:
        x = None
        z = None
    if cell_type:
        cell_type = cell_type.lower().strip()
        values: list[Any | tuple[Any, Any]] = []
        for cell in self.traverse(start=x, end=z):
            # Filter the cells by cell_type
            ctype = cell.type
            if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                if complete:
                    if get_type:
                        values.append((None, None))
                    else:
                        values.append(None)
                continue
            values.append(cell.get_value(get_type=get_type))
        return values
    else:
        return [
            cell.get_value(get_type=get_type)
            for cell in self.traverse(start=x, end=z)
        ]</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.insert_cell"><code class="name flex">
<span>def <span class="ident">insert_cell</span></span>(<span>self, x: int | str, cell: Cell | None = None, clone: bool = True) ‑> <a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert the given cell at position "x" starting from 0. If no cell
is given, an empty one is created.</p>
<p>Alphabetical positions like "D" are accepted.</p>
<p>Do not use when working on a table, use Table.insert_cell().</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>cell &ndash; Cell</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_cell(
    self,
    x: int | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Insert the given cell at position &#34;x&#34; starting from 0. If no cell
    is given, an empty one is created.

    Alphabetical positions like &#34;D&#34; are accepted.

    Do not use when working on a table, use Table.insert_cell().

    Arguments:

        x -- int or str

        cell -- Cell

    returns the cell with x and y updated
    &#34;&#34;&#34;
    cell_back: Cell
    if cell is None:
        cell = Cell()
    x = self._translate_x_from_any(x)
    # Outside the defined row
    diff = x - self.width
    if diff &lt; 0:
        insert_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;)
        cell.x = x
        cell.y = self.y
        cell_back = cell
    elif diff == 0:
        cell_back = self.append_cell(cell, clone=clone)
    else:
        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
        cell_back = self.append_cell(cell, clone=clone)
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self, aggressive: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether every cell in the row has no value or the value
evaluates to False (empty string), and no style.</p>
<p>If aggressive is True, empty cells with style are considered empty.</p>
<h2 id="arguments">Arguments</h2>
<p>aggressive &ndash; bool</p>
<p>Return: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self, aggressive: bool = False) -&gt; bool:
    &#34;&#34;&#34;Return whether every cell in the row has no value or the value
    evaluates to False (empty string), and no style.

    If aggressive is True, empty cells with style are considered empty.

    Arguments:

        aggressive -- bool

    Return: bool
    &#34;&#34;&#34;
    return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.rstrip"><code class="name flex">
<span>def <span class="ident">rstrip</span></span>(<span>self, aggressive: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove <em>in-place</em> empty cells at the right of the row. An empty
cell has no value but can have style. If "aggressive" is True, style
is ignored.</p>
<h2 id="arguments">Arguments</h2>
<p>aggressive &ndash; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rstrip(self, aggressive: bool = False) -&gt; None:
    &#34;&#34;&#34;Remove *in-place* empty cells at the right of the row. An empty
    cell has no value but can have style. If &#34;aggressive&#34; is True, style
    is ignored.

    Arguments:

        aggressive -- bool
    &#34;&#34;&#34;
    for cell in reversed(self._get_cells()):
        if not cell.is_empty(aggressive=aggressive):  # type: ignore
            break
        self.delete(cell)
    self._compute_row_cache()
    self._indexes[&#34;_rmap&#34;] = {}</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.set_cell"><code class="name flex">
<span>def <span class="ident">set_cell</span></span>(<span>self, x: int | str, cell: Cell | None = None, clone: bool = True) ‑> <a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Push the cell back in the row at position "x" starting from 0.
Alphabetical positions like "D" are accepted.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell(
    self,
    x: int | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Push the cell back in the row at position &#34;x&#34; starting from 0.
    Alphabetical positions like &#34;D&#34; are accepted.

    Arguments:

        x -- int or str

    returns the cell with x and y updated
    &#34;&#34;&#34;
    cell_back: Cell
    if cell is None:
        cell = Cell()
        repeated = 1
        clone = False
    else:
        repeated = cell.repeated or 1
    x = self._translate_x_from_any(x)
    # Outside the defined row
    diff = x - self.width
    if diff == 0:
        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
    elif diff &gt; 0:
        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
    else:
        # Inside the defined row
        set_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;, clone=clone)
        cell.x = x
        cell.y = self.y
        cell_back = cell
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.set_cells"><code class="name flex">
<span>def <span class="ident">set_cells</span></span>(<span>self, cells: list[Cell] | tuple[Cell] | None = None, start: int | str = 0, clone: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the cells in the row, from the 'start' column.
This method does not clear the row, use row.clear() before to start
with an empty row.</p>
<h2 id="arguments">Arguments</h2>
<p>cells &ndash; list of cells</p>
<p>start &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cells(
    self,
    cells: list[Cell] | tuple[Cell] | None = None,
    start: int | str = 0,
    clone: bool = True,
) -&gt; None:
    &#34;&#34;&#34;Set the cells in the row, from the &#39;start&#39; column.
    This method does not clear the row, use row.clear() before to start
    with an empty row.

    Arguments:

        cells -- list of cells

        start -- int or str
    &#34;&#34;&#34;
    if cells is None:
        cells = []
    if start is None:
        start = 0
    else:
        start = self._translate_x_from_any(start)
    if start == 0 and clone is False and (len(cells) &gt;= self.width):
        self.clear()
        self.extend_cells(cells)
    else:
        x = start
        for cell in cells:
            self.set_cell(x, cell, clone=clone)
            if cell:
                x += cell.repeated or 1
            else:
                x += 1</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, x: int | str, value: Any, style: str | None = None, cell_type: str | None = None, currency: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the value of the cell at position "x".</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>value &ndash; Python type</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; str</p>
<p>See get_cell() and Cell.get_value().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(
    self,
    x: int | str,
    value: Any,
    style: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the value of the cell at position &#34;x&#34;.

    Arguments:

        x -- int or str

        value -- Python type

        cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                 &#39;string&#39; or &#39;time&#39;

        currency -- three-letter str

        style -- str

    See get_cell() and Cell.get_value().
    &#34;&#34;&#34;
    self.set_cell(
        x,
        Cell(value, style=style, cell_type=cell_type, currency=currency),
        clone=False,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.set_values"><code class="name flex">
<span>def <span class="ident">set_values</span></span>(<span>self, values: list[Any], start: int | str = 0, style: str | None = None, cell_type: str | None = None, currency: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the value of cells in the row, from the 'start'
column vith values.
This method does not clear the row, use row.clear() before to start
with an empty row.</p>
<h2 id="arguments">Arguments</h2>
<p>values &ndash; list of Python types</p>
<p>start &ndash; int or str</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency' or 'percentage'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; cell style</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values(
    self,
    values: list[Any],
    start: int | str = 0,
    style: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the value of cells in the row, from the &#39;start&#39;
    column vith values.
    This method does not clear the row, use row.clear() before to start
    with an empty row.

    Arguments:

        values -- list of Python types

        start -- int or str

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39; or &#39;percentage&#39;

        currency -- three-letter str

        style -- cell style
    &#34;&#34;&#34;
    # fixme : if values n, n+ are same, use repeat
    if start is None:
        start = 0
    else:
        start = self._translate_x_from_any(start)
    if start == 0 and (len(values) &gt;= self.width):
        self.clear()
        cells = [
            Cell(value, style=style, cell_type=cell_type, currency=currency)
            for value in values
        ]
        self.extend_cells(cells)
    else:
        x = start
        for value in values:
            self.set_cell(
                x,
                Cell(value, style=style, cell_type=cell_type, currency=currency),
                clone=False,
            )
            x += 1</code></pre>
</details>
</dd>
<dt id="odfdo.row.Row.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, start: int | None = None, end: int | None = None) ‑> collections.abc.Iterator[<a title="odfdo.cell.Cell" href="cell.html#odfdo.cell.Cell">Cell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Yield as many cell elements as expected cells in the row, i.e.
expand repetitions by returning the same cell as many times as
necessary.</p>
<pre><code>Arguments:

    start -- int

    end -- int
</code></pre>
<p>Copies are returned, use set_cell() to push them back.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse(  # noqa: C901
    self,
    start: int | None = None,
    end: int | None = None,
) -&gt; Iterator[Cell]:
    &#34;&#34;&#34;Yield as many cell elements as expected cells in the row, i.e.
    expand repetitions by returning the same cell as many times as
    necessary.

        Arguments:

            start -- int

            end -- int

    Copies are returned, use set_cell() to push them back.
    &#34;&#34;&#34;
    idx = -1
    before = -1
    x = 0
    cell: Cell
    if start is None and end is None:
        for juska in self._rmap:
            idx += 1
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                if not isinstance(cell, Cell):
                    raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                self._indexes[&#34;_rmap&#34;][idx] = cell
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                # Return a copy without the now obsolete repetition
                if cell is None:
                    cell = Cell()
                else:
                    cell = cell.clone
                    if repeated &gt; 1:
                        cell.repeated = None
                cell.y = self.y
                cell.x = x
                x += 1
                yield cell
    else:
        if start is None:
            start = 0
        start = max(0, start)
        if end is None:
            try:
                end = self._rmap[-1]
            except Exception:
                end = -1
        start_map = find_odf_idx(self._rmap, start)
        if start_map is None:
            return
        if start_map &gt; 0:
            before = self._rmap[start_map - 1]
        idx = start_map - 1
        before = start - 1
        x = start
        for juska in self._rmap[start_map:]:
            idx += 1
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                if not isinstance(cell, Cell):
                    raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                self._indexes[&#34;_rmap&#34;][idx] = cell
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                if x &lt;= end:
                    if cell is None:
                        cell = Cell()
                    else:
                        cell = cell.clone
                        if repeated &gt; 1 or (x == start and start &gt; 0):
                            cell.repeated = None
                    cell.y = self.y
                    cell.x = x
                    x += 1
                    yield cell</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.serialize" href="element.html#odfdo.element.Element.serialize">serialize</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="odfdo" href="index.html">odfdo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="odfdo.row.Row" href="#odfdo.row.Row">Row</a></code></h4>
<ul class="two-column">
<li><code><a title="odfdo.row.Row.append" href="#odfdo.row.Row.append">append</a></code></li>
<li><code><a title="odfdo.row.Row.append_cell" href="#odfdo.row.Row.append_cell">append_cell</a></code></li>
<li><code><a title="odfdo.row.Row.clone" href="#odfdo.row.Row.clone">clone</a></code></li>
<li><code><a title="odfdo.row.Row.delete_cell" href="#odfdo.row.Row.delete_cell">delete_cell</a></code></li>
<li><code><a title="odfdo.row.Row.extend_cells" href="#odfdo.row.Row.extend_cells">extend_cells</a></code></li>
<li><code><a title="odfdo.row.Row.get_cell" href="#odfdo.row.Row.get_cell">get_cell</a></code></li>
<li><code><a title="odfdo.row.Row.get_cells" href="#odfdo.row.Row.get_cells">get_cells</a></code></li>
<li><code><a title="odfdo.row.Row.get_value" href="#odfdo.row.Row.get_value">get_value</a></code></li>
<li><code><a title="odfdo.row.Row.get_values" href="#odfdo.row.Row.get_values">get_values</a></code></li>
<li><code><a title="odfdo.row.Row.insert_cell" href="#odfdo.row.Row.insert_cell">insert_cell</a></code></li>
<li><code><a title="odfdo.row.Row.is_empty" href="#odfdo.row.Row.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.row.Row.repeated" href="#odfdo.row.Row.repeated">repeated</a></code></li>
<li><code><a title="odfdo.row.Row.rstrip" href="#odfdo.row.Row.rstrip">rstrip</a></code></li>
<li><code><a title="odfdo.row.Row.set_cell" href="#odfdo.row.Row.set_cell">set_cell</a></code></li>
<li><code><a title="odfdo.row.Row.set_cells" href="#odfdo.row.Row.set_cells">set_cells</a></code></li>
<li><code><a title="odfdo.row.Row.set_value" href="#odfdo.row.Row.set_value">set_value</a></code></li>
<li><code><a title="odfdo.row.Row.set_values" href="#odfdo.row.Row.set_values">set_values</a></code></li>
<li><code><a title="odfdo.row.Row.style" href="#odfdo.row.Row.style">style</a></code></li>
<li><code><a title="odfdo.row.Row.traverse" href="#odfdo.row.Row.traverse">traverse</a></code></li>
<li><code><a title="odfdo.row.Row.width" href="#odfdo.row.Row.width">width</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>