<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>odfdo.document API documentation</title>
<meta name="description" content="Document class, root of the ODF document." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>odfdo.document</code></h1>
</header>
<section id="section-intro">
<p>Document class, root of the ODF document.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2018-2024 Jérôme Dumonteil
# Copyright (c) 2009-2013 Ars Aperta, Itaapy, Pierlis, Talend.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Authors (odfdo project): jerome.dumonteil@gmail.com
# The odfdo project is a derivative work of the lpod-python project:
# https://github.com/lpod/lpod-python
# Authors: David Versmisse &lt;david.versmisse@itaapy.com&gt;
#          Hervé Cauwelier &lt;herve@itaapy.com&gt;
#          Romain Gauthier &lt;romain@itaapy.com&gt;
#          Jerome Dumonteil &lt;jerome.dumonteil@itaapy.com&gt;
&#34;&#34;&#34;Document class, root of the ODF document.
&#34;&#34;&#34;
from __future__ import annotations

import io
import posixpath
from contextlib import suppress
from copy import deepcopy
from importlib import resources as rso
from mimetypes import guess_type
from operator import itemgetter
from pathlib import Path
from typing import Any
from uuid import uuid4

from .const import (
    ODF_CONTENT,
    ODF_MANIFEST,
    ODF_META,
    ODF_SETTINGS,
    ODF_STYLES,
    ODF_TEMPLATES,
)
from .container import Container
from .content import Content
from .element import Element
from .manifest import Manifest
from .meta import Meta
from .style import Style
from .styles import Styles
from .utils import FAMILY_ODF_STD, bytes_to_str
from .xmlpart import XmlPart

AUTOMATIC_PREFIX = &#34;odfdo_auto_&#34;

UNDERLINE_LVL = [&#34;=&#34;, &#34;-&#34;, &#34;:&#34;, &#34;`&#34;, &#34;&#39;&#34;, &#39;&#34;&#39;, &#34;~&#34;, &#34;^&#34;, &#34;_&#34;, &#34;*&#34;, &#34;+&#34;]


def _underline_string(level: int, name: str) -&gt; str:
    &#34;&#34;&#34;Underline string of the name.&#34;&#34;&#34;
    if level &gt;= len(UNDERLINE_LVL):
        return &#34;\n&#34;
    return UNDERLINE_LVL[level] * len(name)


def _show_styles(element: Element, level: int = 0) -&gt; str | None:
    output: list[str] = []
    attributes = element.attributes
    children = element.children
    # Don&#39;t show the empty elements
    if not attributes and not children:
        return None
    tag_name = element.tag
    output.append(tag_name)
    # Underline the name
    output.append(_underline_string(level, tag_name))
    # Add a separation between name and attributes
    output[-1] += &#34;\n&#34;

    # Attributes
    attrs: list[str] = []
    for key, value in attributes.items():
        attrs.append(f&#34;{key}: {value}&#34;)
    if attrs:
        attrs.sort()
        # Add a separation between attributes and children
        attrs[-1] += &#34;\n&#34;
        output.extend(attrs)

    # Children
    # Sort children according to their names
    children2 = [(child.tag, child) for child in children]
    children2.sort()
    children = [child for name, child in children2]
    for child in children:
        child_output = _show_styles(child, level + 1)
        if child_output:
            output.append(child_output)
    return &#34;\n&#34;.join(output)


def _get_part_path(path: str) -&gt; str:
    &#34;&#34;&#34;Transition to real path of XML parts&#34;&#34;&#34;
    return {
        &#34;content&#34;: ODF_CONTENT,
        &#34;meta&#34;: ODF_META,
        &#34;settings&#34;: ODF_SETTINGS,
        &#34;styles&#34;: ODF_STYLES,
        &#34;manifest&#34;: ODF_MANIFEST,
    }.get(path, path)


def _get_part_class(
    path: str,
) -&gt; type[XmlPart] | None:
    return {
        ODF_CONTENT: Content,
        ODF_META: Meta,
        ODF_SETTINGS: XmlPart,
        ODF_STYLES: Styles,
        ODF_MANIFEST: Manifest,
    }.get(path)


def container_from_template(template: str | Path | io.BytesIO) -&gt; Container:
    &#34;&#34;&#34;Return a Container instance based on template argument.

    Internal use only.&#34;&#34;&#34;
    template_container = Container()
    if isinstance(template, str) and template in ODF_TEMPLATES:
        template = ODF_TEMPLATES[template]
        with rso.as_file(
            rso.files(&#34;odfdo.templates&#34;).joinpath(template)
        ) as template_path:
            template_container.open(template_path)
    else:
        # custome template
        template_container.open(template)
    # Return a copy of the template container
    container = template_container.clone
    # Change type from template to regular
    mimetype = container.mimetype.replace(&#34;-template&#34;, &#34;&#34;)
    container.mimetype = mimetype
    # Update the manifest
    manifest = Manifest(ODF_MANIFEST, container)
    manifest.set_media_type(&#34;/&#34;, mimetype)
    container.set_part(ODF_MANIFEST, manifest.serialize())
    return container


class Document:
    &#34;&#34;&#34;Abstraction of the ODF document.

    To create a new Document, several possibilities:

        - Document() or Document(&#34;text&#34;) -&gt; an &#34;empty&#34; document of type text
        - Document(&#34;spreadsheet&#34;) -&gt; an &#34;empty&#34; document of type spreadsheet
        - Document(&#34;presentation&#34;) -&gt; an &#34;empty&#34; document of type presentation
        - Document(&#34;drawing&#34;) -&gt; an &#34;empty&#34; document of type drawing

        Meaning of “empty”: these documents are copies of the default
        templates documents provided with this library, which, as templates,
        are not really empty. It may be useful to clear the newly created
        document: document.body.clear(), or adjust meta informations like
        description or default language: document.meta.set_language(&#39;fr-FR&#39;)

    If the argument is not a known template type, or is a Path,
    Document(file) will load the content of the ODF file.

    To explicitly create a document from a custom template, use the
    Document.new(path) method whose argument is the path to the template file.
    &#34;&#34;&#34;

    def __init__(
        self,
        target: str | bytes | Path | Container | io.BytesIO | None = &#34;text&#34;,
    ) -&gt; None:
        # Cache of XML parts
        self.__xmlparts: dict[str, XmlPart] = {}
        # Cache of the body
        self.__body: Element | None = None
        self.container: Container | None = None
        if isinstance(target, bytes):
            # eager conversion
            target = bytes_to_str(target)
        if target is None:
            # empty document, you probably don&#39;t wnat this.
            self.container = Container()
            return
        if isinstance(target, Path):
            # let&#39;s assume we open a container on existing file
            self.container = Container(target)
            return
        if isinstance(target, Container):
            # special internal case, use an existing container
            self.container = target
            return
        if isinstance(target, str):
            if target in ODF_TEMPLATES:
                # assuming a new document from templates
                self.container = container_from_template(target)
                return
            # let&#39;s assume we open a container on existing file
            self.container = Container(target)
            return
        if isinstance(target, io.BytesIO):
            self.container = Container(target)
            return
        raise TypeError(f&#34;Unknown Document source type: &#39;{target!r}&#39;&#34;)

    def __repr__(self) -&gt; str:
        return f&#34;&lt;{self.__class__.__name__} type={self.get_type()} path={self.path}&gt;&#34;

    def __str__(self) -&gt; str:
        try:
            return str(self.get_formatted_text())
        except NotImplementedError:
            return self.body.text_recursive

    @classmethod
    def new(cls, template: str | Path | io.BytesIO = &#34;text&#34;) -&gt; Document:
        &#34;&#34;&#34;Create a Document from a template.

        The template argument is expected to be the path to a ODF template.

        Arguments:

            template -- str or Path or file-like (io.BytesIO)

        Return : ODF document -- Document
        &#34;&#34;&#34;
        container = container_from_template(template)
        return cls(container)

    # Public API

    @property
    def path(self) -&gt; Path | None:
        &#34;&#34;&#34;Shortcut to Document.Container.path.&#34;&#34;&#34;
        if not self.container:
            return None
        return self.container.path

    @path.setter
    def path(self, path_or_str: str | Path) -&gt; None:
        &#34;&#34;&#34;Shortcut to Document.Container.path

        Only accepting str or Path.&#34;&#34;&#34;
        if not self.container:
            return
        self.container.path = Path(path_or_str)

    def get_parts(self) -&gt; list[str]:
        &#34;&#34;&#34;Return available part names with path inside the archive, e.g.
        [&#39;content.xml&#39;, ..., &#39;Pictures/100000000000032000000258912EB1C3.jpg&#39;]
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        return self.container.get_parts()

    def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:
        &#34;&#34;&#34;Return the bytes of the given part. The path is relative to the
        archive, e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;.

        &#39;content&#39;, &#39;meta&#39;, &#39;settings&#39;, &#39;styles&#39; and &#39;manifest&#39; are shortcuts
        to the real path, e.g. content.xml, and return a dedicated object with
        its own API.

        path formated as URI, so always use &#39;/&#39; separator
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        # &#34;./ObjectReplacements/Object 1&#34;
        path = path.lstrip(&#34;./&#34;)
        path = _get_part_path(path)
        cls = _get_part_class(path)
        # Raw bytes
        if cls is None:
            return self.container.get_part(path)
        # XML part
        part = self.__xmlparts.get(path)
        if part is None:
            self.__xmlparts[path] = part = cls(path, self.container)
        return part

    def set_part(self, path: str, data: bytes) -&gt; None:
        &#34;&#34;&#34;Set the bytes of the given part. The path is relative to the
        archive, e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;.

        path formated as URI, so always use &#39;/&#39; separator
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        # &#34;./ObjectReplacements/Object 1&#34;
        path = path.lstrip(&#34;./&#34;)
        path = _get_part_path(path)
        cls = _get_part_class(path)
        # XML part overwritten
        if cls is not None:
            with suppress(KeyError):
                self.__xmlparts[path]
        self.container.set_part(path, data)

    def del_part(self, path: str) -&gt; None:
        &#34;&#34;&#34;Mark a part for deletion. The path is relative to the archive,
        e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        path = _get_part_path(path)
        cls = _get_part_class(path)
        if path == ODF_MANIFEST or cls is not None:
            raise ValueError(f&#34;part &#39;{path}&#39; is mandatory&#34;)
        self.container.del_part(path)

    @property
    def mimetype(self) -&gt; str:
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        return self.container.mimetype

    @mimetype.setter
    def mimetype(self, mimetype: str) -&gt; None:
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        self.container.mimetype = mimetype

    def get_type(self) -&gt; str:
        &#34;&#34;&#34;Get the ODF type (also called class) of this document.

        Return: &#39;chart&#39;, &#39;database&#39;, &#39;formula&#39;, &#39;graphics&#39;,
            &#39;graphics-template&#39;, &#39;image&#39;, &#39;presentation&#39;,
            &#39;presentation-template&#39;, &#39;spreadsheet&#39;, &#39;spreadsheet-template&#39;,
            &#39;text&#39;, &#39;text-master&#39;, &#39;text-template&#39; or &#39;text-web&#39;
        &#34;&#34;&#34;
        # The mimetype must be with the form:
        # application/vnd.oasis.opendocument.text

        # Isolate and return the last part
        return self.mimetype.rsplit(&#34;.&#34;, 1)[-1]

    @property
    def body(self) -&gt; Element:
        &#34;&#34;&#34;Return the body element of the content part, where actual content
        is stored.
        &#34;&#34;&#34;
        if self.__body is None:
            self.__body = self.content.body
        return self.__body

    @property
    def meta(self) -&gt; Meta:
        &#34;&#34;&#34;Return the meta part (meta.xml) of the document, where meta data
        are stored.&#34;&#34;&#34;
        metadata = self.get_part(ODF_META)
        if metadata is None or not isinstance(metadata, Meta):
            raise ValueError(&#34;Empty Meta&#34;)
        return metadata

    @property
    def manifest(self) -&gt; Manifest:
        &#34;&#34;&#34;Return the manifest part (manifest.xml) of the document.&#34;&#34;&#34;
        manifest = self.get_part(ODF_MANIFEST)
        if manifest is None or not isinstance(manifest, Manifest):
            raise ValueError(&#34;Empty Manifest&#34;)
        return manifest

    def _get_formatted_text_footnotes(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Separate text from notes
        if rst_mode:
            result.append(&#34;\n&#34;)
        else:
            result.append(&#34;----\n&#34;)
        for citation, body in context[&#34;footnotes&#34;]:
            if rst_mode:
                result.append(f&#34;.. [#] {body}\n&#34;)
            else:
                result.append(f&#34;[{citation}] {body}\n&#34;)
        # Append a \n after the notes
        result.append(&#34;\n&#34;)
        # Reset for the next paragraph
        context[&#34;footnotes&#34;] = []

    def _get_formatted_text_annotations(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Insert the annotations
        # With a separation
        if rst_mode:
            result.append(&#34;\n&#34;)
        else:
            result.append(&#34;----\n&#34;)
        for annotation in context[&#34;annotations&#34;]:
            if rst_mode:
                result.append(f&#34;.. [#] {annotation}\n&#34;)
            else:
                result.append(f&#34;[*] {annotation}\n&#34;)
        context[&#34;annotations&#34;] = []

    def _get_formatted_text_images(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Insert the images ref, only in rst mode
        result.append(&#34;\n&#34;)
        for ref, filename, (width, height) in context[&#34;images&#34;]:
            result.append(f&#34;.. {ref} image:: {filename}\n&#34;)
            if width is not None:
                result.append(f&#34;   :width: {width}\n&#34;)
            if height is not None:
                result.append(f&#34;   :height: {height}\n&#34;)
        context[&#34;images&#34;] = []

    def _get_formatted_text_endnotes(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Append the end notes
        if rst_mode:
            result.append(&#34;\n\n&#34;)
        else:
            result.append(&#34;\n========\n&#34;)
        for citation, body in context[&#34;endnotes&#34;]:
            if rst_mode:
                result.append(f&#34;.. [*] {body}\n&#34;)
            else:
                result.append(f&#34;({citation}) {body}\n&#34;)

    def get_formatted_text(self, rst_mode: bool = False) -&gt; str:
        &#34;&#34;&#34;Return content as text, with some formatting.&#34;&#34;&#34;
        # For the moment, only &#34;type=&#39;text&#39;&#34;
        doc_type = self.get_type()
        if doc_type == &#34;spreadsheet&#34;:
            return self._tables_csv()
        if doc_type in {
            &#34;text&#34;,
            &#34;text-template&#34;,
            &#34;presentation&#34;,
            &#34;presentation-template&#34;,
        }:
            return self._formatted_text(rst_mode)
        raise NotImplementedError(f&#34;Type of document &#39;{doc_type}&#39; not supported yet&#34;)

    def _tables_csv(self) -&gt; str:
        return &#34;\n\n&#34;.join(str(table) for table in self.body.get_tables())

    def _formatted_text(self, rst_mode: bool) -&gt; str:
        # Initialize an empty context
        context = {
            &#34;document&#34;: self,
            &#34;footnotes&#34;: [],
            &#34;endnotes&#34;: [],
            &#34;annotations&#34;: [],
            &#34;rst_mode&#34;: rst_mode,
            &#34;img_counter&#34;: 0,
            &#34;images&#34;: [],
            &#34;no_img_level&#34;: 0,
        }
        body = self.body
        # Get the text
        result = []
        for child in body.children:
            # self._get_formatted_text_child(result, element, context, rst_mode)
            # if child.tag == &#34;table:table&#34;:
            #     result.append(child.get_formatted_text(context))
            #     return
            result.append(child.get_formatted_text(context))
            if context[&#34;footnotes&#34;]:
                self._get_formatted_text_footnotes(result, context, rst_mode)
            if context[&#34;annotations&#34;]:
                self._get_formatted_text_annotations(result, context, rst_mode)
            # Insert the images ref, only in rst mode
            if context[&#34;images&#34;]:
                self._get_formatted_text_images(result, context, rst_mode)
        if context[&#34;endnotes&#34;]:
            self._get_formatted_text_endnotes(result, context, rst_mode)
        return &#34;&#34;.join(result)

    def get_formated_meta(self) -&gt; str:
        &#34;&#34;&#34;Return meta informations as text, with some formatting.&#34;&#34;&#34;
        result: list[str] = []

        # Simple values
        def print_info(name: str, value: Any) -&gt; None:
            if value:
                result.append(f&#34;{name}: {value}&#34;)

        meta = self.meta
        print_info(&#34;Title&#34;, meta.get_title())
        print_info(&#34;Subject&#34;, meta.get_subject())
        print_info(&#34;Language&#34;, meta.get_language())
        print_info(&#34;Modification date&#34;, meta.get_modification_date())
        print_info(&#34;Creation date&#34;, meta.get_creation_date())
        print_info(&#34;Initial creator&#34;, meta.get_initial_creator())
        print_info(&#34;Keyword&#34;, meta.get_keywords())
        print_info(&#34;Editing duration&#34;, meta.get_editing_duration())
        print_info(&#34;Editing cycles&#34;, meta.get_editing_cycles())
        print_info(&#34;Generator&#34;, meta.get_generator())

        # Statistic
        result.append(&#34;Statistic:&#34;)
        statistic = meta.get_statistic()
        if statistic:
            for name, data in statistic.items():
                result.append(f&#34;  - {name[5:].replace(&#39;-&#39;, &#39; &#39;).capitalize()}: {data}&#34;)

        # User defined metadata
        result.append(&#34;User defined metadata:&#34;)
        user_metadata = meta.get_user_defined_metadata()
        for name, data2 in user_metadata.items():
            result.append(f&#34;  - {name}: {data2}&#34;)

        # And the description
        print_info(&#34;Description&#34;, meta.get_description())

        return &#34;\n&#34;.join(result) + &#34;\n&#34;

    def add_file(self, path_or_file: str | Path) -&gt; str:
        &#34;&#34;&#34;Insert a file from a path or a file-like object in the container.

        Return the full path to reference in the content.

        Arguments:

            path_or_file -- str or Path or file-like

        Return: str (URI)
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        name = &#34;&#34;
        # Folder for added files (FIXME hard-coded and copied)
        manifest = self.manifest
        medias = manifest.get_paths()
        # uuid = str(uuid4())

        if isinstance(path_or_file, (str, Path)):
            path = Path(path_or_file)
            extension = path.suffix.lower()
            name = f&#34;{path.stem}{extension}&#34;
            if posixpath.join(&#34;Pictures&#34;, name) in medias:
                name = f&#34;{path.stem}_{uuid4()}{extension}&#34;
        else:
            path = None
            name = getattr(path_or_file, &#34;name&#34;, None)
            if not name:
                name = str(uuid4())
        media_type, _encoding = guess_type(name)
        if not media_type:
            media_type = &#34;application/octet-stream&#34;
        if manifest.get_media_type(&#34;Pictures/&#34;) is None:
            manifest.add_full_path(&#34;Pictures/&#34;)
        full_path = posixpath.join(&#34;Pictures&#34;, name)
        if path is None:
            self.container.set_part(full_path, path_or_file.read())
        else:
            self.container.set_part(full_path, path.read_bytes())
        manifest.add_full_path(full_path, media_type)
        return full_path

    @property
    def clone(self) -&gt; Document:
        &#34;&#34;&#34;Return an exact copy of the document.

        Return: Document
        &#34;&#34;&#34;
        clone = object.__new__(self.__class__)
        for name in self.__dict__:
            if name == &#34;_Document__body&#34;:
                setattr(clone, name, None)
            elif name == &#34;_Document__xmlparts&#34;:
                setattr(clone, name, {})
            elif name == &#34;container&#34;:
                if not self.container:
                    raise ValueError(&#34;Empty Container&#34;)
                setattr(clone, name, self.container.clone)
            else:
                value = deepcopy(getattr(self, name))
                setattr(clone, name, value)
        return clone

    def save(
        self,
        target: str | Path | io.BytesIO | None = None,
        packaging: str = &#34;zip&#34;,
        pretty: bool = False,
        backup: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Save the document, at the same place it was opened or at the given
        target path. Target can also be a file-like object. It can be saved
        as a Zip file (default) or as files in a folder (for debugging
        purpose). XML parts can be pretty printed.

        Arguments:

            target -- str or file-like object

            packaging -- &#39;zip&#39; or &#39;folder&#39;

            pretty -- bool

            backup -- bool
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        # Some advertising
        self.meta.set_generator_default()
        # Synchronize data with container
        container = self.container
        for path, part in self.__xmlparts.items():
            if part is not None:
                container.set_part(path, part.serialize(pretty))
        # Save the container
        container.save(target, packaging=packaging, backup=backup)

    @property
    def content(self) -&gt; Content:
        content: Content | None = self.get_part(ODF_CONTENT)  # type:ignore
        if content is None:
            raise ValueError(&#34;Empty Content&#34;)
        return content

    @property
    def styles(self) -&gt; Styles:
        styles: Styles | None = self.get_part(ODF_STYLES)  # type:ignore
        if styles is None:
            raise ValueError(&#34;Empty Styles&#34;)
        return styles

    # Styles over several parts

    def get_styles(
        self,
        family: str | bytes = &#34;&#34;,
        automatic: bool = False,
    ) -&gt; list[Style | Element]:
        # compatibility with old versions:

        if isinstance(family, bytes):
            family = bytes_to_str(family)
        return self.content.get_styles(family=family) + self.styles.get_styles(
            family=family, automatic=automatic
        )

    def get_style(
        self,
        family: str,
        name_or_element: str | Style | None = None,
        display_name: str | None = None,
    ) -&gt; Style | None:
        &#34;&#34;&#34;Return the style uniquely identified by the name/family pair. If
        the argument is already a style object, it will return it.

        If the name is None, the default style is fetched.

        If the name is not the internal name but the name you gave in a
        desktop application, use display_name instead.

        Arguments:

            family -- &#39;paragraph&#39;, &#39;text&#39;,  &#39;graphic&#39;, &#39;table&#39;, &#39;list&#39;,
                      &#39;number&#39;, &#39;page-layout&#39;, &#39;master-page&#39;

            name -- str or Element or None

            display_name -- str

        Return: Style or None if not found.
        &#34;&#34;&#34;
        # 1. content.xml
        element = self.content.get_style(
            family, name_or_element=name_or_element, display_name=display_name
        )
        if element is not None:
            return element
        # 2. styles.xml
        return self.styles.get_style(
            family,
            name_or_element=name_or_element,
            display_name=display_name,
        )

    @staticmethod
    def _pseudo_style_attribute(style_element: Style | Element, attribute: str) -&gt; Any:
        if hasattr(style_element, attribute):
            return getattr(style_element, attribute)
        return &#34;&#34;

    def _set_automatic_name(self, style: Style, family: str) -&gt; None:
        &#34;&#34;&#34;Generate a name for the new automatic style.&#34;&#34;&#34;
        if not hasattr(style, &#34;name&#34;):
            # do nothing
            return
        styles = self.get_styles(family=family, automatic=True)
        max_index = 0
        for existing_style in styles:
            if not hasattr(existing_style, &#34;name&#34;):
                continue
            if not existing_style.name.startswith(AUTOMATIC_PREFIX):
                continue
            try:
                index = int(existing_style.name[len(AUTOMATIC_PREFIX) :])
            except ValueError:
                continue
            max_index = max(max_index, index)

        style.name = f&#34;{AUTOMATIC_PREFIX}{max_index+1}&#34;

    def _insert_style_get_common_styles(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:styles&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_automatic_styles(
        self,
        style: Style,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.content.get_element(&#34;office:automatic-styles&#34;)
        # A name ?
        if name:
            if hasattr(style, &#34;name&#34;):
                style.name = name
            existing = self.content.get_style(family, name)
        else:
            self._set_automatic_name(style, family)
            existing = None
        return existing, style_container

    def _insert_style_get_default_styles(
        self,
        style: Style,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:styles&#34;)
        style.tag = &#34;style:default-style&#34;
        if name:
            style.del_attribute(&#34;style:name&#34;)
        existing = self.styles.get_style(family)
        return existing, style_container

    def _insert_style_get_master_page(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:master-styles&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_font_face_default(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:font-face-decls&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_font_face(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.content.get_element(&#34;office:font-face-decls&#34;)
        existing = self.content.get_style(family, name)
        return existing, style_container

    def _insert_style_get_page_layout(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        # force to automatic
        style_container = self.styles.get_element(&#34;office:automatic-styles&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_draw_fill_image(
        self,
        name: str,
    ) -&gt; tuple[Any, Any]:
        # special case for &#39;draw:fill-image&#39; pseudo style
        # not family and style_element.__class__.__name__ == &#34;DrawFillImage&#34;
        style_container = self.styles.get_element(&#34;office:styles&#34;)
        existing = self.styles.get_style(&#34;&#34;, name)
        return existing, style_container

    def _insert_style_standard(
        self,
        style: Style,
        name: str,
        family: str,
        automatic: bool,
        default: bool,
    ) -&gt; tuple[Any, Any]:
        # Common style
        if name and automatic is False and default is False:
            return self._insert_style_get_common_styles(family, name)
        # Automatic style
        elif automatic is True and default is False:
            return self._insert_style_get_automatic_styles(style, family, name)
        # Default style
        elif automatic is False and default is True:
            return self._insert_style_get_default_styles(style, family, name)
        else:
            raise AttributeError(&#34;Invalid combination of arguments&#34;)

    def insert_style(  # noqa: C901
        self,
        style: Style | str,
        name: str = &#34;&#34;,
        automatic: bool = False,
        default: bool = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Insert the given style object in the document, as required by the
        style family and type.

        The style is expected to be a common style with a name. In case it
        was created with no name, the given can be set on the fly.

        If automatic is True, the style will be inserted as an automatic
        style.

        If default is True, the style will be inserted as a default style and
        would replace any existing default style of the same family. Any name
        or display name would be ignored.

        Automatic and default arguments are mutually exclusive.

        All styles can&#39;t be used as default styles. Default styles are
        allowed for the following families: paragraph, text, section, table,
        table-column, table-row, table-cell, table-page, chart, drawing-page,
        graphic, presentation, control and ruby.

        Arguments:

            style -- Style or str

            name -- str

            automatic -- bool

            default -- bool

        Return : style name -- str
        &#34;&#34;&#34;

        # if style is a str, assume it is the Style definition
        if isinstance(style, str):
            style_element: Style = Element.from_tag(style)  # type: ignore
        else:
            style_element = style
        if not isinstance(style_element, Element):
            raise TypeError(f&#34;Unknown Style type: &#39;{style!r}&#39;&#34;)

        # Get family and name
        family = self._pseudo_style_attribute(style_element, &#34;family&#34;)
        if not name:
            name = self._pseudo_style_attribute(style_element, &#34;name&#34;)

        # Master page style
        if family == &#34;master-page&#34;:
            existing, style_container = self._insert_style_get_master_page(family, name)
        # Font face declarations
        elif family == &#34;font-face&#34;:
            if default:
                existing, style_container = self._insert_style_get_font_face_default(
                    family, name
                )
            else:
                existing, style_container = self._insert_style_get_font_face(
                    family, name
                )
        # page layout style
        elif family == &#34;page-layout&#34;:
            existing, style_container = self._insert_style_get_page_layout(family, name)
        # Common style
        elif family in FAMILY_ODF_STD or family in {&#34;number&#34;}:
            existing, style_container = self._insert_style_standard(
                style_element, name, family, automatic, default
            )
        elif not family and style_element.__class__.__name__ == &#34;DrawFillImage&#34;:
            # special case for &#39;draw:fill-image&#39; pseudo style
            existing, style_container = self._insert_style_get_draw_fill_image(name)
        # Invalid style
        else:
            raise ValueError(
                &#34;Invalid style: &#34;
                f&#34;{style_element}, tag:{style_element.tag}, family:{family}&#34;
            )

        # Insert it!
        if existing is not None:
            style_container.delete(existing)
        style_container.append(style_element)
        return self._pseudo_style_attribute(style_element, &#34;name&#34;)

    def get_styled_elements(self, name: str = &#34;&#34;) -&gt; list[Element]:
        &#34;&#34;&#34;Brute-force to find paragraphs, tables, etc. using the given style
        name (or all by default).

        Arguments:

            name -- str

        Return: list
        &#34;&#34;&#34;
        # Header, footer, etc. have styles too
        return self.content.root.get_styled_elements(
            name
        ) + self.styles.root.get_styled_elements(name)

    def show_styles(
        self,
        automatic: bool = True,
        common: bool = True,
        properties: bool = False,
    ) -&gt; str:
        infos = []
        for style in self.get_styles():
            try:
                name = style.name  # type: ignore
            except AttributeError:
                print(&#34;--------------&#34;)
                print(style.__class__)
                print(style.serialize())
                raise
            if style.__class__.__name__ == &#34;DrawFillImage&#34;:
                family = &#34;&#34;
            else:
                family = str(style.family)  # type: ignore
            parent = style.parent
            is_auto = parent and parent.tag == &#34;office:automatic-styles&#34;
            if is_auto and automatic is False or not is_auto and common is False:
                continue
            is_used = bool(self.get_styled_elements(name))
            infos.append(
                {
                    &#34;type&#34;: &#34;auto  &#34; if is_auto else &#34;common&#34;,
                    &#34;used&#34;: &#34;y&#34; if is_used else &#34;n&#34;,
                    &#34;family&#34;: family,
                    &#34;parent&#34;: self._pseudo_style_attribute(style, &#34;parent_style&#34;) or &#34;&#34;,
                    &#34;name&#34;: name or &#34;&#34;,
                    &#34;display_name&#34;: self._pseudo_style_attribute(style, &#34;display_name&#34;)
                    or &#34;&#34;,
                    &#34;properties&#34;: style.get_properties() if properties else None,  # type: ignore
                }
            )
        if not infos:
            return &#34;&#34;
        # Sort by family and name
        infos.sort(key=itemgetter(&#34;family&#34;, &#34;name&#34;))
        # Show common and used first
        infos.sort(key=itemgetter(&#34;type&#34;, &#34;used&#34;), reverse=True)
        max_family = str(max([len(x[&#34;family&#34;]) for x in infos]))  # type: ignore
        max_parent = str(max([len(x[&#34;parent&#34;]) for x in infos]))  # type: ignore
        formater = (
            &#34;%(type)s used:%(used)s family:%(family)-0&#34;
            + max_family
            + &#34;s parent:%(parent)-0&#34;
            + max_parent
            + &#34;s name:%(name)s&#34;
        )
        output = []
        for info in infos:
            line = formater % info
            if info[&#34;display_name&#34;]:
                line += &#34; display_name:&#34; + info[&#34;display_name&#34;]  # type: ignore
            output.append(line)
            if info[&#34;properties&#34;]:
                for name, value in info[&#34;properties&#34;].items():  # type: ignore
                    output.append(f&#34;   - {name}: {value}&#34;)
        output.append(&#34;&#34;)
        return &#34;\n&#34;.join(output)

    def delete_styles(self) -&gt; int:
        &#34;&#34;&#34;Remove all style information from content and all styles.

        Return: number of deleted styles
        &#34;&#34;&#34;
        # First remove references to styles
        for element in self.get_styled_elements():
            for attribute in (
                &#34;text:style-name&#34;,
                &#34;draw:style-name&#34;,
                &#34;draw:text-style-name&#34;,
                &#34;table:style-name&#34;,
                &#34;style:page-layout-name&#34;,
            ):
                try:
                    element.del_attribute(attribute)
                except KeyError:
                    continue
        # Then remove supposedly orphaned styles
        deleted = 0
        for style in self.get_styles():
            if style.name is None:  # type: ignore
                # Don&#39;t delete default styles
                continue
            # elif type(style) is odf_master_page:
            #    # Don&#39;t suppress header and footer, just styling was removed
            #    continue
            style.delete()
            deleted += 1
        return deleted

    def merge_styles_from(self, document: Document) -&gt; None:
        &#34;&#34;&#34;Copy all the styles of a document into ourself.

        Styles with the same type and name will be replaced, so only unique
        styles will be preserved.
        &#34;&#34;&#34;
        manifest = self.manifest
        document_manifest = document.manifest
        for style in document.get_styles():
            tagname = style.tag
            family = self._pseudo_style_attribute(style, &#34;family&#34;)
            stylename = style.name  # type: ignore
            container = style.parent
            container_name = container.tag  # type: ignore
            partname = container.parent.tag  # type: ignore
            # The destination part
            if partname == &#34;office:document-styles&#34;:
                part: Content | Styles = self.styles
            elif partname == &#34;office:document-content&#34;:
                part = self.content
            else:
                raise NotImplementedError(partname)
            # Implemented containers
            if container_name not in {
                &#34;office:styles&#34;,
                &#34;office:automatic-styles&#34;,
                &#34;office:master-styles&#34;,
                &#34;office:font-face-decls&#34;,
            }:
                raise NotImplementedError(container_name)
            dest = part.get_element(f&#34;//{container_name}&#34;)
            # Implemented style types
            # if tagname not in registered_styles:
            #    raise NotImplementedError(tagname)
            duplicate = part.get_style(family, stylename)
            if duplicate is not None:
                duplicate.delete()
            dest.append(style)
            # Copy images from the header/footer
            if tagname == &#34;style:master-page&#34;:
                query = &#34;descendant::draw:image&#34;
                for image in style.get_elements(query):
                    url = image.url  # type: ignore
                    part_url = document.get_part(url)
                    # Manually add the part to keep the name
                    self.set_part(url, part_url)  # type: ignore
                    media_type = document_manifest.get_media_type(url)
                    manifest.add_full_path(url, media_type)  # type: ignore
            # Copy images from the fill-image
            elif tagname == &#34;draw:fill-image&#34;:
                url = style.url  # type: ignore
                part_url = document.get_part(url)
                self.set_part(url, part_url)  # type: ignore
                media_type = document_manifest.get_media_type(url)
                manifest.add_full_path(url, media_type)  # type: ignore

    def add_page_break_style(self) -&gt; None:
        &#34;&#34;&#34;Ensure that the document contains the style required for a manual page break.

        Then a manual page break can be added to the document with:
            from paragraph import PageBreak
            ...
            document.body.append(PageBreak())

        Note: this style uses the property &#39;fo:break-after&#39;, another
        possibility could be the property &#39;fo:break-before&#39;
        &#34;&#34;&#34;
        if existing := self.get_style(  # noqa: SIM102
            family=&#34;paragraph&#34;,
            name_or_element=&#34;odfdopagebreak&#34;,
        ):
            if properties := existing.get_properties():  # noqa: SIM102
                if properties[&#34;fo:break-after&#34;] == &#34;page&#34;:
                    return
        style = (
            &#39;&lt;style:style style:family=&#34;paragraph&#34; style:parent-style-name=&#34;Standard&#34; &#39;
            &#39;style:name=&#34;odfdopagebreak&#34;&gt;&#39;
            &#39;&lt;style:paragraph-properties fo:break-after=&#34;page&#34;/&gt;&lt;/style:style&gt;&#39;
        )
        self.insert_style(style, automatic=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="odfdo.document.container_from_template"><code class="name flex">
<span>def <span class="ident">container_from_template</span></span>(<span>template: str | Path | io.BytesIO) ‑> <a title="odfdo.container.Container" href="container.html#odfdo.container.Container">Container</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a Container instance based on template argument.</p>
<p>Internal use only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def container_from_template(template: str | Path | io.BytesIO) -&gt; Container:
    &#34;&#34;&#34;Return a Container instance based on template argument.

    Internal use only.&#34;&#34;&#34;
    template_container = Container()
    if isinstance(template, str) and template in ODF_TEMPLATES:
        template = ODF_TEMPLATES[template]
        with rso.as_file(
            rso.files(&#34;odfdo.templates&#34;).joinpath(template)
        ) as template_path:
            template_container.open(template_path)
    else:
        # custome template
        template_container.open(template)
    # Return a copy of the template container
    container = template_container.clone
    # Change type from template to regular
    mimetype = container.mimetype.replace(&#34;-template&#34;, &#34;&#34;)
    container.mimetype = mimetype
    # Update the manifest
    manifest = Manifest(ODF_MANIFEST, container)
    manifest.set_media_type(&#34;/&#34;, mimetype)
    container.set_part(ODF_MANIFEST, manifest.serialize())
    return container</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="odfdo.document.Document"><code class="flex name class">
<span>class <span class="ident">Document</span></span>
<span>(</span><span>target: str | bytes | Path | Container | io.BytesIO | None = 'text')</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of the ODF document.</p>
<p>To create a new Document, several possibilities:</p>
<pre><code>- Document() or Document("text") -&gt; an "empty" document of type text
- Document("spreadsheet") -&gt; an "empty" document of type spreadsheet
- Document("presentation") -&gt; an "empty" document of type presentation
- Document("drawing") -&gt; an "empty" document of type drawing

Meaning of “empty”: these documents are copies of the default
templates documents provided with this library, which, as templates,
are not really empty. It may be useful to clear the newly created
document: document.body.clear(), or adjust meta informations like
description or default language: document.meta.set_language('fr-FR')
</code></pre>
<p>If the argument is not a known template type, or is a Path,
Document(file) will load the content of the ODF file.</p>
<p>To explicitly create a document from a custom template, use the
Document.new(path) method whose argument is the path to the template file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Document:
    &#34;&#34;&#34;Abstraction of the ODF document.

    To create a new Document, several possibilities:

        - Document() or Document(&#34;text&#34;) -&gt; an &#34;empty&#34; document of type text
        - Document(&#34;spreadsheet&#34;) -&gt; an &#34;empty&#34; document of type spreadsheet
        - Document(&#34;presentation&#34;) -&gt; an &#34;empty&#34; document of type presentation
        - Document(&#34;drawing&#34;) -&gt; an &#34;empty&#34; document of type drawing

        Meaning of “empty”: these documents are copies of the default
        templates documents provided with this library, which, as templates,
        are not really empty. It may be useful to clear the newly created
        document: document.body.clear(), or adjust meta informations like
        description or default language: document.meta.set_language(&#39;fr-FR&#39;)

    If the argument is not a known template type, or is a Path,
    Document(file) will load the content of the ODF file.

    To explicitly create a document from a custom template, use the
    Document.new(path) method whose argument is the path to the template file.
    &#34;&#34;&#34;

    def __init__(
        self,
        target: str | bytes | Path | Container | io.BytesIO | None = &#34;text&#34;,
    ) -&gt; None:
        # Cache of XML parts
        self.__xmlparts: dict[str, XmlPart] = {}
        # Cache of the body
        self.__body: Element | None = None
        self.container: Container | None = None
        if isinstance(target, bytes):
            # eager conversion
            target = bytes_to_str(target)
        if target is None:
            # empty document, you probably don&#39;t wnat this.
            self.container = Container()
            return
        if isinstance(target, Path):
            # let&#39;s assume we open a container on existing file
            self.container = Container(target)
            return
        if isinstance(target, Container):
            # special internal case, use an existing container
            self.container = target
            return
        if isinstance(target, str):
            if target in ODF_TEMPLATES:
                # assuming a new document from templates
                self.container = container_from_template(target)
                return
            # let&#39;s assume we open a container on existing file
            self.container = Container(target)
            return
        if isinstance(target, io.BytesIO):
            self.container = Container(target)
            return
        raise TypeError(f&#34;Unknown Document source type: &#39;{target!r}&#39;&#34;)

    def __repr__(self) -&gt; str:
        return f&#34;&lt;{self.__class__.__name__} type={self.get_type()} path={self.path}&gt;&#34;

    def __str__(self) -&gt; str:
        try:
            return str(self.get_formatted_text())
        except NotImplementedError:
            return self.body.text_recursive

    @classmethod
    def new(cls, template: str | Path | io.BytesIO = &#34;text&#34;) -&gt; Document:
        &#34;&#34;&#34;Create a Document from a template.

        The template argument is expected to be the path to a ODF template.

        Arguments:

            template -- str or Path or file-like (io.BytesIO)

        Return : ODF document -- Document
        &#34;&#34;&#34;
        container = container_from_template(template)
        return cls(container)

    # Public API

    @property
    def path(self) -&gt; Path | None:
        &#34;&#34;&#34;Shortcut to Document.Container.path.&#34;&#34;&#34;
        if not self.container:
            return None
        return self.container.path

    @path.setter
    def path(self, path_or_str: str | Path) -&gt; None:
        &#34;&#34;&#34;Shortcut to Document.Container.path

        Only accepting str or Path.&#34;&#34;&#34;
        if not self.container:
            return
        self.container.path = Path(path_or_str)

    def get_parts(self) -&gt; list[str]:
        &#34;&#34;&#34;Return available part names with path inside the archive, e.g.
        [&#39;content.xml&#39;, ..., &#39;Pictures/100000000000032000000258912EB1C3.jpg&#39;]
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        return self.container.get_parts()

    def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:
        &#34;&#34;&#34;Return the bytes of the given part. The path is relative to the
        archive, e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;.

        &#39;content&#39;, &#39;meta&#39;, &#39;settings&#39;, &#39;styles&#39; and &#39;manifest&#39; are shortcuts
        to the real path, e.g. content.xml, and return a dedicated object with
        its own API.

        path formated as URI, so always use &#39;/&#39; separator
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        # &#34;./ObjectReplacements/Object 1&#34;
        path = path.lstrip(&#34;./&#34;)
        path = _get_part_path(path)
        cls = _get_part_class(path)
        # Raw bytes
        if cls is None:
            return self.container.get_part(path)
        # XML part
        part = self.__xmlparts.get(path)
        if part is None:
            self.__xmlparts[path] = part = cls(path, self.container)
        return part

    def set_part(self, path: str, data: bytes) -&gt; None:
        &#34;&#34;&#34;Set the bytes of the given part. The path is relative to the
        archive, e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;.

        path formated as URI, so always use &#39;/&#39; separator
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        # &#34;./ObjectReplacements/Object 1&#34;
        path = path.lstrip(&#34;./&#34;)
        path = _get_part_path(path)
        cls = _get_part_class(path)
        # XML part overwritten
        if cls is not None:
            with suppress(KeyError):
                self.__xmlparts[path]
        self.container.set_part(path, data)

    def del_part(self, path: str) -&gt; None:
        &#34;&#34;&#34;Mark a part for deletion. The path is relative to the archive,
        e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        path = _get_part_path(path)
        cls = _get_part_class(path)
        if path == ODF_MANIFEST or cls is not None:
            raise ValueError(f&#34;part &#39;{path}&#39; is mandatory&#34;)
        self.container.del_part(path)

    @property
    def mimetype(self) -&gt; str:
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        return self.container.mimetype

    @mimetype.setter
    def mimetype(self, mimetype: str) -&gt; None:
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        self.container.mimetype = mimetype

    def get_type(self) -&gt; str:
        &#34;&#34;&#34;Get the ODF type (also called class) of this document.

        Return: &#39;chart&#39;, &#39;database&#39;, &#39;formula&#39;, &#39;graphics&#39;,
            &#39;graphics-template&#39;, &#39;image&#39;, &#39;presentation&#39;,
            &#39;presentation-template&#39;, &#39;spreadsheet&#39;, &#39;spreadsheet-template&#39;,
            &#39;text&#39;, &#39;text-master&#39;, &#39;text-template&#39; or &#39;text-web&#39;
        &#34;&#34;&#34;
        # The mimetype must be with the form:
        # application/vnd.oasis.opendocument.text

        # Isolate and return the last part
        return self.mimetype.rsplit(&#34;.&#34;, 1)[-1]

    @property
    def body(self) -&gt; Element:
        &#34;&#34;&#34;Return the body element of the content part, where actual content
        is stored.
        &#34;&#34;&#34;
        if self.__body is None:
            self.__body = self.content.body
        return self.__body

    @property
    def meta(self) -&gt; Meta:
        &#34;&#34;&#34;Return the meta part (meta.xml) of the document, where meta data
        are stored.&#34;&#34;&#34;
        metadata = self.get_part(ODF_META)
        if metadata is None or not isinstance(metadata, Meta):
            raise ValueError(&#34;Empty Meta&#34;)
        return metadata

    @property
    def manifest(self) -&gt; Manifest:
        &#34;&#34;&#34;Return the manifest part (manifest.xml) of the document.&#34;&#34;&#34;
        manifest = self.get_part(ODF_MANIFEST)
        if manifest is None or not isinstance(manifest, Manifest):
            raise ValueError(&#34;Empty Manifest&#34;)
        return manifest

    def _get_formatted_text_footnotes(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Separate text from notes
        if rst_mode:
            result.append(&#34;\n&#34;)
        else:
            result.append(&#34;----\n&#34;)
        for citation, body in context[&#34;footnotes&#34;]:
            if rst_mode:
                result.append(f&#34;.. [#] {body}\n&#34;)
            else:
                result.append(f&#34;[{citation}] {body}\n&#34;)
        # Append a \n after the notes
        result.append(&#34;\n&#34;)
        # Reset for the next paragraph
        context[&#34;footnotes&#34;] = []

    def _get_formatted_text_annotations(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Insert the annotations
        # With a separation
        if rst_mode:
            result.append(&#34;\n&#34;)
        else:
            result.append(&#34;----\n&#34;)
        for annotation in context[&#34;annotations&#34;]:
            if rst_mode:
                result.append(f&#34;.. [#] {annotation}\n&#34;)
            else:
                result.append(f&#34;[*] {annotation}\n&#34;)
        context[&#34;annotations&#34;] = []

    def _get_formatted_text_images(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Insert the images ref, only in rst mode
        result.append(&#34;\n&#34;)
        for ref, filename, (width, height) in context[&#34;images&#34;]:
            result.append(f&#34;.. {ref} image:: {filename}\n&#34;)
            if width is not None:
                result.append(f&#34;   :width: {width}\n&#34;)
            if height is not None:
                result.append(f&#34;   :height: {height}\n&#34;)
        context[&#34;images&#34;] = []

    def _get_formatted_text_endnotes(
        self,
        result: list[str],
        context: dict,
        rst_mode: bool,
    ) -&gt; None:
        # Append the end notes
        if rst_mode:
            result.append(&#34;\n\n&#34;)
        else:
            result.append(&#34;\n========\n&#34;)
        for citation, body in context[&#34;endnotes&#34;]:
            if rst_mode:
                result.append(f&#34;.. [*] {body}\n&#34;)
            else:
                result.append(f&#34;({citation}) {body}\n&#34;)

    def get_formatted_text(self, rst_mode: bool = False) -&gt; str:
        &#34;&#34;&#34;Return content as text, with some formatting.&#34;&#34;&#34;
        # For the moment, only &#34;type=&#39;text&#39;&#34;
        doc_type = self.get_type()
        if doc_type == &#34;spreadsheet&#34;:
            return self._tables_csv()
        if doc_type in {
            &#34;text&#34;,
            &#34;text-template&#34;,
            &#34;presentation&#34;,
            &#34;presentation-template&#34;,
        }:
            return self._formatted_text(rst_mode)
        raise NotImplementedError(f&#34;Type of document &#39;{doc_type}&#39; not supported yet&#34;)

    def _tables_csv(self) -&gt; str:
        return &#34;\n\n&#34;.join(str(table) for table in self.body.get_tables())

    def _formatted_text(self, rst_mode: bool) -&gt; str:
        # Initialize an empty context
        context = {
            &#34;document&#34;: self,
            &#34;footnotes&#34;: [],
            &#34;endnotes&#34;: [],
            &#34;annotations&#34;: [],
            &#34;rst_mode&#34;: rst_mode,
            &#34;img_counter&#34;: 0,
            &#34;images&#34;: [],
            &#34;no_img_level&#34;: 0,
        }
        body = self.body
        # Get the text
        result = []
        for child in body.children:
            # self._get_formatted_text_child(result, element, context, rst_mode)
            # if child.tag == &#34;table:table&#34;:
            #     result.append(child.get_formatted_text(context))
            #     return
            result.append(child.get_formatted_text(context))
            if context[&#34;footnotes&#34;]:
                self._get_formatted_text_footnotes(result, context, rst_mode)
            if context[&#34;annotations&#34;]:
                self._get_formatted_text_annotations(result, context, rst_mode)
            # Insert the images ref, only in rst mode
            if context[&#34;images&#34;]:
                self._get_formatted_text_images(result, context, rst_mode)
        if context[&#34;endnotes&#34;]:
            self._get_formatted_text_endnotes(result, context, rst_mode)
        return &#34;&#34;.join(result)

    def get_formated_meta(self) -&gt; str:
        &#34;&#34;&#34;Return meta informations as text, with some formatting.&#34;&#34;&#34;
        result: list[str] = []

        # Simple values
        def print_info(name: str, value: Any) -&gt; None:
            if value:
                result.append(f&#34;{name}: {value}&#34;)

        meta = self.meta
        print_info(&#34;Title&#34;, meta.get_title())
        print_info(&#34;Subject&#34;, meta.get_subject())
        print_info(&#34;Language&#34;, meta.get_language())
        print_info(&#34;Modification date&#34;, meta.get_modification_date())
        print_info(&#34;Creation date&#34;, meta.get_creation_date())
        print_info(&#34;Initial creator&#34;, meta.get_initial_creator())
        print_info(&#34;Keyword&#34;, meta.get_keywords())
        print_info(&#34;Editing duration&#34;, meta.get_editing_duration())
        print_info(&#34;Editing cycles&#34;, meta.get_editing_cycles())
        print_info(&#34;Generator&#34;, meta.get_generator())

        # Statistic
        result.append(&#34;Statistic:&#34;)
        statistic = meta.get_statistic()
        if statistic:
            for name, data in statistic.items():
                result.append(f&#34;  - {name[5:].replace(&#39;-&#39;, &#39; &#39;).capitalize()}: {data}&#34;)

        # User defined metadata
        result.append(&#34;User defined metadata:&#34;)
        user_metadata = meta.get_user_defined_metadata()
        for name, data2 in user_metadata.items():
            result.append(f&#34;  - {name}: {data2}&#34;)

        # And the description
        print_info(&#34;Description&#34;, meta.get_description())

        return &#34;\n&#34;.join(result) + &#34;\n&#34;

    def add_file(self, path_or_file: str | Path) -&gt; str:
        &#34;&#34;&#34;Insert a file from a path or a file-like object in the container.

        Return the full path to reference in the content.

        Arguments:

            path_or_file -- str or Path or file-like

        Return: str (URI)
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        name = &#34;&#34;
        # Folder for added files (FIXME hard-coded and copied)
        manifest = self.manifest
        medias = manifest.get_paths()
        # uuid = str(uuid4())

        if isinstance(path_or_file, (str, Path)):
            path = Path(path_or_file)
            extension = path.suffix.lower()
            name = f&#34;{path.stem}{extension}&#34;
            if posixpath.join(&#34;Pictures&#34;, name) in medias:
                name = f&#34;{path.stem}_{uuid4()}{extension}&#34;
        else:
            path = None
            name = getattr(path_or_file, &#34;name&#34;, None)
            if not name:
                name = str(uuid4())
        media_type, _encoding = guess_type(name)
        if not media_type:
            media_type = &#34;application/octet-stream&#34;
        if manifest.get_media_type(&#34;Pictures/&#34;) is None:
            manifest.add_full_path(&#34;Pictures/&#34;)
        full_path = posixpath.join(&#34;Pictures&#34;, name)
        if path is None:
            self.container.set_part(full_path, path_or_file.read())
        else:
            self.container.set_part(full_path, path.read_bytes())
        manifest.add_full_path(full_path, media_type)
        return full_path

    @property
    def clone(self) -&gt; Document:
        &#34;&#34;&#34;Return an exact copy of the document.

        Return: Document
        &#34;&#34;&#34;
        clone = object.__new__(self.__class__)
        for name in self.__dict__:
            if name == &#34;_Document__body&#34;:
                setattr(clone, name, None)
            elif name == &#34;_Document__xmlparts&#34;:
                setattr(clone, name, {})
            elif name == &#34;container&#34;:
                if not self.container:
                    raise ValueError(&#34;Empty Container&#34;)
                setattr(clone, name, self.container.clone)
            else:
                value = deepcopy(getattr(self, name))
                setattr(clone, name, value)
        return clone

    def save(
        self,
        target: str | Path | io.BytesIO | None = None,
        packaging: str = &#34;zip&#34;,
        pretty: bool = False,
        backup: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Save the document, at the same place it was opened or at the given
        target path. Target can also be a file-like object. It can be saved
        as a Zip file (default) or as files in a folder (for debugging
        purpose). XML parts can be pretty printed.

        Arguments:

            target -- str or file-like object

            packaging -- &#39;zip&#39; or &#39;folder&#39;

            pretty -- bool

            backup -- bool
        &#34;&#34;&#34;
        if not self.container:
            raise ValueError(&#34;Empty Container&#34;)
        # Some advertising
        self.meta.set_generator_default()
        # Synchronize data with container
        container = self.container
        for path, part in self.__xmlparts.items():
            if part is not None:
                container.set_part(path, part.serialize(pretty))
        # Save the container
        container.save(target, packaging=packaging, backup=backup)

    @property
    def content(self) -&gt; Content:
        content: Content | None = self.get_part(ODF_CONTENT)  # type:ignore
        if content is None:
            raise ValueError(&#34;Empty Content&#34;)
        return content

    @property
    def styles(self) -&gt; Styles:
        styles: Styles | None = self.get_part(ODF_STYLES)  # type:ignore
        if styles is None:
            raise ValueError(&#34;Empty Styles&#34;)
        return styles

    # Styles over several parts

    def get_styles(
        self,
        family: str | bytes = &#34;&#34;,
        automatic: bool = False,
    ) -&gt; list[Style | Element]:
        # compatibility with old versions:

        if isinstance(family, bytes):
            family = bytes_to_str(family)
        return self.content.get_styles(family=family) + self.styles.get_styles(
            family=family, automatic=automatic
        )

    def get_style(
        self,
        family: str,
        name_or_element: str | Style | None = None,
        display_name: str | None = None,
    ) -&gt; Style | None:
        &#34;&#34;&#34;Return the style uniquely identified by the name/family pair. If
        the argument is already a style object, it will return it.

        If the name is None, the default style is fetched.

        If the name is not the internal name but the name you gave in a
        desktop application, use display_name instead.

        Arguments:

            family -- &#39;paragraph&#39;, &#39;text&#39;,  &#39;graphic&#39;, &#39;table&#39;, &#39;list&#39;,
                      &#39;number&#39;, &#39;page-layout&#39;, &#39;master-page&#39;

            name -- str or Element or None

            display_name -- str

        Return: Style or None if not found.
        &#34;&#34;&#34;
        # 1. content.xml
        element = self.content.get_style(
            family, name_or_element=name_or_element, display_name=display_name
        )
        if element is not None:
            return element
        # 2. styles.xml
        return self.styles.get_style(
            family,
            name_or_element=name_or_element,
            display_name=display_name,
        )

    @staticmethod
    def _pseudo_style_attribute(style_element: Style | Element, attribute: str) -&gt; Any:
        if hasattr(style_element, attribute):
            return getattr(style_element, attribute)
        return &#34;&#34;

    def _set_automatic_name(self, style: Style, family: str) -&gt; None:
        &#34;&#34;&#34;Generate a name for the new automatic style.&#34;&#34;&#34;
        if not hasattr(style, &#34;name&#34;):
            # do nothing
            return
        styles = self.get_styles(family=family, automatic=True)
        max_index = 0
        for existing_style in styles:
            if not hasattr(existing_style, &#34;name&#34;):
                continue
            if not existing_style.name.startswith(AUTOMATIC_PREFIX):
                continue
            try:
                index = int(existing_style.name[len(AUTOMATIC_PREFIX) :])
            except ValueError:
                continue
            max_index = max(max_index, index)

        style.name = f&#34;{AUTOMATIC_PREFIX}{max_index+1}&#34;

    def _insert_style_get_common_styles(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:styles&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_automatic_styles(
        self,
        style: Style,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.content.get_element(&#34;office:automatic-styles&#34;)
        # A name ?
        if name:
            if hasattr(style, &#34;name&#34;):
                style.name = name
            existing = self.content.get_style(family, name)
        else:
            self._set_automatic_name(style, family)
            existing = None
        return existing, style_container

    def _insert_style_get_default_styles(
        self,
        style: Style,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:styles&#34;)
        style.tag = &#34;style:default-style&#34;
        if name:
            style.del_attribute(&#34;style:name&#34;)
        existing = self.styles.get_style(family)
        return existing, style_container

    def _insert_style_get_master_page(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:master-styles&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_font_face_default(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.styles.get_element(&#34;office:font-face-decls&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_font_face(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        style_container = self.content.get_element(&#34;office:font-face-decls&#34;)
        existing = self.content.get_style(family, name)
        return existing, style_container

    def _insert_style_get_page_layout(
        self,
        family: str,
        name: str,
    ) -&gt; tuple[Any, Any]:
        # force to automatic
        style_container = self.styles.get_element(&#34;office:automatic-styles&#34;)
        existing = self.styles.get_style(family, name)
        return existing, style_container

    def _insert_style_get_draw_fill_image(
        self,
        name: str,
    ) -&gt; tuple[Any, Any]:
        # special case for &#39;draw:fill-image&#39; pseudo style
        # not family and style_element.__class__.__name__ == &#34;DrawFillImage&#34;
        style_container = self.styles.get_element(&#34;office:styles&#34;)
        existing = self.styles.get_style(&#34;&#34;, name)
        return existing, style_container

    def _insert_style_standard(
        self,
        style: Style,
        name: str,
        family: str,
        automatic: bool,
        default: bool,
    ) -&gt; tuple[Any, Any]:
        # Common style
        if name and automatic is False and default is False:
            return self._insert_style_get_common_styles(family, name)
        # Automatic style
        elif automatic is True and default is False:
            return self._insert_style_get_automatic_styles(style, family, name)
        # Default style
        elif automatic is False and default is True:
            return self._insert_style_get_default_styles(style, family, name)
        else:
            raise AttributeError(&#34;Invalid combination of arguments&#34;)

    def insert_style(  # noqa: C901
        self,
        style: Style | str,
        name: str = &#34;&#34;,
        automatic: bool = False,
        default: bool = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Insert the given style object in the document, as required by the
        style family and type.

        The style is expected to be a common style with a name. In case it
        was created with no name, the given can be set on the fly.

        If automatic is True, the style will be inserted as an automatic
        style.

        If default is True, the style will be inserted as a default style and
        would replace any existing default style of the same family. Any name
        or display name would be ignored.

        Automatic and default arguments are mutually exclusive.

        All styles can&#39;t be used as default styles. Default styles are
        allowed for the following families: paragraph, text, section, table,
        table-column, table-row, table-cell, table-page, chart, drawing-page,
        graphic, presentation, control and ruby.

        Arguments:

            style -- Style or str

            name -- str

            automatic -- bool

            default -- bool

        Return : style name -- str
        &#34;&#34;&#34;

        # if style is a str, assume it is the Style definition
        if isinstance(style, str):
            style_element: Style = Element.from_tag(style)  # type: ignore
        else:
            style_element = style
        if not isinstance(style_element, Element):
            raise TypeError(f&#34;Unknown Style type: &#39;{style!r}&#39;&#34;)

        # Get family and name
        family = self._pseudo_style_attribute(style_element, &#34;family&#34;)
        if not name:
            name = self._pseudo_style_attribute(style_element, &#34;name&#34;)

        # Master page style
        if family == &#34;master-page&#34;:
            existing, style_container = self._insert_style_get_master_page(family, name)
        # Font face declarations
        elif family == &#34;font-face&#34;:
            if default:
                existing, style_container = self._insert_style_get_font_face_default(
                    family, name
                )
            else:
                existing, style_container = self._insert_style_get_font_face(
                    family, name
                )
        # page layout style
        elif family == &#34;page-layout&#34;:
            existing, style_container = self._insert_style_get_page_layout(family, name)
        # Common style
        elif family in FAMILY_ODF_STD or family in {&#34;number&#34;}:
            existing, style_container = self._insert_style_standard(
                style_element, name, family, automatic, default
            )
        elif not family and style_element.__class__.__name__ == &#34;DrawFillImage&#34;:
            # special case for &#39;draw:fill-image&#39; pseudo style
            existing, style_container = self._insert_style_get_draw_fill_image(name)
        # Invalid style
        else:
            raise ValueError(
                &#34;Invalid style: &#34;
                f&#34;{style_element}, tag:{style_element.tag}, family:{family}&#34;
            )

        # Insert it!
        if existing is not None:
            style_container.delete(existing)
        style_container.append(style_element)
        return self._pseudo_style_attribute(style_element, &#34;name&#34;)

    def get_styled_elements(self, name: str = &#34;&#34;) -&gt; list[Element]:
        &#34;&#34;&#34;Brute-force to find paragraphs, tables, etc. using the given style
        name (or all by default).

        Arguments:

            name -- str

        Return: list
        &#34;&#34;&#34;
        # Header, footer, etc. have styles too
        return self.content.root.get_styled_elements(
            name
        ) + self.styles.root.get_styled_elements(name)

    def show_styles(
        self,
        automatic: bool = True,
        common: bool = True,
        properties: bool = False,
    ) -&gt; str:
        infos = []
        for style in self.get_styles():
            try:
                name = style.name  # type: ignore
            except AttributeError:
                print(&#34;--------------&#34;)
                print(style.__class__)
                print(style.serialize())
                raise
            if style.__class__.__name__ == &#34;DrawFillImage&#34;:
                family = &#34;&#34;
            else:
                family = str(style.family)  # type: ignore
            parent = style.parent
            is_auto = parent and parent.tag == &#34;office:automatic-styles&#34;
            if is_auto and automatic is False or not is_auto and common is False:
                continue
            is_used = bool(self.get_styled_elements(name))
            infos.append(
                {
                    &#34;type&#34;: &#34;auto  &#34; if is_auto else &#34;common&#34;,
                    &#34;used&#34;: &#34;y&#34; if is_used else &#34;n&#34;,
                    &#34;family&#34;: family,
                    &#34;parent&#34;: self._pseudo_style_attribute(style, &#34;parent_style&#34;) or &#34;&#34;,
                    &#34;name&#34;: name or &#34;&#34;,
                    &#34;display_name&#34;: self._pseudo_style_attribute(style, &#34;display_name&#34;)
                    or &#34;&#34;,
                    &#34;properties&#34;: style.get_properties() if properties else None,  # type: ignore
                }
            )
        if not infos:
            return &#34;&#34;
        # Sort by family and name
        infos.sort(key=itemgetter(&#34;family&#34;, &#34;name&#34;))
        # Show common and used first
        infos.sort(key=itemgetter(&#34;type&#34;, &#34;used&#34;), reverse=True)
        max_family = str(max([len(x[&#34;family&#34;]) for x in infos]))  # type: ignore
        max_parent = str(max([len(x[&#34;parent&#34;]) for x in infos]))  # type: ignore
        formater = (
            &#34;%(type)s used:%(used)s family:%(family)-0&#34;
            + max_family
            + &#34;s parent:%(parent)-0&#34;
            + max_parent
            + &#34;s name:%(name)s&#34;
        )
        output = []
        for info in infos:
            line = formater % info
            if info[&#34;display_name&#34;]:
                line += &#34; display_name:&#34; + info[&#34;display_name&#34;]  # type: ignore
            output.append(line)
            if info[&#34;properties&#34;]:
                for name, value in info[&#34;properties&#34;].items():  # type: ignore
                    output.append(f&#34;   - {name}: {value}&#34;)
        output.append(&#34;&#34;)
        return &#34;\n&#34;.join(output)

    def delete_styles(self) -&gt; int:
        &#34;&#34;&#34;Remove all style information from content and all styles.

        Return: number of deleted styles
        &#34;&#34;&#34;
        # First remove references to styles
        for element in self.get_styled_elements():
            for attribute in (
                &#34;text:style-name&#34;,
                &#34;draw:style-name&#34;,
                &#34;draw:text-style-name&#34;,
                &#34;table:style-name&#34;,
                &#34;style:page-layout-name&#34;,
            ):
                try:
                    element.del_attribute(attribute)
                except KeyError:
                    continue
        # Then remove supposedly orphaned styles
        deleted = 0
        for style in self.get_styles():
            if style.name is None:  # type: ignore
                # Don&#39;t delete default styles
                continue
            # elif type(style) is odf_master_page:
            #    # Don&#39;t suppress header and footer, just styling was removed
            #    continue
            style.delete()
            deleted += 1
        return deleted

    def merge_styles_from(self, document: Document) -&gt; None:
        &#34;&#34;&#34;Copy all the styles of a document into ourself.

        Styles with the same type and name will be replaced, so only unique
        styles will be preserved.
        &#34;&#34;&#34;
        manifest = self.manifest
        document_manifest = document.manifest
        for style in document.get_styles():
            tagname = style.tag
            family = self._pseudo_style_attribute(style, &#34;family&#34;)
            stylename = style.name  # type: ignore
            container = style.parent
            container_name = container.tag  # type: ignore
            partname = container.parent.tag  # type: ignore
            # The destination part
            if partname == &#34;office:document-styles&#34;:
                part: Content | Styles = self.styles
            elif partname == &#34;office:document-content&#34;:
                part = self.content
            else:
                raise NotImplementedError(partname)
            # Implemented containers
            if container_name not in {
                &#34;office:styles&#34;,
                &#34;office:automatic-styles&#34;,
                &#34;office:master-styles&#34;,
                &#34;office:font-face-decls&#34;,
            }:
                raise NotImplementedError(container_name)
            dest = part.get_element(f&#34;//{container_name}&#34;)
            # Implemented style types
            # if tagname not in registered_styles:
            #    raise NotImplementedError(tagname)
            duplicate = part.get_style(family, stylename)
            if duplicate is not None:
                duplicate.delete()
            dest.append(style)
            # Copy images from the header/footer
            if tagname == &#34;style:master-page&#34;:
                query = &#34;descendant::draw:image&#34;
                for image in style.get_elements(query):
                    url = image.url  # type: ignore
                    part_url = document.get_part(url)
                    # Manually add the part to keep the name
                    self.set_part(url, part_url)  # type: ignore
                    media_type = document_manifest.get_media_type(url)
                    manifest.add_full_path(url, media_type)  # type: ignore
            # Copy images from the fill-image
            elif tagname == &#34;draw:fill-image&#34;:
                url = style.url  # type: ignore
                part_url = document.get_part(url)
                self.set_part(url, part_url)  # type: ignore
                media_type = document_manifest.get_media_type(url)
                manifest.add_full_path(url, media_type)  # type: ignore

    def add_page_break_style(self) -&gt; None:
        &#34;&#34;&#34;Ensure that the document contains the style required for a manual page break.

        Then a manual page break can be added to the document with:
            from paragraph import PageBreak
            ...
            document.body.append(PageBreak())

        Note: this style uses the property &#39;fo:break-after&#39;, another
        possibility could be the property &#39;fo:break-before&#39;
        &#34;&#34;&#34;
        if existing := self.get_style(  # noqa: SIM102
            family=&#34;paragraph&#34;,
            name_or_element=&#34;odfdopagebreak&#34;,
        ):
            if properties := existing.get_properties():  # noqa: SIM102
                if properties[&#34;fo:break-after&#34;] == &#34;page&#34;:
                    return
        style = (
            &#39;&lt;style:style style:family=&#34;paragraph&#34; style:parent-style-name=&#34;Standard&#34; &#39;
            &#39;style:name=&#34;odfdopagebreak&#34;&gt;&#39;
            &#39;&lt;style:paragraph-properties fo:break-after=&#34;page&#34;/&gt;&lt;/style:style&gt;&#39;
        )
        self.insert_style(style, automatic=False)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="odfdo.document.Document.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>template: str | Path | io.BytesIO = 'text') ‑> <a title="odfdo.document.Document" href="#odfdo.document.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a Document from a template.</p>
<p>The template argument is expected to be the path to a ODF template.</p>
<h2 id="arguments">Arguments</h2>
<p>template &ndash; str or Path or file-like (io.BytesIO)</p>
<p>Return : ODF document &ndash; Document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new(cls, template: str | Path | io.BytesIO = &#34;text&#34;) -&gt; Document:
    &#34;&#34;&#34;Create a Document from a template.

    The template argument is expected to be the path to a ODF template.

    Arguments:

        template -- str or Path or file-like (io.BytesIO)

    Return : ODF document -- Document
    &#34;&#34;&#34;
    container = container_from_template(template)
    return cls(container)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.document.Document.body"><code class="name">var <span class="ident">body</span> : <a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></code></dt>
<dd>
<div class="desc"><p>Return the body element of the content part, where actual content
is stored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def body(self) -&gt; Element:
    &#34;&#34;&#34;Return the body element of the content part, where actual content
    is stored.
    &#34;&#34;&#34;
    if self.__body is None:
        self.__body = self.content.body
    return self.__body</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.clone"><code class="name">var <span class="ident">clone</span> : <a title="odfdo.document.Document" href="#odfdo.document.Document">Document</a></code></dt>
<dd>
<div class="desc"><p>Return an exact copy of the document.</p>
<p>Return: Document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clone(self) -&gt; Document:
    &#34;&#34;&#34;Return an exact copy of the document.

    Return: Document
    &#34;&#34;&#34;
    clone = object.__new__(self.__class__)
    for name in self.__dict__:
        if name == &#34;_Document__body&#34;:
            setattr(clone, name, None)
        elif name == &#34;_Document__xmlparts&#34;:
            setattr(clone, name, {})
        elif name == &#34;container&#34;:
            if not self.container:
                raise ValueError(&#34;Empty Container&#34;)
            setattr(clone, name, self.container.clone)
        else:
            value = deepcopy(getattr(self, name))
            setattr(clone, name, value)
    return clone</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.content"><code class="name">var <span class="ident">content</span> : <a title="odfdo.content.Content" href="content.html#odfdo.content.Content">Content</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self) -&gt; Content:
    content: Content | None = self.get_part(ODF_CONTENT)  # type:ignore
    if content is None:
        raise ValueError(&#34;Empty Content&#34;)
    return content</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.manifest"><code class="name">var <span class="ident">manifest</span> : <a title="odfdo.manifest.Manifest" href="manifest.html#odfdo.manifest.Manifest">Manifest</a></code></dt>
<dd>
<div class="desc"><p>Return the manifest part (manifest.xml) of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def manifest(self) -&gt; Manifest:
    &#34;&#34;&#34;Return the manifest part (manifest.xml) of the document.&#34;&#34;&#34;
    manifest = self.get_part(ODF_MANIFEST)
    if manifest is None or not isinstance(manifest, Manifest):
        raise ValueError(&#34;Empty Manifest&#34;)
    return manifest</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.meta"><code class="name">var <span class="ident">meta</span> : <a title="odfdo.meta.Meta" href="meta.html#odfdo.meta.Meta">Meta</a></code></dt>
<dd>
<div class="desc"><p>Return the meta part (meta.xml) of the document, where meta data
are stored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def meta(self) -&gt; Meta:
    &#34;&#34;&#34;Return the meta part (meta.xml) of the document, where meta data
    are stored.&#34;&#34;&#34;
    metadata = self.get_part(ODF_META)
    if metadata is None or not isinstance(metadata, Meta):
        raise ValueError(&#34;Empty Meta&#34;)
    return metadata</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.mimetype"><code class="name">var <span class="ident">mimetype</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mimetype(self) -&gt; str:
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    return self.container.mimetype</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.path"><code class="name">var <span class="ident">path</span> : pathlib.Path | None</code></dt>
<dd>
<div class="desc"><p>Shortcut to Document.Container.path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Path | None:
    &#34;&#34;&#34;Shortcut to Document.Container.path.&#34;&#34;&#34;
    if not self.container:
        return None
    return self.container.path</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.styles"><code class="name">var <span class="ident">styles</span> : <a title="odfdo.styles.Styles" href="styles.html#odfdo.styles.Styles">Styles</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def styles(self) -&gt; Styles:
    styles: Styles | None = self.get_part(ODF_STYLES)  # type:ignore
    if styles is None:
        raise ValueError(&#34;Empty Styles&#34;)
    return styles</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.document.Document.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, path_or_file: str | Path) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a file from a path or a file-like object in the container.</p>
<p>Return the full path to reference in the content.</p>
<h2 id="arguments">Arguments</h2>
<p>path_or_file &ndash; str or Path or file-like</p>
<p>Return: str (URI)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self, path_or_file: str | Path) -&gt; str:
    &#34;&#34;&#34;Insert a file from a path or a file-like object in the container.

    Return the full path to reference in the content.

    Arguments:

        path_or_file -- str or Path or file-like

    Return: str (URI)
    &#34;&#34;&#34;
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    name = &#34;&#34;
    # Folder for added files (FIXME hard-coded and copied)
    manifest = self.manifest
    medias = manifest.get_paths()
    # uuid = str(uuid4())

    if isinstance(path_or_file, (str, Path)):
        path = Path(path_or_file)
        extension = path.suffix.lower()
        name = f&#34;{path.stem}{extension}&#34;
        if posixpath.join(&#34;Pictures&#34;, name) in medias:
            name = f&#34;{path.stem}_{uuid4()}{extension}&#34;
    else:
        path = None
        name = getattr(path_or_file, &#34;name&#34;, None)
        if not name:
            name = str(uuid4())
    media_type, _encoding = guess_type(name)
    if not media_type:
        media_type = &#34;application/octet-stream&#34;
    if manifest.get_media_type(&#34;Pictures/&#34;) is None:
        manifest.add_full_path(&#34;Pictures/&#34;)
    full_path = posixpath.join(&#34;Pictures&#34;, name)
    if path is None:
        self.container.set_part(full_path, path_or_file.read())
    else:
        self.container.set_part(full_path, path.read_bytes())
    manifest.add_full_path(full_path, media_type)
    return full_path</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.add_page_break_style"><code class="name flex">
<span>def <span class="ident">add_page_break_style</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that the document contains the style required for a manual page break.</p>
<p>Then a manual page break can be added to the document with:
from paragraph import PageBreak
&hellip;
document.body.append(PageBreak())</p>
<p>Note: this style uses the property 'fo:break-after', another
possibility could be the property 'fo:break-before'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page_break_style(self) -&gt; None:
    &#34;&#34;&#34;Ensure that the document contains the style required for a manual page break.

    Then a manual page break can be added to the document with:
        from paragraph import PageBreak
        ...
        document.body.append(PageBreak())

    Note: this style uses the property &#39;fo:break-after&#39;, another
    possibility could be the property &#39;fo:break-before&#39;
    &#34;&#34;&#34;
    if existing := self.get_style(  # noqa: SIM102
        family=&#34;paragraph&#34;,
        name_or_element=&#34;odfdopagebreak&#34;,
    ):
        if properties := existing.get_properties():  # noqa: SIM102
            if properties[&#34;fo:break-after&#34;] == &#34;page&#34;:
                return
    style = (
        &#39;&lt;style:style style:family=&#34;paragraph&#34; style:parent-style-name=&#34;Standard&#34; &#39;
        &#39;style:name=&#34;odfdopagebreak&#34;&gt;&#39;
        &#39;&lt;style:paragraph-properties fo:break-after=&#34;page&#34;/&gt;&lt;/style:style&gt;&#39;
    )
    self.insert_style(style, automatic=False)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.del_part"><code class="name flex">
<span>def <span class="ident">del_part</span></span>(<span>self, path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Mark a part for deletion. The path is relative to the archive,
e.g. "Pictures/1003200258912EB1C3.jpg"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_part(self, path: str) -&gt; None:
    &#34;&#34;&#34;Mark a part for deletion. The path is relative to the archive,
    e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;
    &#34;&#34;&#34;
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    path = _get_part_path(path)
    cls = _get_part_class(path)
    if path == ODF_MANIFEST or cls is not None:
        raise ValueError(f&#34;part &#39;{path}&#39; is mandatory&#34;)
    self.container.del_part(path)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.delete_styles"><code class="name flex">
<span>def <span class="ident">delete_styles</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all style information from content and all styles.</p>
<p>Return: number of deleted styles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_styles(self) -&gt; int:
    &#34;&#34;&#34;Remove all style information from content and all styles.

    Return: number of deleted styles
    &#34;&#34;&#34;
    # First remove references to styles
    for element in self.get_styled_elements():
        for attribute in (
            &#34;text:style-name&#34;,
            &#34;draw:style-name&#34;,
            &#34;draw:text-style-name&#34;,
            &#34;table:style-name&#34;,
            &#34;style:page-layout-name&#34;,
        ):
            try:
                element.del_attribute(attribute)
            except KeyError:
                continue
    # Then remove supposedly orphaned styles
    deleted = 0
    for style in self.get_styles():
        if style.name is None:  # type: ignore
            # Don&#39;t delete default styles
            continue
        # elif type(style) is odf_master_page:
        #    # Don&#39;t suppress header and footer, just styling was removed
        #    continue
        style.delete()
        deleted += 1
    return deleted</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_formated_meta"><code class="name flex">
<span>def <span class="ident">get_formated_meta</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return meta informations as text, with some formatting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_formated_meta(self) -&gt; str:
    &#34;&#34;&#34;Return meta informations as text, with some formatting.&#34;&#34;&#34;
    result: list[str] = []

    # Simple values
    def print_info(name: str, value: Any) -&gt; None:
        if value:
            result.append(f&#34;{name}: {value}&#34;)

    meta = self.meta
    print_info(&#34;Title&#34;, meta.get_title())
    print_info(&#34;Subject&#34;, meta.get_subject())
    print_info(&#34;Language&#34;, meta.get_language())
    print_info(&#34;Modification date&#34;, meta.get_modification_date())
    print_info(&#34;Creation date&#34;, meta.get_creation_date())
    print_info(&#34;Initial creator&#34;, meta.get_initial_creator())
    print_info(&#34;Keyword&#34;, meta.get_keywords())
    print_info(&#34;Editing duration&#34;, meta.get_editing_duration())
    print_info(&#34;Editing cycles&#34;, meta.get_editing_cycles())
    print_info(&#34;Generator&#34;, meta.get_generator())

    # Statistic
    result.append(&#34;Statistic:&#34;)
    statistic = meta.get_statistic()
    if statistic:
        for name, data in statistic.items():
            result.append(f&#34;  - {name[5:].replace(&#39;-&#39;, &#39; &#39;).capitalize()}: {data}&#34;)

    # User defined metadata
    result.append(&#34;User defined metadata:&#34;)
    user_metadata = meta.get_user_defined_metadata()
    for name, data2 in user_metadata.items():
        result.append(f&#34;  - {name}: {data2}&#34;)

    # And the description
    print_info(&#34;Description&#34;, meta.get_description())

    return &#34;\n&#34;.join(result) + &#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_formatted_text"><code class="name flex">
<span>def <span class="ident">get_formatted_text</span></span>(<span>self, rst_mode: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return content as text, with some formatting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_formatted_text(self, rst_mode: bool = False) -&gt; str:
    &#34;&#34;&#34;Return content as text, with some formatting.&#34;&#34;&#34;
    # For the moment, only &#34;type=&#39;text&#39;&#34;
    doc_type = self.get_type()
    if doc_type == &#34;spreadsheet&#34;:
        return self._tables_csv()
    if doc_type in {
        &#34;text&#34;,
        &#34;text-template&#34;,
        &#34;presentation&#34;,
        &#34;presentation-template&#34;,
    }:
        return self._formatted_text(rst_mode)
    raise NotImplementedError(f&#34;Type of document &#39;{doc_type}&#39; not supported yet&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_part"><code class="name flex">
<span>def <span class="ident">get_part</span></span>(<span>self, path: str) ‑> <a title="odfdo.xmlpart.XmlPart" href="xmlpart.html#odfdo.xmlpart.XmlPart">XmlPart</a> | str | bytes | None</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bytes of the given part. The path is relative to the
archive, e.g. "Pictures/1003200258912EB1C3.jpg".</p>
<p>'content', 'meta', 'settings', 'styles' and 'manifest' are shortcuts
to the real path, e.g. content.xml, and return a dedicated object with
its own API.</p>
<p>path formated as URI, so always use '/' separator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:
    &#34;&#34;&#34;Return the bytes of the given part. The path is relative to the
    archive, e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;.

    &#39;content&#39;, &#39;meta&#39;, &#39;settings&#39;, &#39;styles&#39; and &#39;manifest&#39; are shortcuts
    to the real path, e.g. content.xml, and return a dedicated object with
    its own API.

    path formated as URI, so always use &#39;/&#39; separator
    &#34;&#34;&#34;
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    # &#34;./ObjectReplacements/Object 1&#34;
    path = path.lstrip(&#34;./&#34;)
    path = _get_part_path(path)
    cls = _get_part_class(path)
    # Raw bytes
    if cls is None:
        return self.container.get_part(path)
    # XML part
    part = self.__xmlparts.get(path)
    if part is None:
        self.__xmlparts[path] = part = cls(path, self.container)
    return part</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_parts"><code class="name flex">
<span>def <span class="ident">get_parts</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return available part names with path inside the archive, e.g.
['content.xml', &hellip;, 'Pictures/100000000000032000000258912EB1C3.jpg']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parts(self) -&gt; list[str]:
    &#34;&#34;&#34;Return available part names with path inside the archive, e.g.
    [&#39;content.xml&#39;, ..., &#39;Pictures/100000000000032000000258912EB1C3.jpg&#39;]
    &#34;&#34;&#34;
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    return self.container.get_parts()</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_style"><code class="name flex">
<span>def <span class="ident">get_style</span></span>(<span>self, family: str, name_or_element: str | Style | None = None, display_name: str | None = None) ‑> <a title="odfdo.style.Style" href="style.html#odfdo.style.Style">Style</a> | None</span>
</code></dt>
<dd>
<div class="desc"><p>Return the style uniquely identified by the name/family pair. If
the argument is already a style object, it will return it.</p>
<p>If the name is None, the default style is fetched.</p>
<p>If the name is not the internal name but the name you gave in a
desktop application, use display_name instead.</p>
<h2 id="arguments">Arguments</h2>
<p>family &ndash; 'paragraph', 'text',
'graphic', 'table', 'list',
'number', 'page-layout', 'master-page'</p>
<p>name &ndash; str or Element or None</p>
<p>display_name &ndash; str</p>
<p>Return: Style or None if not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_style(
    self,
    family: str,
    name_or_element: str | Style | None = None,
    display_name: str | None = None,
) -&gt; Style | None:
    &#34;&#34;&#34;Return the style uniquely identified by the name/family pair. If
    the argument is already a style object, it will return it.

    If the name is None, the default style is fetched.

    If the name is not the internal name but the name you gave in a
    desktop application, use display_name instead.

    Arguments:

        family -- &#39;paragraph&#39;, &#39;text&#39;,  &#39;graphic&#39;, &#39;table&#39;, &#39;list&#39;,
                  &#39;number&#39;, &#39;page-layout&#39;, &#39;master-page&#39;

        name -- str or Element or None

        display_name -- str

    Return: Style or None if not found.
    &#34;&#34;&#34;
    # 1. content.xml
    element = self.content.get_style(
        family, name_or_element=name_or_element, display_name=display_name
    )
    if element is not None:
        return element
    # 2. styles.xml
    return self.styles.get_style(
        family,
        name_or_element=name_or_element,
        display_name=display_name,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_styled_elements"><code class="name flex">
<span>def <span class="ident">get_styled_elements</span></span>(<span>self, name: str = '') ‑> list[<a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Brute-force to find paragraphs, tables, etc. using the given style
name (or all by default).</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>Return: list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_styled_elements(self, name: str = &#34;&#34;) -&gt; list[Element]:
    &#34;&#34;&#34;Brute-force to find paragraphs, tables, etc. using the given style
    name (or all by default).

    Arguments:

        name -- str

    Return: list
    &#34;&#34;&#34;
    # Header, footer, etc. have styles too
    return self.content.root.get_styled_elements(
        name
    ) + self.styles.root.get_styled_elements(name)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_styles"><code class="name flex">
<span>def <span class="ident">get_styles</span></span>(<span>self, family: str | bytes = '', automatic: bool = False) ‑> list[<a title="odfdo.style.Style" href="style.html#odfdo.style.Style">Style</a> | <a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_styles(
    self,
    family: str | bytes = &#34;&#34;,
    automatic: bool = False,
) -&gt; list[Style | Element]:
    # compatibility with old versions:

    if isinstance(family, bytes):
        family = bytes_to_str(family)
    return self.content.get_styles(family=family) + self.styles.get_styles(
        family=family, automatic=automatic
    )</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.get_type"><code class="name flex">
<span>def <span class="ident">get_type</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ODF type (also called class) of this document.</p>
<p>Return: 'chart', 'database', 'formula', 'graphics',
'graphics-template', 'image', 'presentation',
'presentation-template', 'spreadsheet', 'spreadsheet-template',
'text', 'text-master', 'text-template' or 'text-web'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type(self) -&gt; str:
    &#34;&#34;&#34;Get the ODF type (also called class) of this document.

    Return: &#39;chart&#39;, &#39;database&#39;, &#39;formula&#39;, &#39;graphics&#39;,
        &#39;graphics-template&#39;, &#39;image&#39;, &#39;presentation&#39;,
        &#39;presentation-template&#39;, &#39;spreadsheet&#39;, &#39;spreadsheet-template&#39;,
        &#39;text&#39;, &#39;text-master&#39;, &#39;text-template&#39; or &#39;text-web&#39;
    &#34;&#34;&#34;
    # The mimetype must be with the form:
    # application/vnd.oasis.opendocument.text

    # Isolate and return the last part
    return self.mimetype.rsplit(&#34;.&#34;, 1)[-1]</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.insert_style"><code class="name flex">
<span>def <span class="ident">insert_style</span></span>(<span>self, style: Style | str, name: str = '', automatic: bool = False, default: bool = False) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Insert the given style object in the document, as required by the
style family and type.</p>
<p>The style is expected to be a common style with a name. In case it
was created with no name, the given can be set on the fly.</p>
<p>If automatic is True, the style will be inserted as an automatic
style.</p>
<p>If default is True, the style will be inserted as a default style and
would replace any existing default style of the same family. Any name
or display name would be ignored.</p>
<p>Automatic and default arguments are mutually exclusive.</p>
<p>All styles can't be used as default styles. Default styles are
allowed for the following families: paragraph, text, section, table,
table-column, table-row, table-cell, table-page, chart, drawing-page,
graphic, presentation, control and ruby.</p>
<h2 id="arguments">Arguments</h2>
<p>style &ndash; Style or str</p>
<p>name &ndash; str</p>
<p>automatic &ndash; bool</p>
<p>default &ndash; bool</p>
<p>Return : style name &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_style(  # noqa: C901
    self,
    style: Style | str,
    name: str = &#34;&#34;,
    automatic: bool = False,
    default: bool = False,
) -&gt; Any:
    &#34;&#34;&#34;Insert the given style object in the document, as required by the
    style family and type.

    The style is expected to be a common style with a name. In case it
    was created with no name, the given can be set on the fly.

    If automatic is True, the style will be inserted as an automatic
    style.

    If default is True, the style will be inserted as a default style and
    would replace any existing default style of the same family. Any name
    or display name would be ignored.

    Automatic and default arguments are mutually exclusive.

    All styles can&#39;t be used as default styles. Default styles are
    allowed for the following families: paragraph, text, section, table,
    table-column, table-row, table-cell, table-page, chart, drawing-page,
    graphic, presentation, control and ruby.

    Arguments:

        style -- Style or str

        name -- str

        automatic -- bool

        default -- bool

    Return : style name -- str
    &#34;&#34;&#34;

    # if style is a str, assume it is the Style definition
    if isinstance(style, str):
        style_element: Style = Element.from_tag(style)  # type: ignore
    else:
        style_element = style
    if not isinstance(style_element, Element):
        raise TypeError(f&#34;Unknown Style type: &#39;{style!r}&#39;&#34;)

    # Get family and name
    family = self._pseudo_style_attribute(style_element, &#34;family&#34;)
    if not name:
        name = self._pseudo_style_attribute(style_element, &#34;name&#34;)

    # Master page style
    if family == &#34;master-page&#34;:
        existing, style_container = self._insert_style_get_master_page(family, name)
    # Font face declarations
    elif family == &#34;font-face&#34;:
        if default:
            existing, style_container = self._insert_style_get_font_face_default(
                family, name
            )
        else:
            existing, style_container = self._insert_style_get_font_face(
                family, name
            )
    # page layout style
    elif family == &#34;page-layout&#34;:
        existing, style_container = self._insert_style_get_page_layout(family, name)
    # Common style
    elif family in FAMILY_ODF_STD or family in {&#34;number&#34;}:
        existing, style_container = self._insert_style_standard(
            style_element, name, family, automatic, default
        )
    elif not family and style_element.__class__.__name__ == &#34;DrawFillImage&#34;:
        # special case for &#39;draw:fill-image&#39; pseudo style
        existing, style_container = self._insert_style_get_draw_fill_image(name)
    # Invalid style
    else:
        raise ValueError(
            &#34;Invalid style: &#34;
            f&#34;{style_element}, tag:{style_element.tag}, family:{family}&#34;
        )

    # Insert it!
    if existing is not None:
        style_container.delete(existing)
    style_container.append(style_element)
    return self._pseudo_style_attribute(style_element, &#34;name&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.merge_styles_from"><code class="name flex">
<span>def <span class="ident">merge_styles_from</span></span>(<span>self, document: <a title="odfdo.document.Document" href="#odfdo.document.Document">Document</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Copy all the styles of a document into ourself.</p>
<p>Styles with the same type and name will be replaced, so only unique
styles will be preserved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_styles_from(self, document: Document) -&gt; None:
    &#34;&#34;&#34;Copy all the styles of a document into ourself.

    Styles with the same type and name will be replaced, so only unique
    styles will be preserved.
    &#34;&#34;&#34;
    manifest = self.manifest
    document_manifest = document.manifest
    for style in document.get_styles():
        tagname = style.tag
        family = self._pseudo_style_attribute(style, &#34;family&#34;)
        stylename = style.name  # type: ignore
        container = style.parent
        container_name = container.tag  # type: ignore
        partname = container.parent.tag  # type: ignore
        # The destination part
        if partname == &#34;office:document-styles&#34;:
            part: Content | Styles = self.styles
        elif partname == &#34;office:document-content&#34;:
            part = self.content
        else:
            raise NotImplementedError(partname)
        # Implemented containers
        if container_name not in {
            &#34;office:styles&#34;,
            &#34;office:automatic-styles&#34;,
            &#34;office:master-styles&#34;,
            &#34;office:font-face-decls&#34;,
        }:
            raise NotImplementedError(container_name)
        dest = part.get_element(f&#34;//{container_name}&#34;)
        # Implemented style types
        # if tagname not in registered_styles:
        #    raise NotImplementedError(tagname)
        duplicate = part.get_style(family, stylename)
        if duplicate is not None:
            duplicate.delete()
        dest.append(style)
        # Copy images from the header/footer
        if tagname == &#34;style:master-page&#34;:
            query = &#34;descendant::draw:image&#34;
            for image in style.get_elements(query):
                url = image.url  # type: ignore
                part_url = document.get_part(url)
                # Manually add the part to keep the name
                self.set_part(url, part_url)  # type: ignore
                media_type = document_manifest.get_media_type(url)
                manifest.add_full_path(url, media_type)  # type: ignore
        # Copy images from the fill-image
        elif tagname == &#34;draw:fill-image&#34;:
            url = style.url  # type: ignore
            part_url = document.get_part(url)
            self.set_part(url, part_url)  # type: ignore
            media_type = document_manifest.get_media_type(url)
            manifest.add_full_path(url, media_type)  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, target: str | Path | io.BytesIO | None = None, packaging: str = 'zip', pretty: bool = False, backup: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Save the document, at the same place it was opened or at the given
target path. Target can also be a file-like object. It can be saved
as a Zip file (default) or as files in a folder (for debugging
purpose). XML parts can be pretty printed.</p>
<h2 id="arguments">Arguments</h2>
<p>target &ndash; str or file-like object</p>
<p>packaging &ndash; 'zip' or 'folder'</p>
<p>pretty &ndash; bool</p>
<p>backup &ndash; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(
    self,
    target: str | Path | io.BytesIO | None = None,
    packaging: str = &#34;zip&#34;,
    pretty: bool = False,
    backup: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Save the document, at the same place it was opened or at the given
    target path. Target can also be a file-like object. It can be saved
    as a Zip file (default) or as files in a folder (for debugging
    purpose). XML parts can be pretty printed.

    Arguments:

        target -- str or file-like object

        packaging -- &#39;zip&#39; or &#39;folder&#39;

        pretty -- bool

        backup -- bool
    &#34;&#34;&#34;
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    # Some advertising
    self.meta.set_generator_default()
    # Synchronize data with container
    container = self.container
    for path, part in self.__xmlparts.items():
        if part is not None:
            container.set_part(path, part.serialize(pretty))
    # Save the container
    container.save(target, packaging=packaging, backup=backup)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.set_part"><code class="name flex">
<span>def <span class="ident">set_part</span></span>(<span>self, path: str, data: bytes) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the bytes of the given part. The path is relative to the
archive, e.g. "Pictures/1003200258912EB1C3.jpg".</p>
<p>path formated as URI, so always use '/' separator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_part(self, path: str, data: bytes) -&gt; None:
    &#34;&#34;&#34;Set the bytes of the given part. The path is relative to the
    archive, e.g. &#34;Pictures/1003200258912EB1C3.jpg&#34;.

    path formated as URI, so always use &#39;/&#39; separator
    &#34;&#34;&#34;
    if not self.container:
        raise ValueError(&#34;Empty Container&#34;)
    # &#34;./ObjectReplacements/Object 1&#34;
    path = path.lstrip(&#34;./&#34;)
    path = _get_part_path(path)
    cls = _get_part_class(path)
    # XML part overwritten
    if cls is not None:
        with suppress(KeyError):
            self.__xmlparts[path]
    self.container.set_part(path, data)</code></pre>
</details>
</dd>
<dt id="odfdo.document.Document.show_styles"><code class="name flex">
<span>def <span class="ident">show_styles</span></span>(<span>self, automatic: bool = True, common: bool = True, properties: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_styles(
    self,
    automatic: bool = True,
    common: bool = True,
    properties: bool = False,
) -&gt; str:
    infos = []
    for style in self.get_styles():
        try:
            name = style.name  # type: ignore
        except AttributeError:
            print(&#34;--------------&#34;)
            print(style.__class__)
            print(style.serialize())
            raise
        if style.__class__.__name__ == &#34;DrawFillImage&#34;:
            family = &#34;&#34;
        else:
            family = str(style.family)  # type: ignore
        parent = style.parent
        is_auto = parent and parent.tag == &#34;office:automatic-styles&#34;
        if is_auto and automatic is False or not is_auto and common is False:
            continue
        is_used = bool(self.get_styled_elements(name))
        infos.append(
            {
                &#34;type&#34;: &#34;auto  &#34; if is_auto else &#34;common&#34;,
                &#34;used&#34;: &#34;y&#34; if is_used else &#34;n&#34;,
                &#34;family&#34;: family,
                &#34;parent&#34;: self._pseudo_style_attribute(style, &#34;parent_style&#34;) or &#34;&#34;,
                &#34;name&#34;: name or &#34;&#34;,
                &#34;display_name&#34;: self._pseudo_style_attribute(style, &#34;display_name&#34;)
                or &#34;&#34;,
                &#34;properties&#34;: style.get_properties() if properties else None,  # type: ignore
            }
        )
    if not infos:
        return &#34;&#34;
    # Sort by family and name
    infos.sort(key=itemgetter(&#34;family&#34;, &#34;name&#34;))
    # Show common and used first
    infos.sort(key=itemgetter(&#34;type&#34;, &#34;used&#34;), reverse=True)
    max_family = str(max([len(x[&#34;family&#34;]) for x in infos]))  # type: ignore
    max_parent = str(max([len(x[&#34;parent&#34;]) for x in infos]))  # type: ignore
    formater = (
        &#34;%(type)s used:%(used)s family:%(family)-0&#34;
        + max_family
        + &#34;s parent:%(parent)-0&#34;
        + max_parent
        + &#34;s name:%(name)s&#34;
    )
    output = []
    for info in infos:
        line = formater % info
        if info[&#34;display_name&#34;]:
            line += &#34; display_name:&#34; + info[&#34;display_name&#34;]  # type: ignore
        output.append(line)
        if info[&#34;properties&#34;]:
            for name, value in info[&#34;properties&#34;].items():  # type: ignore
                output.append(f&#34;   - {name}: {value}&#34;)
    output.append(&#34;&#34;)
    return &#34;\n&#34;.join(output)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="odfdo" href="index.html">odfdo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="odfdo.document.container_from_template" href="#odfdo.document.container_from_template">container_from_template</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="odfdo.document.Document" href="#odfdo.document.Document">Document</a></code></h4>
<ul class="">
<li><code><a title="odfdo.document.Document.add_file" href="#odfdo.document.Document.add_file">add_file</a></code></li>
<li><code><a title="odfdo.document.Document.add_page_break_style" href="#odfdo.document.Document.add_page_break_style">add_page_break_style</a></code></li>
<li><code><a title="odfdo.document.Document.body" href="#odfdo.document.Document.body">body</a></code></li>
<li><code><a title="odfdo.document.Document.clone" href="#odfdo.document.Document.clone">clone</a></code></li>
<li><code><a title="odfdo.document.Document.content" href="#odfdo.document.Document.content">content</a></code></li>
<li><code><a title="odfdo.document.Document.del_part" href="#odfdo.document.Document.del_part">del_part</a></code></li>
<li><code><a title="odfdo.document.Document.delete_styles" href="#odfdo.document.Document.delete_styles">delete_styles</a></code></li>
<li><code><a title="odfdo.document.Document.get_formated_meta" href="#odfdo.document.Document.get_formated_meta">get_formated_meta</a></code></li>
<li><code><a title="odfdo.document.Document.get_formatted_text" href="#odfdo.document.Document.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.document.Document.get_part" href="#odfdo.document.Document.get_part">get_part</a></code></li>
<li><code><a title="odfdo.document.Document.get_parts" href="#odfdo.document.Document.get_parts">get_parts</a></code></li>
<li><code><a title="odfdo.document.Document.get_style" href="#odfdo.document.Document.get_style">get_style</a></code></li>
<li><code><a title="odfdo.document.Document.get_styled_elements" href="#odfdo.document.Document.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.document.Document.get_styles" href="#odfdo.document.Document.get_styles">get_styles</a></code></li>
<li><code><a title="odfdo.document.Document.get_type" href="#odfdo.document.Document.get_type">get_type</a></code></li>
<li><code><a title="odfdo.document.Document.insert_style" href="#odfdo.document.Document.insert_style">insert_style</a></code></li>
<li><code><a title="odfdo.document.Document.manifest" href="#odfdo.document.Document.manifest">manifest</a></code></li>
<li><code><a title="odfdo.document.Document.merge_styles_from" href="#odfdo.document.Document.merge_styles_from">merge_styles_from</a></code></li>
<li><code><a title="odfdo.document.Document.meta" href="#odfdo.document.Document.meta">meta</a></code></li>
<li><code><a title="odfdo.document.Document.mimetype" href="#odfdo.document.Document.mimetype">mimetype</a></code></li>
<li><code><a title="odfdo.document.Document.new" href="#odfdo.document.Document.new">new</a></code></li>
<li><code><a title="odfdo.document.Document.path" href="#odfdo.document.Document.path">path</a></code></li>
<li><code><a title="odfdo.document.Document.save" href="#odfdo.document.Document.save">save</a></code></li>
<li><code><a title="odfdo.document.Document.set_part" href="#odfdo.document.Document.set_part">set_part</a></code></li>
<li><code><a title="odfdo.document.Document.show_styles" href="#odfdo.document.Document.show_styles">show_styles</a></code></li>
<li><code><a title="odfdo.document.Document.styles" href="#odfdo.document.Document.styles">styles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>