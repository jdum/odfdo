{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"odfdo","text":"<p>Python library for OpenDocument format (ODF)</p> <p></p> <p><code>odfdo</code> is a Python3 library implementing the ISO/IEC 26300 OpenDocument Format standard.</p> <p>Project: https://github.com/jdum/odfdo</p> <p>Author: jerome.dumonteil@gmail.com</p> <p>License: Apache License, Version 2.0</p> <p><code>odfdo</code> is a derivative work of the former <code>lpod-python</code> project.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Installation from Pypi (recommended):</p> <pre><code>pip install odfdo\n</code></pre> <p>Installation from sources (requiring setuptools):</p> <pre><code>pip install .\n</code></pre> <p>After installation from sources, you can check everything is working (some requirements: <code>pytest</code>, Pillow, \u2026):</p> <pre><code>pytest\n</code></pre> <p>The tests should run for a few seconds or minutes and issue no error.</p>"},{"location":"index.html#usage","title":"Usage","text":"<pre><code>from odfdo import Document, Paragraph\n\ndoc = Document('text')\ndoc.body.append(Paragraph(\"Hello world!\"))\ndoc.save(\"hello.odt\")\n</code></pre>"},{"location":"index.html#tldr","title":"tl;dr","text":"<p>\u2018Intended Audience :: Developers\u2019</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>There is no detailed documentation or tutorial, but:</p> <ul> <li>the <code>recipes</code> folder contains more than 50 working sample scripts,</li> <li>the <code>doc</code> folder contains an auto generated documentation.</li> </ul> <p>When installing odfdo, a few scripts are installed:</p> <ul> <li><code>odfdo-diff</code>: show a diff between two .odt document.</li> <li><code>odfdo-folder</code>: convert standard ODF file to folder and files, and reverse.</li> <li><code>odfdo-show</code>: dump text from an ODF file to the standard output, and optionally styles and meta informations.</li> <li><code>odfdo-styles</code>: command line interface tool to manipulate styles of ODF files.</li> <li><code>odfdo-replace</code>: find a pattern (regex) in an ODF file and replace by some string.</li> <li><code>odfdo-highlight</code>: highlight the text matching a pattern (regex) in an ODF file.</li> <li><code>odfdo-headers</code>: print the headers of an ODF file.</li> <li><code>odfdo-table-shrink</code>: shrink tables to optimize width and height.</li> </ul> <p>About styles: the best way to apply style is by merging styles from a template document into your generated document (See <code>odfdo-styles</code> script). Styles are a complex matter in ODF, so trying to generate styles programmatically is not recommended.</p>"},{"location":"index.html#limitations","title":"Limitations","text":"<p><code>odfdo</code> is intended to facilitate the generation of ODF documents, nevertheless a basic knowledge of the ODF format is necessary.</p> <p>ODF document rendering can vary greatly from software to software. Especially the \u201cstyles\u201d of the document allow an adaptation of the rendering for a particular software.</p> <p>The best (only ?) way to apply style is by merging styles from a template document into your generated document. However a few recipes show how to make programmatically some basic styles: <code>create_basic_text_styles</code>, <code>add_text_span_styles</code>).</p>"},{"location":"index.html#related-project","title":"Related project","text":"<p>I you work on <code>.ods</code> files (spreadsheet), you may be interested by these scripts using this library to parse/generate <code>.ods</code> files: <code>https://github.com/jdum/odsgenerator</code> and <code>https://github.com/jdum/odsparsator</code></p>"},{"location":"index.html#changes-from-former-lpod-library","title":"Changes from former lpod library","text":"<p><code>lpod-python</code> was written in 2009-2010 as a Python 2.x library, see: <code>https://github.com/lpod/lpod-python</code></p> <p><code>odfdo</code> is an adaptation of this former project. <code>odfdo</code> main changes from <code>lpod</code>:</p> <ul> <li><code>odfdo</code> requires Python version 3.9 to 3.12. For Python 3.6 to 3.8 see previous releases.</li> <li>API change: more pythonic.</li> <li>include recipes.</li> <li>use Apache 2.0 license.</li> </ul>"},{"location":"CHANGES.html","title":"Odfdo Release Notes","text":""},{"location":"CHANGES.html#3710-2024-05-4","title":"[3.7.10] - 2024-05-4","text":"<ul> <li> <p>Refactor to add property getter for some common methods. Original get_*     method is still available and permits detailed requests with parameters.</p> <pre><code>-   Body.tables -&gt; Body.get_tables()\n-   Element.tocs -&gt; Element.get_tocs()\n-   Element.toc -&gt; Element.get_toc()\n-   Element.text_changes -&gt; Element.get_text_changes()\n-   Element.tracked_changes -&gt; Element.get_tracked_changes()\n-   Element.user_defined_list -&gt; Element.get_user_defined_list()\n-   Element.images -&gt; Element.get_images()\n-   Element.frames -&gt; Element.get_frames()\n-   Element.lists -&gt; Element.get_lists()\n-   Element.headers -&gt; Element.get_headers()\n-   Element.spans -&gt; Element.get_spans()\n-   Element.paragraphs -&gt; Element.get_paragraphs()\n-   Element.sections -&gt; Element.get_sections()\n-   Table.rows -&gt; Table.get_rows()\n-   Table.cells -&gt; Table.get_cells()\n-   Table.columns -&gt; Table.get_columns()\n-   Row.cells -&gt; Row.get_cells()\n-   Document.parts -&gt; Document.get_parts()\n-   Container.parts -&gt; Container.get_parts()\n</code></pre> </li> <li> <p>Refactor to add property getter/setter for some common methods. Original get_*     and set_* methods are still available and permit detailed requests with parameters.</p> <pre><code>-   Column.default_cell_style -&gt; Column.get/set_default_cell_style()\n</code></pre> </li> </ul>"},{"location":"CHANGES.html#added","title":"Added","text":"<ul> <li>Added <code>Body.tables</code></li> <li>Added <code>Element.tocs</code></li> <li>Added <code>Element.toc</code></li> <li>Added <code>Element.text_changes</code></li> <li>Added <code>Element.tracked_changes</code></li> <li>Added <code>Element.images</code></li> <li>Added <code>Element.frames</code></li> <li>Added <code>Element.lists</code></li> <li>Added <code>Element.headers</code></li> <li>Added <code>Element.spans</code></li> <li>Added <code>Element.paragraphs</code></li> <li>Added <code>Element.sections</code></li> <li>Added <code>Column.default_cell_style</code></li> <li>Added <code>Table.rows</code></li> <li>Added <code>Table.cells</code></li> <li>Added <code>Table.columns</code></li> <li>Added <code>Row.cells</code></li> <li>Added <code>Document.parts</code></li> <li>Added <code>Container.parts</code></li> </ul>"},{"location":"CHANGES.html#379-2024-05-3","title":"[3.7.9] - 2024-05-3","text":"<ul> <li> <p>Refactor the Body access methods, creating relevant a Body class and related sub-classes. Moved some access method from the Element class to relevant Body sub-classes.</p> </li> <li> <p>Refactor metadata methods to permit access throuh @property (the legacy get_* and set_* methods are still available).</p> </li> <li> <p>Added a few metadata elements from the ODF standard (hyperlink-behaviour, auto-reload, template, print-dateprinted-by)</p> </li> </ul>"},{"location":"CHANGES.html#added_1","title":"Added","text":"<ul> <li>Added <code>MetaAutoReload</code> class</li> <li>Added <code>MetaHyperlinkBehaviour</code> class</li> <li>Added <code>MetaTemplate</code> class</li> <li>Added <code>DcCreatorMixin</code> class</li> <li>Added <code>DcDateMixin</code> class</li> <li>Added <code>Body</code> class</li> <li>Added <code>Chart</code> class</li> <li>Added <code>Database</code> class</li> <li>Added <code>Drawing</code> class</li> <li>Added <code>Image</code> class</li> <li>Added <code>Presentation</code> class</li> <li>Added <code>Spreadsheet</code> class</li> <li>Added <code>Text</code> class (renaming the previous internal <code>Text</code> class to <code>EText</code>)</li> </ul>"},{"location":"CHANGES.html#378-2024-05-2","title":"[3.7.8] - 2024-05-2","text":"<p>Fix embedded chart analysis in documents, see recipe <code>change_values_of_a_chart_inside_a_document.py</code>.</p>"},{"location":"CHANGES.html#added_2","title":"Added","text":"<ul> <li>Added <code>change_values_of_a_chart_inside_a_document.py</code> recipe</li> </ul>"},{"location":"CHANGES.html#changed","title":"Changed","text":"<ul> <li> <p>The \u201cpretty\u201d setting when saving the file always defaults to False. This setting should only be used for debugging purposes</p> </li> <li> <p><code>meta.generator</code> can be used via a @property accessor</p> </li> <li> <p>(Internal change) move body() definition to xmlpart</p> </li> <li> <p>(Internal change) refactoring for future XML feature</p> </li> </ul>"},{"location":"CHANGES.html#fixed","title":"Fixed","text":"<ul> <li> <p>Fix parsing of Table when parent uses \u201ctable:table-rows\u201d kind of wrapper</p> </li> <li> <p>Fix a bug when a Cell contains the valid \u2018NaN\u2019 Decimal number</p> </li> </ul>"},{"location":"CHANGES.html#377-2024-04-1","title":"[3.7.7] - 2024-04-1","text":"<p>Improvement of the <code>lxml</code> dependency support.</p>"},{"location":"CHANGES.html#added_3","title":"Added","text":"<ul> <li> <p>Added a <code>CHANGES.md</code> file</p> </li> <li> <p>Automatic tests for ubuntu-latest, macos-latest, windows-latest</p> </li> </ul>"},{"location":"CHANGES.html#changed_1","title":"Changed","text":"<ul> <li> <p>Now supports a wider range of <code>lxml</code> versions:</p> <ul> <li> <p>python 3.9: lxml version 4.8.0 to 4.9.4</p> </li> <li> <p>python 3.10: lxml version 4.8.0 to 5.1.1</p> </li> <li> <p>python 3.11: lxml version 4.9.4 to 5.2.0 and beyond</p> </li> <li> <p>python 3.12: lxml version 4.9.4 to 5.2.0 and beyond</p> </li> </ul> </li> <li> <p>autogenerated documentation now uses <code>mkdocs</code></p> </li> </ul>"},{"location":"CHANGES.html#fixed_1","title":"Fixed","text":"<ul> <li> <p>Use <code>sys.executable</code> to ensure all tests can pass in a github virtualenv on Windows.</p> </li> <li> <p>Remove import of <code>lxml</code> internal <code>\\_ElementUnicodeResult</code> and <code>\\_ElementUnicodeResult</code> classes.</p> </li> </ul>"},{"location":"CHANGES.html#376-2024-03-30","title":"[3.7.6] - 2024-03-30","text":"<p>Quick fix for the crash with new <code>lxml</code> version 5.1.1</p>"},{"location":"CHANGES.html#fixed_2","title":"Fixed","text":"<pre><code>- Fix crash with `lxml` 5.1.1 by restricting version do 5.1.0\n</code></pre>"},{"location":"CHANGES.html#375-2024-03-23","title":"[3.7.5] - 2024-03-23","text":"<p>Add the method <code>get_cell_background_color</code> to retrieve the background color of a cell in a table.</p>"},{"location":"CHANGES.html#added_4","title":"Added","text":"<ul> <li> <p>Tables: some users need to easily access the background color of cells, including cells without \u201cvalue\u201d content. That was requiring a complex parsing of styles. So a new method: <code>Document.get_cell_background_color(sheet_id, cell_coords)</code>.</p> </li> <li> <p>See the corresponding recipe <code>recipes/get_cell_background_color.py</code> for an exemple of usage.</p> </li> <li> <p>Tables: (related to previous). It is often useful to reduce the table size before working on it, especially if styles apply to whole rows. A method called <code>Table.rstrip()</code> already permitted to remove empty bottom rows and empty right columns. However, a <code>Cell</code> mays have no value but a style (color background for example), and <code>rstrip()</code> was removing such cells. So an new clever method is provided: <code>Table.optimize_width()</code> that shrink the table size, still keeping styled empty cells.</p> </li> <li> <p>To test the actual result of this method, you can use the new script <code>odfdo-table-shrink</code> which is basically a wrapper upon this method. (Note: all this stuff aims to facilitate some feature for the related github project <code>odsparsator</code>).</p> </li> <li> <p><code>repr()</code> method for <code>Cell</code>, <code>Row</code> and <code>Column</code>.</p> </li> <li> <p>Ancillary methods related to above features.</p> </li> </ul>"},{"location":"CHANGES.html#fixed_3","title":"Fixed","text":"<ul> <li><code>Document(path)</code> now accepts a <code>str</code> path starting with <code>~</code> as the path relative to the user home.</li> </ul>"},{"location":"CHANGES.html#changed_2","title":"Changed","text":"<ul> <li> <p>Tables: (related to previous), change the <code>Cell.is_empty()</code> test. A cell is now considered as not empty if part of a <code>span</code> (a cell spanned on several rows or columns). This may induce some changes for parsing scripts. Before that, only the first cell of the span (which actually contains the value) was considered as non empty. Now other cells of the span are not empty (but contain a null value).</p> </li> <li> <p>Minor refactor of code, version updates of dependencies.</p> </li> </ul>"},{"location":"CHANGES.html#374-2024-03-17","title":"[3.7.4] - 2024-03-17","text":"<p>Add a recipe as example of programmatically setting text styles for headers and paragraphs, with basic font and color properties.</p>"},{"location":"CHANGES.html#added_5","title":"Added","text":"<ul> <li> <p>Add recipe <code>create_basic_text_styles</code>.</p> </li> <li> <p>All style fields related to color accept a color name from the CSS list of color.</p> </li> </ul>"},{"location":"CHANGES.html#changed_3","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#373-2024-03-10","title":"[3.7.3] - 2024-03-10","text":"<p>Internal maintenance release.</p>"},{"location":"CHANGES.html#fixed_4","title":"Fixed","text":"<ul> <li>Fix logo link on <code>Pypi</code> page.</li> </ul>"},{"location":"CHANGES.html#changed_4","title":"Changed","text":"<ul> <li> <p>Technical updates from <code>optparse</code> to <code>argparse</code>.</p> </li> <li> <p>Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#372-2024-03-9","title":"[3.7.2] - 2024-03-9","text":"<p>Internal maintenance release.</p>"},{"location":"CHANGES.html#changed_5","title":"Changed","text":"<ul> <li> <p>Use <code>pdoc</code> for autogenerated documentation.</p> </li> <li> <p>Refactor some recipes to use them in a test suit.</p> </li> <li> <p>Code refactor, Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#371-2024-03-3","title":"[3.7.1] - 2024-03-3","text":"<p>Minor performance improvement of script <code>odfdo-headers</code>.</p>"},{"location":"CHANGES.html#changed_6","title":"Changed","text":"<ul> <li>Use better algorithm for script <code>odfdo-headers</code>.</li> </ul>"},{"location":"CHANGES.html#370-2024-03-2","title":"[3.7.0] - 2024-03-2","text":"<p>New script <code>odfdo-headers</code> to print the headers of a <code>ODF</code> file.</p>"},{"location":"CHANGES.html#added_6","title":"Added","text":"<ul> <li>Add script <code>odfdo-headers</code>.</li> </ul>"},{"location":"CHANGES.html#changed_7","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#360-2024-02-25","title":"[3.6.0] - 2024-02-25","text":"<p>New script <code>odfdo-highlight</code> to highlight the text matching a pattern (regex) in a <code>ODF</code> file.</p>"},{"location":"CHANGES.html#added_7","title":"Added","text":"<ul> <li>Add script <code>odfdo-highlight</code>.</li> </ul>"},{"location":"CHANGES.html#changed_8","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#351-2024-02-20","title":"[3.5.1] - 2024-02-20","text":"<p>Fix the update method of <code>Table of Content</code> and add a recipe to show how to update a <code>TOC</code>.</p>"},{"location":"CHANGES.html#added_8","title":"Added","text":"<ul> <li>Add recipe <code>update_a_text_document_with_a_table_of_content</code>.</li> </ul>"},{"location":"CHANGES.html#changed_9","title":"Changed","text":"<ul> <li> <p>Refactor of TOC related code.</p> </li> <li> <p>Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#350-2024-01-27","title":"[3.5.0] - 2024-01-27","text":"<p>2024 release, updated ODF templates and better test suit.</p>"},{"location":"CHANGES.html#changed_10","title":"Changed","text":"<ul> <li> <p>Update <code>ODF</code> templates.</p> </li> <li> <p>Refactor many Python files for use of type hints.</p> </li> <li> <p>Updates for year 2024, updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#347-2024-01-15","title":"[3.4.7] - 2024-01-15","text":"<p>Updade to <code>lxml</code> version 5.</p>"},{"location":"CHANGES.html#changed_11","title":"Changed","text":"<pre><code>- Update `lxml` from version 4 to 5.\n</code></pre>"},{"location":"CHANGES.html#346-2023-12-25","title":"[3.4.6] - 2023-12-25","text":"<p>Add script <code>odfdo-replace</code> to find a pattern (regex) in an <code>ODF</code> file and replace by some string.</p>"},{"location":"CHANGES.html#fixed_5","title":"Fixed","text":"<ul> <li>Fix reading content from a <code>BytesIO</code>.</li> </ul>"},{"location":"CHANGES.html#changed_12","title":"Changed","text":"<ul> <li>Add script <code>odfdo-replace</code>.</li> </ul>"},{"location":"CHANGES.html#345-2023-12-24","title":"[3.4.5] - 2023-12-24","text":"<p>Add recipes showing how to save/read document from <code>io.BytesIO</code>.</p>"},{"location":"CHANGES.html#added_9","title":"Added","text":"<ul> <li>Add recipes <code>read_document_from_bytesio.py</code> and <code>save_document_as_bytesio.py</code>.</li> </ul>"},{"location":"CHANGES.html#changed_13","title":"Changed","text":"<ul> <li>Refactoring of code.</li> </ul>"},{"location":"reference.html","title":"Reference","text":""},{"location":"reference.html#odfdo.AnimPar","title":"<code>AnimPar</code>","text":"<p>             Bases: <code>Element</code></p> <p>A container for SMIL Presentation Animations.</p> <p>Arguments:</p> <pre><code>presentation_node_type -- default, on-click, with-previous,\n                          after-previous, timing-root, main-sequence\n                          and interactive-sequence\n\nsmil_begin -- indefinite, 10s, [id].click, [id].begin\n</code></pre> Source code in <code>odfdo/smil.py</code> <pre><code>class AnimPar(Element):\n    \"\"\"A container for SMIL Presentation Animations.\n\n    Arguments:\n\n        presentation_node_type -- default, on-click, with-previous,\n                                  after-previous, timing-root, main-sequence\n                                  and interactive-sequence\n\n        smil_begin -- indefinite, 10s, [id].click, [id].begin\n    \"\"\"\n\n    _tag = \"anim:par\"\n    _properties = (\n        PropDef(\"presentation_node_type\", \"presentation:node-type\"),\n        PropDef(\"smil_begin\", \"smil:begin\"),\n    )\n\n    def __init__(\n        self,\n        presentation_node_type: str | None = None,\n        smil_begin: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if presentation_node_type:\n                self.presentation_node_type = presentation_node_type\n            if smil_begin:\n                self.smil_begin = smil_begin\n</code></pre>"},{"location":"reference.html#odfdo.AnimSeq","title":"<code>AnimSeq</code>","text":"<p>             Bases: <code>Element</code></p> <p>TA container for SMIL Presentation Animations. Animations inside this block are executed after the slide has executed its initial transition.</p> <p>Arguments:</p> <pre><code>presentation_node_type -- default, on-click, with-previous,\n                          after-previous, timing-root, main-sequence\n                          and interactive-sequence\n</code></pre> Source code in <code>odfdo/smil.py</code> <pre><code>class AnimSeq(Element):\n    \"\"\"TA container for SMIL Presentation Animations. Animations\n    inside this block are executed after the slide has executed its initial\n    transition.\n\n    Arguments:\n\n        presentation_node_type -- default, on-click, with-previous,\n                                  after-previous, timing-root, main-sequence\n                                  and interactive-sequence\n    \"\"\"\n\n    _tag = \"anim:seq\"\n    _properties = (PropDef(\"presentation_node_type\", \"presentation:node-type\"),)\n\n    def __init__(\n        self,\n        presentation_node_type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init and presentation_node_type:\n            self.presentation_node_type = presentation_node_type\n</code></pre>"},{"location":"reference.html#odfdo.AnimTransFilter","title":"<code>AnimTransFilter</code>","text":"<p>             Bases: <code>Element</code></p> <p>Class to make a beautiful transition between two frames.</p> <p>Parameters:</p> Name Type Description Default <code>smil_type</code> <code>and smil_subtype -- see http</code> <p>//www.w3.org/TR/SMIL20/             smil-transitions.html#TransitionEffects-Appendix                             to get a list of all types/subtypes</p> <code>None</code> Source code in <code>odfdo/smil.py</code> <pre><code>class AnimTransFilter(Element):\n    \"\"\"\n    Class to make a beautiful transition between two frames.\n\n    Arguments:\n      smil_dur -- XXX complete me\n\n      smil_type and smil_subtype -- see http://www.w3.org/TR/SMIL20/\n                    smil-transitions.html#TransitionEffects-Appendix\n                                    to get a list of all types/subtypes\n\n      smil_direction -- forward, reverse\n\n      smil_fadeColor -- forward, reverse\n\n      smil_mode -- in, out\n    \"\"\"\n\n    _tag = \"anim:transitionFilter\"\n    _properties = (\n        PropDef(\"smil_dur\", \"smil:dur\"),\n        PropDef(\"smil_type\", \"smil:type\"),\n        PropDef(\"smil_subtype\", \"smil:subtype\"),\n        PropDef(\"smil_direction\", \"smil:direction\"),\n        PropDef(\"smil_fadeColor\", \"smil:fadeColor\"),\n        PropDef(\"smil_mode\", \"smil:mode\"),\n    )\n\n    def __init__(\n        self,\n        smil_dur: str | None = None,\n        smil_type: str | None = None,\n        smil_subtype: str | None = None,\n        smil_direction: str | None = None,\n        smil_fadeColor: str | None = None,\n        smil_mode: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if smil_dur:\n                self.smil_dur = smil_dur\n            if smil_type:\n                self.smil_type = smil_type\n            if smil_subtype:\n                self.smil_subtype = smil_subtype\n            if smil_direction:\n                self.smil_direction = smil_direction\n            if smil_fadeColor:\n                self.smil_fadeColor = smil_fadeColor\n            if smil_mode:\n                self.smil_mode = smil_mode\n</code></pre>"},{"location":"reference.html#odfdo.Annotation","title":"<code>Annotation</code>","text":"<p>             Bases: <code>Element</code>, <code>DcCreatorMixin</code>, <code>DcDateMixin</code></p> <p>Annotation element credited to the given creator with the given text, optionally dated (current date by default). If name not provided and some parent is provided, the name is autogenerated.</p> <p>Arguments:</p> <pre><code>text -- str or odf_element\n\ncreator -- str\n\ndate -- datetime\n\nname -- str\n\nparent -- Element\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>class Annotation(Element, DcCreatorMixin, DcDateMixin):\n    \"\"\"Annotation element credited to the given creator with the\n    given text, optionally dated (current date by default).\n    If name not provided and some parent is provided, the name is\n    autogenerated.\n\n    Arguments:\n\n        text -- str or odf_element\n\n        creator -- str\n\n        date -- datetime\n\n        name -- str\n\n        parent -- Element\n    \"\"\"\n\n    _tag = \"office:annotation\"\n    _properties = (\n        PropDef(\"name\", \"office:name\"),\n        PropDef(\"note_id\", \"text:id\"),\n    )\n\n    def __init__(\n        self,\n        text_or_element: Element | str | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        name: str | None = None,\n        parent: Element | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        # fixme : use offset\n        # TODO allow paragraph and text styles\n        super().__init__(**kwargs)\n\n        if self._do_init:\n            self.note_body = text_or_element  # type:ignore\n            if creator:\n                self.creator = creator\n            if date is None:\n                date = datetime.now()\n            self.date = date\n            if not name:\n                name = get_unique_office_name(parent)\n                self.name = name\n\n    @property\n    def dc_creator(self) -&gt; str | None:\n        \"\"\"Alias for self.creator property.\"\"\"\n        return self.creator\n\n    @dc_creator.setter\n    def dc_creator(self, creator: str) -&gt; None:\n        self.creator = creator\n\n    @property\n    def dc_date(self) -&gt; datetime | None:\n        \"\"\"Alias for self.date property.\"\"\"\n        return self.date\n\n    @dc_date.setter\n    def dc_date(self, dtdate: datetime) -&gt; None:\n        self.date = dtdate\n\n    @property\n    def note_body(self) -&gt; str:\n        return self.text_content\n\n    @note_body.setter\n    def note_body(self, text_or_element: Element | str | None) -&gt; None:\n        if text_or_element is None:\n            self.text_content = \"\"\n        elif isinstance(text_or_element, str):\n            self.text_content = text_or_element\n        elif isinstance(text_or_element, Element):\n            self.clear()\n            self.append(text_or_element)\n        else:\n            raise TypeError(f'Unexpected type for body: \"{type(text_or_element)}\"')\n\n    @property\n    def start(self) -&gt; Element:\n        \"\"\"Return self.\"\"\"\n        return self\n\n    @property\n    def end(self) -&gt; Element | None:\n        \"\"\"Return the corresponding annotation-end tag or None.\"\"\"\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can't find end tag: no parent available\")\n        body = self.document_body\n        if not body:\n            body = parent\n        return body.get_annotation_end(name=name)\n\n    def get_annotated(\n        self,\n        as_text: bool = False,\n        no_header: bool = True,\n        clean: bool = True,\n    ) -&gt; Element | list | str | None:\n        \"\"\"Returns the annotated content from an annotation.\n\n        If no content exists (single position annotation or annotation-end not\n        found), returns [] (or \"\" if text flag is True).\n        If as_text is True: returns the text content.\n        If clean is True: suppress unwanted tags (deletions marks, ...)\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of odf_element, cleaned and without headers.\n\n        Arguments:\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list or Element or text or None\n        \"\"\"\n        end = self.end\n        if end is None:\n            if as_text:\n                return \"\"\n            return None\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_between(\n            self, end, as_text=as_text, no_header=no_header, clean=clean\n        )\n\n    def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        For Annotation : delete the annotation-end tag if exists.\n\n        Arguments:\n\n            child -- Element or None\n        \"\"\"\n        if child is not None:  # act like normal delete\n            super().delete(child)\n            return\n        end = self.end\n        if end:\n            end.delete()\n        # act like normal delete\n        super().delete()\n\n    def check_validity(self) -&gt; None:\n        if not self.note_body:\n            raise ValueError(\"Annotation must have a body\")\n        if not self.dc_creator:\n            raise ValueError(\"Annotation must have a creator\")\n        if not self.dc_date:\n            self.dc_date = datetime.now()\n</code></pre>"},{"location":"reference.html#odfdo.Annotation.dc_creator","title":"<code>dc_creator: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Alias for self.creator property.</p>"},{"location":"reference.html#odfdo.Annotation.dc_date","title":"<code>dc_date: datetime | None</code>  <code>property</code> <code>writable</code>","text":"<p>Alias for self.date property.</p>"},{"location":"reference.html#odfdo.Annotation.end","title":"<code>end: Element | None</code>  <code>property</code>","text":"<p>Return the corresponding annotation-end tag or None.</p>"},{"location":"reference.html#odfdo.Annotation.start","title":"<code>start: Element</code>  <code>property</code>","text":"<p>Return self.</p>"},{"location":"reference.html#odfdo.Annotation.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>For Annotation : delete the annotation-end tag if exists.</p> <p>Arguments:</p> <pre><code>child -- Element or None\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    For Annotation : delete the annotation-end tag if exists.\n\n    Arguments:\n\n        child -- Element or None\n    \"\"\"\n    if child is not None:  # act like normal delete\n        super().delete(child)\n        return\n    end = self.end\n    if end:\n        end.delete()\n    # act like normal delete\n    super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.Annotation.get_annotated","title":"<code>get_annotated(as_text=False, no_header=True, clean=True)</code>","text":"<p>Returns the annotated content from an annotation.</p> <p>If no content exists (single position annotation or annotation-end not found), returns [] (or \u201c\u201d if text flag is True). If as_text is True: returns the text content. If clean is True: suppress unwanted tags (deletions marks, \u2026) If no_header is True: existing text:h are changed in text:p By default: returns a list of odf_element, cleaned and without headers.</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list or Element or text or None</p> Source code in <code>odfdo/note.py</code> <pre><code>def get_annotated(\n    self,\n    as_text: bool = False,\n    no_header: bool = True,\n    clean: bool = True,\n) -&gt; Element | list | str | None:\n    \"\"\"Returns the annotated content from an annotation.\n\n    If no content exists (single position annotation or annotation-end not\n    found), returns [] (or \"\" if text flag is True).\n    If as_text is True: returns the text content.\n    If clean is True: suppress unwanted tags (deletions marks, ...)\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of odf_element, cleaned and without headers.\n\n    Arguments:\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list or Element or text or None\n    \"\"\"\n    end = self.end\n    if end is None:\n        if as_text:\n            return \"\"\n        return None\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_between(\n        self, end, as_text=as_text, no_header=no_header, clean=clean\n    )\n</code></pre>"},{"location":"reference.html#odfdo.AnnotationEnd","title":"<code>AnnotationEnd</code>","text":"<p>             Bases: <code>Element</code></p> <p>AnnotationEnd: the \u201coffice:annotation-end\u201d element may be used to define the end of a text range of document content that spans element boundaries. In that case, an \u201coffice:annotation\u201d element shall precede the \u201coffice:annotation-end\u201d element. Both elements shall have the same value for their office:name attribute. The \u201coffice:annotation-end\u201d element shall be preceded by an \u201coffice:annotation\u201d element that has the same value for its office:name attribute as the \u201coffice:annotation-end\u201d element. An \u201coffice:annotation-end\u201d element without a preceding \u201coffice:annotation\u201d element that has the same name assigned is ignored.</p> Source code in <code>odfdo/note.py</code> <pre><code>class AnnotationEnd(Element):\n    \"\"\"AnnotationEnd: the \"office:annotation-end\" element may be used to\n    define the end of a text range of document content that spans element\n    boundaries. In that case, an \"office:annotation\" element shall precede\n    the \"office:annotation-end\" element. Both elements shall have the same\n    value for their office:name attribute. The \"office:annotation-end\" element\n    shall be preceded by an \"office:annotation\" element that has the same\n    value for its office:name attribute as the \"office:annotation-end\"\n    element. An \"office:annotation-end\" element without a preceding\n    \"office:annotation\" element that has the same name assigned is ignored.\n    \"\"\"\n\n    _tag = \"office:annotation-end\"\n    _properties = (PropDef(\"name\", \"office:name\"),)\n\n    def __init__(\n        self,\n        annotation: Element | None = None,\n        name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize an AnnotationEnd element. Either annotation or name must be\n        provided to have proper reference for the annotation-end.\n\n        Arguments:\n\n            annotation -- odf_annotation element\n\n            name -- str\n        \"\"\"\n        # fixme : use offset\n        # TODO allow paragraph and text styles\n        super().__init__(**kwargs)\n        if self._do_init:\n            if annotation:\n                name = annotation.name  # type: ignore\n            if not name:\n                raise ValueError(\"Annotation-end must have a name\")\n            self.name = name\n\n    @property\n    def start(self) -&gt; Element | None:\n        \"\"\"Return the corresponding annotation starting tag or None.\"\"\"\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can't find start tag: no parent available\")\n        body = self.document_body\n        if not body:\n            body = parent\n        return body.get_annotation(name=name)\n\n    @property\n    def end(self) -&gt; Element:\n        \"\"\"Return self.\"\"\"\n        return self\n</code></pre>"},{"location":"reference.html#odfdo.AnnotationEnd.end","title":"<code>end: Element</code>  <code>property</code>","text":"<p>Return self.</p>"},{"location":"reference.html#odfdo.AnnotationEnd.start","title":"<code>start: Element | None</code>  <code>property</code>","text":"<p>Return the corresponding annotation starting tag or None.</p>"},{"location":"reference.html#odfdo.AnnotationEnd.__init__","title":"<code>__init__(annotation=None, name=None, **kwargs)</code>","text":"<p>Initialize an AnnotationEnd element. Either annotation or name must be provided to have proper reference for the annotation-end.</p> <p>Arguments:</p> <pre><code>annotation -- odf_annotation element\n\nname -- str\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>def __init__(\n    self,\n    annotation: Element | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize an AnnotationEnd element. Either annotation or name must be\n    provided to have proper reference for the annotation-end.\n\n    Arguments:\n\n        annotation -- odf_annotation element\n\n        name -- str\n    \"\"\"\n    # fixme : use offset\n    # TODO allow paragraph and text styles\n    super().__init__(**kwargs)\n    if self._do_init:\n        if annotation:\n            name = annotation.name  # type: ignore\n        if not name:\n            raise ValueError(\"Annotation-end must have a name\")\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.Body","title":"<code>Body</code>","text":"<p>             Bases: <code>Element</code></p> <p>Body, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Body(Element):\n    \"\"\"Body, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:body\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n\n    def get_tables(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the tables that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Table\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::table:table\", table_style=style, content=content\n        )\n\n    @property\n    def tables(self) -&gt; list[Element]:\n        \"\"\"Return all the tables.\n\n        Return: list of Table\n        \"\"\"\n        return self.get_elements(\"descendant::table:table\")\n\n    def get_table(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the table that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            content -- str regex\n\n        Return: Table or None if not found\n        \"\"\"\n        if name is None and content is None:\n            result = self._filtered_element(\"descendant::table:table\", position)\n        else:\n            result = self._filtered_element(\n                \"descendant::table:table\",\n                position,\n                table_name=name,\n                content=content,\n            )\n        return result\n</code></pre>"},{"location":"reference.html#odfdo.Body.tables","title":"<code>tables: list[Element]</code>  <code>property</code>","text":"<p>Return all the tables.</p> <p>Return: list of Table</p>"},{"location":"reference.html#odfdo.Body.get_table","title":"<code>get_table(position=0, name=None, content=None)</code>","text":"<p>Return the table that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\ncontent -- str regex\n</code></pre> <p>Return: Table or None if not found</p> Source code in <code>odfdo/body.py</code> <pre><code>def get_table(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the table that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        content -- str regex\n\n    Return: Table or None if not found\n    \"\"\"\n    if name is None and content is None:\n        result = self._filtered_element(\"descendant::table:table\", position)\n    else:\n        result = self._filtered_element(\n            \"descendant::table:table\",\n            position,\n            table_name=name,\n            content=content,\n        )\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Body.get_tables","title":"<code>get_tables(style=None, content=None)</code>","text":"<p>Return all the tables that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Table</p> Source code in <code>odfdo/body.py</code> <pre><code>def get_tables(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the tables that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Table\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::table:table\", table_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Bookmark","title":"<code>Bookmark</code>","text":"<p>             Bases: <code>Element</code></p> <p>Bookmark class for ODF \u201ctext:bookmark\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/bookmark.py</code> <pre><code>class Bookmark(Element):\n    \"\"\"\n    Bookmark class for ODF \"text:bookmark\"\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:bookmark\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.BookmarkEnd","title":"<code>BookmarkEnd</code>","text":"<p>             Bases: <code>Element</code></p> <p>BookmarkEnd class for ODF \u201ctext:bookmark-end\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/bookmark.py</code> <pre><code>class BookmarkEnd(Element):\n    \"\"\"\n    BookmarkEnd class for ODF \"text:bookmark-end\"\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:bookmark-end\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.BookmarkStart","title":"<code>BookmarkStart</code>","text":"<p>             Bases: <code>Element</code></p> <p>BookmarkStart class for ODF \u201ctext:bookmark-start\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/bookmark.py</code> <pre><code>class BookmarkStart(Element):\n    \"\"\"\n    BookmarkStart class for ODF \"text:bookmark-start\"\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:bookmark-start\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.Cell","title":"<code>Cell</code>","text":"<p>             Bases: <code>ElementTyped</code></p> <p>\u201ctable:table-cell\u201d table cell element.</p> Source code in <code>odfdo/cell.py</code> <pre><code>class Cell(ElementTyped):\n    \"\"\" \"table:table-cell\" table cell element.\"\"\"\n\n    _tag = \"table:table-cell\"\n    _caching = True\n\n    def __init__(\n        self,\n        value: Any = None,\n        text: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        formula: str | None = None,\n        repeated: int | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a cell element containing the given value. The textual\n        representation is automatically formatted but can be provided. Cell\n        type can be deduced as well, unless the number is a percentage or\n        currency. If cell type is \"currency\", the currency must be given.\n        The cell can be repeated on the given number of columns.\n\n        Arguments:\n\n            value -- bool, int, float, Decimal, date, datetime, str,\n                     timedelta\n\n            text -- str\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            repeated -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self.x = None\n        self.y = None\n        if self._do_init:\n            self.set_value(\n                value,\n                text=text,\n                cell_type=cell_type,\n                currency=currency,\n                formula=formula,\n            )\n            if repeated and repeated &gt; 1:\n                self.repeated = repeated\n            if style is not None:\n                self.style = style\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} x={self.x} y={self.y}&gt;\"\n\n    @property\n    def clone(self) -&gt; Cell:\n        clone = Element.clone.fget(self)  # type: ignore\n        clone.y = self.y\n        clone.x = self.x\n        if hasattr(self, \"_tmap\"):\n            if hasattr(self, \"_rmap\"):\n                clone._rmap = self._rmap[:]\n            clone._tmap = self._tmap[:]\n            clone._cmap = self._cmap[:]\n        return clone\n\n    @property\n    def value(\n        self,\n    ) -&gt; str | bool | int | Float | Decimal | date | datetime | timedelta | None:\n        \"\"\"Set / get the value of the cell. The type is read from the\n        'office:value-type' attribute of the cell. When setting the value,\n        the type of the value will determine the new value_type of the cell.\n\n        Warning: use this method for boolean, float or string only.\n        \"\"\"\n        value_type = self.get_attribute_string(\"office:value-type\")\n        if value_type == \"boolean\":\n            return self.get_attribute(\"office:boolean-value\")\n        if value_type in {\"float\", \"percentage\", \"currency\"}:\n            value_decimal = Decimal(str(self.get_attribute_string(\"office:value\")))\n            # Return 3 instead of 3.0 if possible\n            if int(value_decimal) == value_decimal:\n                return int(value_decimal)\n            return value_decimal\n        if value_type == \"date\":\n            value_str = str(self.get_attribute_string(\"office:date-value\"))\n            if \"T\" in value_str:\n                return DateTime.decode(value_str)\n            return Date.decode(value_str)\n        if value_type == \"time\":\n            return Duration.decode(str(self.get_attribute_string(\"office:time-value\")))\n        if value_type == \"string\":\n            value = self.get_attribute_string(\"office:string-value\")\n            if value is not None:\n                return value\n            value_list = []\n            for para in self.get_elements(\"text:p\"):\n                value_list.append(para.text_recursive)\n            return \"\\n\".join(value_list)\n        return None\n\n    @value.setter\n    def value(self, value: str | bytes | bool | int | Float | Decimal | None) -&gt; None:\n        self.clear()\n        if value is None:\n            return\n        if isinstance(value, (str, bytes)):\n            if isinstance(value, bytes):\n                value = bytes_to_str(value)\n            self.set_attribute(\"office:value-type\", \"string\")\n            self.set_attribute(\"office:string-value\", value)\n            self.text = value\n            return\n        if value is True or value is False:\n            self.set_attribute(\"office:value-type\", \"boolean\")\n            value_bool = Boolean.encode(value)\n            self.set_attribute(\"office:boolean-value\", value_bool)\n            self.text = value_bool\n            return\n        if isinstance(value, (int, Float, Decimal)):\n            self.set_attribute(\"office:value-type\", \"float\")\n            value_str = str(value)\n            self.set_attribute(\"office:value\", value_str)\n            self.text = value_str\n            return\n        raise TypeError(f\"Unknown value type, try with set_value() : {value!r}\")\n\n    @property\n    def float(self) -&gt; Float:\n        \"\"\"Set / get the value of the cell as a float (or 0.0).\"\"\"\n        for tag in (\"office:value\", \"office:string-value\", \"office:boolean-value\"):\n            read_attr = self.get_attribute(tag)\n            if isinstance(read_attr, str):\n                with contextlib.suppress(ValueError, TypeError):\n                    return Float(read_attr)\n        return 0.0\n\n    @float.setter\n    def float(self, value: str | Float | int | Decimal) -&gt; None:\n        try:\n            value_float = Float(value)\n        except (ValueError, TypeError):\n            value_float = 0.0\n        value_str = str(value_float)\n        self.clear()\n        self.set_attribute(\"office:value\", value_str)\n        self.set_attribute(\"office:value-type\", \"float\")\n        self.text = value_str\n\n    @property\n    def string(self) -&gt; str:\n        \"\"\"Set / get the value of the cell as a string (or '').\"\"\"\n        value = self.get_attribute_string(\"office:string-value\")\n        if isinstance(value, str):\n            return value\n        return \"\"\n\n    @string.setter\n    def string(\n        self,\n        value: str | bytes | int | Float | Decimal | bool | None,  # type: ignore\n    ) -&gt; None:\n        self.clear()\n        if value is None:\n            value_str = \"\"\n        else:\n            value_str = str(value)\n        self.set_attribute(\"office:value-type\", \"string\")\n        self.set_attribute(\"office:string-value\", value_str)\n        self.text = value_str\n\n    def set_value(\n        self,\n        value: (\n            str  # type: ignore\n            | bytes\n            | Float\n            | int\n            | Decimal\n            | bool\n            | datetime\n            | date\n            | timedelta\n            | None\n        ),\n        text: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        formula: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set the cell state from the Python value type.\n\n        Text is how the cell is displayed. Cell type is guessed,\n        unless provided.\n\n        For monetary values, provide the name of the currency.\n\n        Arguments:\n\n            value -- Python type\n\n            text -- str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                        'currency' or 'percentage'\n\n            currency -- str\n        \"\"\"\n        self.clear()\n        text = self.set_value_and_type(\n            value=value,\n            text=text,\n            value_type=cell_type,\n            currency=currency,\n        )\n        if text is not None:\n            self.text_content = text\n        if formula is not None:\n            self.formula = formula\n\n    @property\n    def type(self) -&gt; str | None:\n        \"\"\"Get / set the type of the cell: boolean, float, date, string\n        or time.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"office:value-type\")\n\n    @type.setter\n    def type(self, cell_type: str) -&gt; None:\n        self.set_attribute(\"office:value-type\", cell_type)\n\n    @property\n    def currency(self) -&gt; str | None:\n        \"\"\"Get / set the currency used for monetary values.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"office:currency\")\n\n    @currency.setter\n    def currency(self, currency: str) -&gt; None:\n        self.set_attribute(\"office:currency\", currency)\n\n    def _set_repeated(self, repeated: int | None) -&gt; None:\n        \"\"\"Internal only. Set the numnber of times the cell is repeated, or\n        None to delete. Without changing cache.\n        \"\"\"\n        if repeated is None or repeated &lt; 2:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:number-columns-repeated\")\n            return\n        self.set_attribute(\"table:number-columns-repeated\", str(repeated))\n\n    @property\n    def repeated(self) -&gt; int | None:\n        \"\"\"Get / set the number of times the cell is repeated.\n\n        Always None when using the table API.\n\n        Return: int or None\n        \"\"\"\n        repeated = self.get_attribute(\"table:number-columns-repeated\")\n        if repeated is None:\n            return None\n        return int(repeated)\n\n    @repeated.setter\n    def repeated(self, repeated: int | None) -&gt; None:\n        self._set_repeated(repeated)\n        # update cache\n        child: Element = self\n        while True:\n            # look for Row, parent may be group of rows\n            upper = child.parent\n            if not upper:\n                # lonely cell\n                return\n            # parent may be group of rows, not table\n            if isinstance(upper, Element) and upper._tag == \"table:table-row\":\n                break\n            child = upper\n        # fixme : need to optimize this\n        if isinstance(upper, Element) and upper._tag == \"table:table-row\":\n            upper._compute_row_cache()\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get / set the style of the cell itself.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"table:style-name\")\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n\n    @property\n    def formula(self) -&gt; str | None:\n        \"\"\"Get / set the formula of the cell, or None if undefined.\n\n        The formula is not interpreted in any way.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"table:formula\")\n\n    @formula.setter\n    def formula(self, formula: str | None) -&gt; None:\n        self.set_attribute(\"table:formula\", formula)\n\n    def is_empty(self, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return whether the cell has no value or the value evaluates\n        to False (empty string), and no style.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            aggressive -- bool\n\n        Return: bool\n        \"\"\"\n        if self.value is not None or self.children or self.is_spanned():\n            return False\n        if not aggressive and self.style is not None:\n            return False\n        return True\n\n    def is_spanned(self) -&gt; bool:\n        \"\"\"Return whether the cell is spanned over several cells.\n\n        Returns: True | False\n        \"\"\"\n        if self.tag == \"table:covered-table-cell\":\n            return True\n        if self.get_attribute(\"table:number-columns-spanned\") is not None:\n            return True\n        if self.get_attribute(\"table:number-rows-spanned\") is not None:\n            return True\n        return False\n\n    _is_spanned = is_spanned  # compatibility\n</code></pre>"},{"location":"reference.html#odfdo.Cell.currency","title":"<code>currency: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the currency used for monetary values.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.float","title":"<code>float: Float</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a float (or 0.0).</p>"},{"location":"reference.html#odfdo.Cell.formula","title":"<code>formula: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the formula of the cell, or None if undefined.</p> <p>The formula is not interpreted in any way.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.repeated","title":"<code>repeated: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the number of times the cell is repeated.</p> <p>Always None when using the table API.</p> <p>Return: int or None</p>"},{"location":"reference.html#odfdo.Cell.string","title":"<code>string: str</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a string (or \u2018\u2019).</p>"},{"location":"reference.html#odfdo.Cell.style","title":"<code>style: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the style of the cell itself.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.type","title":"<code>type: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the type of the cell: boolean, float, date, string or time.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.value","title":"<code>value: str | bool | int | Float | Decimal | date | datetime | timedelta | None</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell. The type is read from the \u2018office:value-type\u2019 attribute of the cell. When setting the value, the type of the value will determine the new value_type of the cell.</p> <p>Warning: use this method for boolean, float or string only.</p>"},{"location":"reference.html#odfdo.Cell.__init__","title":"<code>__init__(value=None, text=None, cell_type=None, currency=None, formula=None, repeated=None, style=None, **kwargs)</code>","text":"<p>Create a cell element containing the given value. The textual representation is automatically formatted but can be provided. Cell type can be deduced as well, unless the number is a percentage or currency. If cell type is \u201ccurrency\u201d, the currency must be given. The cell can be repeated on the given number of columns.</p> <p>Arguments:</p> <pre><code>value -- bool, int, float, Decimal, date, datetime, str,\n         timedelta\n\ntext -- str\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nrepeated -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/cell.py</code> <pre><code>def __init__(\n    self,\n    value: Any = None,\n    text: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    formula: str | None = None,\n    repeated: int | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a cell element containing the given value. The textual\n    representation is automatically formatted but can be provided. Cell\n    type can be deduced as well, unless the number is a percentage or\n    currency. If cell type is \"currency\", the currency must be given.\n    The cell can be repeated on the given number of columns.\n\n    Arguments:\n\n        value -- bool, int, float, Decimal, date, datetime, str,\n                 timedelta\n\n        text -- str\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        repeated -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self.x = None\n    self.y = None\n    if self._do_init:\n        self.set_value(\n            value,\n            text=text,\n            cell_type=cell_type,\n            currency=currency,\n            formula=formula,\n        )\n        if repeated and repeated &gt; 1:\n            self.repeated = repeated\n        if style is not None:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Cell.is_empty","title":"<code>is_empty(aggressive=False)</code>","text":"<p>Return whether the cell has no value or the value evaluates to False (empty string), and no style.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> <p>Return: bool</p> Source code in <code>odfdo/cell.py</code> <pre><code>def is_empty(self, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return whether the cell has no value or the value evaluates\n    to False (empty string), and no style.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        aggressive -- bool\n\n    Return: bool\n    \"\"\"\n    if self.value is not None or self.children or self.is_spanned():\n        return False\n    if not aggressive and self.style is not None:\n        return False\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Cell.is_spanned","title":"<code>is_spanned()</code>","text":"<p>Return whether the cell is spanned over several cells.</p> <p>Returns: True | False</p> Source code in <code>odfdo/cell.py</code> <pre><code>def is_spanned(self) -&gt; bool:\n    \"\"\"Return whether the cell is spanned over several cells.\n\n    Returns: True | False\n    \"\"\"\n    if self.tag == \"table:covered-table-cell\":\n        return True\n    if self.get_attribute(\"table:number-columns-spanned\") is not None:\n        return True\n    if self.get_attribute(\"table:number-rows-spanned\") is not None:\n        return True\n    return False\n</code></pre>"},{"location":"reference.html#odfdo.Cell.set_value","title":"<code>set_value(value, text=None, cell_type=None, currency=None, formula=None)</code>","text":"<p>Set the cell state from the Python value type.</p> <p>Text is how the cell is displayed. Cell type is guessed, unless provided.</p> <p>For monetary values, provide the name of the currency.</p> <p>Arguments:</p> <pre><code>value -- Python type\n\ntext -- str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n            'currency' or 'percentage'\n\ncurrency -- str\n</code></pre> Source code in <code>odfdo/cell.py</code> <pre><code>def set_value(\n    self,\n    value: (\n        str  # type: ignore\n        | bytes\n        | Float\n        | int\n        | Decimal\n        | bool\n        | datetime\n        | date\n        | timedelta\n        | None\n    ),\n    text: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    formula: str | None = None,\n) -&gt; None:\n    \"\"\"Set the cell state from the Python value type.\n\n    Text is how the cell is displayed. Cell type is guessed,\n    unless provided.\n\n    For monetary values, provide the name of the currency.\n\n    Arguments:\n\n        value -- Python type\n\n        text -- str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                    'currency' or 'percentage'\n\n        currency -- str\n    \"\"\"\n    self.clear()\n    text = self.set_value_and_type(\n        value=value,\n        text=text,\n        value_type=cell_type,\n        currency=currency,\n    )\n    if text is not None:\n        self.text_content = text\n    if formula is not None:\n        self.formula = formula\n</code></pre>"},{"location":"reference.html#odfdo.ChangeInfo","title":"<code>ChangeInfo</code>","text":"<p>             Bases: <code>Element</code>, <code>DcCreatorMixin</code>, <code>DcDateMixin</code></p> <p>The \u201coffice:change-info\u201d element represents who made a change and when. It may also contain a comment (one or more Paragrah \u201ctext:p\u201d elements) on the change.</p> The comments available in the ChangeInfo are available through <ul> <li>paragraphs property, get_paragraphs and get_paragraph methods for actual Paragraph.</li> <li>get_comments for a plain text version</li> </ul> <p>Arguments:</p> <p>creator \u2013 str (or None)</p> <p>date \u2013 datetime (or None)</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class ChangeInfo(Element, DcCreatorMixin, DcDateMixin):\n    \"\"\"The \"office:change-info\" element represents who made a change and when.\n    It may also contain a comment (one or more Paragrah \"text:p\" elements)\n    on the change.\n\n    The comments available in the ChangeInfo are available through:\n      - paragraphs property, get_paragraphs and get_paragraph methods for actual Paragraph.\n      - get_comments for a plain text version\n\n      Arguments:\n\n         creator -- str (or None)\n\n         date -- datetime (or None)\n    \"\"\"\n\n    _tag = \"office:change-info\"\n\n    def __init__(\n        self,\n        creator: str | None = None,\n        date: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.creator = creator or \"Unknown\"\n            self.date = date\n\n    def get_comments(self, joined: bool = True) -&gt; str | list[str]:\n        \"\"\"Get text content of the comments. If joined is True (default), the\n        text of different paragraphs is concatenated, else a list of strings,\n        one per paragraph, is returned.\n\n        Arguments:\n\n            joined -- boolean (default is True)\n\n        Return: str or list of str.\n        \"\"\"\n        content = self.paragraphs\n        if content is None:\n            content = []\n        text = [para.get_formatted_text(simple=True) for para in content]  # type: ignore\n        if joined:\n            return \"\\n\".join(text)\n        return text\n\n    def set_comments(self, text: str = \"\", replace: bool = True) -&gt; None:\n        \"\"\"Set the text content of the comments. If replace is True (default),\n        the new text replace old comments, else it is added at the end.\n\n        Arguments:\n\n            text -- str\n\n            replace -- boolean\n        \"\"\"\n        if replace:\n            for para in self.paragraphs:\n                self.delete(para)\n        para = Paragraph()\n        para.append_plain_text(text)\n        self.insert(para, xmlposition=LAST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.ChangeInfo.get_comments","title":"<code>get_comments(joined=True)</code>","text":"<p>Get text content of the comments. If joined is True (default), the text of different paragraphs is concatenated, else a list of strings, one per paragraph, is returned.</p> <p>Arguments:</p> <pre><code>joined -- boolean (default is True)\n</code></pre> <p>Return: str or list of str.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_comments(self, joined: bool = True) -&gt; str | list[str]:\n    \"\"\"Get text content of the comments. If joined is True (default), the\n    text of different paragraphs is concatenated, else a list of strings,\n    one per paragraph, is returned.\n\n    Arguments:\n\n        joined -- boolean (default is True)\n\n    Return: str or list of str.\n    \"\"\"\n    content = self.paragraphs\n    if content is None:\n        content = []\n    text = [para.get_formatted_text(simple=True) for para in content]  # type: ignore\n    if joined:\n        return \"\\n\".join(text)\n    return text\n</code></pre>"},{"location":"reference.html#odfdo.ChangeInfo.set_comments","title":"<code>set_comments(text='', replace=True)</code>","text":"<p>Set the text content of the comments. If replace is True (default), the new text replace old comments, else it is added at the end.</p> <p>Arguments:</p> <pre><code>text -- str\n\nreplace -- boolean\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_comments(self, text: str = \"\", replace: bool = True) -&gt; None:\n    \"\"\"Set the text content of the comments. If replace is True (default),\n    the new text replace old comments, else it is added at the end.\n\n    Arguments:\n\n        text -- str\n\n        replace -- boolean\n    \"\"\"\n    if replace:\n        for para in self.paragraphs:\n            self.delete(para)\n    para = Paragraph()\n    para.append_plain_text(text)\n    self.insert(para, xmlposition=LAST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.Chart","title":"<code>Chart</code>","text":"<p>             Bases: <code>Body</code></p> <p>Chart, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Chart(Body):\n    \"\"\"Chart, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:chart\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.Column","title":"<code>Column</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF table column \u201ctable:table-column\u201d</p> Source code in <code>odfdo/table.py</code> <pre><code>class Column(Element):\n    \"\"\"ODF table column \"table:table-column\" \"\"\"\n\n    _tag = \"table:table-column\"\n    _caching = True\n\n    def __init__(\n        self,\n        default_cell_style: str | None = None,\n        repeated: int | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a column group element of the optionally given style. Cell\n        style can be set for the whole column. If the properties apply to\n        several columns, give the number of repeated columns.\n\n        Columns don't contain cells, just style information.\n\n        You don't generally have to create columns by hand, use the Table API.\n\n        Arguments:\n\n            default_cell_style -- str\n\n            repeated -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self.x = None\n        if self._do_init:\n            if default_cell_style:\n                self.default_cell_style = default_cell_style\n            if repeated and repeated &gt; 1:\n                self.repeated = repeated\n            if style:\n                self.style = style\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} x={self.x}&gt;\"\n\n    @property\n    def clone(self) -&gt; Column:\n        clone = Element.clone.fget(self)  # type: ignore\n        clone.x = self.x\n        if hasattr(self, \"_tmap\"):\n            if hasattr(self, \"_rmap\"):\n                clone._rmap = self._rmap[:]\n            clone._tmap = self._tmap[:]\n            clone._cmap = self._cmap[:]\n        return clone\n\n    def get_default_cell_style(self) -&gt; str | None:\n        \"\"\"Get or set the default cell style for column.\n\n        (See also self.default_cell_style property.)\n        \"\"\"\n        return self.get_attribute_string(\"table:default-cell-style-name\")\n\n    def set_default_cell_style(self, style: Element | str | None) -&gt; None:\n        \"\"\"Get or set the default cell style for column.\n\n        (See also self.default_cell_style property.)\n        \"\"\"\n        self.set_style_attribute(\"table:default-cell-style-name\", style)\n\n    @property\n    def default_cell_style(self) -&gt; str | None:\n        \"\"\"Get or set the default cell style for column.\"\"\"\n        return self.get_attribute_string(\"table:default-cell-style-name\")\n\n    @default_cell_style.setter\n    def default_cell_style(self, style: Element | str | None) -&gt; None:\n        self.set_style_attribute(\"table:default-cell-style-name\", style)\n\n    def _set_repeated(self, repeated: int | None) -&gt; None:\n        \"\"\"Internal only. Set the number of times the column is repeated, or\n        None to delete it. Without changing cache.\n\n        Arguments:\n\n            repeated -- int or None\n        \"\"\"\n        if repeated is None or repeated &lt; 2:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:number-columns-repeated\")\n            return\n        self.set_attribute(\"table:number-columns-repeated\", str(repeated))\n\n    @property\n    def repeated(self) -&gt; int | None:\n        \"\"\"Get /set the number of times the column is repeated.\n\n        Always None when using the table API.\n\n        Return: int or None\n        \"\"\"\n        repeated = self.get_attribute(\"table:number-columns-repeated\")\n        if repeated is None:\n            return None\n        return int(repeated)\n\n    @repeated.setter\n    def repeated(self, repeated: int | None) -&gt; None:\n        self._set_repeated(repeated)\n        # update cache\n        current: Element = self\n        while True:\n            # look for Table, parent may be group of rows\n            upper = current.parent\n            if not upper:\n                # lonely column\n                return\n            # parent may be group of rows, not table\n            if isinstance(upper, Table):\n                break\n            current = upper\n        # fixme : need to optimize this\n        if isinstance(upper, Table):\n            upper._compute_table_cache()\n            if hasattr(self, \"_cmap\"):\n                del self._cmap[:]\n                self._cmap.extend(upper._cmap)\n            else:\n                self._cmap = upper._cmap\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get /set the style of the column itself.\n\n        Return: str\n        \"\"\"\n        return self.get_attribute_string(\"table:style-name\")\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n</code></pre>"},{"location":"reference.html#odfdo.Column.default_cell_style","title":"<code>default_cell_style: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the default cell style for column.</p>"},{"location":"reference.html#odfdo.Column.repeated","title":"<code>repeated: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get /set the number of times the column is repeated.</p> <p>Always None when using the table API.</p> <p>Return: int or None</p>"},{"location":"reference.html#odfdo.Column.style","title":"<code>style: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get /set the style of the column itself.</p> <p>Return: str</p>"},{"location":"reference.html#odfdo.Column.__init__","title":"<code>__init__(default_cell_style=None, repeated=None, style=None, **kwargs)</code>","text":"<p>Create a column group element of the optionally given style. Cell style can be set for the whole column. If the properties apply to several columns, give the number of repeated columns.</p> <p>Columns don\u2019t contain cells, just style information.</p> <p>You don\u2019t generally have to create columns by hand, use the Table API.</p> <p>Arguments:</p> <pre><code>default_cell_style -- str\n\nrepeated -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    default_cell_style: str | None = None,\n    repeated: int | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a column group element of the optionally given style. Cell\n    style can be set for the whole column. If the properties apply to\n    several columns, give the number of repeated columns.\n\n    Columns don't contain cells, just style information.\n\n    You don't generally have to create columns by hand, use the Table API.\n\n    Arguments:\n\n        default_cell_style -- str\n\n        repeated -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self.x = None\n    if self._do_init:\n        if default_cell_style:\n            self.default_cell_style = default_cell_style\n        if repeated and repeated &gt; 1:\n            self.repeated = repeated\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Column.get_default_cell_style","title":"<code>get_default_cell_style()</code>","text":"<p>Get or set the default cell style for column.</p> <p>(See also self.default_cell_style property.)</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_default_cell_style(self) -&gt; str | None:\n    \"\"\"Get or set the default cell style for column.\n\n    (See also self.default_cell_style property.)\n    \"\"\"\n    return self.get_attribute_string(\"table:default-cell-style-name\")\n</code></pre>"},{"location":"reference.html#odfdo.Column.set_default_cell_style","title":"<code>set_default_cell_style(style)</code>","text":"<p>Get or set the default cell style for column.</p> <p>(See also self.default_cell_style property.)</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_default_cell_style(self, style: Element | str | None) -&gt; None:\n    \"\"\"Get or set the default cell style for column.\n\n    (See also self.default_cell_style property.)\n    \"\"\"\n    self.set_style_attribute(\"table:default-cell-style-name\", style)\n</code></pre>"},{"location":"reference.html#odfdo.ConnectorShape","title":"<code>ConnectorShape</code>","text":"<p>             Bases: <code>ShapeBase</code></p> <p>Create a Connector shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\nconnected_shapes -- (shape, shape)\n\nglue_points -- (point, point)\n\np1 -- (str, str)\n\np2 -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class ConnectorShape(ShapeBase):\n    \"\"\"Create a Connector shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        connected_shapes -- (shape, shape)\n\n        glue_points -- (point, point)\n\n        p1 -- (str, str)\n\n        p2 -- (str, str)\n    \"\"\"\n\n    _tag = \"draw:connector\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"start_shape\", \"draw:start-shape\"),\n        PropDef(\"end_shape\", \"draw:end-shape\"),\n        PropDef(\"start_glue_point\", \"draw:start-glue-point\"),\n        PropDef(\"end_glue_point\", \"draw:end-glue-point\"),\n        PropDef(\"x1\", \"svg:x1\"),\n        PropDef(\"y1\", \"svg:y1\"),\n        PropDef(\"x2\", \"svg:x2\"),\n        PropDef(\"y2\", \"svg:y2\"),\n    )\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        connected_shapes: tuple | None = None,\n        glue_points: tuple | None = None,\n        p1: tuple | None = None,\n        p2: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n            }\n        )\n        super().__init__(**kwargs)\n        if self._do_init:\n            if connected_shapes:\n                self.start_shape = connected_shapes[0].draw_id\n                self.end_shape = connected_shapes[1].draw_id\n            if glue_points:\n                self.start_glue_point = glue_points[0]\n                self.end_glue_point = glue_points[1]\n            if p1:\n                self.x1 = p1[0]\n                self.y1 = p1[1]\n            if p2:\n                self.x2 = p2[0]\n                self.y2 = p2[1]\n</code></pre>"},{"location":"reference.html#odfdo.Container","title":"<code>Container</code>","text":"<p>Representation of the ODF file.</p> Source code in <code>odfdo/container.py</code> <pre><code>class Container:\n    \"\"\"Representation of the ODF file.\"\"\"\n\n    def __init__(self, path: Path | str | io.BytesIO | None = None) -&gt; None:\n        self.__parts: dict[str, bytes | None] = {}\n        self.__parts_ts: dict[str, int] = {}\n        self.__path_like: Path | str | io.BytesIO | None = None\n        self.__packaging: str = ZIP\n        self.path: Path | None = None  # or Path\n        if path:\n            self.open(path)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} type={self.mimetype} path={self.path}&gt;\"\n\n    def open(self, path_or_file: Path | str | io.BytesIO) -&gt; None:\n        \"\"\"Load the content of an ODF file.\"\"\"\n        self.__path_like = path_or_file\n        if isinstance(path_or_file, (str, Path)):\n            self.path = Path(path_or_file).expanduser()\n            if not self.path.exists():\n                raise FileNotFoundError(str(self.path))\n            self.__path_like = self.path\n        if (self.path or isinstance(self.__path_like, io.BytesIO)) and is_zipfile(\n            self.__path_like  # type: ignore\n        ):\n            self.__packaging = ZIP\n            return self._read_zip()\n        if self.path:\n            is_folder = False\n            with contextlib.suppress(OSError):\n                is_folder = self.path.is_dir()\n            if is_folder:\n                self.__packaging = FOLDER\n                return self._read_folder()\n        raise TypeError(f\"Document format not managed by odfdo: {type(path_or_file)}.\")\n\n    def _read_zip(self) -&gt; None:\n        if isinstance(self.__path_like, io.BytesIO):\n            self.__path_like.seek(0)\n        with ZipFile(self.__path_like) as zf:  # type: ignore\n            mimetype = bytes_to_str(zf.read(\"mimetype\"))\n            if mimetype not in ODF_MIMETYPES:\n                raise ValueError(f\"Document of unknown type {mimetype}\")\n            self.__parts[\"mimetype\"] = str_to_bytes(mimetype)\n        if self.path is None:\n            if isinstance(self.__path_like, io.BytesIO):\n                self.__path_like.seek(0)\n            # read the full file at once and forget file\n            with ZipFile(self.__path_like) as zf:  # type: ignore\n                for name in zf.namelist():\n                    upath = normalize_path(name)\n                    self.__parts[upath] = zf.read(name)\n            self.__path_like = None\n\n    def _read_folder(self) -&gt; None:\n        try:\n            mimetype, timestamp = self._get_folder_part(\"mimetype\")\n        except OSError:\n            printwarn(\"Corrupted or not an OpenDocument folder (missing mimetype)\")\n            mimetype = b\"\"\n            timestamp = int(time.time())\n        if bytes_to_str(mimetype) not in ODF_MIMETYPES:\n            message = f\"Document of unknown type {mimetype!r}, try with ODF Text.\"\n            printwarn(message)\n            self.__parts[\"mimetype\"] = str_to_bytes(ODF_EXTENSIONS[\"odt\"])\n            self.__parts_ts[\"mimetype\"] = timestamp\n\n    def _parse_folder(self, folder: str) -&gt; list[str]:\n        parts = []\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        root = self.path / folder\n        for path in root.iterdir():\n            if path.name.startswith(\".\"):  # no hidden files\n                continue\n            relative_path = path.relative_to(self.path)\n            if path.is_file():\n                parts.append(relative_path.as_posix())\n            if path.is_dir():\n                sub_parts = self._parse_folder(str(relative_path))\n                if sub_parts:\n                    parts.extend(sub_parts)\n                else:\n                    # store leaf directories\n                    parts.append(relative_path.as_posix() + \"/\")\n        return parts\n\n    def _get_folder_parts(self) -&gt; list[str]:\n        \"\"\"Get the list of members in the ODF folder.\"\"\"\n        return self._parse_folder(\"\")\n\n    def _get_folder_part(self, name: str) -&gt; tuple[bytes, int]:\n        \"\"\"Get bytes of a part from the ODF folder, with timestamp.\"\"\"\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        path = self.path / name\n        timestamp = int(path.stat().st_mtime)\n        if path.is_dir():\n            return (b\"\", timestamp)\n        return (path.read_bytes(), timestamp)\n\n    def _get_folder_part_timestamp(self, name: str) -&gt; int:\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        path = self.path / name\n        try:\n            timestamp = int(path.stat().st_mtime)\n        except OSError:\n            timestamp = -1\n        return timestamp\n\n    def _get_zip_part(self, name: str) -&gt; bytes | None:\n        \"\"\"Get bytes of a part from the Zip ODF file. No cache.\"\"\"\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        try:\n            with ZipFile(self.path) as zf:\n                upath = normalize_path(name)\n                self.__parts[upath] = zf.read(name)\n                return self.__parts[upath]\n        except BadZipfile:\n            return None\n\n    def _get_all_zip_part(self) -&gt; None:\n        \"\"\"Read all parts. No cache.\"\"\"\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        try:\n            with ZipFile(self.path) as zf:\n                for name in zf.namelist():\n                    upath = normalize_path(name)\n                    self.__parts[upath] = zf.read(name)\n        except BadZipfile:\n            pass\n\n    def _save_zip(self, target: str | Path | io.BytesIO) -&gt; None:\n        \"\"\"Save a Zip ODF from the available parts.\"\"\"\n        parts = self.__parts\n        with ZipFile(target, \"w\", compression=ZIP_DEFLATED) as filezip:\n            # Parts to save, except manifest at the end\n            part_names = list(parts.keys())\n            try:\n                part_names.remove(ODF_MANIFEST)\n            except ValueError:\n                printwarn(f\"Missing '{ODF_MANIFEST}'\")\n            # \"Pretty-save\" parts in some order\n            # mimetype requires to be first and uncompressed\n            mimetype = parts.get(\"mimetype\")\n            if mimetype is None:\n                raise ValueError(\"Mimetype is not defined\")\n            try:\n                filezip.writestr(\"mimetype\", mimetype, ZIP_STORED)\n                part_names.remove(\"mimetype\")\n            except (ValueError, KeyError):\n                printwarn(\"Missing 'mimetype'\")\n            # XML parts\n            for path in ODF_CONTENT, ODF_META, ODF_SETTINGS, ODF_STYLES:\n                if path not in parts:\n                    printwarn(f\"Missing '{path}'\")\n                    continue\n                part = parts[path]\n                if part is None:\n                    continue\n                filezip.writestr(path, part)\n                part_names.remove(path)\n            # Everything else\n            for path in part_names:\n                data = parts[path]\n                if data is None:\n                    # Deleted\n                    continue\n                filezip.writestr(path, data)\n            # Manifest\n            with contextlib.suppress(KeyError):\n                part = parts[ODF_MANIFEST]\n                if part is not None:\n                    filezip.writestr(ODF_MANIFEST, part)\n\n    def _save_folder(self, folder: Path | str) -&gt; None:\n        \"\"\"Save a folder ODF from the available parts.\"\"\"\n\n        def dump(part_path: str, content: bytes) -&gt; None:\n            if part_path.endswith(\"/\"):  # folder\n                is_folder = True\n                pure_path = PurePath(folder, part_path[:-1])\n            else:\n                is_folder = False\n                pure_path = PurePath(folder, part_path)\n            path = Path(pure_path)\n            if is_folder:\n                path.mkdir(parents=True, exist_ok=True)\n            else:\n                path.parent.mkdir(parents=True, exist_ok=True)\n                path.write_bytes(content)\n                path.chmod(0o666)\n\n        for part_path, data in self.__parts.items():\n            if data is None:\n                # Deleted\n                continue\n            dump(part_path, data)\n\n    def _xml_content(self) -&gt; bytes:\n        mimetype = self.__parts[\"mimetype\"].decode(\"utf8\")\n        doc_xml = (\n            OFFICE_PREFIX.decode(\"utf8\")\n            + f'office:version=\"{OFFICE_VERSION}\"\\n'\n            + f'office:mimetype=\"{mimetype}\"&gt;'\n            + \"&lt;/office:document&gt;\"\n        )\n        root = fromstring(doc_xml.encode(\"utf8\"))\n        for path in ODF_META, ODF_SETTINGS, ODF_STYLES, ODF_CONTENT:\n            if path not in self.__parts:\n                printwarn(f\"Missing '{path}'\")\n                continue\n            part = self.__parts[path]\n            if part is None:\n                continue\n            if isinstance(part, bytes):\n                xpart = fromstring(part)\n            else:\n                xpart = part\n            print(xpart, part.__class__.__name__)\n            for child in xpart:\n                root.append(child)\n        return tostring(root, encoding=\"UTF-8\", xml_declaration=True)\n\n    def _save_xml(self, target: Path | str) -&gt; None:\n        \"\"\"Save a XML flat ODF format from the available parts.\"\"\"\n        target = Path(target).with_suffix(\".xml\")\n        target.write_bytes(self._xml_content())\n\n    # Public API\n\n    def get_parts(self) -&gt; list[str]:\n        \"\"\"Get the list of members.\"\"\"\n        if not self.path:\n            # maybe a file like zip archive\n            return list(self.__parts.keys())\n        if self.__packaging == ZIP:\n            parts = []\n            with ZipFile(self.path) as zf:\n                for name in zf.namelist():\n                    upath = normalize_path(name)\n                    parts.append(upath)\n            return parts\n        elif self.__packaging == FOLDER:\n            return self._get_folder_parts()\n        else:\n            raise ValueError(\"Unable to provide parts of the document\")\n\n    @property\n    def parts(self) -&gt; list[str]:\n        \"\"\"Get the list of members.\"\"\"\n        return self.get_parts()\n\n    def get_part(self, path: str) -&gt; str | bytes | None:\n        \"\"\"Get the bytes of a part of the ODF.\"\"\"\n        path = str(path)\n        if path in self.__parts:\n            part = self.__parts[path]\n            if part is None:\n                raise ValueError(f'Part \"{path}\" is deleted')\n            if self.__packaging == FOLDER:\n                cache_ts = self.__parts_ts.get(path, -1)\n                current_ts = self._get_folder_part_timestamp(path)\n                if current_ts != cache_ts:\n                    part, timestamp = self._get_folder_part(path)\n                    self.__parts[path] = part\n                    self.__parts_ts[path] = timestamp\n            return part\n        if self.__packaging == ZIP:\n            return self._get_zip_part(path)\n        if self.__packaging == FOLDER:\n            part, timestamp = self._get_folder_part(path)\n            self.__parts[path] = part\n            self.__parts_ts[path] = timestamp\n            return part\n        return None\n\n    @property\n    def mimetype(self) -&gt; str:\n        \"\"\"Return str value of mimetype of the document.\"\"\"\n        with contextlib.suppress(Exception):\n            b_mimetype = self.get_part(\"mimetype\")\n            if isinstance(b_mimetype, bytes):\n                return bytes_to_str(b_mimetype)\n        return \"\"\n\n    @mimetype.setter\n    def mimetype(self, mimetype: str | bytes) -&gt; None:\n        \"\"\"Set mimetype value of the document.\"\"\"\n        if isinstance(mimetype, str):\n            self.__parts[\"mimetype\"] = str_to_bytes(mimetype)\n        elif isinstance(mimetype, bytes):\n            self.__parts[\"mimetype\"] = mimetype\n        else:\n            raise TypeError(f'Wrong mimetype \"{mimetype!r}\"')\n\n    def set_part(self, path: str, data: bytes) -&gt; None:\n        \"\"\"Replace or add a new part.\"\"\"\n        self.__parts[path] = data\n\n    def del_part(self, path: str) -&gt; None:\n        \"\"\"Mark a part for deletion.\"\"\"\n        self.__parts[path] = None\n\n    @property\n    def clone(self) -&gt; Container:\n        \"\"\"Make a copy of this container with no path.\"\"\"\n        if self.path and self.__packaging == ZIP:\n            self._get_all_zip_part()\n        clone = deepcopy(self)\n        clone.path = None\n        return clone\n\n    def _backup_or_unlink(self, backup: bool, target: str | Path) -&gt; None:\n        if backup:\n            self._do_backup(target)\n        else:\n            self._do_unlink(target)\n\n    @staticmethod\n    def _do_backup(target: str | Path) -&gt; None:\n        path = Path(target)\n        if not path.exists():\n            return\n        back_file = Path(path.stem + \".backup\" + path.suffix)\n        if back_file.is_dir():\n            try:\n                shutil.rmtree(back_file)\n            except OSError as e:\n                printwarn(str(e))\n        try:\n            shutil.move(target, back_file)\n        except OSError as e:\n            printwarn(str(e))\n\n    @staticmethod\n    def _do_unlink(target: str | Path) -&gt; None:\n        path = Path(target)\n        if path.exists():\n            try:\n                shutil.rmtree(path)\n            except OSError as e:\n                printwarn(str(e))\n\n    def _clean_save_packaging(self, packaging: str | None) -&gt; str:\n        if not packaging:\n            packaging = self.__packaging if self.__packaging else ZIP\n        packaging = packaging.strip().lower()\n        if packaging not in PACKAGING:\n            raise ValueError(f'Packaging of type \"{packaging}\" is not supported')\n        return packaging\n\n    def _clean_save_target(\n        self,\n        target: str | Path | io.BytesIO | None,\n    ) -&gt; str | io.BytesIO:\n        if target is None:\n            target = self.path\n        if isinstance(target, Path):\n            target = str(target)\n        if isinstance(target, str):\n            while target.endswith(os.sep):\n                target = target[:-1]\n            while target.endswith(\".folder\"):\n                target = target.split(\".folder\", 1)[0]\n        return target  # type: ignore\n\n    def _save_as_zip(self, target: str | Path | io.BytesIO, backup: bool) -&gt; None:\n        if isinstance(target, (str, Path)) and backup:\n            self._do_backup(target)\n        self._save_zip(target)\n\n    def _save_as_folder(self, target: str | Path, backup: bool) -&gt; None:\n        if not isinstance(target, (str, Path)):\n            raise TypeError(\n                f\"Saving in folder format requires a folder name, not '{target!r}'\"\n            )\n        if not str(target).endswith(\".folder\"):\n            target = str(target) + \".folder\"\n        self._backup_or_unlink(backup, target)\n        self._save_folder(target)\n\n    def _save_as_xml(self, target: str | Path | io.BytesIO, backup: bool) -&gt; None:\n        if not isinstance(target, (str, Path)):\n            raise TypeError(\n                f\"Saving in XML format requires a folder name, not '{target!r}'\"\n            )\n        if not str(target).endswith(\".xml\"):\n            target = str(target) + \".xml\"\n        if isinstance(target, (str, Path)) and backup:\n            self._do_backup(target)\n        self._save_xml(target)\n\n    def save(\n        self,\n        target: str | Path | io.BytesIO | None,\n        packaging: str | None = None,\n        backup: bool = False,\n    ) -&gt; None:\n        \"\"\"Save the container to the given target, a path or a file-like\n        object.\n\n        Package the output document in the same format than current document,\n        unless \"packaging\" is different.\n\n        Arguments:\n\n            target -- str or file-like or Path\n\n            packaging -- 'zip', or for debugging purpose 'xml' or 'folder'\n\n            backup -- boolean\n        \"\"\"\n        parts = self.__parts\n        packaging = self._clean_save_packaging(packaging)\n        # Load parts else they will be considered deleted\n        for path in self.parts:\n            if path not in parts:\n                self.get_part(path)\n        target = self._clean_save_target(target)\n        if packaging == FOLDER:\n            if isinstance(target, io.BytesIO):\n                raise TypeError(\n                    \"Impossible to save on io.BytesIO with 'folder' packaging\"\n                )\n            self._save_as_folder(target, backup)\n        elif packaging == XML:\n            self._save_as_xml(target, backup)\n        else:\n            # default:\n            self._save_as_zip(target, backup)\n</code></pre>"},{"location":"reference.html#odfdo.Container.clone","title":"<code>clone: Container</code>  <code>property</code>","text":"<p>Make a copy of this container with no path.</p>"},{"location":"reference.html#odfdo.Container.mimetype","title":"<code>mimetype: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return str value of mimetype of the document.</p>"},{"location":"reference.html#odfdo.Container.parts","title":"<code>parts: list[str]</code>  <code>property</code>","text":"<p>Get the list of members.</p>"},{"location":"reference.html#odfdo.Container.del_part","title":"<code>del_part(path)</code>","text":"<p>Mark a part for deletion.</p> Source code in <code>odfdo/container.py</code> <pre><code>def del_part(self, path: str) -&gt; None:\n    \"\"\"Mark a part for deletion.\"\"\"\n    self.__parts[path] = None\n</code></pre>"},{"location":"reference.html#odfdo.Container.get_part","title":"<code>get_part(path)</code>","text":"<p>Get the bytes of a part of the ODF.</p> Source code in <code>odfdo/container.py</code> <pre><code>def get_part(self, path: str) -&gt; str | bytes | None:\n    \"\"\"Get the bytes of a part of the ODF.\"\"\"\n    path = str(path)\n    if path in self.__parts:\n        part = self.__parts[path]\n        if part is None:\n            raise ValueError(f'Part \"{path}\" is deleted')\n        if self.__packaging == FOLDER:\n            cache_ts = self.__parts_ts.get(path, -1)\n            current_ts = self._get_folder_part_timestamp(path)\n            if current_ts != cache_ts:\n                part, timestamp = self._get_folder_part(path)\n                self.__parts[path] = part\n                self.__parts_ts[path] = timestamp\n        return part\n    if self.__packaging == ZIP:\n        return self._get_zip_part(path)\n    if self.__packaging == FOLDER:\n        part, timestamp = self._get_folder_part(path)\n        self.__parts[path] = part\n        self.__parts_ts[path] = timestamp\n        return part\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Container.get_parts","title":"<code>get_parts()</code>","text":"<p>Get the list of members.</p> Source code in <code>odfdo/container.py</code> <pre><code>def get_parts(self) -&gt; list[str]:\n    \"\"\"Get the list of members.\"\"\"\n    if not self.path:\n        # maybe a file like zip archive\n        return list(self.__parts.keys())\n    if self.__packaging == ZIP:\n        parts = []\n        with ZipFile(self.path) as zf:\n            for name in zf.namelist():\n                upath = normalize_path(name)\n                parts.append(upath)\n        return parts\n    elif self.__packaging == FOLDER:\n        return self._get_folder_parts()\n    else:\n        raise ValueError(\"Unable to provide parts of the document\")\n</code></pre>"},{"location":"reference.html#odfdo.Container.open","title":"<code>open(path_or_file)</code>","text":"<p>Load the content of an ODF file.</p> Source code in <code>odfdo/container.py</code> <pre><code>def open(self, path_or_file: Path | str | io.BytesIO) -&gt; None:\n    \"\"\"Load the content of an ODF file.\"\"\"\n    self.__path_like = path_or_file\n    if isinstance(path_or_file, (str, Path)):\n        self.path = Path(path_or_file).expanduser()\n        if not self.path.exists():\n            raise FileNotFoundError(str(self.path))\n        self.__path_like = self.path\n    if (self.path or isinstance(self.__path_like, io.BytesIO)) and is_zipfile(\n        self.__path_like  # type: ignore\n    ):\n        self.__packaging = ZIP\n        return self._read_zip()\n    if self.path:\n        is_folder = False\n        with contextlib.suppress(OSError):\n            is_folder = self.path.is_dir()\n        if is_folder:\n            self.__packaging = FOLDER\n            return self._read_folder()\n    raise TypeError(f\"Document format not managed by odfdo: {type(path_or_file)}.\")\n</code></pre>"},{"location":"reference.html#odfdo.Container.save","title":"<code>save(target, packaging=None, backup=False)</code>","text":"<p>Save the container to the given target, a path or a file-like object.</p> <p>Package the output document in the same format than current document, unless \u201cpackaging\u201d is different.</p> <p>Arguments:</p> <pre><code>target -- str or file-like or Path\n\npackaging -- 'zip', or for debugging purpose 'xml' or 'folder'\n\nbackup -- boolean\n</code></pre> Source code in <code>odfdo/container.py</code> <pre><code>def save(\n    self,\n    target: str | Path | io.BytesIO | None,\n    packaging: str | None = None,\n    backup: bool = False,\n) -&gt; None:\n    \"\"\"Save the container to the given target, a path or a file-like\n    object.\n\n    Package the output document in the same format than current document,\n    unless \"packaging\" is different.\n\n    Arguments:\n\n        target -- str or file-like or Path\n\n        packaging -- 'zip', or for debugging purpose 'xml' or 'folder'\n\n        backup -- boolean\n    \"\"\"\n    parts = self.__parts\n    packaging = self._clean_save_packaging(packaging)\n    # Load parts else they will be considered deleted\n    for path in self.parts:\n        if path not in parts:\n            self.get_part(path)\n    target = self._clean_save_target(target)\n    if packaging == FOLDER:\n        if isinstance(target, io.BytesIO):\n            raise TypeError(\n                \"Impossible to save on io.BytesIO with 'folder' packaging\"\n            )\n        self._save_as_folder(target, backup)\n    elif packaging == XML:\n        self._save_as_xml(target, backup)\n    else:\n        # default:\n        self._save_as_zip(target, backup)\n</code></pre>"},{"location":"reference.html#odfdo.Container.set_part","title":"<code>set_part(path, data)</code>","text":"<p>Replace or add a new part.</p> Source code in <code>odfdo/container.py</code> <pre><code>def set_part(self, path: str, data: bytes) -&gt; None:\n    \"\"\"Replace or add a new part.\"\"\"\n    self.__parts[path] = data\n</code></pre>"},{"location":"reference.html#odfdo.Content","title":"<code>Content</code>","text":"<p>             Bases: <code>XmlPart</code></p> Source code in <code>odfdo/content.py</code> <pre><code>class Content(XmlPart):\n    # The following two seem useless but they match styles API\n\n    def _get_style_contexts(self, family: str | None) -&gt; tuple:\n        if family == \"font-face\":\n            return (self.get_element(\"//office:font-face-decls\"),)\n        return (\n            self.get_element(\"//office:font-face-decls\"),\n            self.get_element(\"//office:automatic-styles\"),\n        )\n\n    def __str__(self) -&gt; str:\n        return str(self.body)\n\n    # Public API\n\n    def get_styles(self, family: str | None = None) -&gt; list[Style]:\n        \"\"\"Return the list of styles in the Content part, optionally limited\n        to the given family.\n\n        Arguments:\n\n            family -- str or None\n\n        Return: list of Style\n        \"\"\"\n        result: list[Style] = []\n        for context in self._get_style_contexts(family):\n            if context is None:\n                continue\n            result.extend(context.get_styles(family=family))\n        return result\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Element | None = None,\n        display_name: str | None = None,\n    ) -&gt; Style | None:\n        \"\"\"Return the style uniquely identified by the name/family pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is None, the default style is fetched.\n\n        If the name is not the internal name but the name you gave in the\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                      'number'\n\n            name_or_element -- str or Style\n\n            display_name -- str\n\n        Return: Style or None if not found\n        \"\"\"\n        for context in self._get_style_contexts(family):\n            if context is None:\n                continue\n            style = context.get_style(\n                family,\n                name_or_element=name_or_element,\n                display_name=display_name,\n            )\n            if style is not None:\n                return style\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Content.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the name/family pair. If the argument is already a style object, it will return it.</p> <p>If the name is None, the default style is fetched.</p> <p>If the name is not the internal name but the name you gave in the desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n          'number'\n\nname_or_element -- str or Style\n\ndisplay_name -- str\n</code></pre> <p>Return: Style or None if not found</p> Source code in <code>odfdo/content.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Element | None = None,\n    display_name: str | None = None,\n) -&gt; Style | None:\n    \"\"\"Return the style uniquely identified by the name/family pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is None, the default style is fetched.\n\n    If the name is not the internal name but the name you gave in the\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                  'number'\n\n        name_or_element -- str or Style\n\n        display_name -- str\n\n    Return: Style or None if not found\n    \"\"\"\n    for context in self._get_style_contexts(family):\n        if context is None:\n            continue\n        style = context.get_style(\n            family,\n            name_or_element=name_or_element,\n            display_name=display_name,\n        )\n        if style is not None:\n            return style\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Content.get_styles","title":"<code>get_styles(family=None)</code>","text":"<p>Return the list of styles in the Content part, optionally limited to the given family.</p> <p>Arguments:</p> <pre><code>family -- str or None\n</code></pre> <p>Return: list of Style</p> Source code in <code>odfdo/content.py</code> <pre><code>def get_styles(self, family: str | None = None) -&gt; list[Style]:\n    \"\"\"Return the list of styles in the Content part, optionally limited\n    to the given family.\n\n    Arguments:\n\n        family -- str or None\n\n    Return: list of Style\n    \"\"\"\n    result: list[Style] = []\n    for context in self._get_style_contexts(family):\n        if context is None:\n            continue\n        result.extend(context.get_styles(family=family))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Database","title":"<code>Database</code>","text":"<p>             Bases: <code>Body</code></p> <p>Database, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Database(Body):\n    \"\"\"Database, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:database\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.Document","title":"<code>Document</code>","text":"<p>Abstraction of the ODF document.</p> <p>To create a new Document, several possibilities:</p> <pre><code>- Document() or Document(\"text\") -&gt; an \"empty\" document of type text\n- Document(\"spreadsheet\") -&gt; an \"empty\" document of type spreadsheet\n- Document(\"presentation\") -&gt; an \"empty\" document of type presentation\n- Document(\"drawing\") -&gt; an \"empty\" document of type drawing\n\nMeaning of \u201cempty\u201d: these documents are copies of the default\ntemplates documents provided with this library, which, as templates,\nare not really empty. It may be useful to clear the newly created\ndocument: document.body.clear(), or adjust meta informations like\ndescription or default language: document.meta.language = 'fr-FR'\n</code></pre> <p>If the argument is not a known template type, or is a Path, Document(file) will load the content of the ODF file.</p> <p>To explicitly create a document from a custom template, use the Document.new(path) method whose argument is the path to the template file.</p> Source code in <code>odfdo/document.py</code> <pre><code>class Document:\n    \"\"\"Abstraction of the ODF document.\n\n    To create a new Document, several possibilities:\n\n        - Document() or Document(\"text\") -&gt; an \"empty\" document of type text\n        - Document(\"spreadsheet\") -&gt; an \"empty\" document of type spreadsheet\n        - Document(\"presentation\") -&gt; an \"empty\" document of type presentation\n        - Document(\"drawing\") -&gt; an \"empty\" document of type drawing\n\n        Meaning of \u201cempty\u201d: these documents are copies of the default\n        templates documents provided with this library, which, as templates,\n        are not really empty. It may be useful to clear the newly created\n        document: document.body.clear(), or adjust meta informations like\n        description or default language: document.meta.language = 'fr-FR'\n\n    If the argument is not a known template type, or is a Path,\n    Document(file) will load the content of the ODF file.\n\n    To explicitly create a document from a custom template, use the\n    Document.new(path) method whose argument is the path to the template file.\n    \"\"\"\n\n    def __init__(\n        self,\n        target: str | bytes | Path | Container | io.BytesIO | None = \"text\",\n    ) -&gt; None:\n        # Cache of XML parts\n        self.__xmlparts: dict[str, XmlPart] = {}\n        # Cache of the body\n        self.__body: Element | None = None\n        self.container: Container | None = None\n        if isinstance(target, bytes):\n            # eager conversion\n            target = bytes_to_str(target)\n        if target is None:\n            # empty document, you probably don't wnat this.\n            self.container = Container()\n            return\n        if isinstance(target, Path):\n            # let's assume we open a container on existing file\n            self.container = Container(target)\n            return\n        if isinstance(target, Container):\n            # special internal case, use an existing container\n            self.container = target\n            return\n        if isinstance(target, str):\n            if target in ODF_TEMPLATES:\n                # assuming a new document from templates\n                self.container = container_from_template(target)\n                return\n            # let's assume we open a container on existing file\n            self.container = Container(target)\n            return\n        if isinstance(target, io.BytesIO):\n            self.container = Container(target)\n            return\n        raise TypeError(f\"Unknown Document source type: '{target!r}'\")\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} type={self.get_type()} path={self.path}&gt;\"\n\n    def __str__(self) -&gt; str:\n        try:\n            return str(self.get_formatted_text())\n        except NotImplementedError:\n            return self.body.text_recursive\n\n    @classmethod\n    def new(cls, template: str | Path | io.BytesIO = \"text\") -&gt; Document:\n        \"\"\"Create a Document from a template.\n\n        The template argument is expected to be the path to a ODF template.\n\n        Arguments:\n\n            template -- str or Path or file-like (io.BytesIO)\n\n        Return : ODF document -- Document\n        \"\"\"\n        container = container_from_template(template)\n        return cls(container)\n\n    # Public API\n\n    @property\n    def path(self) -&gt; Path | None:\n        \"\"\"Shortcut to Document.Container.path.\"\"\"\n        if not self.container:\n            return None\n        return self.container.path\n\n    @path.setter\n    def path(self, path_or_str: str | Path) -&gt; None:\n        \"\"\"Shortcut to Document.Container.path\n\n        Only accepting str or Path.\"\"\"\n        if not self.container:\n            return\n        self.container.path = Path(path_or_str)\n\n    def get_parts(self) -&gt; list[str]:\n        \"\"\"Return available part names with path inside the archive, e.g.\n        ['content.xml', ..., 'Pictures/100000000000032000000258912EB1C3.jpg']\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        return self.container.parts\n\n    @property\n    def parts(self) -&gt; list[str]:\n        \"\"\"Return available part names with path inside the archive, e.g.\n        ['content.xml', ..., 'Pictures/100000000000032000000258912EB1C3.jpg']\n        \"\"\"\n        return self.get_parts()\n\n    def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:\n        \"\"\"Return the bytes of the given part. The path is relative to the\n        archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n        'content', 'meta', 'settings', 'styles' and 'manifest' are shortcuts\n        to the real path, e.g. content.xml, and return a dedicated object with\n        its own API.\n\n        path formated as URI, so always use '/' separator\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        # \"./ObjectReplacements/Object 1\"\n        path = path.lstrip(\"./\")\n        path = _get_part_path(path)\n        cls = _get_part_class(path)\n        # Raw bytes\n        if cls is None:\n            return self.container.get_part(path)\n        # XML part\n        part = self.__xmlparts.get(path)\n        if part is None:\n            self.__xmlparts[path] = part = cls(path, self.container)\n        return part\n\n    def set_part(self, path: str, data: bytes) -&gt; None:\n        \"\"\"Set the bytes of the given part. The path is relative to the\n        archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n        path formated as URI, so always use '/' separator\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        # \"./ObjectReplacements/Object 1\"\n        path = path.lstrip(\"./\")\n        path = _get_part_path(path)\n        cls = _get_part_class(path)\n        # XML part overwritten\n        if cls is not None:\n            with suppress(KeyError):\n                self.__xmlparts[path]\n        self.container.set_part(path, data)\n\n    def del_part(self, path: str) -&gt; None:\n        \"\"\"Mark a part for deletion. The path is relative to the archive,\n        e.g. \"Pictures/1003200258912EB1C3.jpg\"\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        path = _get_part_path(path)\n        cls = _get_part_class(path)\n        if path == ODF_MANIFEST or cls is not None:\n            raise ValueError(f\"part '{path}' is mandatory\")\n        self.container.del_part(path)\n\n    @property\n    def mimetype(self) -&gt; str:\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        return self.container.mimetype\n\n    @mimetype.setter\n    def mimetype(self, mimetype: str) -&gt; None:\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        self.container.mimetype = mimetype\n\n    def get_type(self) -&gt; str:\n        \"\"\"Get the ODF type (also called class) of this document.\n\n        Return: 'chart', 'database', 'formula', 'graphics',\n            'graphics-template', 'image', 'presentation',\n            'presentation-template', 'spreadsheet', 'spreadsheet-template',\n            'text', 'text-master', 'text-template' or 'text-web'\n        \"\"\"\n        # The mimetype must be with the form:\n        # application/vnd.oasis.opendocument.text\n\n        # Isolate and return the last part\n        return self.mimetype.rsplit(\".\", 1)[-1]\n\n    @property\n    def body(self) -&gt; Element:\n        \"\"\"Return the body element of the content part, where actual content\n        is stored.\n        \"\"\"\n        if self.__body is None:\n            self.__body = self.content.body\n        return self.__body\n\n    @property\n    def meta(self) -&gt; Meta:\n        \"\"\"Return the meta part (meta.xml) of the document, where meta data\n        are stored.\"\"\"\n        metadata = self.get_part(ODF_META)\n        if metadata is None or not isinstance(metadata, Meta):\n            raise ValueError(\"Empty Meta\")\n        return metadata\n\n    @property\n    def manifest(self) -&gt; Manifest:\n        \"\"\"Return the manifest part (manifest.xml) of the document.\"\"\"\n        manifest = self.get_part(ODF_MANIFEST)\n        if manifest is None or not isinstance(manifest, Manifest):\n            raise ValueError(\"Empty Manifest\")\n        return manifest\n\n    def _get_formatted_text_footnotes(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Separate text from notes\n        if rst_mode:\n            result.append(\"\\n\")\n        else:\n            result.append(\"----\\n\")\n        for citation, body in context[\"footnotes\"]:\n            if rst_mode:\n                result.append(f\".. [#] {body}\\n\")\n            else:\n                result.append(f\"[{citation}] {body}\\n\")\n        # Append a \\n after the notes\n        result.append(\"\\n\")\n        # Reset for the next paragraph\n        context[\"footnotes\"] = []\n\n    def _get_formatted_text_annotations(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Insert the annotations\n        # With a separation\n        if rst_mode:\n            result.append(\"\\n\")\n        else:\n            result.append(\"----\\n\")\n        for annotation in context[\"annotations\"]:\n            if rst_mode:\n                result.append(f\".. [#] {annotation}\\n\")\n            else:\n                result.append(f\"[*] {annotation}\\n\")\n        context[\"annotations\"] = []\n\n    def _get_formatted_text_images(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Insert the images ref, only in rst mode\n        result.append(\"\\n\")\n        for ref, filename, (width, height) in context[\"images\"]:\n            result.append(f\".. {ref} image:: {filename}\\n\")\n            if width is not None:\n                result.append(f\"   :width: {width}\\n\")\n            if height is not None:\n                result.append(f\"   :height: {height}\\n\")\n        context[\"images\"] = []\n\n    def _get_formatted_text_endnotes(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Append the end notes\n        if rst_mode:\n            result.append(\"\\n\\n\")\n        else:\n            result.append(\"\\n========\\n\")\n        for citation, body in context[\"endnotes\"]:\n            if rst_mode:\n                result.append(f\".. [*] {body}\\n\")\n            else:\n                result.append(f\"({citation}) {body}\\n\")\n\n    def get_formatted_text(self, rst_mode: bool = False) -&gt; str:\n        \"\"\"Return content as text, with some formatting.\"\"\"\n        # For the moment, only \"type='text'\"\n        doc_type = self.get_type()\n        if doc_type == \"spreadsheet\":\n            return self._tables_csv()\n        if doc_type in {\n            \"text\",\n            \"text-template\",\n            \"presentation\",\n            \"presentation-template\",\n        }:\n            return self._formatted_text(rst_mode)\n        raise NotImplementedError(f\"Type of document '{doc_type}' not supported yet\")\n\n    def _tables_csv(self) -&gt; str:\n        return \"\\n\\n\".join(str(table) for table in self.body.tables)\n\n    def _formatted_text(self, rst_mode: bool) -&gt; str:\n        # Initialize an empty context\n        context = {\n            \"document\": self,\n            \"footnotes\": [],\n            \"endnotes\": [],\n            \"annotations\": [],\n            \"rst_mode\": rst_mode,\n            \"img_counter\": 0,\n            \"images\": [],\n            \"no_img_level\": 0,\n        }\n        body = self.body\n        # Get the text\n        result = []\n        for child in body.children:\n            # self._get_formatted_text_child(result, element, context, rst_mode)\n            # if child.tag == \"table:table\":\n            #     result.append(child.get_formatted_text(context))\n            #     return\n            result.append(child.get_formatted_text(context))\n            if context[\"footnotes\"]:\n                self._get_formatted_text_footnotes(result, context, rst_mode)\n            if context[\"annotations\"]:\n                self._get_formatted_text_annotations(result, context, rst_mode)\n            # Insert the images ref, only in rst mode\n            if context[\"images\"]:\n                self._get_formatted_text_images(result, context, rst_mode)\n        if context[\"endnotes\"]:\n            self._get_formatted_text_endnotes(result, context, rst_mode)\n        return \"\".join(result)\n\n    def get_formated_meta(self) -&gt; str:\n        \"\"\"Return meta informations as text, with some formatting.\"\"\"\n        result: list[str] = []\n\n        # Simple values\n        def print_info(name: str, value: Any) -&gt; None:\n            if value:\n                result.append(f\"{name}: {value}\")\n\n        meta = self.meta\n        print_info(\"Title\", meta.title)\n        print_info(\"Subject\", meta.subject)\n        print_info(\"Description\", meta.description)\n        print_info(\"Language\", meta.language)\n        print_info(\"Modification date\", meta.date)\n        print_info(\"Creation date\", meta.creation_date)\n        print_info(\"Initial creator\", meta.initial_creator)\n        print_info(\"Keyword\", meta.keyword)\n        print_info(\"Editing duration\", meta.editing_duration)\n        print_info(\"Editing cycles\", meta.editing_cycles)\n        print_info(\"Generator\", meta.generator)\n\n        # Statistic\n        result.append(\"Statistic:\")\n        statistic = meta.statistic\n        if statistic:\n            for name, data in statistic.items():\n                result.append(f\"  - {name[5:].replace('-', ' ').capitalize()}: {data}\")\n\n        # User defined metadata\n        result.append(\"User defined metadata:\")\n        user_metadata = meta.user_defined_metadata\n        for name, data2 in user_metadata.items():\n            result.append(f\"  - {name}: {data2}\")\n\n        # And the description\n        print_info(\"Description\", meta.get_description())\n\n        return \"\\n\".join(result) + \"\\n\"\n\n    def add_file(self, path_or_file: str | Path) -&gt; str:\n        \"\"\"Insert a file from a path or a file-like object in the container.\n\n        Return the full path to reference in the content.\n\n        Arguments:\n\n            path_or_file -- str or Path or file-like\n\n        Return: str (URI)\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        name = \"\"\n        # Folder for added files (FIXME hard-coded and copied)\n        manifest = self.manifest\n        medias = manifest.get_paths()\n        # uuid = str(uuid4())\n\n        if isinstance(path_or_file, (str, Path)):\n            path = Path(path_or_file)\n            extension = path.suffix.lower()\n            name = f\"{path.stem}{extension}\"\n            if posixpath.join(\"Pictures\", name) in medias:\n                name = f\"{path.stem}_{uuid4()}{extension}\"\n        else:\n            path = None\n            name = getattr(path_or_file, \"name\", None)\n            if not name:\n                name = str(uuid4())\n        media_type, _encoding = guess_type(name)\n        if not media_type:\n            media_type = \"application/octet-stream\"\n        if manifest.get_media_type(\"Pictures/\") is None:\n            manifest.add_full_path(\"Pictures/\")\n        full_path = posixpath.join(\"Pictures\", name)\n        if path is None:\n            self.container.set_part(full_path, path_or_file.read())  # type:ignore\n        else:\n            self.container.set_part(full_path, path.read_bytes())\n        manifest.add_full_path(full_path, media_type)\n        return full_path\n\n    @property\n    def clone(self) -&gt; Document:\n        \"\"\"Return an exact copy of the document.\n\n        Return: Document\n        \"\"\"\n        clone = object.__new__(self.__class__)\n        for name in self.__dict__:\n            if name == \"_Document__body\":\n                setattr(clone, name, None)\n            elif name == \"_Document__xmlparts\":\n                setattr(clone, name, {})\n            elif name == \"container\":\n                if not self.container:\n                    raise ValueError(\"Empty Container\")\n                setattr(clone, name, self.container.clone)\n            else:\n                value = deepcopy(getattr(self, name))\n                setattr(clone, name, value)\n        return clone\n\n    def save(\n        self,\n        target: str | Path | io.BytesIO | None = None,\n        packaging: str = ZIP,\n        pretty: bool = False,\n        backup: bool = False,\n    ) -&gt; None:\n        \"\"\"Save the document, at the same place it was opened or at the given\n        target path. Target can also be a file-like object. It can be saved\n        as a Zip file (default), flat XML format or as files in a folder\n        (for debugging purpose). XML parts can be pretty printed.\n\n        Arguments:\n\n            target -- str or file-like object\n\n            packaging -- 'zip', 'folder', 'xml'\n\n            pretty -- bool\n\n            backup -- bool\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        # Some advertising\n        self.meta.set_generator_default()\n        # Synchronize data with container\n        container = self.container\n        for path, part in self.__xmlparts.items():\n            if part is not None:\n                container.set_part(path, part.serialize(pretty))\n        # Save the container\n        container.save(target, packaging=packaging, backup=backup)\n\n    @property\n    def content(self) -&gt; Content:\n        content: Content | None = self.get_part(ODF_CONTENT)  # type:ignore\n        if content is None:\n            raise ValueError(\"Empty Content\")\n        return content\n\n    @property\n    def styles(self) -&gt; Styles:\n        styles: Styles | None = self.get_part(ODF_STYLES)  # type:ignore\n        if styles is None:\n            raise ValueError(\"Empty Styles\")\n        return styles\n\n    # Styles over several parts\n\n    def get_styles(\n        self,\n        family: str | bytes = \"\",\n        automatic: bool = False,\n    ) -&gt; list[Style | Element]:\n        # compatibility with old versions:\n\n        if isinstance(family, bytes):\n            family = bytes_to_str(family)\n        return self.content.get_styles(family=family) + self.styles.get_styles(\n            family=family, automatic=automatic\n        )\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Style | None = None,\n        display_name: str | None = None,\n    ) -&gt; Style | None:\n        \"\"\"Return the style uniquely identified by the name/family pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is None, the default style is fetched.\n\n        If the name is not the internal name but the name you gave in a\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                      'number', 'page-layout', 'master-page'\n\n            name -- str or Element or None\n\n            display_name -- str\n\n        Return: Style or None if not found.\n        \"\"\"\n        # 1. content.xml\n        element = self.content.get_style(\n            family, name_or_element=name_or_element, display_name=display_name\n        )\n        if element is not None:\n            return element\n        # 2. styles.xml\n        return self.styles.get_style(\n            family,\n            name_or_element=name_or_element,\n            display_name=display_name,\n        )\n\n    @staticmethod\n    def _pseudo_style_attribute(style_element: Style | Element, attribute: str) -&gt; Any:\n        if hasattr(style_element, attribute):\n            return getattr(style_element, attribute)\n        return \"\"\n\n    def _set_automatic_name(self, style: Style, family: str) -&gt; None:\n        \"\"\"Generate a name for the new automatic style.\"\"\"\n        if not hasattr(style, \"name\"):\n            # do nothing\n            return\n        styles = self.get_styles(family=family, automatic=True)\n        max_index = 0\n        for existing_style in styles:\n            if not hasattr(existing_style, \"name\"):\n                continue\n            if not existing_style.name.startswith(AUTOMATIC_PREFIX):\n                continue\n            try:\n                index = int(existing_style.name[len(AUTOMATIC_PREFIX) :])  # type: ignore\n            except ValueError:\n                continue\n            max_index = max(max_index, index)\n\n        style.name = f\"{AUTOMATIC_PREFIX}{max_index+1}\"\n\n    def _insert_style_get_common_styles(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:styles\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_automatic_styles(\n        self,\n        style: Style,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.content.get_element(\"office:automatic-styles\")\n        # A name ?\n        if name:\n            if hasattr(style, \"name\"):\n                style.name = name\n            existing = self.content.get_style(family, name)\n        else:\n            self._set_automatic_name(style, family)\n            existing = None\n        return existing, style_container\n\n    def _insert_style_get_default_styles(\n        self,\n        style: Style,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:styles\")\n        style.tag = \"style:default-style\"\n        if name:\n            style.del_attribute(\"style:name\")\n        existing = self.styles.get_style(family)\n        return existing, style_container\n\n    def _insert_style_get_master_page(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:master-styles\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_font_face_default(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:font-face-decls\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_font_face(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.content.get_element(\"office:font-face-decls\")\n        existing = self.content.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_page_layout(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        # force to automatic\n        style_container = self.styles.get_element(\"office:automatic-styles\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_draw_fill_image(\n        self,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        # special case for 'draw:fill-image' pseudo style\n        # not family and style_element.__class__.__name__ == \"DrawFillImage\"\n        style_container = self.styles.get_element(\"office:styles\")\n        existing = self.styles.get_style(\"\", name)\n        return existing, style_container\n\n    def _insert_style_standard(\n        self,\n        style: Style,\n        name: str,\n        family: str,\n        automatic: bool,\n        default: bool,\n    ) -&gt; tuple[Any, Any]:\n        # Common style\n        if name and automatic is False and default is False:\n            return self._insert_style_get_common_styles(family, name)\n        # Automatic style\n        elif automatic is True and default is False:\n            return self._insert_style_get_automatic_styles(style, family, name)\n        # Default style\n        elif automatic is False and default is True:\n            return self._insert_style_get_default_styles(style, family, name)\n        else:\n            raise AttributeError(\"Invalid combination of arguments\")\n\n    def insert_style(  # noqa: C901\n        self,\n        style: Style | str,\n        name: str = \"\",\n        automatic: bool = False,\n        default: bool = False,\n    ) -&gt; Any:\n        \"\"\"Insert the given style object in the document, as required by the\n        style family and type.\n\n        The style is expected to be a common style with a name. In case it\n        was created with no name, the given can be set on the fly.\n\n        If automatic is True, the style will be inserted as an automatic\n        style.\n\n        If default is True, the style will be inserted as a default style and\n        would replace any existing default style of the same family. Any name\n        or display name would be ignored.\n\n        Automatic and default arguments are mutually exclusive.\n\n        All styles can't be used as default styles. Default styles are\n        allowed for the following families: paragraph, text, section, table,\n        table-column, table-row, table-cell, table-page, chart, drawing-page,\n        graphic, presentation, control and ruby.\n\n        Arguments:\n\n            style -- Style or str\n\n            name -- str\n\n            automatic -- bool\n\n            default -- bool\n\n        Return : style name -- str\n        \"\"\"\n\n        # if style is a str, assume it is the Style definition\n        if isinstance(style, str):\n            style_element: Style = Element.from_tag(style)  # type: ignore\n        else:\n            style_element = style\n        if not isinstance(style_element, Element):\n            raise TypeError(f\"Unknown Style type: '{style!r}'\")\n\n        # Get family and name\n        family = self._pseudo_style_attribute(style_element, \"family\")\n        if not name:\n            name = self._pseudo_style_attribute(style_element, \"name\")\n\n        # Master page style\n        if family == \"master-page\":\n            existing, style_container = self._insert_style_get_master_page(family, name)\n        # Font face declarations\n        elif family == \"font-face\":\n            if default:\n                existing, style_container = self._insert_style_get_font_face_default(\n                    family, name\n                )\n            else:\n                existing, style_container = self._insert_style_get_font_face(\n                    family, name\n                )\n        # page layout style\n        elif family == \"page-layout\":\n            existing, style_container = self._insert_style_get_page_layout(family, name)\n        # Common style\n        elif family in FAMILY_ODF_STD or family in {\"number\"}:\n            existing, style_container = self._insert_style_standard(\n                style_element, name, family, automatic, default\n            )\n        elif not family and style_element.__class__.__name__ == \"DrawFillImage\":\n            # special case for 'draw:fill-image' pseudo style\n            existing, style_container = self._insert_style_get_draw_fill_image(name)\n        # Invalid style\n        else:\n            raise ValueError(\n                \"Invalid style: \"\n                f\"{style_element}, tag:{style_element.tag}, family:{family}\"\n            )\n\n        # Insert it!\n        if existing is not None:\n            style_container.delete(existing)\n        style_container.append(style_element)\n        return self._pseudo_style_attribute(style_element, \"name\")\n\n    def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n        \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n        name (or all by default).\n\n        Arguments:\n\n            name -- str\n\n        Return: list\n        \"\"\"\n        # Header, footer, etc. have styles too\n        return self.content.root.get_styled_elements(\n            name\n        ) + self.styles.root.get_styled_elements(name)\n\n    def show_styles(\n        self,\n        automatic: bool = True,\n        common: bool = True,\n        properties: bool = False,\n    ) -&gt; str:\n        infos = []\n        for style in self.get_styles():\n            try:\n                name = style.name  # type: ignore\n            except AttributeError:\n                print(\"--------------\")\n                print(style.__class__)\n                print(style.serialize())\n                raise\n            if style.__class__.__name__ == \"DrawFillImage\":\n                family = \"\"\n            else:\n                family = str(style.family)  # type: ignore\n            parent = style.parent\n            is_auto = parent and parent.tag == \"office:automatic-styles\"\n            if is_auto and automatic is False or not is_auto and common is False:\n                continue\n            is_used = bool(self.get_styled_elements(name))\n            infos.append(\n                {\n                    \"type\": \"auto  \" if is_auto else \"common\",\n                    \"used\": \"y\" if is_used else \"n\",\n                    \"family\": family,\n                    \"parent\": self._pseudo_style_attribute(style, \"parent_style\") or \"\",\n                    \"name\": name or \"\",\n                    \"display_name\": self._pseudo_style_attribute(style, \"display_name\")\n                    or \"\",\n                    \"properties\": style.get_properties() if properties else None,  # type: ignore\n                }\n            )\n        if not infos:\n            return \"\"\n        # Sort by family and name\n        infos.sort(key=itemgetter(\"family\", \"name\"))\n        # Show common and used first\n        infos.sort(key=itemgetter(\"type\", \"used\"), reverse=True)\n        max_family = str(max([len(x[\"family\"]) for x in infos]))  # type: ignore\n        max_parent = str(max([len(x[\"parent\"]) for x in infos]))  # type: ignore\n        formater = (\n            \"%(type)s used:%(used)s family:%(family)-0\"\n            + max_family\n            + \"s parent:%(parent)-0\"\n            + max_parent\n            + \"s name:%(name)s\"\n        )\n        output = []\n        for info in infos:\n            line = formater % info\n            if info[\"display_name\"]:\n                line += \" display_name:\" + info[\"display_name\"]  # type: ignore\n            output.append(line)\n            if info[\"properties\"]:\n                for name, value in info[\"properties\"].items():  # type: ignore\n                    output.append(f\"   - {name}: {value}\")\n        output.append(\"\")\n        return \"\\n\".join(output)\n\n    def delete_styles(self) -&gt; int:\n        \"\"\"Remove all style information from content and all styles.\n\n        Return: number of deleted styles\n        \"\"\"\n        # First remove references to styles\n        for element in self.get_styled_elements():\n            for attribute in (\n                \"text:style-name\",\n                \"draw:style-name\",\n                \"draw:text-style-name\",\n                \"table:style-name\",\n                \"style:page-layout-name\",\n            ):\n                try:\n                    element.del_attribute(attribute)\n                except KeyError:\n                    continue\n        # Then remove supposedly orphaned styles\n        deleted = 0\n        for style in self.get_styles():\n            if style.name is None:  # type: ignore\n                # Don't delete default styles\n                continue\n            # elif type(style) is odf_master_page:\n            #    # Don't suppress header and footer, just styling was removed\n            #    continue\n            style.delete()\n            deleted += 1\n        return deleted\n\n    def merge_styles_from(self, document: Document) -&gt; None:\n        \"\"\"Copy all the styles of a document into ourself.\n\n        Styles with the same type and name will be replaced, so only unique\n        styles will be preserved.\n        \"\"\"\n        manifest = self.manifest\n        document_manifest = document.manifest\n        for style in document.get_styles():\n            tagname = style.tag\n            family = self._pseudo_style_attribute(style, \"family\")\n            stylename = style.name  # type: ignore\n            container = style.parent\n            container_name = container.tag  # type: ignore\n            partname = container.parent.tag  # type: ignore\n            # The destination part\n            if partname == \"office:document-styles\":\n                part: Content | Styles = self.styles\n            elif partname == \"office:document-content\":\n                part = self.content\n            else:\n                raise NotImplementedError(partname)\n            # Implemented containers\n            if container_name not in {\n                \"office:styles\",\n                \"office:automatic-styles\",\n                \"office:master-styles\",\n                \"office:font-face-decls\",\n            }:\n                raise NotImplementedError(container_name)\n            dest = part.get_element(f\"//{container_name}\")\n            # Implemented style types\n            # if tagname not in registered_styles:\n            #    raise NotImplementedError(tagname)\n            duplicate = part.get_style(family, stylename)\n            if duplicate is not None:\n                duplicate.delete()\n            dest.append(style)\n            # Copy images from the header/footer\n            if tagname == \"style:master-page\":\n                query = \"descendant::draw:image\"\n                for image in style.get_elements(query):\n                    url = image.url  # type: ignore\n                    part_url = document.get_part(url)\n                    # Manually add the part to keep the name\n                    self.set_part(url, part_url)  # type: ignore\n                    media_type = document_manifest.get_media_type(url)\n                    manifest.add_full_path(url, media_type)  # type: ignore\n            # Copy images from the fill-image\n            elif tagname == \"draw:fill-image\":\n                url = style.url  # type: ignore\n                part_url = document.get_part(url)\n                self.set_part(url, part_url)  # type: ignore\n                media_type = document_manifest.get_media_type(url)\n                manifest.add_full_path(url, media_type)  # type: ignore\n\n    def add_page_break_style(self) -&gt; None:\n        \"\"\"Ensure that the document contains the style required for a manual page break.\n\n        Then a manual page break can be added to the document with:\n            from paragraph import PageBreak\n            ...\n            document.body.append(PageBreak())\n\n        Note: this style uses the property 'fo:break-after', another\n        possibility could be the property 'fo:break-before'\n        \"\"\"\n        if existing := self.get_style(  # noqa: SIM102\n            family=\"paragraph\",\n            name_or_element=\"odfdopagebreak\",\n        ):\n            if properties := existing.get_properties():  # noqa: SIM102\n                if properties[\"fo:break-after\"] == \"page\":\n                    return\n        style = (\n            '&lt;style:style style:family=\"paragraph\" style:parent-style-name=\"Standard\" '\n            'style:name=\"odfdopagebreak\"&gt;'\n            '&lt;style:paragraph-properties fo:break-after=\"page\"/&gt;&lt;/style:style&gt;'\n        )\n        self.insert_style(style, automatic=False)\n\n    def get_style_properties(\n        self, family: str, name: str, area: str | None = None\n    ) -&gt; dict[str, str] | None:\n        \"\"\"Return the properties of the required style as a dict.\"\"\"\n        style = self.get_style(family, name)\n        if style is None:\n            return None\n        return style.get_properties(area=area)  # type: ignore\n\n    def get_cell_style_properties(  # noqa: C901\n        self, table: str | int, coord: tuple | list | str\n    ) -&gt; dict[str, str]:  # type: ignore\n        \"\"\"Return the style properties of a table cell of a .ods document,\n        from the cell style or from the row style.\"\"\"\n\n        def _get_table(table: int | str) -&gt; Table | None:\n            table_pos = 0\n            table_name = None\n            if isinstance(table, int):\n                table_pos = table\n            elif isinstance(table, str):\n                table_name = table_name\n            else:\n                raise TypeError(f\"Table parameter must be int or str: {table!r}\")\n            return self.body.get_table(\n                position=table_pos, name=table_name  # type: ignore\n            )\n\n        if not (sheet := _get_table(table)):\n            return {}\n        cell = sheet.get_cell(coord, clone=False)\n        if cell.style:\n            return (\n                self.get_style_properties(\"table-cell\", cell.style, \"table-cell\") or {}\n            )\n        try:\n            row = sheet.get_row(cell.y, clone=False, create=False)  # type: ignore\n            if row.style:  # noqa: SIM102\n                if props := self.get_style_properties(\n                    \"table-row\", row.style, \"table-cell\"\n                ):\n                    return props\n            column = sheet.get_column(cell.x)  # type: ignore\n            style = column.default_cell_style\n            if style:  # noqa: SIM102\n                if props := self.get_style_properties(\n                    \"table-cell\", style, \"table-cell\"\n                ):\n                    return props\n        except ValueError:\n            pass\n        return {}\n\n    def get_cell_background_color(\n        self,\n        table: str | int,\n        coord: tuple | list | str,\n        default: str = \"#ffffff\",\n    ) -&gt; str:\n        \"\"\"Return the background color of a table cell of a .ods document,\n        from the cell style, or from the row or column.\n\n        If color is not defined, return default value..\"\"\"\n        found = self.get_cell_style_properties(table, coord).get(\"fo:background-color\")\n        return found or default\n</code></pre>"},{"location":"reference.html#odfdo.Document.body","title":"<code>body: Element</code>  <code>property</code>","text":"<p>Return the body element of the content part, where actual content is stored.</p>"},{"location":"reference.html#odfdo.Document.clone","title":"<code>clone: Document</code>  <code>property</code>","text":"<p>Return an exact copy of the document.</p> <p>Return: Document</p>"},{"location":"reference.html#odfdo.Document.manifest","title":"<code>manifest: Manifest</code>  <code>property</code>","text":"<p>Return the manifest part (manifest.xml) of the document.</p>"},{"location":"reference.html#odfdo.Document.meta","title":"<code>meta: Meta</code>  <code>property</code>","text":"<p>Return the meta part (meta.xml) of the document, where meta data are stored.</p>"},{"location":"reference.html#odfdo.Document.parts","title":"<code>parts: list[str]</code>  <code>property</code>","text":"<p>Return available part names with path inside the archive, e.g. [\u2018content.xml\u2019, \u2026, \u2018Pictures/100000000000032000000258912EB1C3.jpg\u2019]</p>"},{"location":"reference.html#odfdo.Document.path","title":"<code>path: Path | None</code>  <code>property</code> <code>writable</code>","text":"<p>Shortcut to Document.Container.path.</p>"},{"location":"reference.html#odfdo.Document.add_file","title":"<code>add_file(path_or_file)</code>","text":"<p>Insert a file from a path or a file-like object in the container.</p> <p>Return the full path to reference in the content.</p> <p>Arguments:</p> <pre><code>path_or_file -- str or Path or file-like\n</code></pre> <p>Return: str (URI)</p> Source code in <code>odfdo/document.py</code> <pre><code>def add_file(self, path_or_file: str | Path) -&gt; str:\n    \"\"\"Insert a file from a path or a file-like object in the container.\n\n    Return the full path to reference in the content.\n\n    Arguments:\n\n        path_or_file -- str or Path or file-like\n\n    Return: str (URI)\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    name = \"\"\n    # Folder for added files (FIXME hard-coded and copied)\n    manifest = self.manifest\n    medias = manifest.get_paths()\n    # uuid = str(uuid4())\n\n    if isinstance(path_or_file, (str, Path)):\n        path = Path(path_or_file)\n        extension = path.suffix.lower()\n        name = f\"{path.stem}{extension}\"\n        if posixpath.join(\"Pictures\", name) in medias:\n            name = f\"{path.stem}_{uuid4()}{extension}\"\n    else:\n        path = None\n        name = getattr(path_or_file, \"name\", None)\n        if not name:\n            name = str(uuid4())\n    media_type, _encoding = guess_type(name)\n    if not media_type:\n        media_type = \"application/octet-stream\"\n    if manifest.get_media_type(\"Pictures/\") is None:\n        manifest.add_full_path(\"Pictures/\")\n    full_path = posixpath.join(\"Pictures\", name)\n    if path is None:\n        self.container.set_part(full_path, path_or_file.read())  # type:ignore\n    else:\n        self.container.set_part(full_path, path.read_bytes())\n    manifest.add_full_path(full_path, media_type)\n    return full_path\n</code></pre>"},{"location":"reference.html#odfdo.Document.add_page_break_style","title":"<code>add_page_break_style()</code>","text":"<p>Ensure that the document contains the style required for a manual page break.</p> Then a manual page break can be added to the document with <p>from paragraph import PageBreak \u2026 document.body.append(PageBreak())</p> <p>Note: this style uses the property \u2018fo:break-after\u2019, another possibility could be the property \u2018fo:break-before\u2019</p> Source code in <code>odfdo/document.py</code> <pre><code>def add_page_break_style(self) -&gt; None:\n    \"\"\"Ensure that the document contains the style required for a manual page break.\n\n    Then a manual page break can be added to the document with:\n        from paragraph import PageBreak\n        ...\n        document.body.append(PageBreak())\n\n    Note: this style uses the property 'fo:break-after', another\n    possibility could be the property 'fo:break-before'\n    \"\"\"\n    if existing := self.get_style(  # noqa: SIM102\n        family=\"paragraph\",\n        name_or_element=\"odfdopagebreak\",\n    ):\n        if properties := existing.get_properties():  # noqa: SIM102\n            if properties[\"fo:break-after\"] == \"page\":\n                return\n    style = (\n        '&lt;style:style style:family=\"paragraph\" style:parent-style-name=\"Standard\" '\n        'style:name=\"odfdopagebreak\"&gt;'\n        '&lt;style:paragraph-properties fo:break-after=\"page\"/&gt;&lt;/style:style&gt;'\n    )\n    self.insert_style(style, automatic=False)\n</code></pre>"},{"location":"reference.html#odfdo.Document.del_part","title":"<code>del_part(path)</code>","text":"<p>Mark a part for deletion. The path is relative to the archive, e.g. \u201cPictures/1003200258912EB1C3.jpg\u201d</p> Source code in <code>odfdo/document.py</code> <pre><code>def del_part(self, path: str) -&gt; None:\n    \"\"\"Mark a part for deletion. The path is relative to the archive,\n    e.g. \"Pictures/1003200258912EB1C3.jpg\"\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    path = _get_part_path(path)\n    cls = _get_part_class(path)\n    if path == ODF_MANIFEST or cls is not None:\n        raise ValueError(f\"part '{path}' is mandatory\")\n    self.container.del_part(path)\n</code></pre>"},{"location":"reference.html#odfdo.Document.delete_styles","title":"<code>delete_styles()</code>","text":"<p>Remove all style information from content and all styles.</p> <p>Return: number of deleted styles</p> Source code in <code>odfdo/document.py</code> <pre><code>def delete_styles(self) -&gt; int:\n    \"\"\"Remove all style information from content and all styles.\n\n    Return: number of deleted styles\n    \"\"\"\n    # First remove references to styles\n    for element in self.get_styled_elements():\n        for attribute in (\n            \"text:style-name\",\n            \"draw:style-name\",\n            \"draw:text-style-name\",\n            \"table:style-name\",\n            \"style:page-layout-name\",\n        ):\n            try:\n                element.del_attribute(attribute)\n            except KeyError:\n                continue\n    # Then remove supposedly orphaned styles\n    deleted = 0\n    for style in self.get_styles():\n        if style.name is None:  # type: ignore\n            # Don't delete default styles\n            continue\n        # elif type(style) is odf_master_page:\n        #    # Don't suppress header and footer, just styling was removed\n        #    continue\n        style.delete()\n        deleted += 1\n    return deleted\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_cell_background_color","title":"<code>get_cell_background_color(table, coord, default='#ffffff')</code>","text":"<p>Return the background color of a table cell of a .ods document, from the cell style, or from the row or column.</p> <p>If color is not defined, return default value..</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_cell_background_color(\n    self,\n    table: str | int,\n    coord: tuple | list | str,\n    default: str = \"#ffffff\",\n) -&gt; str:\n    \"\"\"Return the background color of a table cell of a .ods document,\n    from the cell style, or from the row or column.\n\n    If color is not defined, return default value..\"\"\"\n    found = self.get_cell_style_properties(table, coord).get(\"fo:background-color\")\n    return found or default\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_cell_style_properties","title":"<code>get_cell_style_properties(table, coord)</code>","text":"<p>Return the style properties of a table cell of a .ods document, from the cell style or from the row style.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_cell_style_properties(  # noqa: C901\n    self, table: str | int, coord: tuple | list | str\n) -&gt; dict[str, str]:  # type: ignore\n    \"\"\"Return the style properties of a table cell of a .ods document,\n    from the cell style or from the row style.\"\"\"\n\n    def _get_table(table: int | str) -&gt; Table | None:\n        table_pos = 0\n        table_name = None\n        if isinstance(table, int):\n            table_pos = table\n        elif isinstance(table, str):\n            table_name = table_name\n        else:\n            raise TypeError(f\"Table parameter must be int or str: {table!r}\")\n        return self.body.get_table(\n            position=table_pos, name=table_name  # type: ignore\n        )\n\n    if not (sheet := _get_table(table)):\n        return {}\n    cell = sheet.get_cell(coord, clone=False)\n    if cell.style:\n        return (\n            self.get_style_properties(\"table-cell\", cell.style, \"table-cell\") or {}\n        )\n    try:\n        row = sheet.get_row(cell.y, clone=False, create=False)  # type: ignore\n        if row.style:  # noqa: SIM102\n            if props := self.get_style_properties(\n                \"table-row\", row.style, \"table-cell\"\n            ):\n                return props\n        column = sheet.get_column(cell.x)  # type: ignore\n        style = column.default_cell_style\n        if style:  # noqa: SIM102\n            if props := self.get_style_properties(\n                \"table-cell\", style, \"table-cell\"\n            ):\n                return props\n    except ValueError:\n        pass\n    return {}\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_formated_meta","title":"<code>get_formated_meta()</code>","text":"<p>Return meta informations as text, with some formatting.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_formated_meta(self) -&gt; str:\n    \"\"\"Return meta informations as text, with some formatting.\"\"\"\n    result: list[str] = []\n\n    # Simple values\n    def print_info(name: str, value: Any) -&gt; None:\n        if value:\n            result.append(f\"{name}: {value}\")\n\n    meta = self.meta\n    print_info(\"Title\", meta.title)\n    print_info(\"Subject\", meta.subject)\n    print_info(\"Description\", meta.description)\n    print_info(\"Language\", meta.language)\n    print_info(\"Modification date\", meta.date)\n    print_info(\"Creation date\", meta.creation_date)\n    print_info(\"Initial creator\", meta.initial_creator)\n    print_info(\"Keyword\", meta.keyword)\n    print_info(\"Editing duration\", meta.editing_duration)\n    print_info(\"Editing cycles\", meta.editing_cycles)\n    print_info(\"Generator\", meta.generator)\n\n    # Statistic\n    result.append(\"Statistic:\")\n    statistic = meta.statistic\n    if statistic:\n        for name, data in statistic.items():\n            result.append(f\"  - {name[5:].replace('-', ' ').capitalize()}: {data}\")\n\n    # User defined metadata\n    result.append(\"User defined metadata:\")\n    user_metadata = meta.user_defined_metadata\n    for name, data2 in user_metadata.items():\n        result.append(f\"  - {name}: {data2}\")\n\n    # And the description\n    print_info(\"Description\", meta.get_description())\n\n    return \"\\n\".join(result) + \"\\n\"\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_formatted_text","title":"<code>get_formatted_text(rst_mode=False)</code>","text":"<p>Return content as text, with some formatting.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_formatted_text(self, rst_mode: bool = False) -&gt; str:\n    \"\"\"Return content as text, with some formatting.\"\"\"\n    # For the moment, only \"type='text'\"\n    doc_type = self.get_type()\n    if doc_type == \"spreadsheet\":\n        return self._tables_csv()\n    if doc_type in {\n        \"text\",\n        \"text-template\",\n        \"presentation\",\n        \"presentation-template\",\n    }:\n        return self._formatted_text(rst_mode)\n    raise NotImplementedError(f\"Type of document '{doc_type}' not supported yet\")\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_part","title":"<code>get_part(path)</code>","text":"<p>Return the bytes of the given part. The path is relative to the archive, e.g. \u201cPictures/1003200258912EB1C3.jpg\u201d.</p> <p>\u2018content\u2019, \u2018meta\u2019, \u2018settings\u2019, \u2018styles\u2019 and \u2018manifest\u2019 are shortcuts to the real path, e.g. content.xml, and return a dedicated object with its own API.</p> <p>path formated as URI, so always use \u2018/\u2019 separator</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:\n    \"\"\"Return the bytes of the given part. The path is relative to the\n    archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n    'content', 'meta', 'settings', 'styles' and 'manifest' are shortcuts\n    to the real path, e.g. content.xml, and return a dedicated object with\n    its own API.\n\n    path formated as URI, so always use '/' separator\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    # \"./ObjectReplacements/Object 1\"\n    path = path.lstrip(\"./\")\n    path = _get_part_path(path)\n    cls = _get_part_class(path)\n    # Raw bytes\n    if cls is None:\n        return self.container.get_part(path)\n    # XML part\n    part = self.__xmlparts.get(path)\n    if part is None:\n        self.__xmlparts[path] = part = cls(path, self.container)\n    return part\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_parts","title":"<code>get_parts()</code>","text":"<p>Return available part names with path inside the archive, e.g. [\u2018content.xml\u2019, \u2026, \u2018Pictures/100000000000032000000258912EB1C3.jpg\u2019]</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_parts(self) -&gt; list[str]:\n    \"\"\"Return available part names with path inside the archive, e.g.\n    ['content.xml', ..., 'Pictures/100000000000032000000258912EB1C3.jpg']\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    return self.container.parts\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the name/family pair. If the argument is already a style object, it will return it.</p> <p>If the name is None, the default style is fetched.</p> <p>If the name is not the internal name but the name you gave in a desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n          'number', 'page-layout', 'master-page'\n\nname -- str or Element or None\n\ndisplay_name -- str\n</code></pre> <p>Return: Style or None if not found.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Style | None = None,\n    display_name: str | None = None,\n) -&gt; Style | None:\n    \"\"\"Return the style uniquely identified by the name/family pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is None, the default style is fetched.\n\n    If the name is not the internal name but the name you gave in a\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                  'number', 'page-layout', 'master-page'\n\n        name -- str or Element or None\n\n        display_name -- str\n\n    Return: Style or None if not found.\n    \"\"\"\n    # 1. content.xml\n    element = self.content.get_style(\n        family, name_or_element=name_or_element, display_name=display_name\n    )\n    if element is not None:\n        return element\n    # 2. styles.xml\n    return self.styles.get_style(\n        family,\n        name_or_element=name_or_element,\n        display_name=display_name,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_style_properties","title":"<code>get_style_properties(family, name, area=None)</code>","text":"<p>Return the properties of the required style as a dict.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_style_properties(\n    self, family: str, name: str, area: str | None = None\n) -&gt; dict[str, str] | None:\n    \"\"\"Return the properties of the required style as a dict.\"\"\"\n    style = self.get_style(family, name)\n    if style is None:\n        return None\n    return style.get_properties(area=area)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_styled_elements","title":"<code>get_styled_elements(name='')</code>","text":"<p>Brute-force to find paragraphs, tables, etc. using the given style name (or all by default).</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: list</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n    \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n    name (or all by default).\n\n    Arguments:\n\n        name -- str\n\n    Return: list\n    \"\"\"\n    # Header, footer, etc. have styles too\n    return self.content.root.get_styled_elements(\n        name\n    ) + self.styles.root.get_styled_elements(name)\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_type","title":"<code>get_type()</code>","text":"<p>Get the ODF type (also called class) of this document.</p> \u2018chart\u2019, \u2018database\u2019, \u2018formula\u2019, \u2018graphics\u2019, <p>\u2018graphics-template\u2019, \u2018image\u2019, \u2018presentation\u2019, \u2018presentation-template\u2019, \u2018spreadsheet\u2019, \u2018spreadsheet-template\u2019, \u2018text\u2019, \u2018text-master\u2019, \u2018text-template\u2019 or \u2018text-web\u2019</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"Get the ODF type (also called class) of this document.\n\n    Return: 'chart', 'database', 'formula', 'graphics',\n        'graphics-template', 'image', 'presentation',\n        'presentation-template', 'spreadsheet', 'spreadsheet-template',\n        'text', 'text-master', 'text-template' or 'text-web'\n    \"\"\"\n    # The mimetype must be with the form:\n    # application/vnd.oasis.opendocument.text\n\n    # Isolate and return the last part\n    return self.mimetype.rsplit(\".\", 1)[-1]\n</code></pre>"},{"location":"reference.html#odfdo.Document.insert_style","title":"<code>insert_style(style, name='', automatic=False, default=False)</code>","text":"<p>Insert the given style object in the document, as required by the style family and type.</p> <p>The style is expected to be a common style with a name. In case it was created with no name, the given can be set on the fly.</p> <p>If automatic is True, the style will be inserted as an automatic style.</p> <p>If default is True, the style will be inserted as a default style and would replace any existing default style of the same family. Any name or display name would be ignored.</p> <p>Automatic and default arguments are mutually exclusive.</p> <p>All styles can\u2019t be used as default styles. Default styles are allowed for the following families: paragraph, text, section, table, table-column, table-row, table-cell, table-page, chart, drawing-page, graphic, presentation, control and ruby.</p> <p>Arguments:</p> <pre><code>style -- Style or str\n\nname -- str\n\nautomatic -- bool\n\ndefault -- bool\n</code></pre> <p>Return : style name \u2013 str</p> Source code in <code>odfdo/document.py</code> <pre><code>def insert_style(  # noqa: C901\n    self,\n    style: Style | str,\n    name: str = \"\",\n    automatic: bool = False,\n    default: bool = False,\n) -&gt; Any:\n    \"\"\"Insert the given style object in the document, as required by the\n    style family and type.\n\n    The style is expected to be a common style with a name. In case it\n    was created with no name, the given can be set on the fly.\n\n    If automatic is True, the style will be inserted as an automatic\n    style.\n\n    If default is True, the style will be inserted as a default style and\n    would replace any existing default style of the same family. Any name\n    or display name would be ignored.\n\n    Automatic and default arguments are mutually exclusive.\n\n    All styles can't be used as default styles. Default styles are\n    allowed for the following families: paragraph, text, section, table,\n    table-column, table-row, table-cell, table-page, chart, drawing-page,\n    graphic, presentation, control and ruby.\n\n    Arguments:\n\n        style -- Style or str\n\n        name -- str\n\n        automatic -- bool\n\n        default -- bool\n\n    Return : style name -- str\n    \"\"\"\n\n    # if style is a str, assume it is the Style definition\n    if isinstance(style, str):\n        style_element: Style = Element.from_tag(style)  # type: ignore\n    else:\n        style_element = style\n    if not isinstance(style_element, Element):\n        raise TypeError(f\"Unknown Style type: '{style!r}'\")\n\n    # Get family and name\n    family = self._pseudo_style_attribute(style_element, \"family\")\n    if not name:\n        name = self._pseudo_style_attribute(style_element, \"name\")\n\n    # Master page style\n    if family == \"master-page\":\n        existing, style_container = self._insert_style_get_master_page(family, name)\n    # Font face declarations\n    elif family == \"font-face\":\n        if default:\n            existing, style_container = self._insert_style_get_font_face_default(\n                family, name\n            )\n        else:\n            existing, style_container = self._insert_style_get_font_face(\n                family, name\n            )\n    # page layout style\n    elif family == \"page-layout\":\n        existing, style_container = self._insert_style_get_page_layout(family, name)\n    # Common style\n    elif family in FAMILY_ODF_STD or family in {\"number\"}:\n        existing, style_container = self._insert_style_standard(\n            style_element, name, family, automatic, default\n        )\n    elif not family and style_element.__class__.__name__ == \"DrawFillImage\":\n        # special case for 'draw:fill-image' pseudo style\n        existing, style_container = self._insert_style_get_draw_fill_image(name)\n    # Invalid style\n    else:\n        raise ValueError(\n            \"Invalid style: \"\n            f\"{style_element}, tag:{style_element.tag}, family:{family}\"\n        )\n\n    # Insert it!\n    if existing is not None:\n        style_container.delete(existing)\n    style_container.append(style_element)\n    return self._pseudo_style_attribute(style_element, \"name\")\n</code></pre>"},{"location":"reference.html#odfdo.Document.merge_styles_from","title":"<code>merge_styles_from(document)</code>","text":"<p>Copy all the styles of a document into ourself.</p> <p>Styles with the same type and name will be replaced, so only unique styles will be preserved.</p> Source code in <code>odfdo/document.py</code> <pre><code>def merge_styles_from(self, document: Document) -&gt; None:\n    \"\"\"Copy all the styles of a document into ourself.\n\n    Styles with the same type and name will be replaced, so only unique\n    styles will be preserved.\n    \"\"\"\n    manifest = self.manifest\n    document_manifest = document.manifest\n    for style in document.get_styles():\n        tagname = style.tag\n        family = self._pseudo_style_attribute(style, \"family\")\n        stylename = style.name  # type: ignore\n        container = style.parent\n        container_name = container.tag  # type: ignore\n        partname = container.parent.tag  # type: ignore\n        # The destination part\n        if partname == \"office:document-styles\":\n            part: Content | Styles = self.styles\n        elif partname == \"office:document-content\":\n            part = self.content\n        else:\n            raise NotImplementedError(partname)\n        # Implemented containers\n        if container_name not in {\n            \"office:styles\",\n            \"office:automatic-styles\",\n            \"office:master-styles\",\n            \"office:font-face-decls\",\n        }:\n            raise NotImplementedError(container_name)\n        dest = part.get_element(f\"//{container_name}\")\n        # Implemented style types\n        # if tagname not in registered_styles:\n        #    raise NotImplementedError(tagname)\n        duplicate = part.get_style(family, stylename)\n        if duplicate is not None:\n            duplicate.delete()\n        dest.append(style)\n        # Copy images from the header/footer\n        if tagname == \"style:master-page\":\n            query = \"descendant::draw:image\"\n            for image in style.get_elements(query):\n                url = image.url  # type: ignore\n                part_url = document.get_part(url)\n                # Manually add the part to keep the name\n                self.set_part(url, part_url)  # type: ignore\n                media_type = document_manifest.get_media_type(url)\n                manifest.add_full_path(url, media_type)  # type: ignore\n        # Copy images from the fill-image\n        elif tagname == \"draw:fill-image\":\n            url = style.url  # type: ignore\n            part_url = document.get_part(url)\n            self.set_part(url, part_url)  # type: ignore\n            media_type = document_manifest.get_media_type(url)\n            manifest.add_full_path(url, media_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Document.new","title":"<code>new(template='text')</code>  <code>classmethod</code>","text":"<p>Create a Document from a template.</p> <p>The template argument is expected to be the path to a ODF template.</p> <p>Arguments:</p> <pre><code>template -- str or Path or file-like (io.BytesIO)\n</code></pre> <p>Return : ODF document \u2013 Document</p> Source code in <code>odfdo/document.py</code> <pre><code>@classmethod\ndef new(cls, template: str | Path | io.BytesIO = \"text\") -&gt; Document:\n    \"\"\"Create a Document from a template.\n\n    The template argument is expected to be the path to a ODF template.\n\n    Arguments:\n\n        template -- str or Path or file-like (io.BytesIO)\n\n    Return : ODF document -- Document\n    \"\"\"\n    container = container_from_template(template)\n    return cls(container)\n</code></pre>"},{"location":"reference.html#odfdo.Document.save","title":"<code>save(target=None, packaging=ZIP, pretty=False, backup=False)</code>","text":"<p>Save the document, at the same place it was opened or at the given target path. Target can also be a file-like object. It can be saved as a Zip file (default), flat XML format or as files in a folder (for debugging purpose). XML parts can be pretty printed.</p> <p>Arguments:</p> <pre><code>target -- str or file-like object\n\npackaging -- 'zip', 'folder', 'xml'\n\npretty -- bool\n\nbackup -- bool\n</code></pre> Source code in <code>odfdo/document.py</code> <pre><code>def save(\n    self,\n    target: str | Path | io.BytesIO | None = None,\n    packaging: str = ZIP,\n    pretty: bool = False,\n    backup: bool = False,\n) -&gt; None:\n    \"\"\"Save the document, at the same place it was opened or at the given\n    target path. Target can also be a file-like object. It can be saved\n    as a Zip file (default), flat XML format or as files in a folder\n    (for debugging purpose). XML parts can be pretty printed.\n\n    Arguments:\n\n        target -- str or file-like object\n\n        packaging -- 'zip', 'folder', 'xml'\n\n        pretty -- bool\n\n        backup -- bool\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    # Some advertising\n    self.meta.set_generator_default()\n    # Synchronize data with container\n    container = self.container\n    for path, part in self.__xmlparts.items():\n        if part is not None:\n            container.set_part(path, part.serialize(pretty))\n    # Save the container\n    container.save(target, packaging=packaging, backup=backup)\n</code></pre>"},{"location":"reference.html#odfdo.Document.set_part","title":"<code>set_part(path, data)</code>","text":"<p>Set the bytes of the given part. The path is relative to the archive, e.g. \u201cPictures/1003200258912EB1C3.jpg\u201d.</p> <p>path formated as URI, so always use \u2018/\u2019 separator</p> Source code in <code>odfdo/document.py</code> <pre><code>def set_part(self, path: str, data: bytes) -&gt; None:\n    \"\"\"Set the bytes of the given part. The path is relative to the\n    archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n    path formated as URI, so always use '/' separator\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    # \"./ObjectReplacements/Object 1\"\n    path = path.lstrip(\"./\")\n    path = _get_part_path(path)\n    cls = _get_part_class(path)\n    # XML part overwritten\n    if cls is not None:\n        with suppress(KeyError):\n            self.__xmlparts[path]\n    self.container.set_part(path, data)\n</code></pre>"},{"location":"reference.html#odfdo.DrawFillImage","title":"<code>DrawFillImage</code>","text":"<p>             Bases: <code>DrawImage</code></p> Source code in <code>odfdo/image.py</code> <pre><code>class DrawFillImage(DrawImage):\n    _tag = \"draw:fill-image\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"display_name\", \"draw:display-name\"),\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"height\", \"svg:height\"),\n        PropDef(\"width\", \"svg:width\"),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        display_name: str | None = None,\n        height: str | None = None,\n        width: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"The \"draw:fill-image\" element specifies a link to a bitmap\n        resource. Fill image are not available as automatic styles.\n        The \"draw:fill-image\" element is usable within the following element:\n        \"office:styles\"\n\n        Arguments:\n\n            name -- str\n\n            display_name -- str\n\n            height -- str\n\n            width -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n            self.display_name = display_name\n            self.height = height\n            self.width = width\n</code></pre>"},{"location":"reference.html#odfdo.DrawFillImage.__init__","title":"<code>__init__(name=None, display_name=None, height=None, width=None, **kwargs)</code>","text":"<p>The \u201cdraw:fill-image\u201d element specifies a link to a bitmap resource. Fill image are not available as automatic styles. The \u201cdraw:fill-image\u201d element is usable within the following element: \u201coffice:styles\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n\ndisplay_name -- str\n\nheight -- str\n\nwidth -- str\n</code></pre> Source code in <code>odfdo/image.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    display_name: str | None = None,\n    height: str | None = None,\n    width: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"The \"draw:fill-image\" element specifies a link to a bitmap\n    resource. Fill image are not available as automatic styles.\n    The \"draw:fill-image\" element is usable within the following element:\n    \"office:styles\"\n\n    Arguments:\n\n        name -- str\n\n        display_name -- str\n\n        height -- str\n\n        width -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n        self.display_name = display_name\n        self.height = height\n        self.width = width\n</code></pre>"},{"location":"reference.html#odfdo.DrawGroup","title":"<code>DrawGroup</code>","text":"<p>             Bases: <code>Element</code>, <code>AnchorMix</code>, <code>ZMix</code>, <code>PosMix</code></p> <p>The DrawGroup \u201cdraw:g\u201d element represents a group of drawing shapes.</p> <p>Warning: implementation is currently minimal.</p> <p>Drawing shapes contained by a \u201cdraw:g\u201d element that is itself contained by a \u201cdraw:a\u201d element, act as hyperlinks using the xlink:href attribute of the containing \u201cdraw:a\u201d element. If the included drawing shapes are themselves contained within \u201cdraw:a\u201d elements, then the xlink:href attributes of those \u201cdraw:a\u201d elements act as the hyperlink information for the shapes they contain.</p> <p>The \u201cdraw:g\u201d element has the following attributes: draw:caption-id, draw:class-names, draw:id, draw:name, draw:style-name, draw:z-index, presentation:class-names, presentation:style-name, svg:y, table:end-cell-address, table:end-x, table:end-y, table:table-background, text:anchor-page-number, text:anchor-type, and xml:id.</p> <p>The \u201cdraw:g\u201d element has the following child elements: \u201cdr3d:scene\u201d, \u201cdraw:a\u201d, \u201cdraw:caption\u201d, \u201cdraw:circle\u201d, \u201cdraw:connector\u201d, \u201cdraw:control\u201d, \u201cdraw:custom-shape\u201d, \u201cdraw:ellipse\u201d, \u201cdraw:frame\u201d, \u201cdraw:g\u201d, \u201cdraw:glue-point\u201d, \u201cdraw:line\u201d, \u201cdraw:measure\u201d, \u201cdraw:page-thumbnail\u201d, \u201cdraw:path\u201d, \u201cdraw:polygon\u201d, \u201cdraw:polyline\u201d, \u201cdraw:rect\u201d, \u201cdraw:regular-polygon\u201d, \u201coffice:event-listeners\u201d, \u201csvg:desc\u201d and \u201csvg:title\u201d.</p> Source code in <code>odfdo/shapes.py</code> <pre><code>class DrawGroup(Element, AnchorMix, ZMix, PosMix):\n    \"\"\"The DrawGroup \"draw:g\" element represents a group of drawing shapes.\n\n    Warning: implementation is currently minimal.\n\n    Drawing shapes contained by a \"draw:g\" element that is itself\n    contained by a \"draw:a\" element, act as hyperlinks using the\n    xlink:href attribute of the containing \"draw:a\" element. If the\n    included drawing shapes are themselves contained within \"draw:a\"\n    elements, then the xlink:href attributes of those \"draw:a\" elements\n    act as the hyperlink information for the shapes they contain.\n\n    The \"draw:g\" element has the following attributes: draw:caption-id,\n    draw:class-names, draw:id, draw:name, draw:style-name, draw:z-index,\n    presentation:class-names, presentation:style-name, svg:y,\n    table:end-cell-address, table:end-x, table:end-y,\n    table:table-background, text:anchor-page-number, text:anchor-type,\n    and xml:id.\n\n    The \"draw:g\" element has the following child elements: \"dr3d:scene\",\n    \"draw:a\", \"draw:caption\", \"draw:circle\", \"draw:connector\",\n    \"draw:control\", \"draw:custom-shape\", \"draw:ellipse\", \"draw:frame\",\n    \"draw:g\", \"draw:glue-point\", \"draw:line\", \"draw:measure\",\n    \"draw:page-thumbnail\", \"draw:path\", \"draw:polygon\", \"draw:polyline\",\n    \"draw:rect\", \"draw:regular-polygon\", \"office:event-listeners\",\n    \"svg:desc\" and \"svg:title\".\n    \"\"\"\n\n    _tag = \"draw:g\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"draw_id\", \"draw:id\"),\n        PropDef(\"caption_id\", \"draw:caption-id\"),\n        PropDef(\"draw_class_names\", \"draw:class-names\"),\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"style\", \"draw:style-name\"),\n        # ('z_index', 'draw:z-index'),\n        PropDef(\"presentation_class_names\", \"presentation:class-names\"),\n        PropDef(\"presentation_style\", \"presentation:style-name\"),\n        PropDef(\"table_end_cell\", \"table:end-cell-address\"),\n        PropDef(\"table_end_x\", \"table:end-x\"),\n        PropDef(\"table_end_y\", \"table:end-y\"),\n        PropDef(\"table_background\", \"table:table-background\"),\n        # ('anchor_page', 'text:anchor-page-number'),\n        # ('anchor_type', 'text:anchor-type'),\n        PropDef(\"xml_id\", \"xml:id\"),\n        PropDef(\"pos_x\", \"svg:x\"),\n        PropDef(\"pos_y\", \"svg:y\"),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        z_index: int = 0,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if z_index is not None:\n                self.z_index = z_index\n            if name:\n                self.name = name\n            if draw_id is not None:\n                self.draw_id = draw_id\n            if style is not None:\n                self.style = style\n            if position is not None:\n                self.position = position\n            if anchor_type:\n                self.anchor_type = anchor_type\n            if anchor_page is not None:\n                self.anchor_page = anchor_page\n            if presentation_style is not None:\n                self.presentation_style = presentation_style\n</code></pre>"},{"location":"reference.html#odfdo.DrawImage","title":"<code>DrawImage</code>","text":"<p>             Bases: <code>Element</code></p> <p>The \u201cdraw:image\u201d element represents an image. An image can be either: - A link to an external resource or - Embedded in the document (Not implemented in this version)</p> <p>Warning: image elements must be stored in a frame \u201cdraw:frame\u201d, see Frame().</p> Source code in <code>odfdo/image.py</code> <pre><code>class DrawImage(Element):\n    \"\"\"The \"draw:image\" element represents an image. An image can be\n    either:\n    - A link to an external resource or\n    - Embedded in the document (Not implemented in this version)\n\n    Warning: image elements must be stored in a frame \"draw:frame\",\n    see Frame().\n    \"\"\"\n\n    _tag = \"draw:image\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"url\", \"xlink:href\"),\n        PropDef(\"type\", \"xlink:type\"),\n        PropDef(\"show\", \"xlink:show\"),\n        PropDef(\"actuate\", \"xlink:actuate\"),\n        PropDef(\"filter_name\", \"draw:filter-name\"),\n    )\n\n    def __init__(\n        self,\n        url: str = \"\",\n        xlink_type: str = \"simple\",\n        show: str = \"embed\",\n        actuate: str = \"onLoad\",\n        filter_name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialisation of an DrawImage.\n\n        Arguments:\n\n            url -- str\n\n            type -- str\n\n            show -- str\n\n            actuate -- str\n\n            filter_name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.url = url\n            self.type = xlink_type\n            self.show = show\n            self.actuate = actuate\n            self.filter_name = filter_name\n</code></pre>"},{"location":"reference.html#odfdo.DrawImage.__init__","title":"<code>__init__(url='', xlink_type='simple', show='embed', actuate='onLoad', filter_name=None, **kwargs)</code>","text":"<p>Initialisation of an DrawImage.</p> <p>Arguments:</p> <pre><code>url -- str\n\ntype -- str\n\nshow -- str\n\nactuate -- str\n\nfilter_name -- str\n</code></pre> Source code in <code>odfdo/image.py</code> <pre><code>def __init__(\n    self,\n    url: str = \"\",\n    xlink_type: str = \"simple\",\n    show: str = \"embed\",\n    actuate: str = \"onLoad\",\n    filter_name: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialisation of an DrawImage.\n\n    Arguments:\n\n        url -- str\n\n        type -- str\n\n        show -- str\n\n        actuate -- str\n\n        filter_name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.url = url\n        self.type = xlink_type\n        self.show = show\n        self.actuate = actuate\n        self.filter_name = filter_name\n</code></pre>"},{"location":"reference.html#odfdo.DrawPage","title":"<code>DrawPage</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF draw page \u201cdraw:page\u201d, for pages of presentation and drawings.</p> Source code in <code>odfdo/draw_page.py</code> <pre><code>class DrawPage(Element):\n    \"\"\"ODF draw page \"draw:page\", for pages of presentation and drawings.\"\"\"\n\n    _tag = \"draw:page\"\n    _properties = (\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"draw_id\", \"draw:id\"),\n        PropDef(\"master_page\", \"draw:master-page-name\"),\n        PropDef(\n            \"presentation_page_layout\", \"presentation:presentation-page-layout-name\"\n        ),\n        PropDef(\"style\", \"draw:style-name\"),\n    )\n\n    def __init__(\n        self,\n        draw_id: str | None = None,\n        name: str | None = None,\n        master_page: str | None = None,\n        presentation_page_layout: str | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            draw_id -- str\n\n            name -- str\n\n            master_page -- str\n\n            presentation_page_layout -- str\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if draw_id:\n                self.draw_id = draw_id\n            if name:\n                self.name = name\n            if master_page:\n                self.master_page = master_page\n            if presentation_page_layout:\n                self.presentation_page_layout = presentation_page_layout\n            if style:\n                self.style = style\n\n    def set_transition(\n        self,\n        smil_type: str,\n        subtype: str | None = None,\n        dur: str = \"2s\",\n    ) -&gt; None:\n        # Create the new animation\n        anim_page = AnimPar(presentation_node_type=\"timing-root\")\n        anim_begin = AnimPar(smil_begin=f\"{self.draw_id}.begin\")\n        transition = AnimTransFilter(\n            smil_dur=dur, smil_type=smil_type, smil_subtype=subtype\n        )\n        anim_page.append(anim_begin)\n        anim_begin.append(transition)\n\n        # Replace when already a transition:\n        #   anim:seq =&gt; After the frame's transition\n        #   cf page 349 of OpenDocument-v1.0-os.pdf\n        #   Conclusion: We must delete the first child 'anim:par'\n        existing = self.get_element(\"anim:par\")\n        if existing:\n            self.delete(existing)\n        self.append(anim_page)\n\n    def get_shapes(self) -&gt; list[Element]:\n        query = \"(descendant::\" + \"|descendant::\".join(registered_shapes) + \")\"\n        return self.get_elements(query)\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        result: list[str] = []\n        for child in self.children:\n            if child.tag == \"presentation:notes\":\n                # No need for an advanced odf_notes.get_formatted_text()\n                # because the text seems to be only contained in paragraphs\n                # and frames, that we already handle\n                for sub_child in child.children:\n                    result.append(sub_child.get_formatted_text(context))\n                result.append(\"\\n\")\n            result.append(child.get_formatted_text(context))\n        result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.DrawPage.__init__","title":"<code>__init__(draw_id=None, name=None, master_page=None, presentation_page_layout=None, style=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>draw_id -- str\n\nname -- str\n\nmaster_page -- str\n\npresentation_page_layout -- str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/draw_page.py</code> <pre><code>def __init__(\n    self,\n    draw_id: str | None = None,\n    name: str | None = None,\n    master_page: str | None = None,\n    presentation_page_layout: str | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        draw_id -- str\n\n        name -- str\n\n        master_page -- str\n\n        presentation_page_layout -- str\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if draw_id:\n            self.draw_id = draw_id\n        if name:\n            self.name = name\n        if master_page:\n            self.master_page = master_page\n        if presentation_page_layout:\n            self.presentation_page_layout = presentation_page_layout\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Drawing","title":"<code>Drawing</code>","text":"<p>             Bases: <code>Body</code></p> <p>Drawing, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Drawing(Body):\n    \"\"\"Drawing, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:drawing\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.EText","title":"<code>EText</code>","text":"<p>             Bases: <code>str</code></p> <p>Representation of an XML text node. Created to hide the specifics of lxml in searching text nodes using XPath.</p> <p>Constructed like any str object but only accepts lxml text objects.</p> Source code in <code>odfdo/element.py</code> <pre><code>class EText(str):\n    \"\"\"Representation of an XML text node. Created to hide the specifics of\n    lxml in searching text nodes using XPath.\n\n    Constructed like any str object but only accepts lxml text objects.\n    \"\"\"\n\n    # There's some black magic in inheriting from str\n    def __init__(\n        self,\n        text_result: str | bytes,\n    ) -&gt; None:\n        self.__parent = text_result.getparent()  # type: ignore\n        self.__is_text = text_result.is_text\n        self.__is_tail = text_result.is_tail\n\n    @property\n    def parent(self) -&gt; Element | None:\n        parent = self.__parent\n        # XXX happens just because of the unit test\n        if parent is None:\n            return None\n        return Element.from_tag(tag_or_elem=parent)\n\n    def is_text(self) -&gt; bool:\n        return self.__is_text\n\n    def is_tail(self) -&gt; bool:\n        return self.__is_tail\n</code></pre>"},{"location":"reference.html#odfdo.Element","title":"<code>Element</code>","text":"<p>             Bases: <code>CachedElement</code></p> <p>Super class of all ODF classes.</p> <p>Representation of an XML element. Abstraction of the XML library behind.</p> Source code in <code>odfdo/element.py</code> <pre><code>class Element(CachedElement):\n    \"\"\"Super class of all ODF classes.\n\n    Representation of an XML element. Abstraction of the XML library behind.\n    \"\"\"\n\n    _tag: str = \"\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        tag_or_elem = kwargs.pop(\"tag_or_elem\", None)\n        if tag_or_elem is None:\n            # Instance for newly created object: create new lxml element and\n            # continue by subclass __init__\n            # If the tag key word exists, make a custom element\n            self._do_init = True\n            tag = kwargs.pop(\"tag\", self._tag)\n            self.__element = self.make_etree_element(tag)\n        else:\n            # called with an existing lxml element, sould be a result of\n            # from_tag() casting, do not execute the subclass __init__\n            if not isinstance(tag_or_elem, _Element):\n                raise TypeError(f'\"{type(tag_or_elem)}\" is not an element node')\n            self._do_init = False\n            self.__element = tag_or_elem\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return self.text_recursive\n\n    @classmethod\n    def from_tag(cls, tag_or_elem: str | _Element) -&gt; Element:\n        \"\"\"Element class and subclass factory.\n\n        Turn an lxml Element or ODF string tag into an ODF XML Element\n        of the relevant class.\n\n        Arguments:\n\n            tag_or_elem -- ODF str tag or lxml.Element\n\n        Return: Element (or subclass) instance\n        \"\"\"\n        if isinstance(tag_or_elem, str):\n            # assume the argument is a prefix:name tag\n            elem = cls.make_etree_element(tag_or_elem)\n        else:\n            elem = tag_or_elem\n        klass = _class_registry.get(elem.tag, cls)\n        return klass(tag_or_elem=elem)\n\n    @classmethod\n    def from_tag_for_clone(\n        cls: type,\n        tree_element: _Element,\n        cache: tuple | None,\n    ) -&gt; Element:\n        tag = to_str(tree_element.tag)\n        klass = _class_registry.get(tag, cls)\n        element = klass(tag_or_elem=tree_element)\n        if cache and element._caching:\n            element._tmap = cache[0]\n            element._cmap = cache[1]\n            if len(cache) == 3:\n                element._rmap = cache[2]\n        return element\n\n    @staticmethod\n    def make_etree_element(tag: str) -&gt; _Element:\n        if not isinstance(tag, str):\n            raise TypeError(f\"Tag is not str: {tag!r}\")\n        tag = tag.strip()\n        if not tag:\n            raise ValueError(\"Tag is empty\")\n        if \"&lt;\" not in tag:\n            # Qualified name\n            # XXX don't build the element from scratch or lxml will pollute with\n            # repeated namespace declarations\n            tag = f\"&lt;{tag}/&gt;\"\n        # XML fragment\n        root = fromstring(NAMESPACES_XML % str_to_bytes(tag))\n        return root[0]\n\n    @staticmethod\n    def _generic_attrib_getter(attr_name: str, family: str | None = None) -&gt; Callable:\n        name = _get_lxml_tag(attr_name)\n\n        def getter(self: Element) -&gt; str | bool | None:\n            try:\n                if family and self.family != family:  # type: ignore\n                    return None\n            except AttributeError:\n                return None\n            value = self.__element.get(name)\n            if value is None:\n                return None\n            elif value in (\"true\", \"false\"):\n                return Boolean.decode(value)\n            return str(value)\n\n        return getter\n\n    @staticmethod\n    def _generic_attrib_setter(attr_name: str, family: str | None = None) -&gt; Callable:\n        name = _get_lxml_tag(attr_name)\n\n        def setter(self: Element, value: Any) -&gt; None:\n            try:\n                if family and self.family != family:  # type: ignore\n                    return None\n            except AttributeError:\n                return None\n            if value is None:\n                with contextlib.suppress(KeyError):\n                    del self.__element.attrib[name]\n                return\n            if isinstance(value, bool):\n                value = Boolean.encode(value)\n            self.__element.set(name, str(value))\n\n        return setter\n\n    @classmethod\n    def _define_attribut_property(cls: type[Element]) -&gt; None:\n        for prop in cls._properties:\n            setattr(\n                cls,\n                prop.name,\n                property(\n                    cls._generic_attrib_getter(prop.attr, prop.family or None),\n                    cls._generic_attrib_setter(prop.attr, prop.family or None),\n                    None,\n                    f\"Get/set the attribute {prop.attr}\",\n                ),\n            )\n\n    @staticmethod\n    def _make_before_regex(\n        before: str | None,\n        after: str | None,\n    ) -&gt; re.Pattern:\n        # 1) before xor after is not None\n        if before is not None:\n            return re.compile(before)\n        else:\n            if after is None:\n                raise ValueError(\"Both 'before' and 'after' are None\")\n            return re.compile(after)\n\n    @staticmethod\n    def _search_negative_position(\n        xpath_result: list,\n        regex: re.Pattern,\n    ) -&gt; tuple[str, re.Match]:\n        # Found the last text that matches the regex\n        text = None\n        for a_text in xpath_result:\n            if regex.search(str(a_text)) is not None:\n                text = a_text\n        if text is None:\n            raise ValueError(f\"Text not found: '{xpath_result}'\")\n        if not isinstance(text, str):\n            raise TypeError(f\"Text not found or text not of type str: '{text}'\")\n        return text, list(regex.finditer(text))[-1]\n\n    @staticmethod\n    def _search_positive_position(\n        xpath_result: list,\n        regex: re.Pattern,\n        position: int,\n    ) -&gt; tuple[str, re.Match]:\n        # Found the last text that matches the regex\n        count = 0\n        for text in xpath_result:\n            found_nb = len(regex.findall(str(text)))\n            if found_nb + count &gt;= position + 1:\n                break\n            count += found_nb\n        else:\n            raise ValueError(f\"Text not found: '{xpath_result}'\")\n        if not isinstance(text, str):\n            raise TypeError(f\"Text not found or text not of type str: '{text}'\")\n        return text, list(regex.finditer(text))[position - count]\n\n    def _insert_before_after(\n        self,\n        current: _Element,\n        element: _Element,\n        before: str | None,\n        after: str | None,\n        position: int,\n        xpath_text: XPath,\n    ) -&gt; tuple[int, str]:\n        regex = self._make_before_regex(before, after)\n        xpath_result = xpath_text(current)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n        # position = -1\n        if position &lt; 0:\n            text, sre = self._search_negative_position(xpath_result, regex)\n        # position &gt;= 0\n        else:\n            text, sre = self._search_positive_position(xpath_result, regex, position)\n        # Compute pos\n        if before is None:\n            pos = sre.end()\n        else:\n            pos = sre.start()\n        return pos, text\n\n    def _insert_find_text(\n        self,\n        current: _Element,\n        element: _Element,\n        before: str | None,\n        after: str | None,\n        position: int,\n        xpath_text: XPath,\n    ) -&gt; tuple[int, str]:\n        # Find the text\n        xpath_result = xpath_text(current)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n        count = 0\n        for text in xpath_result:\n            if not isinstance(text, str):\n                continue\n            found_nb = len(text)\n            if found_nb + count &gt;= position:\n                break\n            count += found_nb\n        else:\n            raise ValueError(\"Text not found\")\n        # We insert before the character\n        pos = position - count\n        return pos, text\n\n    def _insert(\n        self,\n        element: Element,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n        main_text: bool = False,\n    ) -&gt; None:\n        \"\"\"Insert an element before or after the characters in the text which\n        match the regex before/after.\n\n        When the regex matches more of one part of the text, position can be\n        set to choice which part must be used. If before and after are None,\n        we use only position that is the number of characters. If position is\n        positive and before=after=None, we insert before the position\n        character. But if position=-1, we insert after the last character.\n\n\n        Arguments:\n\n        element -- Element\n\n        before -- str regex\n\n        after -- str regex\n\n        position -- int\n        \"\"\"\n        # not implemented: if main_text is True, filter out the annotations texts in computation.\n        current = self.__element\n        xelement = element.__element\n\n        if main_text:\n            xpath_text = _xpath_text_main_descendant\n        else:\n            xpath_text = _xpath_text_descendant\n\n        # 1) before xor after is not None\n        if (before is not None) ^ (after is not None):\n            pos, text = self._insert_before_after(\n                current,\n                xelement,\n                before,\n                after,\n                position,\n                xpath_text,\n            )\n        # 2) before=after=None =&gt; only with position\n        elif before is None and after is None:\n            # Hack if position is negative =&gt; quickly\n            if position &lt; 0:\n                current.append(xelement)\n                return\n            pos, text = self._insert_find_text(\n                current,\n                xelement,\n                before,\n                after,\n                position,\n                xpath_text,\n            )\n        else:\n            raise ValueError(\"bad combination of arguments\")\n\n        # Compute new texts\n        text_before = text[:pos] if text[:pos] else None\n        text_after = text[pos:] if text[pos:] else None\n\n        # Insert!\n        parent = text.getparent()  # type: ignore\n        if text.is_text:  # type: ignore\n            parent.text = text_before\n            element.tail = text_after\n            parent.insert(0, xelement)\n        else:\n            parent.addnext(xelement)\n            parent.tail = text_before\n            element.tail = text_after\n\n    def _insert_between(  # noqa: C901\n        self,\n        element: Element,\n        from_: str,\n        to: str,\n    ) -&gt; None:\n        \"\"\"Insert the given empty element to wrap the text beginning with\n        \"from_\" and ending with \"to\".\n\n        Example 1: '&lt;p&gt;toto tata titi&lt;/p&gt;\n\n        We want to insert a link around \"tata\".\n\n        Result 1: '&lt;p&gt;toto &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;\n\n        Example 2: '&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; tata titi&lt;/p&gt;\n\n        We want to insert a link around \"tata\".\n\n        Result 2: '&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;\n\n        Example 3: '&lt;p&gt;toto &lt;span&gt; tata &lt;/span&gt; titi&lt;/p&gt;'\n\n        We want to insert a link from \"tata\" to \"titi\" included.\n\n        Result 3: '&lt;p&gt;toto &lt;span&gt; &lt;/span&gt;'\n                  '&lt;a&gt;&lt;span&gt;tata &lt;/span&gt; titi&lt;/a&gt;&lt;/p&gt;'\n\n        Example 4: '&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; tutu&lt;/p&gt;'\n\n        We want to insert a link from \"titi\" to \"tutu\"\n\n        Result 4: '&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;/a&gt;'\n                  '&lt;a&gt; tutu&lt;/a&gt;&lt;/p&gt;'\n\n        Example 5: '&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; '\n                   '&lt;span&gt;tutu tyty&lt;/span&gt;&lt;/p&gt;'\n\n        We want to insert a link from \"titi\" to \"tutu\"\n\n        Result 5: '&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;a&gt; '\n                  '&lt;a&gt; &lt;span&gt;tutu&lt;/span&gt;&lt;/a&gt;&lt;span&gt; tyty&lt;/span&gt;&lt;/p&gt;'\n        \"\"\"\n        current = self.__element\n        wrapper = element.__element\n\n        xpath_result = _xpath_text_descendant(current)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n\n        for text in xpath_result:\n            if not isinstance(text, str):\n                raise TypeError(\"Text not found or text not of type str\")\n            if from_ not in text:\n                continue\n            from_index = text.index(from_)\n            text_before = text[:from_index]\n            text_after = text[from_index:]\n            from_container = text.getparent()  # type: ignore\n            if not isinstance(from_container, _Element):\n                raise TypeError(\"Bad XPath result\")\n            # Include from_index to match a single word\n            to_index = text.find(to, from_index)\n            if to_index &gt;= 0:\n                # Simple case: \"from\" and \"to\" in the same element\n                to_end = to_index + len(to)\n                if text.is_text:  # type: ignore\n                    from_container.text = text_before\n                    wrapper.text = text[to_index:to_end]\n                    wrapper.tail = text[to_end:]\n                    from_container.insert(0, wrapper)\n                else:\n                    from_container.tail = text_before\n                    wrapper.text = text[to_index:to_end]\n                    wrapper.tail = text[to_end:]\n                    parent = from_container.getparent()\n                    index = parent.index(from_container)  # type: ignore\n                    parent.insert(index + 1, wrapper)  # type: ignore\n                return\n            else:\n                # Exit to the second part where we search for the end text\n                break\n        else:\n            raise ValueError(\"Start text not found\")\n\n        # The container is split in two\n        container2 = deepcopy(from_container)\n        if text.is_text:  # type: ignore\n            from_container.text = text_before\n            from_container.tail = None\n            container2.text = text_after\n            from_container.tail = None\n        else:\n            from_container.tail = text_before\n            container2.tail = text_after\n        # Stack the copy into the surrounding element\n        wrapper.append(container2)\n        parent = from_container.getparent()\n        index = parent.index(from_container)  # type: ignore\n        parent.insert(index + 1, wrapper)  # type: ignore\n\n        xpath_result = _xpath_text_descendant(wrapper)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n\n        for text in xpath_result:\n            if not isinstance(text, str):\n                raise TypeError(\"Text not found or text not of type str\")\n            if to not in text:\n                continue\n            to_end = text.index(to) + len(to)\n            text_before = text[:to_end]\n            text_after = text[to_end:]\n            container_to = text.getparent()  # type: ignore\n            if not isinstance(container_to, _Element):\n                raise TypeError(\"Bad XPath result\")\n            if text.is_text:  # type: ignore\n                container_to.text = text_before\n                container_to.tail = text_after\n            else:\n                container_to.tail = text_before\n                next_one = container_to.getnext()\n                if next_one is None:\n                    next_one = container_to.getparent()\n                next_one.tail = text_after  # type: ignore\n            return\n        raise ValueError(\"End text not found\")\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"Get/set the underlying xml tag with the given qualified name.\n\n        Warning: direct change of tag does not change the element class.\n\n        Arguments:\n\n            qname -- str (e.g. \"text:span\")\n        \"\"\"\n        return _get_prefixed_name(self.__element.tag)\n\n    @tag.setter\n    def tag(self, qname: str) -&gt; None:\n        self.__element.tag = _get_lxml_tag(qname)\n\n    def elements_repeated_sequence(\n        self,\n        xpath_instance: XPath,\n        name: str,\n    ) -&gt; list[tuple[int, int]]:\n        \"\"\"Utility method for table module.\"\"\"\n        lxml_tag = _get_lxml_tag_or_name(name)\n        element = self.__element\n        sub_elements = xpath_instance(element)\n        if not isinstance(sub_elements, list):\n            raise TypeError(\"Bad XPath result.\")\n        result: list[tuple[int, int]] = []\n        idx = -1\n        for sub_element in sub_elements:\n            if not isinstance(sub_element, _Element):\n                continue\n            idx += 1\n            value = sub_element.get(lxml_tag)\n            if value is None:\n                result.append((idx, 1))\n                continue\n            try:\n                int_value = int(value)\n            except ValueError:\n                int_value = 1\n            result.append((idx, max(int_value, 1)))\n        return result\n\n    def get_elements(self, xpath_query: XPath | str) -&gt; list[Element]:\n        cache: tuple | None = None\n        element = self.__element\n        if isinstance(xpath_query, str):\n            new_xpath_query = xpath_compile(xpath_query)\n            result = new_xpath_query(element)\n        else:\n            result = xpath_query(element)\n        if not isinstance(result, list):\n            raise TypeError(\"Bad XPath result\")\n\n        if hasattr(self, \"_tmap\"):\n            if hasattr(self, \"_rmap\"):\n                cache = (self._tmap, self._cmap, self._rmap)\n            else:\n                cache = (self._tmap, self._cmap)\n        return [\n            Element.from_tag_for_clone(e, cache)\n            for e in result\n            if isinstance(e, _Element)\n        ]\n\n    # fixme : need original get_element as wrapper of get_elements\n\n    def get_element(self, xpath_query: XPath | str) -&gt; Element | None:\n        element = self.__element\n        result = element.xpath(f\"({xpath_query})[1]\", namespaces=ODF_NAMESPACES)\n        if result:\n            return Element.from_tag(result[0])  # type:ignore\n        return None\n\n    def _get_element_idx(self, xpath_query: XPath | str, idx: int) -&gt; Element | None:\n        element = self.__element\n        result = element.xpath(f\"({xpath_query})[{idx + 1}]\", namespaces=ODF_NAMESPACES)\n        if result:\n            return Element.from_tag(result[0])  # type:ignore\n        return None\n\n    def _get_element_idx2(self, xpath_instance: XPath, idx: int) -&gt; Element | None:\n        element = self.__element\n        result = xpath_instance(element, idx=idx + 1)\n        if result:\n            return Element.from_tag(result[0])  # type:ignore\n        return None\n\n    @property\n    def attributes(self) -&gt; dict[str, str]:\n        return {\n            _get_prefixed_name(str(key)): str(value)\n            for key, value in self.__element.attrib.items()\n        }\n\n    def get_attribute(self, name: str) -&gt; str | bool | None:\n        \"\"\"Return the attribute value as type str | bool | None.\"\"\"\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        value = element.get(lxml_tag)\n        if value is None:\n            return None\n        elif value in (\"true\", \"false\"):\n            return Boolean.decode(value)\n        return str(value)\n\n    def get_attribute_integer(self, name: str) -&gt; int | None:\n        \"\"\"Return either the attribute as type int, or None.\"\"\"\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        value = element.get(lxml_tag)\n        if value is None:\n            return None\n        try:\n            return int(value)\n        except ValueError:\n            return None\n\n    def get_attribute_string(self, name: str) -&gt; str | None:\n        \"\"\"Return either the attribute as type str, or None.\"\"\"\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        value = element.get(lxml_tag)\n        if value is None:\n            return None\n        return str(value)\n\n    def set_attribute(\n        self, name: str, value: bool | str | tuple[int, int, int] | None\n    ) -&gt; None:\n        if name in ODF_COLOR_PROPERTY:\n            if isinstance(value, bool):\n                raise TypeError(f\"Wrong color type {value!r}\")\n            if value != \"transparent\":\n                value = hexa_color(value)\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        if isinstance(value, bool):\n            value = Boolean.encode(value)\n        elif value is None:\n            with contextlib.suppress(KeyError):\n                del element.attrib[lxml_tag]\n            return\n        element.set(lxml_tag, str(value))\n\n    def set_style_attribute(self, name: str, value: Element | str) -&gt; None:\n        \"\"\"Shortcut to accept a style object as a value.\"\"\"\n        if isinstance(value, Element):\n            value = str(value.name)  # type:ignore\n        return self.set_attribute(name, value)\n\n    def del_attribute(self, name: str) -&gt; None:\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        del element.attrib[lxml_tag]\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"Get / set the text content of the element.\"\"\"\n        return self.__element.text or \"\"\n\n    @text.setter\n    def text(self, text: str | None) -&gt; None:\n        if text is None:\n            text = \"\"\n        try:\n            self.__element.text = text\n        except TypeError as e:\n            raise TypeError(f'Str type expected: \"{type(text)}\"') from e\n\n    @property\n    def text_recursive(self) -&gt; str:\n        return \"\".join(str(x) for x in self.__element.itertext())\n\n    @property\n    def tail(self) -&gt; str | None:\n        \"\"\"Get / set the text immediately following the element.\"\"\"\n        return self.__element.tail\n\n    @tail.setter\n    def tail(self, text: str | None) -&gt; None:\n        self.__element.tail = text or \"\"\n\n    def search(self, pattern: str) -&gt; int | None:\n        \"\"\"Return the first position of the pattern in the text content of\n        the element, or None if not found.\n\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n        Return: int or None\n        \"\"\"\n        match = re.search(pattern, self.text_recursive)\n        if match is None:\n            return None\n        return match.start()\n\n    def match(self, pattern: str) -&gt; bool:\n        \"\"\"return True if the pattern is found one or more times anywhere in\n        the text content of the element.\n\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n        Return: bool\n        \"\"\"\n        return self.search(pattern) is not None\n\n    def replace(self, pattern: str, new: str | None = None) -&gt; int:\n        \"\"\"Replace the pattern with the given text, or delete if text is an\n        empty string, and return the number of replacements. By default, only\n        return the number of occurences that would be replaced.\n\n        It cannot replace patterns found across several element, like a word\n        split into two consecutive spans.\n\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n            new -- str\n\n        Return: int\n        \"\"\"\n        if not isinstance(pattern, str):\n            # Fail properly if the pattern is an non-ascii bytestring\n            pattern = str(pattern)\n        cpattern = re.compile(pattern)\n        count = 0\n        for text in self.xpath(\"descendant::text()\"):\n            if new is None:\n                count += len(cpattern.findall(str(text)))\n            else:\n                new_text, number = cpattern.subn(new, str(text))\n                container = text.parent\n                if text.is_text():  # type: ignore\n                    container.text = new_text  # type: ignore\n                else:\n                    container.tail = new_text  # type: ignore\n                count += number\n        return count\n\n    @property\n    def root(self) -&gt; Element:\n        element = self.__element\n        tree = element.getroottree()\n        root = tree.getroot()\n        return Element.from_tag(root)\n\n    @property\n    def parent(self) -&gt; Element | None:\n        element = self.__element\n        parent = element.getparent()\n        if parent is None:\n            # Already at root\n            return None\n        return Element.from_tag(parent)\n\n    @property\n    def is_bound(self) -&gt; bool:\n        return self.parent is not None\n\n    # def get_next_sibling(self):\n    #     element = self.__element\n    #     next_one = element.getnext()\n    #     if next_one is None:\n    #         return None\n    #     return Element.from_tag(next_one)\n    #\n    # def get_prev_sibling(self):\n    #     element = self.__element\n    #     prev = element.getprevious()\n    #     if prev is None:\n    #         return None\n    #     return Element.from_tag(prev)\n\n    @property\n    def children(self) -&gt; list[Element]:\n        element = self.__element\n        return [\n            Element.from_tag(e)\n            for e in element.iterchildren()\n            if isinstance(e, _Element)\n        ]\n\n    def index(self, child: Element) -&gt; int:\n        \"\"\"Return the position of the child in this element.\n\n        Inspired by lxml\n        \"\"\"\n        return self.__element.index(child.__element)\n\n    @property\n    def text_content(self) -&gt; str:\n        \"\"\"Get / set the text of the embedded paragraph, including embeded\n        annotations, cells...\n\n        Set create a paragraph if missing\n        \"\"\"\n        return \"\\n\".join(\n            child.text_recursive for child in self.get_elements(\"descendant::text:p\")\n        )\n\n    @text_content.setter\n    def text_content(self, text: str | None) -&gt; None:\n        paragraphs = self.get_elements(\"text:p\")\n        if not paragraphs:\n            # E.g., text:p in draw:text-box in draw:frame\n            paragraphs = self.get_elements(\"*/text:p\")\n        if paragraphs:\n            paragraph = paragraphs.pop(0)\n            for obsolete in paragraphs:\n                obsolete.delete()\n        else:\n            paragraph = Element.from_tag(\"text:p\")\n            self.insert(paragraph, FIRST_CHILD)\n        # As \"text_content\" returned all text nodes, \"text_content\"\n        # will overwrite all text nodes and children that may contain them\n        element = paragraph.__element\n        # Clear but the attributes\n        del element[:]\n        element.text = text\n\n    def _erase_text_content(self) -&gt; None:\n        paragraphs = self.get_elements(\"text:p\")\n        if not paragraphs:\n            # E.g., text:p in draw:text-box in draw:frame\n            paragraphs = self.get_elements(\"*/text:p\")\n        if paragraphs:\n            paragraphs.pop(0)\n            for obsolete in paragraphs:\n                obsolete.delete()\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the element is empty : no text, no children, no tail.\n\n        Return: Boolean\n        \"\"\"\n        element = self.__element\n        if element.tail is not None:\n            return False\n        if element.text is not None:\n            return False\n        if list(element.iterchildren()):\n            return False\n        return True\n\n    def _get_successor(self, target: Element) -&gt; tuple[Element | None, Element | None]:\n        element = self.__element\n        next_one = element.getnext()\n        if next_one is not None:\n            return Element.from_tag(next_one), target\n        parent = self.parent\n        if parent is None:\n            return None, None\n        return parent._get_successor(target.parent)  # type:ignore\n\n    def _get_between_base(  # noqa:C901\n        self,\n        tag1: Element,\n        tag2: Element,\n    ) -&gt; list[Element]:\n        def find_any_id(elem: Element) -&gt; tuple[str, str, str]:\n            elem_tag = elem.tag\n            for attribute in (\n                \"text:id\",\n                \"text:change-id\",\n                \"text:name\",\n                \"office:name\",\n                \"text:ref-name\",\n                \"xml:id\",\n            ):\n                idx = elem.get_attribute(attribute)\n                if idx is not None:\n                    return elem_tag, attribute, str(idx)\n            raise ValueError(f\"No Id found in {elem.serialize()}\")\n\n        def common_ancestor(\n            tag1: str,\n            attr1: str,\n            val1: str,\n            tag2: str,\n            attr2: str,\n            val2: str,\n        ) -&gt; Element | None:\n            root = self.root\n            request1 = f'descendant::{tag1}[@{attr1}=\"{val1}\"]'\n            request2 = f'descendant::{tag2}[@{attr2}=\"{val2}\"]'\n            ancestor = root.xpath(request1)[0]\n            if ancestor is None:\n                return None\n            while True:\n                # print \"up\",\n                new_ancestor = ancestor.parent\n                if new_ancestor is None:\n                    return None\n                has_tag2 = new_ancestor.xpath(request2)\n                ancestor = new_ancestor\n                if not has_tag2:\n                    continue\n                # print 'found'\n                break\n            # print up.serialize()\n            return ancestor\n\n        elem1_tag, elem1_attr, elem1_val = find_any_id(tag1)\n        elem2_tag, elem2_attr, elem2_val = find_any_id(tag2)\n        ancestor_result = common_ancestor(\n            elem1_tag,\n            elem1_attr,\n            elem1_val,\n            elem2_tag,\n            elem2_attr,\n            elem2_val,\n        )\n        if ancestor_result is None:\n            raise RuntimeError(f\"No common ancestor for {elem1_tag} {elem2_tag}\")\n        ancestor = ancestor_result.clone\n        path1 = f'{elem1_tag}[@{elem1_attr}=\"{elem1_val}\"]'\n        path2 = f'{elem2_tag}[@{elem2_attr}=\"{elem2_val}\"]'\n        result = ancestor.clone\n        for child in result.children:\n            result.delete(child)\n        result.text = \"\"\n        result.tail = \"\"\n        target = result\n        current = ancestor.children[0]\n\n        state = 0\n        while True:\n            if current is None:\n                raise RuntimeError(f\"No current ancestor for {elem1_tag} {elem2_tag}\")\n            # print 'current', state, current.serialize()\n            if state == 0:  # before tag 1\n                if current.xpath(f\"descendant-or-self::{path1}\"):\n                    if current.xpath(f\"self::{path1}\"):\n                        tail = current.tail\n                        if tail:\n                            # got a tail =&gt; the parent should be either t:p or t:h\n                            target.text = tail  # type: ignore\n                        current, target = current._get_successor(target)  # type: ignore\n                        state = 1\n                        continue\n                    # got T1 in chidren, need further analysis\n                    new_target = current.clone\n                    for child in new_target.children:\n                        new_target.delete(child)\n                    new_target.text = \"\"\n                    new_target.tail = \"\"\n                    target.append(new_target)  # type: ignore\n                    target = new_target\n                    current = current.children[0]\n                    continue\n                else:\n                    # before tag1 : forget element, go to next one\n                    current, target = current._get_successor(target)  # type: ignore\n                    continue\n            elif state == 1:  # collect elements\n                further = False\n                if current.xpath(f\"descendant-or-self::{path2}\"):\n                    if current.xpath(f\"self::{path2}\"):\n                        # end of trip\n                        break\n                    # got T2 in chidren, need further analysis\n                    further = True\n                # further analysis needed :\n                if further:\n                    new_target = current.clone\n                    for child in new_target.children:\n                        new_target.delete(child)\n                    new_target.text = \"\"\n                    new_target.tail = \"\"\n                    target.append(new_target)  # type: ignore\n                    target = new_target\n                    current = current.children[0]\n                    continue\n                # collect\n                target.append(current.clone)  # type: ignore\n                current, target = current._get_successor(target)  # type: ignore\n                continue\n        # Now resu should be the \"parent\" of inserted parts\n        # - a text:h or text:p sigle item (simple case)\n        # - a upper element, with some text:p, text:h in it =&gt; need to be\n        #   stripped to have a list of text:p, text:h\n        if result.tag in {\"text:p\", \"text:h\"}:\n            inner = [result]\n        else:\n            inner = result.children\n        return inner\n\n    def get_between(\n        self,\n        tag1: Element,\n        tag2: Element,\n        as_text: bool = False,\n        clean: bool = True,\n        no_header: bool = True,\n    ) -&gt; list | Element | str:\n        \"\"\"Returns elements between tag1 and tag2, tag1 and tag2 shall\n        be unique and having an id attribute.\n        (WARN: buggy if tag1/tag2 defines a malformed odf xml.)\n        If as_text is True: returns the text content.\n        If clean is True: suppress unwanted tags (deletions marks, ...)\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of Element, cleaned and without headers.\n\n        Implementation and standard retrictions:\n        Only text:h and text:p sould be 'cut' by an insert tag, so inner parts\n        of insert tags are:\n\n            - any text:h, text:p or sub tag of these\n\n            - some text, part of a parent text:h or text:p\n\n        Arguments:\n\n            tag1 -- Element\n\n            tag2 -- Element\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list of odf_paragraph or odf_header\n        \"\"\"\n        inner = self._get_between_base(tag1, tag2)\n\n        if clean:\n            clean_tags = (\n                \"text:change\",\n                \"text:change-start\",\n                \"text:change-end\",\n                \"text:reference-mark\",\n                \"text:reference-mark-start\",\n                \"text:reference-mark-end\",\n            )\n            request_self = \" | \".join([f\"self::{tag}\" for tag in clean_tags])\n            inner = [e for e in inner if not e.xpath(request_self)]\n            request = \" | \".join([f\"descendant::{tag}\" for tag in clean_tags])\n            for element in inner:\n                to_del = element.xpath(request)\n                for elem in to_del:\n                    if isinstance(elem, Element):\n                        element.delete(elem)\n        if no_header:  # crude replace t:h by t:p\n            new_inner = []\n            for element in inner:\n                if element.tag == \"text:h\":\n                    children = element.children\n                    text = element.__element.text\n                    para = Element.from_tag(\"text:p\")\n                    para.text = text or \"\"\n                    for c in children:\n                        para.append(c)\n                    new_inner.append(para)\n                else:\n                    new_inner.append(element)\n            inner = new_inner\n        if as_text:\n            return \"\\n\".join([e.get_formatted_text() for e in inner])\n        else:\n            return inner\n\n    def insert(\n        self,\n        element: Element,\n        xmlposition: int | None = None,\n        position: int | None = None,\n        start: bool = False,\n    ) -&gt; None:\n        \"\"\"Insert an element relatively to ourself.\n\n        Insert either using DOM vocabulary or by numeric position.\n        If text start is True, insert the element before any existing text.\n\n        Position start at 0.\n\n        Arguments:\n\n            element -- Element\n\n            xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING\n                           or PREV_SIBLING\n\n            start -- Boolean\n\n            position -- int\n        \"\"\"\n        # child_tag = element.tag\n        current = self.__element\n        _element = element.__element\n        if start:\n            text = current.text\n            if text is not None:\n                current.text = None\n                tail = _element.tail\n                if tail is None:\n                    tail = text\n                else:\n                    tail = tail + text\n                _element.tail = tail\n            position = 0\n        if position is not None:\n            current.insert(position, _element)\n        elif xmlposition is FIRST_CHILD:\n            current.insert(0, _element)\n        elif xmlposition is LAST_CHILD:\n            current.append(_element)\n        elif xmlposition is NEXT_SIBLING:\n            parent = current.getparent()\n            index = parent.index(current)  # type: ignore\n            parent.insert(index + 1, _element)  # type: ignore\n        elif xmlposition is PREV_SIBLING:\n            parent = current.getparent()\n            index = parent.index(current)  # type: ignore\n            parent.insert(index, _element)  # type: ignore\n        else:\n            raise ValueError(\"(xml)position must be defined\")\n\n    def extend(self, odf_elements: Iterable[Element]) -&gt; None:\n        \"\"\"Fast append elements at the end of ourself using extend.\"\"\"\n        if odf_elements:\n            current = self.__element\n            elements = [element.__element for element in odf_elements]\n            current.extend(elements)\n\n    def append(self, str_or_element: str | Element) -&gt; None:\n        \"\"\"Insert element or text in the last position.\"\"\"\n        current = self.__element\n        if isinstance(str_or_element, str):\n            # Has children ?\n            children = list(current.iterchildren())\n            if children:\n                # Append to tail of the last child\n                last_child = children[-1]\n                text = last_child.tail\n                text = text if text is not None else \"\"\n                text += str_or_element\n                last_child.tail = text\n            else:\n                # Append to text of the element\n                text = current.text\n                text = text if text is not None else \"\"\n                text += str_or_element\n                current.text = text\n        elif isinstance(str_or_element, Element):\n            current.append(str_or_element.__element)\n        else:\n            raise TypeError(f'Element or string expected, not \"{type(str_or_element)}\"')\n\n    def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        if keep_tail is True (default), the tail text is not erased.\n\n        Arguments:\n\n            child -- Element\n\n            keep_tail -- boolean (default to True), True for most usages.\n        \"\"\"\n        if child is None:\n            parent = self.parent\n            if parent is None:\n                raise ValueError(f\"Can't delete the root element\\n{self.serialize()}\")\n            child = self\n        else:\n            parent = self\n        if keep_tail and child.__element.tail is not None:\n            current = child.__element\n            tail = str(current.tail)\n            current.tail = None\n            prev = current.getprevious()\n            if prev is not None:\n                if prev.tail is None:\n                    prev.tail = tail\n                else:\n                    prev.tail += tail\n            else:\n                if parent.__element.text is None:\n                    parent.__element.text = tail\n                else:\n                    parent.__element.text += tail\n        parent.__element.remove(child.__element)\n\n    def replace_element(self, old_element: Element, new_element: Element) -&gt; None:\n        \"\"\"Replaces in place a sub element with the element passed as second\n        argument.\n\n        Warning : no clone for old element.\n        \"\"\"\n        current = self.__element\n        current.replace(old_element.__element, new_element.__element)\n\n    def strip_elements(\n        self,\n        sub_elements: Element | Iterable[Element],\n    ) -&gt; Element | list:\n        \"\"\"Remove the tags of provided elements, keeping inner childs and text.\n\n        Return : the striped element.\n\n        Warning : no clone in sub_elements list.\n\n        Arguments:\n\n            sub_elements -- Element or list of Element\n        \"\"\"\n        if not sub_elements:\n            return self\n        if isinstance(sub_elements, Element):\n            sub_elements = (sub_elements,)\n        replacer = _get_lxml_tag(\"text:this-will-be-removed\")\n        for element in sub_elements:\n            element.__element.tag = replacer\n        strip = (\"text:this-will-be-removed\",)\n        return self.strip_tags(strip=strip, default=None)\n\n    def strip_tags(\n        self,\n        strip: Iterable[str] | None = None,\n        protect: Iterable[str] | None = None,\n        default: str | None = \"text:p\",\n    ) -&gt; Element | list:\n        \"\"\"Remove the tags listed in strip, recursively, keeping inner childs\n        and text. Tags listed in protect stop the removal one level depth. If\n        the first level element is stripped, default is used to embed the\n        content in the default element. If default is None and first level is\n        striped, a list of text and children is returned. Return : the striped\n        element.\n\n        strip_tags should be used by on purpose methods (strip_span ...)\n        (Method name taken from lxml).\n\n        Arguments:\n\n            strip -- iterable list of str odf tags, or None\n\n            protect -- iterable list of str odf tags, or None\n\n            default -- str odf tag, or None\n\n        Return:\n\n            Element.\n        \"\"\"\n        if not strip:\n            return self\n        if not protect:\n            protect = ()\n        protected = False\n        element, modified = Element._strip_tags(self, strip, protect, protected)\n        if modified and isinstance(element, list) and default:\n            new = Element.from_tag(default)\n            for content in element:\n                if isinstance(content, Element):\n                    new.append(content)\n                else:\n                    new.text = content\n            element = new\n        return element\n\n    @staticmethod\n    def _strip_tags(  # noqa:C901\n        element: Element,\n        strip: Iterable[str],\n        protect: Iterable[str],\n        protected: bool,\n    ) -&gt; tuple[Element | list, bool]:\n        \"\"\"Sub method for strip_tags().\"\"\"\n        element_clone = element.clone\n        modified = False\n        children = []\n        if protect and element.tag in protect:\n            protect_below = True\n        else:\n            protect_below = False\n        for child in element_clone.children:\n            striped_child, is_modified = Element._strip_tags(\n                child, strip, protect, protect_below\n            )\n            if is_modified:\n                modified = True\n            if isinstance(striped_child, list):\n                children.extend(striped_child)\n            else:\n                children.append(striped_child)\n\n        text = element_clone.text\n        tail = element_clone.tail\n        if not protected and strip and element.tag in strip:\n            element_result: list[Element | str] = []\n            if text is not None:\n                element_result.append(text)\n            for child in children:\n                element_result.append(child)\n            if tail is not None:\n                element_result.append(tail)\n            return (element_result, True)\n        else:\n            if not modified:\n                return (element, False)\n            element.clear()\n            try:\n                for key, value in element_clone.attributes.items():\n                    element.set_attribute(key, value)\n            except ValueError:\n                sys.stderr.write(f\"strip_tags(): bad attribute in {element_clone}\\n\")\n            if text is not None:\n                element.append(text)\n            for child in children:\n                element.append(child)\n            if tail is not None:\n                element.tail = tail\n            return (element, True)\n\n    def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n        \"\"\"Apply XPath query to the element and its subtree. Return list of\n        Element or EText instances translated from the nodes found.\n        \"\"\"\n        element = self.__element\n        xpath_instance = xpath_compile(xpath_query)\n        elements = xpath_instance(element)\n        result: list[Element | EText] = []\n        if hasattr(elements, \"__iter__\"):\n            for obj in elements:  # type: ignore\n                if isinstance(obj, (str, bytes)):\n                    result.append(EText(obj))\n                elif isinstance(obj, _Element):\n                    result.append(Element.from_tag(obj))\n                # else:\n                #     result.append(obj)\n        return result\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove text, children and attributes from the element.\"\"\"\n        self.__element.clear()\n        if hasattr(self, \"_tmap\"):\n            self._tmap: list[int] = []\n        if hasattr(self, \"_cmap\"):\n            self._cmap: list[int] = []\n        if hasattr(self, \"_rmap\"):\n            self._rmap: list[int] = []\n        if hasattr(self, \"_indexes\"):\n            remember = False\n            if \"_rmap\" in self._indexes:\n                remember = True\n            self._indexes: dict[str, dict] = {}\n            self._indexes[\"_cmap\"] = {}\n            self._indexes[\"_tmap\"] = {}\n            if remember:\n                self._indexes[\"_rmap\"] = {}\n\n    @property\n    def clone(self) -&gt; Element:\n        clone = deepcopy(self.__element)\n        root = lxml_Element(\"ROOT\", nsmap=ODF_NAMESPACES)\n        root.append(clone)\n        return self.from_tag(clone)\n\n        # slow data = tostring(self.__element, encoding='unicode')\n        # return self.from_tag(data)\n\n    @staticmethod\n    def _strip_namespaces(data: str) -&gt; str:\n        \"\"\"Remove xmlns:* fields from serialized XML.\"\"\"\n        return re.sub(r' xmlns:\\w*=\"[\\w:\\-\\/\\.#]*\"', \"\", data)\n\n    def serialize(self, pretty: bool = False, with_ns: bool = False) -&gt; str:\n        \"\"\"Return text serialization of XML element.\"\"\"\n        # This copy bypasses serialization side-effects in lxml\n        native = deepcopy(self.__element)\n        data = tostring(\n            native, with_tail=False, pretty_print=pretty, encoding=\"unicode\"\n        )\n        if with_ns:\n            return data\n        # Remove namespaces\n        return self._strip_namespaces(data)\n\n    # Element helpers usable from any context\n\n    @property\n    def document_body(self) -&gt; Element | None:\n        \"\"\"Return the first children of document body if any: 'office:body/*[1]'\"\"\"\n        return self.get_element(\"//office:body/*[1]\")\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        \"\"\"This function should return a beautiful version of the text.\"\"\"\n        return \"\"\n\n    def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n        \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n        name (or all by default).\n\n        Arguments:\n\n            name -- str\n\n        Return: list\n        \"\"\"\n        # FIXME incomplete (and possibly inaccurate)\n        return (\n            self._filtered_elements(\"descendant::*\", text_style=name)\n            + self._filtered_elements(\"descendant::*\", draw_style=name)\n            + self._filtered_elements(\"descendant::*\", draw_text_style=name)\n            + self._filtered_elements(\"descendant::*\", table_style=name)\n            + self._filtered_elements(\"descendant::*\", page_layout=name)\n            + self._filtered_elements(\"descendant::*\", master_page=name)\n            + self._filtered_elements(\"descendant::*\", parent_style=name)\n        )\n\n    # Common attributes\n\n    def _get_inner_text(self, tag: str) -&gt; str | None:\n        element = self.get_element(tag)\n        if element is None:\n            return None\n        return element.text\n\n    def _set_inner_text(self, tag: str, text: str) -&gt; None:\n        element = self.get_element(tag)\n        if element is None:\n            element = Element.from_tag(tag)\n            self.append(element)\n        element.text = text\n\n    # SVG\n\n    @property\n    def svg_title(self) -&gt; str | None:\n        return self._get_inner_text(\"svg:title\")\n\n    @svg_title.setter\n    def svg_title(self, title: str) -&gt; None:\n        self._set_inner_text(\"svg:title\", title)\n\n    @property\n    def svg_description(self) -&gt; str | None:\n        return self._get_inner_text(\"svg:desc\")\n\n    @svg_description.setter\n    def svg_description(self, description: str) -&gt; None:\n        self._set_inner_text(\"svg:desc\", description)\n\n    # Sections\n\n    def get_sections(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the sections that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"text:section\", text_style=style, content=content\n        )\n\n    @property\n    def sections(\n        self,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the sections.\n\n        Return: list of Element\n        \"\"\"\n        return self.get_elements(\"text:section\")\n\n    def get_section(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the section that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:section\", position, content=content\n        )\n\n    # Paragraphs\n\n    def get_paragraphs(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the paragraphs that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Paragraph\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:p\", text_style=style, content=content\n        )\n\n    @property\n    def paragraphs(self) -&gt; list[Element]:\n        \"\"\"Return all the paragraphs.\n\n        Return: list of Paragraph\n        \"\"\"\n        return self.get_elements(\"descendant::text:p\")\n\n    def get_paragraph(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the paragraph that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Paragraph or None if not found\n        \"\"\"\n        return self._filtered_element(\"descendant::text:p\", position, content=content)\n\n    # Span\n\n    def get_spans(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the spans that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Span\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:span\", text_style=style, content=content\n        )\n\n    @property\n    def spans(self) -&gt; list[Element]:\n        \"\"\"Return all the spans.\n\n        Return: list of Span\n        \"\"\"\n        return self.get_elements(\"descendant::text:span\")\n\n    def get_span(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the span that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Span or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:span\", position, content=content\n        )\n\n    # Headers\n\n    def get_headers(\n        self,\n        style: str | None = None,\n        outline_level: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the Headers that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Header\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:h\",\n            text_style=style,\n            outline_level=outline_level,\n            content=content,\n        )\n\n    @property\n    def headers(self) -&gt; list[Element]:\n        \"\"\"Return all the Headers.\n\n        Return: list of Header\n        \"\"\"\n        return self.get_elements(\"descendant::text:h\")\n\n    def get_header(\n        self,\n        position: int = 0,\n        outline_level: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the Header that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Header or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:h\",\n            position,\n            outline_level=outline_level,\n            content=content,\n        )\n\n    # Lists\n\n    def get_lists(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the lists that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of List\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:list\", text_style=style, content=content\n        )\n\n    @property\n    def lists(self) -&gt; list[Element]:\n        \"\"\"Return all the lists.\n\n        Return: list of List\n        \"\"\"\n        return self.get_elements(\"descendant::text:list\")\n\n    def get_list(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the list that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: List or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:list\", position, content=content\n        )\n\n    # Frames\n\n    def get_frames(\n        self,\n        presentation_class: str | None = None,\n        style: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the frames that match the criteria.\n\n        Arguments:\n\n            presentation_class -- str\n\n            style -- str\n\n            title -- str regex\n\n            description -- str regex\n\n            content -- str regex\n\n        Return: list of Frame\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:frame\",\n            presentation_class=presentation_class,\n            draw_style=style,\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    @property\n    def frames(self) -&gt; list[Element]:\n        \"\"\"Return all the frames.\n\n        Return: list of Frame\n        \"\"\"\n        return self.get_elements(\"descendant::draw:frame\")\n\n    def get_frame(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        presentation_class: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the section that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            presentation_class -- str\n\n            title -- str regex\n\n            description -- str regex\n\n            content -- str regex\n\n        Return: Frame or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:frame\",\n            position,\n            draw_name=name,\n            presentation_class=presentation_class,\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    # Images\n\n    def get_images(\n        self,\n        style: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the images matching the criteria.\n\n        Arguments:\n\n            style -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:image\", text_style=style, url=url, content=content\n        )\n\n    @property\n    def images(self) -&gt; list[Element]:\n        \"\"\"Return all the images.\n\n        Return: list of Element\n        \"\"\"\n        return self.get_elements(\"descendant::draw:image\")\n\n    def get_image(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the image matching the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        # The frame is holding the name\n        if name is not None:\n            frame = self._filtered_element(\n                \"descendant::draw:frame\", position, draw_name=name\n            )\n            if frame is None:\n                return None\n            # The name is supposedly unique\n            return frame.get_element(\"draw:image\")\n        return self._filtered_element(\n            \"descendant::draw:image\", position, url=url, content=content\n        )\n\n    # Named Range\n\n    def get_named_ranges(self) -&gt; list[Element]:\n        \"\"\"Return all the tables named ranges.\n\n        Return: list of odf_named_range\n        \"\"\"\n        named_ranges = self.get_elements(\n            \"descendant::table:named-expressions/table:named-range\"\n        )\n        return named_ranges\n\n    def get_named_range(self, name: str) -&gt; Element | None:\n        \"\"\"Return the named range of specified name, or None if not found.\n\n        Arguments:\n\n            name -- str\n\n        Return: NamedRange\n        \"\"\"\n        named_range = self.get_elements(\n            f'descendant::table:named-expressions/table:named-range[@table:name=\"{name}\"][1]'\n        )\n        if named_range:\n            return named_range[0]\n        else:\n            return None\n\n    def append_named_range(self, named_range: Element) -&gt; None:\n        \"\"\"Append the named range to the spreadsheet, replacing existing named\n        range of same name if any.\n\n        Arguments:\n\n            named_range --  NamedRange\n        \"\"\"\n        if self.tag != \"office:spreadsheet\":\n            raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n        named_expressions = self.get_element(\"table:named-expressions\")\n        if not named_expressions:\n            named_expressions = Element.from_tag(\"table:named-expressions\")\n            self.append(named_expressions)\n        # exists ?\n        current = named_expressions.get_element(\n            f'table:named-range[@table:name=\"{named_range.name}\"][1]'  # type:ignore\n        )\n        if current:\n            named_expressions.delete(current)\n        named_expressions.append(named_range)\n\n    def delete_named_range(self, name: str) -&gt; None:\n        \"\"\"Delete the Named Range of specified name from the spreadsheet.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        if self.tag != \"office:spreadsheet\":\n            raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n        named_range = self.get_named_range(name)\n        if not named_range:\n            return\n        named_range.delete()\n        named_expressions = self.get_element(\"table:named-expressions\")\n        if not named_expressions:\n            return\n        element = named_expressions.__element\n        children = list(element.iterchildren())\n        if not children:\n            self.delete(named_expressions)\n\n    # Notes\n\n    def get_notes(\n        self,\n        note_class: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the notes that match the criteria.\n\n        Arguments:\n\n            note_class -- 'footnote' or 'endnote'\n\n            content -- str regex\n\n        Return: list of Note\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:note\", note_class=note_class, content=content\n        )\n\n    def get_note(\n        self,\n        position: int = 0,\n        note_id: str | None = None,\n        note_class: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the note that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            note_id -- str\n\n            note_class -- 'footnote' or 'endnote'\n\n            content -- str regex\n\n        Return: Note or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:note\",\n            position,\n            text_id=note_id,\n            note_class=note_class,\n            content=content,\n        )\n\n    # Annotations\n\n    def get_annotations(\n        self,\n        creator: str | None = None,\n        start_date: datetime | None = None,\n        end_date: datetime | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the annotations that match the criteria.\n\n        Arguments:\n\n            creator -- str\n\n            start_date -- datetime instance\n\n            end_date --  datetime instance\n\n            content -- str regex\n\n        Return: list of Annotation\n        \"\"\"\n        annotations = []\n        for annotation in self._filtered_elements(\n            \"descendant::office:annotation\", content=content\n        ):\n            if creator is not None and creator != annotation.dc_creator:\n                continue\n            date = annotation.date\n            if date is None:\n                continue\n            if start_date is not None and date &lt; start_date:\n                continue\n            if end_date is not None and date &gt;= end_date:\n                continue\n            annotations.append(annotation)\n        return annotations\n\n    def get_annotation(\n        self,\n        position: int = 0,\n        creator: str | None = None,\n        start_date: datetime | None = None,\n        end_date: datetime | None = None,\n        content: str | None = None,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the annotation that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            creator -- str\n\n            start_date -- datetime instance\n\n            end_date -- datetime instance\n\n            content -- str regex\n\n            name -- str\n\n        Return: Annotation or None if not found\n        \"\"\"\n        if name is not None:\n            return self._filtered_element(\n                \"descendant::office:annotation\", 0, office_name=name\n            )\n        annotations = self.get_annotations(\n            creator=creator, start_date=start_date, end_date=end_date, content=content\n        )\n        if not annotations:\n            return None\n        try:\n            return annotations[position]\n        except IndexError:\n            return None\n\n    def get_annotation_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the annotation ends.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::office:annotation-end\")\n\n    def get_annotation_end(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the annotation end that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::office:annotation-end\", position, office_name=name\n        )\n\n    # office:names\n\n    def get_office_names(self) -&gt; list[str]:\n        \"\"\"Return all the used office:name tags values of the element.\n\n        Return: list of unique str\n        \"\"\"\n        name_xpath_query = xpath_compile(\"//@office:name\")\n        response = name_xpath_query(self.__element)\n        if not isinstance(response, list):\n            return []\n        return list({str(name) for name in response if name})\n\n    # Variables\n\n    def get_variable_decls(self) -&gt; Element:\n        \"\"\"Return the container for variable declarations. Created if not\n        found.\n\n        Return: Element\n        \"\"\"\n        variable_decls = self.get_element(\"//text:variable-decls\")\n        if variable_decls is None:\n            body = self.document_body\n            if not body:\n                raise ValueError(\"Empty document.body\")\n            body.insert(Element.from_tag(\"text:variable-decls\"), FIRST_CHILD)\n            variable_decls = body.get_element(\"//text:variable-decls\")\n\n        return variable_decls  # type:ignore\n\n    def get_variable_decl_list(self) -&gt; list[Element]:\n        \"\"\"Return all the variable declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:variable-decl\")\n\n    def get_variable_decl(self, name: str, position: int = 0) -&gt; Element | None:\n        \"\"\"return the variable declaration for the given name.\n\n        Arguments:\n\n            name -- str\n\n            position -- int\n\n        return: Element or none if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:variable-decl\", position, text_name=name\n        )\n\n    def get_variable_sets(self, name: str | None = None) -&gt; list[Element]:\n        \"\"\"Return all the variable sets that match the criteria.\n\n        Arguments:\n\n            name -- str\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:variable-set\", text_name=name)\n\n    def get_variable_set(self, name: str, position: int = -1) -&gt; Element | None:\n        \"\"\"Return the variable set for the given name (last one by default).\n\n        Arguments:\n\n            name -- str\n\n            position -- int\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:variable-set\", position, text_name=name\n        )\n\n    def get_variable_set_value(\n        self,\n        name: str,\n        value_type: str | None = None,\n    ) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n        \"\"\"Return the last value of the given variable name.\n\n        Arguments:\n\n            name -- str\n\n            value_type -- 'boolean', 'currency', 'date', 'float',\n                          'percentage', 'string', 'time' or automatic\n\n        Return: most appropriate Python type\n        \"\"\"\n        variable_set = self.get_variable_set(name)\n        if not variable_set:\n            return None\n        return variable_set.get_value(value_type)  # type: ignore\n\n    # User fields\n\n    def get_user_field_decls(self) -&gt; Element | None:\n        \"\"\"Return the container for user field declarations. Created if not\n        found.\n\n        Return: Element\n        \"\"\"\n        user_field_decls = self.get_element(\"//text:user-field-decls\")\n        if user_field_decls is None:\n            body = self.document_body\n            if not body:\n                raise ValueError(\"Empty document.body\")\n            body.insert(Element.from_tag(\"text:user-field-decls\"), FIRST_CHILD)\n            user_field_decls = body.get_element(\"//text:user-field-decls\")\n\n        return user_field_decls\n\n    def get_user_field_decl_list(self) -&gt; list[Element]:\n        \"\"\"Return all the user field declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:user-field-decl\")\n\n    def get_user_field_decl(self, name: str, position: int = 0) -&gt; Element | None:\n        \"\"\"return the user field declaration for the given name.\n\n        return: Element or none if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:user-field-decl\", position, text_name=name\n        )\n\n    def get_user_field_value(\n        self, name: str, value_type: str | None = None\n    ) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n        \"\"\"Return the value of the given user field name.\n\n        Arguments:\n\n            name -- str\n\n            value_type -- 'boolean', 'currency', 'date', 'float',\n                          'percentage', 'string', 'time' or automatic\n\n        Return: most appropriate Python type\n        \"\"\"\n        user_field_decl = self.get_user_field_decl(name)\n        if user_field_decl is None:\n            return None\n        return user_field_decl.get_value(value_type)  # type: ignore\n\n    # User defined fields\n    # They are fields who should contain a copy of a user defined medtadata\n\n    def get_user_defined_list(self) -&gt; list[Element]:\n        \"\"\"Return all the user defined field declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:user-defined\")\n\n    @property\n    def user_defined_list(self) -&gt; list[Element]:\n        \"\"\"Return all the user defined field declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self.get_user_defined_list()\n\n    def get_user_defined(self, name: str, position: int = 0) -&gt; Element | None:\n        \"\"\"return the user defined declaration for the given name.\n\n        return: Element or none if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:user-defined\", position, text_name=name\n        )\n\n    def get_user_defined_value(\n        self, name: str, value_type: str | None = None\n    ) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n        \"\"\"Return the value of the given user defined field name.\n\n        Arguments:\n\n            name -- str\n\n            value_type -- 'boolean', 'date', 'float',\n                          'string', 'time' or automatic\n\n        Return: most appropriate Python type\n        \"\"\"\n        user_defined = self.get_user_defined(name)\n        if user_defined is None:\n            return None\n        return user_defined.get_value(value_type)  # type: ignore\n\n    # Draw Pages\n\n    def get_draw_pages(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw pages that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of DrawPage\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:page\", draw_style=style, content=content\n        )\n\n    def get_draw_page(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw page that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            content -- str regex\n\n        Return: DrawPage or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:page\", position, draw_name=name, content=content\n        )\n\n    # Links\n\n    def get_links(\n        self,\n        name: str | None = None,\n        title: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the links that match the criteria.\n\n        Arguments:\n\n            name -- str\n\n            title -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:a\",\n            office_name=name,\n            office_title=title,\n            url=url,\n            content=content,\n        )\n\n    def get_link(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        title: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the link that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            title -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:a\",\n            position,\n            office_name=name,\n            office_title=title,\n            url=url,\n            content=content,\n        )\n\n    # Bookmarks\n\n    def get_bookmarks(self) -&gt; list[Element]:\n        \"\"\"Return all the bookmarks.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:bookmark\")\n\n    def get_bookmark(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the bookmark that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Bookmark or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:bookmark\", position, text_name=name\n        )\n\n    def get_bookmark_starts(self) -&gt; list[Element]:\n        \"\"\"Return all the bookmark starts.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:bookmark-start\")\n\n    def get_bookmark_start(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the bookmark start that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:bookmark-start\", position, text_name=name\n        )\n\n    def get_bookmark_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the bookmark ends.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:bookmark-end\")\n\n    def get_bookmark_end(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the bookmark end that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:bookmark-end\", position, text_name=name\n        )\n\n    # Reference marks\n\n    def get_reference_marks_single(self) -&gt; list[Element]:\n        \"\"\"Return all the reference marks. Search only the tags\n        text:reference-mark.\n        Consider using : get_reference_marks()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:reference-mark\")\n\n    def get_reference_mark_single(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark that matches the criteria. Search only the\n        tags text:reference-mark.\n        Consider using : get_reference_mark()\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:reference-mark\", position, text_name=name\n        )\n\n    def get_reference_mark_starts(self) -&gt; list[Element]:\n        \"\"\"Return all the reference mark starts. Search only the tags\n        text:reference-mark-start.\n        Consider using : get_reference_marks()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:reference-mark-start\")\n\n    def get_reference_mark_start(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark start that matches the criteria. Search\n        only the tags text:reference-mark-start.\n        Consider using : get_reference_mark()\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:reference-mark-start\", position, text_name=name\n        )\n\n    def get_reference_mark_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the reference mark ends. Search only the tags\n        text:reference-mark-end.\n        Consider using : get_reference_marks()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:reference-mark-end\")\n\n    def get_reference_mark_end(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark end that matches the criteria. Search only\n        the tags text:reference-mark-end.\n        Consider using : get_reference_marks()\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:reference-mark-end\", position, text_name=name\n        )\n\n    def get_reference_marks(self) -&gt; list[Element]:\n        \"\"\"Return all the reference marks, either single position reference\n        (text:reference-mark) or start of range reference\n        (text:reference-mark-start).\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n        )\n\n    def get_reference_mark(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark that match the criteria. Either single\n        position reference mark (text:reference-mark) or start of range\n        reference (text:reference-mark-start).\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        if name:\n            request = (\n                f\"descendant::text:reference-mark-start\"\n                f'[@text:name=\"{name}\"] '\n                f\"| descendant::text:reference-mark\"\n                f'[@text:name=\"{name}\"]'\n            )\n            return self._filtered_element(request, position=0)\n        request = (\n            \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n        )\n        return self._filtered_element(request, position)\n\n    def get_references(self, name: str | None = None) -&gt; list[Element]:\n        \"\"\"Return all the references (text:reference-ref). If name is\n        provided, returns the references of that name.\n\n        Return: list of Element\n\n        Arguments:\n\n            name -- str or None\n        \"\"\"\n        if name is None:\n            return self._filtered_elements(\"descendant::text:reference-ref\")\n        request = f'descendant::text:reference-ref[@text:ref-name=\"{name}\"]'\n        return self._filtered_elements(request)\n\n    # Shapes elements\n\n    # Groups\n\n    def get_draw_groups(\n        self,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        return self._filtered_elements(\n            \"descendant::draw:g\",\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    def get_draw_group(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        return self._filtered_element(\n            \"descendant::draw:g\",\n            position,\n            draw_name=name,\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    # Lines\n\n    def get_draw_lines(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw lines that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:line\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_line(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw line that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:line\", position, draw_id=id, content=content\n        )\n\n    # Rectangles\n\n    def get_draw_rectangles(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw rectangles that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:rect\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_rectangle(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw rectangle that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:rect\", position, draw_id=id, content=content\n        )\n\n    # Ellipse\n\n    def get_draw_ellipses(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw ellipses that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:ellipse\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_ellipse(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw ellipse that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:ellipse\", position, draw_id=id, content=content\n        )\n\n    # Connectors\n\n    def get_draw_connectors(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw connectors that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:connector\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_connector(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw connector that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:connector\", position, draw_id=id, content=content\n        )\n\n    def get_orphan_draw_connectors(self) -&gt; list[Element]:\n        \"\"\"Return a list of connectors which don't have any shape connected\n        to them.\n        \"\"\"\n        connectors = []\n        for connector in self.get_draw_connectors():\n            start_shape = connector.get_attribute(\"draw:start-shape\")\n            end_shape = connector.get_attribute(\"draw:end-shape\")\n            if start_shape is None and end_shape is None:\n                connectors.append(connector)\n        return connectors\n\n    # Tracked changes and text change\n\n    def get_tracked_changes(self) -&gt; Element | None:\n        \"\"\"Return the tracked-changes part in the text body.\n\n        Return: Element or None\n        \"\"\"\n        return self.get_element(\"//text:tracked-changes\")\n\n    @property\n    def tracked_changes(self) -&gt; Element | None:\n        \"\"\"Return the tracked-changes part in the text body.\n\n        Return: Element or None\n        \"\"\"\n        return self.get_tracked_changes()\n\n    def get_changes_ids(self) -&gt; list[Element | EText]:\n        \"\"\"Return a list of ids that refers to a change region in the tracked\n        changes list.\n        \"\"\"\n        # Insertion changes\n        xpath_query = \"descendant::text:change-start/@text:change-id\"\n        # Deletion changes\n        xpath_query += \" | descendant::text:change/@text:change-id\"\n        return self.xpath(xpath_query)\n\n    def get_text_change_deletions(self) -&gt; list[Element]:\n        \"\"\"Return all the text changes of deletion kind: the tags text:change.\n        Consider using : get_text_changes()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:text:change\")\n\n    def get_text_change_deletion(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change of deletion kind that matches the criteria.\n        Search only for the tags text:change.\n        Consider using : get_text_change()\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:change\", position, change_id=idx\n        )\n\n    def get_text_change_starts(self) -&gt; list[Element]:\n        \"\"\"Return all the text change-start. Search only for the tags\n        text:change-start.\n        Consider using : get_text_changes()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:change-start\")\n\n    def get_text_change_start(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change-start that matches the criteria. Search\n        only the tags text:change-start.\n        Consider using : get_text_change()\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:change-start\", position, change_id=idx\n        )\n\n    def get_text_change_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the text change-end. Search only the tags\n        text:change-end.\n        Consider using : get_text_changes()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:change-end\")\n\n    def get_text_change_end(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change-end that matches the criteria. Search only\n        the tags text:change-end.\n        Consider using : get_text_change()\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:change-end\", position, change_id=idx\n        )\n\n    def get_text_changes(self) -&gt; list[Element]:\n        \"\"\"Return all the text changes, either single deletion\n        (text:change) or start of range of changes (text:change-start).\n\n        Return: list of Element\n        \"\"\"\n        request = \"descendant::text:change-start | descendant::text:change\"\n        return self._filtered_elements(request)\n\n    @property\n    def text_changes(self) -&gt; list[Element]:\n        \"\"\"Return all the text changes, either single deletion\n        (text:change) or start of range of changes (text:change-start).\n\n        Return: list of Element\n        \"\"\"\n        return self.get_text_changes()\n\n    def get_text_change(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change that matches the criteria. Either single\n        deletion (text:change) or start of range of changes (text:change-start).\n        position : index of the element to retrieve if several matches, default\n        is 0.\n        idx : change-id of the element.\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        if idx:\n            request = (\n                f'descendant::text:change-start[@text:change-id=\"{idx}\"] '\n                f'| descendant::text:change[@text:change-id=\"{idx}\"]'\n            )\n            return self._filtered_element(request, 0)\n        request = \"descendant::text:change-start | descendant::text:change\"\n        return self._filtered_element(request, position)\n\n    # Table Of Content\n\n    def get_tocs(self) -&gt; list[Element]:\n        \"\"\"Return all the tables of contents.\n\n        Return: list of odf_toc\n        \"\"\"\n        return self.get_elements(\"text:table-of-content\")\n\n    @property\n    def tocs(self) -&gt; list[Element]:\n        \"\"\"Return all the tables of contents.\n\n        Return: list of odf_toc\n        \"\"\"\n        return self.get_elements(\"text:table-of-content\")\n\n    def get_toc(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the table of contents that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: odf_toc or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"text:table-of-content\", position, content=content\n        )\n\n    @property\n    def toc(self) -&gt; Element | None:\n        \"\"\"Return the first table of contents.\n\n        Return: odf_toc or None if not found\n        \"\"\"\n        return self.get_toc()\n\n    # Styles\n\n    @staticmethod\n    def _get_style_tagname(family: str | None, is_default: bool = False) -&gt; str:\n        \"\"\"Widely match possible tag names given the family (or not).\"\"\"\n        if not family:\n            tagname = \"(style:default-style|*[@style:name]|draw:fill-image|draw:marker)\"\n        elif is_default:\n            # Default style\n            tagname = \"style:default-style\"\n        else:\n            tagname = _family_style_tagname(family)\n            # if famattr:\n            #    # Include family default style\n            #    tagname = '(%s|style:default-style)' % tagname\n            if family in FAMILY_ODF_STD:\n                # Include family default style\n                tagname = f\"({tagname}|style:default-style)\"\n        return tagname\n\n    def get_styles(self, family: str | None = None) -&gt; list[Element]:\n        # Both common and default styles\n        tagname = self._get_style_tagname(family)\n        return self._filtered_elements(tagname, family=family)\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Element | None = None,\n        display_name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the style uniquely identified by the family/name pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is not the internal name but the name you gave in the\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                      'number'\n\n            name_or_element -- str or Style\n\n            display_name -- str\n\n        Return: odf_style or None if not found\n        \"\"\"\n        if isinstance(name_or_element, Element):\n            name = self.get_attribute(\"style:name\")\n            if name is not None:\n                return name_or_element\n            else:\n                raise ValueError(f\"Not a odf_style ? {name_or_element!r}\")\n        style_name = name_or_element\n        is_default = not (style_name or display_name)\n        tagname = self._get_style_tagname(family, is_default=is_default)\n        # famattr became None if no \"style:family\" attribute\n        if family:\n            return self._filtered_element(\n                tagname,\n                0,\n                style_name=style_name,\n                display_name=display_name,\n                family=family,\n            )\n        else:\n            return self._filtered_element(\n                tagname,\n                0,\n                draw_name=style_name or display_name,\n                family=family,\n            )\n\n    def _filtered_element(\n        self,\n        query_string: str,\n        position: int,\n        **kwargs: Any,\n    ) -&gt; Element | None:\n        results = self._filtered_elements(query_string, **kwargs)\n        try:\n            return results[position]\n        except IndexError:\n            return None\n\n    def _filtered_elements(\n        self,\n        query_string: str,\n        content: str | None = None,\n        url: str | None = None,\n        svg_title: str | None = None,\n        svg_desc: str | None = None,\n        dc_creator: str | None = None,\n        dc_date: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; list[Element]:\n        query = make_xpath_query(query_string, **kwargs)\n        elements = self.get_elements(query)\n        # Filter the elements with the regex (TODO use XPath)\n        if content is not None:\n            elements = [element for element in elements if element.match(content)]\n        if url is not None:\n            filtered = []\n            for element in elements:\n                url_attr = element.get_attribute(\"xlink:href\")\n                if isinstance(url_attr, str) and search(url, url_attr) is not None:\n                    filtered.append(element)\n            elements = filtered\n        if dc_date is None:\n            dt_dc_date = None\n        else:\n            dt_dc_date = DateTime.encode(dc_date)\n        for variable, childname in [\n            (svg_title, \"svg:title\"),\n            (svg_desc, \"svg:desc\"),\n            (dc_creator, \"descendant::dc:creator\"),\n            (dt_dc_date, \"descendant::dc:date\"),\n        ]:\n            if not variable:\n                continue\n            filtered = []\n            for element in elements:\n                child = element.get_element(childname)\n                if child and child.match(variable):\n                    filtered.append(element)\n            elements = filtered\n        return elements\n</code></pre>"},{"location":"reference.html#odfdo.Element.document_body","title":"<code>document_body: Element | None</code>  <code>property</code>","text":"<p>Return the first children of document body if any: \u2018office:body/*[1]\u2019</p>"},{"location":"reference.html#odfdo.Element.frames","title":"<code>frames: list[Element]</code>  <code>property</code>","text":"<p>Return all the frames.</p> <p>Return: list of Frame</p>"},{"location":"reference.html#odfdo.Element.headers","title":"<code>headers: list[Element]</code>  <code>property</code>","text":"<p>Return all the Headers.</p> <p>Return: list of Header</p>"},{"location":"reference.html#odfdo.Element.images","title":"<code>images: list[Element]</code>  <code>property</code>","text":"<p>Return all the images.</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.lists","title":"<code>lists: list[Element]</code>  <code>property</code>","text":"<p>Return all the lists.</p> <p>Return: list of List</p>"},{"location":"reference.html#odfdo.Element.paragraphs","title":"<code>paragraphs: list[Element]</code>  <code>property</code>","text":"<p>Return all the paragraphs.</p> <p>Return: list of Paragraph</p>"},{"location":"reference.html#odfdo.Element.sections","title":"<code>sections: list[Element]</code>  <code>property</code>","text":"<p>Return all the sections.</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.spans","title":"<code>spans: list[Element]</code>  <code>property</code>","text":"<p>Return all the spans.</p> <p>Return: list of Span</p>"},{"location":"reference.html#odfdo.Element.tag","title":"<code>tag: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get/set the underlying xml tag with the given qualified name.</p> <p>Warning: direct change of tag does not change the element class.</p> <p>Arguments:</p> <pre><code>qname -- str (e.g. \"text:span\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.tail","title":"<code>tail: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text immediately following the element.</p>"},{"location":"reference.html#odfdo.Element.text","title":"<code>text: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text content of the element.</p>"},{"location":"reference.html#odfdo.Element.text_changes","title":"<code>text_changes: list[Element]</code>  <code>property</code>","text":"<p>Return all the text changes, either single deletion (text:change) or start of range of changes (text:change-start).</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.text_content","title":"<code>text_content: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text of the embedded paragraph, including embeded annotations, cells\u2026</p> <p>Set create a paragraph if missing</p>"},{"location":"reference.html#odfdo.Element.toc","title":"<code>toc: Element | None</code>  <code>property</code>","text":"<p>Return the first table of contents.</p> <p>Return: odf_toc or None if not found</p>"},{"location":"reference.html#odfdo.Element.tocs","title":"<code>tocs: list[Element]</code>  <code>property</code>","text":"<p>Return all the tables of contents.</p> <p>Return: list of odf_toc</p>"},{"location":"reference.html#odfdo.Element.tracked_changes","title":"<code>tracked_changes: Element | None</code>  <code>property</code>","text":"<p>Return the tracked-changes part in the text body.</p> <p>Return: Element or None</p>"},{"location":"reference.html#odfdo.Element.user_defined_list","title":"<code>user_defined_list: list[Element]</code>  <code>property</code>","text":"<p>Return all the user defined field declarations.</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.append","title":"<code>append(str_or_element)</code>","text":"<p>Insert element or text in the last position.</p> Source code in <code>odfdo/element.py</code> <pre><code>def append(self, str_or_element: str | Element) -&gt; None:\n    \"\"\"Insert element or text in the last position.\"\"\"\n    current = self.__element\n    if isinstance(str_or_element, str):\n        # Has children ?\n        children = list(current.iterchildren())\n        if children:\n            # Append to tail of the last child\n            last_child = children[-1]\n            text = last_child.tail\n            text = text if text is not None else \"\"\n            text += str_or_element\n            last_child.tail = text\n        else:\n            # Append to text of the element\n            text = current.text\n            text = text if text is not None else \"\"\n            text += str_or_element\n            current.text = text\n    elif isinstance(str_or_element, Element):\n        current.append(str_or_element.__element)\n    else:\n        raise TypeError(f'Element or string expected, not \"{type(str_or_element)}\"')\n</code></pre>"},{"location":"reference.html#odfdo.Element.append_named_range","title":"<code>append_named_range(named_range)</code>","text":"<p>Append the named range to the spreadsheet, replacing existing named range of same name if any.</p> <p>Arguments:</p> <pre><code>named_range --  NamedRange\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def append_named_range(self, named_range: Element) -&gt; None:\n    \"\"\"Append the named range to the spreadsheet, replacing existing named\n    range of same name if any.\n\n    Arguments:\n\n        named_range --  NamedRange\n    \"\"\"\n    if self.tag != \"office:spreadsheet\":\n        raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n    named_expressions = self.get_element(\"table:named-expressions\")\n    if not named_expressions:\n        named_expressions = Element.from_tag(\"table:named-expressions\")\n        self.append(named_expressions)\n    # exists ?\n    current = named_expressions.get_element(\n        f'table:named-range[@table:name=\"{named_range.name}\"][1]'  # type:ignore\n    )\n    if current:\n        named_expressions.delete(current)\n    named_expressions.append(named_range)\n</code></pre>"},{"location":"reference.html#odfdo.Element.clear","title":"<code>clear()</code>","text":"<p>Remove text, children and attributes from the element.</p> Source code in <code>odfdo/element.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove text, children and attributes from the element.\"\"\"\n    self.__element.clear()\n    if hasattr(self, \"_tmap\"):\n        self._tmap: list[int] = []\n    if hasattr(self, \"_cmap\"):\n        self._cmap: list[int] = []\n    if hasattr(self, \"_rmap\"):\n        self._rmap: list[int] = []\n    if hasattr(self, \"_indexes\"):\n        remember = False\n        if \"_rmap\" in self._indexes:\n            remember = True\n        self._indexes: dict[str, dict] = {}\n        self._indexes[\"_cmap\"] = {}\n        self._indexes[\"_tmap\"] = {}\n        if remember:\n            self._indexes[\"_rmap\"] = {}\n</code></pre>"},{"location":"reference.html#odfdo.Element.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>if keep_tail is True (default), the tail text is not erased.</p> <p>Arguments:</p> <pre><code>child -- Element\n\nkeep_tail -- boolean (default to True), True for most usages.\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    if keep_tail is True (default), the tail text is not erased.\n\n    Arguments:\n\n        child -- Element\n\n        keep_tail -- boolean (default to True), True for most usages.\n    \"\"\"\n    if child is None:\n        parent = self.parent\n        if parent is None:\n            raise ValueError(f\"Can't delete the root element\\n{self.serialize()}\")\n        child = self\n    else:\n        parent = self\n    if keep_tail and child.__element.tail is not None:\n        current = child.__element\n        tail = str(current.tail)\n        current.tail = None\n        prev = current.getprevious()\n        if prev is not None:\n            if prev.tail is None:\n                prev.tail = tail\n            else:\n                prev.tail += tail\n        else:\n            if parent.__element.text is None:\n                parent.__element.text = tail\n            else:\n                parent.__element.text += tail\n    parent.__element.remove(child.__element)\n</code></pre>"},{"location":"reference.html#odfdo.Element.delete_named_range","title":"<code>delete_named_range(name)</code>","text":"<p>Delete the Named Range of specified name from the spreadsheet.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def delete_named_range(self, name: str) -&gt; None:\n    \"\"\"Delete the Named Range of specified name from the spreadsheet.\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    if self.tag != \"office:spreadsheet\":\n        raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n    named_range = self.get_named_range(name)\n    if not named_range:\n        return\n    named_range.delete()\n    named_expressions = self.get_element(\"table:named-expressions\")\n    if not named_expressions:\n        return\n    element = named_expressions.__element\n    children = list(element.iterchildren())\n    if not children:\n        self.delete(named_expressions)\n</code></pre>"},{"location":"reference.html#odfdo.Element.elements_repeated_sequence","title":"<code>elements_repeated_sequence(xpath_instance, name)</code>","text":"<p>Utility method for table module.</p> Source code in <code>odfdo/element.py</code> <pre><code>def elements_repeated_sequence(\n    self,\n    xpath_instance: XPath,\n    name: str,\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Utility method for table module.\"\"\"\n    lxml_tag = _get_lxml_tag_or_name(name)\n    element = self.__element\n    sub_elements = xpath_instance(element)\n    if not isinstance(sub_elements, list):\n        raise TypeError(\"Bad XPath result.\")\n    result: list[tuple[int, int]] = []\n    idx = -1\n    for sub_element in sub_elements:\n        if not isinstance(sub_element, _Element):\n            continue\n        idx += 1\n        value = sub_element.get(lxml_tag)\n        if value is None:\n            result.append((idx, 1))\n            continue\n        try:\n            int_value = int(value)\n        except ValueError:\n            int_value = 1\n        result.append((idx, max(int_value, 1)))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Element.extend","title":"<code>extend(odf_elements)</code>","text":"<p>Fast append elements at the end of ourself using extend.</p> Source code in <code>odfdo/element.py</code> <pre><code>def extend(self, odf_elements: Iterable[Element]) -&gt; None:\n    \"\"\"Fast append elements at the end of ourself using extend.\"\"\"\n    if odf_elements:\n        current = self.__element\n        elements = [element.__element for element in odf_elements]\n        current.extend(elements)\n</code></pre>"},{"location":"reference.html#odfdo.Element.from_tag","title":"<code>from_tag(tag_or_elem)</code>  <code>classmethod</code>","text":"<p>Element class and subclass factory.</p> <p>Turn an lxml Element or ODF string tag into an ODF XML Element of the relevant class.</p> <p>Arguments:</p> <pre><code>tag_or_elem -- ODF str tag or lxml.Element\n</code></pre> <p>Return: Element (or subclass) instance</p> Source code in <code>odfdo/element.py</code> <pre><code>@classmethod\ndef from_tag(cls, tag_or_elem: str | _Element) -&gt; Element:\n    \"\"\"Element class and subclass factory.\n\n    Turn an lxml Element or ODF string tag into an ODF XML Element\n    of the relevant class.\n\n    Arguments:\n\n        tag_or_elem -- ODF str tag or lxml.Element\n\n    Return: Element (or subclass) instance\n    \"\"\"\n    if isinstance(tag_or_elem, str):\n        # assume the argument is a prefix:name tag\n        elem = cls.make_etree_element(tag_or_elem)\n    else:\n        elem = tag_or_elem\n    klass = _class_registry.get(elem.tag, cls)\n    return klass(tag_or_elem=elem)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotation","title":"<code>get_annotation(position=0, creator=None, start_date=None, end_date=None, content=None, name=None)</code>","text":"<p>Return the annotation that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncreator -- str\n\nstart_date -- datetime instance\n\nend_date -- datetime instance\n\ncontent -- str regex\n\nname -- str\n</code></pre> <p>Return: Annotation or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotation(\n    self,\n    position: int = 0,\n    creator: str | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    content: str | None = None,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the annotation that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        creator -- str\n\n        start_date -- datetime instance\n\n        end_date -- datetime instance\n\n        content -- str regex\n\n        name -- str\n\n    Return: Annotation or None if not found\n    \"\"\"\n    if name is not None:\n        return self._filtered_element(\n            \"descendant::office:annotation\", 0, office_name=name\n        )\n    annotations = self.get_annotations(\n        creator=creator, start_date=start_date, end_date=end_date, content=content\n    )\n    if not annotations:\n        return None\n    try:\n        return annotations[position]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotation_end","title":"<code>get_annotation_end(position=0, name=None)</code>","text":"<p>Return the annotation end that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotation_end(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the annotation end that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::office:annotation-end\", position, office_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotation_ends","title":"<code>get_annotation_ends()</code>","text":"<p>Return all the annotation ends.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotation_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the annotation ends.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::office:annotation-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotations","title":"<code>get_annotations(creator=None, start_date=None, end_date=None, content=None)</code>","text":"<p>Return all the annotations that match the criteria.</p> <p>Arguments:</p> <pre><code>creator -- str\n\nstart_date -- datetime instance\n\nend_date --  datetime instance\n\ncontent -- str regex\n</code></pre> <p>Return: list of Annotation</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotations(\n    self,\n    creator: str | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the annotations that match the criteria.\n\n    Arguments:\n\n        creator -- str\n\n        start_date -- datetime instance\n\n        end_date --  datetime instance\n\n        content -- str regex\n\n    Return: list of Annotation\n    \"\"\"\n    annotations = []\n    for annotation in self._filtered_elements(\n        \"descendant::office:annotation\", content=content\n    ):\n        if creator is not None and creator != annotation.dc_creator:\n            continue\n        date = annotation.date\n        if date is None:\n            continue\n        if start_date is not None and date &lt; start_date:\n            continue\n        if end_date is not None and date &gt;= end_date:\n            continue\n        annotations.append(annotation)\n    return annotations\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Return the attribute value as type str | bool | None.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_attribute(self, name: str) -&gt; str | bool | None:\n    \"\"\"Return the attribute value as type str | bool | None.\"\"\"\n    element = self.__element\n    lxml_tag = _get_lxml_tag_or_name(name)\n    value = element.get(lxml_tag)\n    if value is None:\n        return None\n    elif value in (\"true\", \"false\"):\n        return Boolean.decode(value)\n    return str(value)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_attribute_integer","title":"<code>get_attribute_integer(name)</code>","text":"<p>Return either the attribute as type int, or None.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_attribute_integer(self, name: str) -&gt; int | None:\n    \"\"\"Return either the attribute as type int, or None.\"\"\"\n    element = self.__element\n    lxml_tag = _get_lxml_tag_or_name(name)\n    value = element.get(lxml_tag)\n    if value is None:\n        return None\n    try:\n        return int(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_attribute_string","title":"<code>get_attribute_string(name)</code>","text":"<p>Return either the attribute as type str, or None.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_attribute_string(self, name: str) -&gt; str | None:\n    \"\"\"Return either the attribute as type str, or None.\"\"\"\n    element = self.__element\n    lxml_tag = _get_lxml_tag_or_name(name)\n    value = element.get(lxml_tag)\n    if value is None:\n        return None\n    return str(value)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_between","title":"<code>get_between(tag1, tag2, as_text=False, clean=True, no_header=True)</code>","text":"<p>Returns elements between tag1 and tag2, tag1 and tag2 shall be unique and having an id attribute. (WARN: buggy if tag1/tag2 defines a malformed odf xml.) If as_text is True: returns the text content. If clean is True: suppress unwanted tags (deletions marks, \u2026) If no_header is True: existing text:h are changed in text:p By default: returns a list of Element, cleaned and without headers.</p> <p>Implementation and standard retrictions: Only text:h and text:p sould be \u2018cut\u2019 by an insert tag, so inner parts of insert tags are:</p> <pre><code>- any text:h, text:p or sub tag of these\n\n- some text, part of a parent text:h or text:p\n</code></pre> <p>Arguments:</p> <pre><code>tag1 -- Element\n\ntag2 -- Element\n\nas_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list of odf_paragraph or odf_header</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_between(\n    self,\n    tag1: Element,\n    tag2: Element,\n    as_text: bool = False,\n    clean: bool = True,\n    no_header: bool = True,\n) -&gt; list | Element | str:\n    \"\"\"Returns elements between tag1 and tag2, tag1 and tag2 shall\n    be unique and having an id attribute.\n    (WARN: buggy if tag1/tag2 defines a malformed odf xml.)\n    If as_text is True: returns the text content.\n    If clean is True: suppress unwanted tags (deletions marks, ...)\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of Element, cleaned and without headers.\n\n    Implementation and standard retrictions:\n    Only text:h and text:p sould be 'cut' by an insert tag, so inner parts\n    of insert tags are:\n\n        - any text:h, text:p or sub tag of these\n\n        - some text, part of a parent text:h or text:p\n\n    Arguments:\n\n        tag1 -- Element\n\n        tag2 -- Element\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list of odf_paragraph or odf_header\n    \"\"\"\n    inner = self._get_between_base(tag1, tag2)\n\n    if clean:\n        clean_tags = (\n            \"text:change\",\n            \"text:change-start\",\n            \"text:change-end\",\n            \"text:reference-mark\",\n            \"text:reference-mark-start\",\n            \"text:reference-mark-end\",\n        )\n        request_self = \" | \".join([f\"self::{tag}\" for tag in clean_tags])\n        inner = [e for e in inner if not e.xpath(request_self)]\n        request = \" | \".join([f\"descendant::{tag}\" for tag in clean_tags])\n        for element in inner:\n            to_del = element.xpath(request)\n            for elem in to_del:\n                if isinstance(elem, Element):\n                    element.delete(elem)\n    if no_header:  # crude replace t:h by t:p\n        new_inner = []\n        for element in inner:\n            if element.tag == \"text:h\":\n                children = element.children\n                text = element.__element.text\n                para = Element.from_tag(\"text:p\")\n                para.text = text or \"\"\n                for c in children:\n                    para.append(c)\n                new_inner.append(para)\n            else:\n                new_inner.append(element)\n        inner = new_inner\n    if as_text:\n        return \"\\n\".join([e.get_formatted_text() for e in inner])\n    else:\n        return inner\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark","title":"<code>get_bookmark(position=0, name=None)</code>","text":"<p>Return the bookmark that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Bookmark or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the bookmark that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Bookmark or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:bookmark\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_end","title":"<code>get_bookmark_end(position=0, name=None)</code>","text":"<p>Return the bookmark end that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_end(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the bookmark end that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:bookmark-end\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_ends","title":"<code>get_bookmark_ends()</code>","text":"<p>Return all the bookmark ends.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the bookmark ends.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:bookmark-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_start","title":"<code>get_bookmark_start(position=0, name=None)</code>","text":"<p>Return the bookmark start that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_start(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the bookmark start that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:bookmark-start\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_starts","title":"<code>get_bookmark_starts()</code>","text":"<p>Return all the bookmark starts.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_starts(self) -&gt; list[Element]:\n    \"\"\"Return all the bookmark starts.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:bookmark-start\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmarks","title":"<code>get_bookmarks()</code>","text":"<p>Return all the bookmarks.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmarks(self) -&gt; list[Element]:\n    \"\"\"Return all the bookmarks.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:bookmark\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_changes_ids","title":"<code>get_changes_ids()</code>","text":"<p>Return a list of ids that refers to a change region in the tracked changes list.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_changes_ids(self) -&gt; list[Element | EText]:\n    \"\"\"Return a list of ids that refers to a change region in the tracked\n    changes list.\n    \"\"\"\n    # Insertion changes\n    xpath_query = \"descendant::text:change-start/@text:change-id\"\n    # Deletion changes\n    xpath_query += \" | descendant::text:change/@text:change-id\"\n    return self.xpath(xpath_query)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_connector","title":"<code>get_draw_connector(position=0, id=None, content=None)</code>","text":"<p>Return the draw connector that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_connector(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw connector that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:connector\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_connectors","title":"<code>get_draw_connectors(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw connectors that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_connectors(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw connectors that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:connector\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_ellipse","title":"<code>get_draw_ellipse(position=0, id=None, content=None)</code>","text":"<p>Return the draw ellipse that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_ellipse(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw ellipse that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:ellipse\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_ellipses","title":"<code>get_draw_ellipses(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw ellipses that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_ellipses(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw ellipses that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:ellipse\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_line","title":"<code>get_draw_line(position=0, id=None, content=None)</code>","text":"<p>Return the draw line that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_line(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw line that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:line\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_lines","title":"<code>get_draw_lines(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw lines that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_lines(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw lines that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:line\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_page","title":"<code>get_draw_page(position=0, name=None, content=None)</code>","text":"<p>Return the draw page that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\ncontent -- str regex\n</code></pre> <p>Return: DrawPage or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_page(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw page that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        content -- str regex\n\n    Return: DrawPage or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:page\", position, draw_name=name, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_pages","title":"<code>get_draw_pages(style=None, content=None)</code>","text":"<p>Return all the draw pages that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of DrawPage</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_pages(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw pages that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of DrawPage\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:page\", draw_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_rectangle","title":"<code>get_draw_rectangle(position=0, id=None, content=None)</code>","text":"<p>Return the draw rectangle that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_rectangle(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw rectangle that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:rect\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_rectangles","title":"<code>get_draw_rectangles(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw rectangles that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_rectangles(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw rectangles that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:rect\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_formatted_text","title":"<code>get_formatted_text(context=None)</code>","text":"<p>This function should return a beautiful version of the text.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_formatted_text(self, context: dict | None = None) -&gt; str:\n    \"\"\"This function should return a beautiful version of the text.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_frame","title":"<code>get_frame(position=0, name=None, presentation_class=None, title=None, description=None, content=None)</code>","text":"<p>Return the section that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\npresentation_class -- str\n\ntitle -- str regex\n\ndescription -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: Frame or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_frame(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    presentation_class: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the section that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        presentation_class -- str\n\n        title -- str regex\n\n        description -- str regex\n\n        content -- str regex\n\n    Return: Frame or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:frame\",\n        position,\n        draw_name=name,\n        presentation_class=presentation_class,\n        svg_title=title,\n        svg_desc=description,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_frames","title":"<code>get_frames(presentation_class=None, style=None, title=None, description=None, content=None)</code>","text":"<p>Return all the frames that match the criteria.</p> <p>Arguments:</p> <pre><code>presentation_class -- str\n\nstyle -- str\n\ntitle -- str regex\n\ndescription -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: list of Frame</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_frames(\n    self,\n    presentation_class: str | None = None,\n    style: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the frames that match the criteria.\n\n    Arguments:\n\n        presentation_class -- str\n\n        style -- str\n\n        title -- str regex\n\n        description -- str regex\n\n        content -- str regex\n\n    Return: list of Frame\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:frame\",\n        presentation_class=presentation_class,\n        draw_style=style,\n        svg_title=title,\n        svg_desc=description,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_header","title":"<code>get_header(position=0, outline_level=None, content=None)</code>","text":"<p>Return the Header that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Header or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_header(\n    self,\n    position: int = 0,\n    outline_level: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the Header that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Header or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:h\",\n        position,\n        outline_level=outline_level,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_headers","title":"<code>get_headers(style=None, outline_level=None, content=None)</code>","text":"<p>Return all the Headers that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Header</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_headers(\n    self,\n    style: str | None = None,\n    outline_level: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the Headers that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Header\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:h\",\n        text_style=style,\n        outline_level=outline_level,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_image","title":"<code>get_image(position=0, name=None, url=None, content=None)</code>","text":"<p>Return the image matching the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_image(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the image matching the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    # The frame is holding the name\n    if name is not None:\n        frame = self._filtered_element(\n            \"descendant::draw:frame\", position, draw_name=name\n        )\n        if frame is None:\n            return None\n        # The name is supposedly unique\n        return frame.get_element(\"draw:image\")\n    return self._filtered_element(\n        \"descendant::draw:image\", position, url=url, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_images","title":"<code>get_images(style=None, url=None, content=None)</code>","text":"<p>Return all the images matching the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_images(\n    self,\n    style: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the images matching the criteria.\n\n    Arguments:\n\n        style -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:image\", text_style=style, url=url, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_link","title":"<code>get_link(position=0, name=None, title=None, url=None, content=None)</code>","text":"<p>Return the link that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\ntitle -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_link(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    title: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the link that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        title -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:a\",\n        position,\n        office_name=name,\n        office_title=title,\n        url=url,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_links","title":"<code>get_links(name=None, title=None, url=None, content=None)</code>","text":"<p>Return all the links that match the criteria.</p> <p>Arguments:</p> <pre><code>name -- str\n\ntitle -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_links(\n    self,\n    name: str | None = None,\n    title: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the links that match the criteria.\n\n    Arguments:\n\n        name -- str\n\n        title -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:a\",\n        office_name=name,\n        office_title=title,\n        url=url,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_list","title":"<code>get_list(position=0, content=None)</code>","text":"<p>Return the list that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: List or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_list(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the list that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: List or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:list\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_lists","title":"<code>get_lists(style=None, content=None)</code>","text":"<p>Return all the lists that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of List</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_lists(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the lists that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of List\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:list\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_named_range","title":"<code>get_named_range(name)</code>","text":"<p>Return the named range of specified name, or None if not found.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: NamedRange</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_named_range(self, name: str) -&gt; Element | None:\n    \"\"\"Return the named range of specified name, or None if not found.\n\n    Arguments:\n\n        name -- str\n\n    Return: NamedRange\n    \"\"\"\n    named_range = self.get_elements(\n        f'descendant::table:named-expressions/table:named-range[@table:name=\"{name}\"][1]'\n    )\n    if named_range:\n        return named_range[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_named_ranges","title":"<code>get_named_ranges()</code>","text":"<p>Return all the tables named ranges.</p> <p>Return: list of odf_named_range</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_named_ranges(self) -&gt; list[Element]:\n    \"\"\"Return all the tables named ranges.\n\n    Return: list of odf_named_range\n    \"\"\"\n    named_ranges = self.get_elements(\n        \"descendant::table:named-expressions/table:named-range\"\n    )\n    return named_ranges\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_note","title":"<code>get_note(position=0, note_id=None, note_class=None, content=None)</code>","text":"<p>Return the note that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nnote_id -- str\n\nnote_class -- 'footnote' or 'endnote'\n\ncontent -- str regex\n</code></pre> <p>Return: Note or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_note(\n    self,\n    position: int = 0,\n    note_id: str | None = None,\n    note_class: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the note that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        note_id -- str\n\n        note_class -- 'footnote' or 'endnote'\n\n        content -- str regex\n\n    Return: Note or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:note\",\n        position,\n        text_id=note_id,\n        note_class=note_class,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_notes","title":"<code>get_notes(note_class=None, content=None)</code>","text":"<p>Return all the notes that match the criteria.</p> <p>Arguments:</p> <pre><code>note_class -- 'footnote' or 'endnote'\n\ncontent -- str regex\n</code></pre> <p>Return: list of Note</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_notes(\n    self,\n    note_class: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the notes that match the criteria.\n\n    Arguments:\n\n        note_class -- 'footnote' or 'endnote'\n\n        content -- str regex\n\n    Return: list of Note\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:note\", note_class=note_class, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_office_names","title":"<code>get_office_names()</code>","text":"<p>Return all the used office:name tags values of the element.</p> <p>Return: list of unique str</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_office_names(self) -&gt; list[str]:\n    \"\"\"Return all the used office:name tags values of the element.\n\n    Return: list of unique str\n    \"\"\"\n    name_xpath_query = xpath_compile(\"//@office:name\")\n    response = name_xpath_query(self.__element)\n    if not isinstance(response, list):\n        return []\n    return list({str(name) for name in response if name})\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_orphan_draw_connectors","title":"<code>get_orphan_draw_connectors()</code>","text":"<p>Return a list of connectors which don\u2019t have any shape connected to them.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_orphan_draw_connectors(self) -&gt; list[Element]:\n    \"\"\"Return a list of connectors which don't have any shape connected\n    to them.\n    \"\"\"\n    connectors = []\n    for connector in self.get_draw_connectors():\n        start_shape = connector.get_attribute(\"draw:start-shape\")\n        end_shape = connector.get_attribute(\"draw:end-shape\")\n        if start_shape is None and end_shape is None:\n            connectors.append(connector)\n    return connectors\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_paragraph","title":"<code>get_paragraph(position=0, content=None)</code>","text":"<p>Return the paragraph that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Paragraph or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_paragraph(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the paragraph that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Paragraph or None if not found\n    \"\"\"\n    return self._filtered_element(\"descendant::text:p\", position, content=content)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_paragraphs","title":"<code>get_paragraphs(style=None, content=None)</code>","text":"<p>Return all the paragraphs that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Paragraph</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_paragraphs(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the paragraphs that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Paragraph\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:p\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark","title":"<code>get_reference_mark(position=0, name=None)</code>","text":"<p>Return the reference mark that match the criteria. Either single position reference mark (text:reference-mark) or start of range reference (text:reference-mark-start).</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark that match the criteria. Either single\n    position reference mark (text:reference-mark) or start of range\n    reference (text:reference-mark-start).\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    if name:\n        request = (\n            f\"descendant::text:reference-mark-start\"\n            f'[@text:name=\"{name}\"] '\n            f\"| descendant::text:reference-mark\"\n            f'[@text:name=\"{name}\"]'\n        )\n        return self._filtered_element(request, position=0)\n    request = (\n        \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n    )\n    return self._filtered_element(request, position)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_end","title":"<code>get_reference_mark_end(position=0, name=None)</code>","text":"<p>Return the reference mark end that matches the criteria. Search only the tags text:reference-mark-end. Consider using : get_reference_marks()</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_end(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark end that matches the criteria. Search only\n    the tags text:reference-mark-end.\n    Consider using : get_reference_marks()\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:reference-mark-end\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_ends","title":"<code>get_reference_mark_ends()</code>","text":"<p>Return all the reference mark ends. Search only the tags text:reference-mark-end. Consider using : get_reference_marks()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the reference mark ends. Search only the tags\n    text:reference-mark-end.\n    Consider using : get_reference_marks()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:reference-mark-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_single","title":"<code>get_reference_mark_single(position=0, name=None)</code>","text":"<p>Return the reference mark that matches the criteria. Search only the tags text:reference-mark. Consider using : get_reference_mark()</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_single(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark that matches the criteria. Search only the\n    tags text:reference-mark.\n    Consider using : get_reference_mark()\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:reference-mark\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_start","title":"<code>get_reference_mark_start(position=0, name=None)</code>","text":"<p>Return the reference mark start that matches the criteria. Search only the tags text:reference-mark-start. Consider using : get_reference_mark()</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_start(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark start that matches the criteria. Search\n    only the tags text:reference-mark-start.\n    Consider using : get_reference_mark()\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:reference-mark-start\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_starts","title":"<code>get_reference_mark_starts()</code>","text":"<p>Return all the reference mark starts. Search only the tags text:reference-mark-start. Consider using : get_reference_marks()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_starts(self) -&gt; list[Element]:\n    \"\"\"Return all the reference mark starts. Search only the tags\n    text:reference-mark-start.\n    Consider using : get_reference_marks()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:reference-mark-start\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_marks","title":"<code>get_reference_marks()</code>","text":"<p>Return all the reference marks, either single position reference (text:reference-mark) or start of range reference (text:reference-mark-start).</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_marks(self) -&gt; list[Element]:\n    \"\"\"Return all the reference marks, either single position reference\n    (text:reference-mark) or start of range reference\n    (text:reference-mark-start).\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_marks_single","title":"<code>get_reference_marks_single()</code>","text":"<p>Return all the reference marks. Search only the tags text:reference-mark. Consider using : get_reference_marks()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_marks_single(self) -&gt; list[Element]:\n    \"\"\"Return all the reference marks. Search only the tags\n    text:reference-mark.\n    Consider using : get_reference_marks()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:reference-mark\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_references","title":"<code>get_references(name=None)</code>","text":"<p>Return all the references (text:reference-ref). If name is provided, returns the references of that name.</p> <p>Return: list of Element</p> <p>Arguments:</p> <pre><code>name -- str or None\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def get_references(self, name: str | None = None) -&gt; list[Element]:\n    \"\"\"Return all the references (text:reference-ref). If name is\n    provided, returns the references of that name.\n\n    Return: list of Element\n\n    Arguments:\n\n        name -- str or None\n    \"\"\"\n    if name is None:\n        return self._filtered_elements(\"descendant::text:reference-ref\")\n    request = f'descendant::text:reference-ref[@text:ref-name=\"{name}\"]'\n    return self._filtered_elements(request)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_section","title":"<code>get_section(position=0, content=None)</code>","text":"<p>Return the section that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_section(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the section that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:section\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_sections","title":"<code>get_sections(style=None, content=None)</code>","text":"<p>Return all the sections that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_sections(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the sections that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"text:section\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_span","title":"<code>get_span(position=0, content=None)</code>","text":"<p>Return the span that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Span or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_span(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the span that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Span or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:span\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_spans","title":"<code>get_spans(style=None, content=None)</code>","text":"<p>Return all the spans that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Span</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_spans(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the spans that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Span\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:span\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the family/name pair. If the argument is already a style object, it will return it.</p> <p>If the name is not the internal name but the name you gave in the desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n          'number'\n\nname_or_element -- str or Style\n\ndisplay_name -- str\n</code></pre> <p>Return: odf_style or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Element | None = None,\n    display_name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the style uniquely identified by the family/name pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is not the internal name but the name you gave in the\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                  'number'\n\n        name_or_element -- str or Style\n\n        display_name -- str\n\n    Return: odf_style or None if not found\n    \"\"\"\n    if isinstance(name_or_element, Element):\n        name = self.get_attribute(\"style:name\")\n        if name is not None:\n            return name_or_element\n        else:\n            raise ValueError(f\"Not a odf_style ? {name_or_element!r}\")\n    style_name = name_or_element\n    is_default = not (style_name or display_name)\n    tagname = self._get_style_tagname(family, is_default=is_default)\n    # famattr became None if no \"style:family\" attribute\n    if family:\n        return self._filtered_element(\n            tagname,\n            0,\n            style_name=style_name,\n            display_name=display_name,\n            family=family,\n        )\n    else:\n        return self._filtered_element(\n            tagname,\n            0,\n            draw_name=style_name or display_name,\n            family=family,\n        )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_styled_elements","title":"<code>get_styled_elements(name='')</code>","text":"<p>Brute-force to find paragraphs, tables, etc. using the given style name (or all by default).</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: list</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n    \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n    name (or all by default).\n\n    Arguments:\n\n        name -- str\n\n    Return: list\n    \"\"\"\n    # FIXME incomplete (and possibly inaccurate)\n    return (\n        self._filtered_elements(\"descendant::*\", text_style=name)\n        + self._filtered_elements(\"descendant::*\", draw_style=name)\n        + self._filtered_elements(\"descendant::*\", draw_text_style=name)\n        + self._filtered_elements(\"descendant::*\", table_style=name)\n        + self._filtered_elements(\"descendant::*\", page_layout=name)\n        + self._filtered_elements(\"descendant::*\", master_page=name)\n        + self._filtered_elements(\"descendant::*\", parent_style=name)\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change","title":"<code>get_text_change(position=0, idx=None)</code>","text":"<p>Return the text change that matches the criteria. Either single deletion (text:change) or start of range of changes (text:change-start). position : index of the element to retrieve if several matches, default is 0. idx : change-id of the element.</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change that matches the criteria. Either single\n    deletion (text:change) or start of range of changes (text:change-start).\n    position : index of the element to retrieve if several matches, default\n    is 0.\n    idx : change-id of the element.\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    if idx:\n        request = (\n            f'descendant::text:change-start[@text:change-id=\"{idx}\"] '\n            f'| descendant::text:change[@text:change-id=\"{idx}\"]'\n        )\n        return self._filtered_element(request, 0)\n    request = \"descendant::text:change-start | descendant::text:change\"\n    return self._filtered_element(request, position)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_deletion","title":"<code>get_text_change_deletion(position=0, idx=None)</code>","text":"<p>Return the text change of deletion kind that matches the criteria. Search only for the tags text:change. Consider using : get_text_change()</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_deletion(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change of deletion kind that matches the criteria.\n    Search only for the tags text:change.\n    Consider using : get_text_change()\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:change\", position, change_id=idx\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_deletions","title":"<code>get_text_change_deletions()</code>","text":"<p>Return all the text changes of deletion kind: the tags text:change. Consider using : get_text_changes()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_deletions(self) -&gt; list[Element]:\n    \"\"\"Return all the text changes of deletion kind: the tags text:change.\n    Consider using : get_text_changes()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:text:change\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_end","title":"<code>get_text_change_end(position=0, idx=None)</code>","text":"<p>Return the text change-end that matches the criteria. Search only the tags text:change-end. Consider using : get_text_change()</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_end(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change-end that matches the criteria. Search only\n    the tags text:change-end.\n    Consider using : get_text_change()\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:change-end\", position, change_id=idx\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_ends","title":"<code>get_text_change_ends()</code>","text":"<p>Return all the text change-end. Search only the tags text:change-end. Consider using : get_text_changes()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the text change-end. Search only the tags\n    text:change-end.\n    Consider using : get_text_changes()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:change-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_start","title":"<code>get_text_change_start(position=0, idx=None)</code>","text":"<p>Return the text change-start that matches the criteria. Search only the tags text:change-start. Consider using : get_text_change()</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_start(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change-start that matches the criteria. Search\n    only the tags text:change-start.\n    Consider using : get_text_change()\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:change-start\", position, change_id=idx\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_starts","title":"<code>get_text_change_starts()</code>","text":"<p>Return all the text change-start. Search only for the tags text:change-start. Consider using : get_text_changes()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_starts(self) -&gt; list[Element]:\n    \"\"\"Return all the text change-start. Search only for the tags\n    text:change-start.\n    Consider using : get_text_changes()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:change-start\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_changes","title":"<code>get_text_changes()</code>","text":"<p>Return all the text changes, either single deletion (text:change) or start of range of changes (text:change-start).</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_changes(self) -&gt; list[Element]:\n    \"\"\"Return all the text changes, either single deletion\n    (text:change) or start of range of changes (text:change-start).\n\n    Return: list of Element\n    \"\"\"\n    request = \"descendant::text:change-start | descendant::text:change\"\n    return self._filtered_elements(request)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_toc","title":"<code>get_toc(position=0, content=None)</code>","text":"<p>Return the table of contents that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: odf_toc or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_toc(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the table of contents that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: odf_toc or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"text:table-of-content\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_tocs","title":"<code>get_tocs()</code>","text":"<p>Return all the tables of contents.</p> <p>Return: list of odf_toc</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_tocs(self) -&gt; list[Element]:\n    \"\"\"Return all the tables of contents.\n\n    Return: list of odf_toc\n    \"\"\"\n    return self.get_elements(\"text:table-of-content\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_tracked_changes","title":"<code>get_tracked_changes()</code>","text":"<p>Return the tracked-changes part in the text body.</p> <p>Return: Element or None</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_tracked_changes(self) -&gt; Element | None:\n    \"\"\"Return the tracked-changes part in the text body.\n\n    Return: Element or None\n    \"\"\"\n    return self.get_element(\"//text:tracked-changes\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_defined","title":"<code>get_user_defined(name, position=0)</code>","text":"<p>return the user defined declaration for the given name.</p> <p>return: Element or none if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_defined(self, name: str, position: int = 0) -&gt; Element | None:\n    \"\"\"return the user defined declaration for the given name.\n\n    return: Element or none if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:user-defined\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_defined_list","title":"<code>get_user_defined_list()</code>","text":"<p>Return all the user defined field declarations.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_defined_list(self) -&gt; list[Element]:\n    \"\"\"Return all the user defined field declarations.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:user-defined\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_defined_value","title":"<code>get_user_defined_value(name, value_type=None)</code>","text":"<p>Return the value of the given user defined field name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nvalue_type -- 'boolean', 'date', 'float',\n              'string', 'time' or automatic\n</code></pre> <p>Return: most appropriate Python type</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_defined_value(\n    self, name: str, value_type: str | None = None\n) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n    \"\"\"Return the value of the given user defined field name.\n\n    Arguments:\n\n        name -- str\n\n        value_type -- 'boolean', 'date', 'float',\n                      'string', 'time' or automatic\n\n    Return: most appropriate Python type\n    \"\"\"\n    user_defined = self.get_user_defined(name)\n    if user_defined is None:\n        return None\n    return user_defined.get_value(value_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_decl","title":"<code>get_user_field_decl(name, position=0)</code>","text":"<p>return the user field declaration for the given name.</p> <p>return: Element or none if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_decl(self, name: str, position: int = 0) -&gt; Element | None:\n    \"\"\"return the user field declaration for the given name.\n\n    return: Element or none if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:user-field-decl\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_decl_list","title":"<code>get_user_field_decl_list()</code>","text":"<p>Return all the user field declarations.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_decl_list(self) -&gt; list[Element]:\n    \"\"\"Return all the user field declarations.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:user-field-decl\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_decls","title":"<code>get_user_field_decls()</code>","text":"<p>Return the container for user field declarations. Created if not found.</p> <p>Return: Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_decls(self) -&gt; Element | None:\n    \"\"\"Return the container for user field declarations. Created if not\n    found.\n\n    Return: Element\n    \"\"\"\n    user_field_decls = self.get_element(\"//text:user-field-decls\")\n    if user_field_decls is None:\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Empty document.body\")\n        body.insert(Element.from_tag(\"text:user-field-decls\"), FIRST_CHILD)\n        user_field_decls = body.get_element(\"//text:user-field-decls\")\n\n    return user_field_decls\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_value","title":"<code>get_user_field_value(name, value_type=None)</code>","text":"<p>Return the value of the given user field name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nvalue_type -- 'boolean', 'currency', 'date', 'float',\n              'percentage', 'string', 'time' or automatic\n</code></pre> <p>Return: most appropriate Python type</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_value(\n    self, name: str, value_type: str | None = None\n) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n    \"\"\"Return the value of the given user field name.\n\n    Arguments:\n\n        name -- str\n\n        value_type -- 'boolean', 'currency', 'date', 'float',\n                      'percentage', 'string', 'time' or automatic\n\n    Return: most appropriate Python type\n    \"\"\"\n    user_field_decl = self.get_user_field_decl(name)\n    if user_field_decl is None:\n        return None\n    return user_field_decl.get_value(value_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_decl","title":"<code>get_variable_decl(name, position=0)</code>","text":"<p>return the variable declaration for the given name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nposition -- int\n</code></pre> <p>return: Element or none if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_decl(self, name: str, position: int = 0) -&gt; Element | None:\n    \"\"\"return the variable declaration for the given name.\n\n    Arguments:\n\n        name -- str\n\n        position -- int\n\n    return: Element or none if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:variable-decl\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_decl_list","title":"<code>get_variable_decl_list()</code>","text":"<p>Return all the variable declarations.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_decl_list(self) -&gt; list[Element]:\n    \"\"\"Return all the variable declarations.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:variable-decl\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_decls","title":"<code>get_variable_decls()</code>","text":"<p>Return the container for variable declarations. Created if not found.</p> <p>Return: Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_decls(self) -&gt; Element:\n    \"\"\"Return the container for variable declarations. Created if not\n    found.\n\n    Return: Element\n    \"\"\"\n    variable_decls = self.get_element(\"//text:variable-decls\")\n    if variable_decls is None:\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Empty document.body\")\n        body.insert(Element.from_tag(\"text:variable-decls\"), FIRST_CHILD)\n        variable_decls = body.get_element(\"//text:variable-decls\")\n\n    return variable_decls  # type:ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_set","title":"<code>get_variable_set(name, position=-1)</code>","text":"<p>Return the variable set for the given name (last one by default).</p> <p>Arguments:</p> <pre><code>name -- str\n\nposition -- int\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_set(self, name: str, position: int = -1) -&gt; Element | None:\n    \"\"\"Return the variable set for the given name (last one by default).\n\n    Arguments:\n\n        name -- str\n\n        position -- int\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:variable-set\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_set_value","title":"<code>get_variable_set_value(name, value_type=None)</code>","text":"<p>Return the last value of the given variable name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nvalue_type -- 'boolean', 'currency', 'date', 'float',\n              'percentage', 'string', 'time' or automatic\n</code></pre> <p>Return: most appropriate Python type</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_set_value(\n    self,\n    name: str,\n    value_type: str | None = None,\n) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n    \"\"\"Return the last value of the given variable name.\n\n    Arguments:\n\n        name -- str\n\n        value_type -- 'boolean', 'currency', 'date', 'float',\n                      'percentage', 'string', 'time' or automatic\n\n    Return: most appropriate Python type\n    \"\"\"\n    variable_set = self.get_variable_set(name)\n    if not variable_set:\n        return None\n    return variable_set.get_value(value_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_sets","title":"<code>get_variable_sets(name=None)</code>","text":"<p>Return all the variable sets that match the criteria.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_sets(self, name: str | None = None) -&gt; list[Element]:\n    \"\"\"Return all the variable sets that match the criteria.\n\n    Arguments:\n\n        name -- str\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:variable-set\", text_name=name)\n</code></pre>"},{"location":"reference.html#odfdo.Element.index","title":"<code>index(child)</code>","text":"<p>Return the position of the child in this element.</p> <p>Inspired by lxml</p> Source code in <code>odfdo/element.py</code> <pre><code>def index(self, child: Element) -&gt; int:\n    \"\"\"Return the position of the child in this element.\n\n    Inspired by lxml\n    \"\"\"\n    return self.__element.index(child.__element)\n</code></pre>"},{"location":"reference.html#odfdo.Element.insert","title":"<code>insert(element, xmlposition=None, position=None, start=False)</code>","text":"<p>Insert an element relatively to ourself.</p> <p>Insert either using DOM vocabulary or by numeric position. If text start is True, insert the element before any existing text.</p> <p>Position start at 0.</p> <p>Arguments:</p> <pre><code>element -- Element\n\nxmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING\n               or PREV_SIBLING\n\nstart -- Boolean\n\nposition -- int\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def insert(\n    self,\n    element: Element,\n    xmlposition: int | None = None,\n    position: int | None = None,\n    start: bool = False,\n) -&gt; None:\n    \"\"\"Insert an element relatively to ourself.\n\n    Insert either using DOM vocabulary or by numeric position.\n    If text start is True, insert the element before any existing text.\n\n    Position start at 0.\n\n    Arguments:\n\n        element -- Element\n\n        xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING\n                       or PREV_SIBLING\n\n        start -- Boolean\n\n        position -- int\n    \"\"\"\n    # child_tag = element.tag\n    current = self.__element\n    _element = element.__element\n    if start:\n        text = current.text\n        if text is not None:\n            current.text = None\n            tail = _element.tail\n            if tail is None:\n                tail = text\n            else:\n                tail = tail + text\n            _element.tail = tail\n        position = 0\n    if position is not None:\n        current.insert(position, _element)\n    elif xmlposition is FIRST_CHILD:\n        current.insert(0, _element)\n    elif xmlposition is LAST_CHILD:\n        current.append(_element)\n    elif xmlposition is NEXT_SIBLING:\n        parent = current.getparent()\n        index = parent.index(current)  # type: ignore\n        parent.insert(index + 1, _element)  # type: ignore\n    elif xmlposition is PREV_SIBLING:\n        parent = current.getparent()\n        index = parent.index(current)  # type: ignore\n        parent.insert(index, _element)  # type: ignore\n    else:\n        raise ValueError(\"(xml)position must be defined\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the element is empty : no text, no children, no tail.</p> <p>Return: Boolean</p> Source code in <code>odfdo/element.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the element is empty : no text, no children, no tail.\n\n    Return: Boolean\n    \"\"\"\n    element = self.__element\n    if element.tail is not None:\n        return False\n    if element.text is not None:\n        return False\n    if list(element.iterchildren()):\n        return False\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Element.match","title":"<code>match(pattern)</code>","text":"<p>return True if the pattern is found one or more times anywhere in the text content of the element.</p> <p>Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n</code></pre> <p>Return: bool</p> Source code in <code>odfdo/element.py</code> <pre><code>def match(self, pattern: str) -&gt; bool:\n    \"\"\"return True if the pattern is found one or more times anywhere in\n    the text content of the element.\n\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n    Return: bool\n    \"\"\"\n    return self.search(pattern) is not None\n</code></pre>"},{"location":"reference.html#odfdo.Element.replace","title":"<code>replace(pattern, new=None)</code>","text":"<p>Replace the pattern with the given text, or delete if text is an empty string, and return the number of replacements. By default, only return the number of occurences that would be replaced.</p> <p>It cannot replace patterns found across several element, like a word split into two consecutive spans.</p> <p>Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n\nnew -- str\n</code></pre> <p>Return: int</p> Source code in <code>odfdo/element.py</code> <pre><code>def replace(self, pattern: str, new: str | None = None) -&gt; int:\n    \"\"\"Replace the pattern with the given text, or delete if text is an\n    empty string, and return the number of replacements. By default, only\n    return the number of occurences that would be replaced.\n\n    It cannot replace patterns found across several element, like a word\n    split into two consecutive spans.\n\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n        new -- str\n\n    Return: int\n    \"\"\"\n    if not isinstance(pattern, str):\n        # Fail properly if the pattern is an non-ascii bytestring\n        pattern = str(pattern)\n    cpattern = re.compile(pattern)\n    count = 0\n    for text in self.xpath(\"descendant::text()\"):\n        if new is None:\n            count += len(cpattern.findall(str(text)))\n        else:\n            new_text, number = cpattern.subn(new, str(text))\n            container = text.parent\n            if text.is_text():  # type: ignore\n                container.text = new_text  # type: ignore\n            else:\n                container.tail = new_text  # type: ignore\n            count += number\n    return count\n</code></pre>"},{"location":"reference.html#odfdo.Element.replace_element","title":"<code>replace_element(old_element, new_element)</code>","text":"<p>Replaces in place a sub element with the element passed as second argument.</p> <p>Warning : no clone for old element.</p> Source code in <code>odfdo/element.py</code> <pre><code>def replace_element(self, old_element: Element, new_element: Element) -&gt; None:\n    \"\"\"Replaces in place a sub element with the element passed as second\n    argument.\n\n    Warning : no clone for old element.\n    \"\"\"\n    current = self.__element\n    current.replace(old_element.__element, new_element.__element)\n</code></pre>"},{"location":"reference.html#odfdo.Element.search","title":"<code>search(pattern)</code>","text":"<p>Return the first position of the pattern in the text content of the element, or None if not found.</p> <p>Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n</code></pre> <p>Return: int or None</p> Source code in <code>odfdo/element.py</code> <pre><code>def search(self, pattern: str) -&gt; int | None:\n    \"\"\"Return the first position of the pattern in the text content of\n    the element, or None if not found.\n\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n    Return: int or None\n    \"\"\"\n    match = re.search(pattern, self.text_recursive)\n    if match is None:\n        return None\n    return match.start()\n</code></pre>"},{"location":"reference.html#odfdo.Element.serialize","title":"<code>serialize(pretty=False, with_ns=False)</code>","text":"<p>Return text serialization of XML element.</p> Source code in <code>odfdo/element.py</code> <pre><code>def serialize(self, pretty: bool = False, with_ns: bool = False) -&gt; str:\n    \"\"\"Return text serialization of XML element.\"\"\"\n    # This copy bypasses serialization side-effects in lxml\n    native = deepcopy(self.__element)\n    data = tostring(\n        native, with_tail=False, pretty_print=pretty, encoding=\"unicode\"\n    )\n    if with_ns:\n        return data\n    # Remove namespaces\n    return self._strip_namespaces(data)\n</code></pre>"},{"location":"reference.html#odfdo.Element.set_style_attribute","title":"<code>set_style_attribute(name, value)</code>","text":"<p>Shortcut to accept a style object as a value.</p> Source code in <code>odfdo/element.py</code> <pre><code>def set_style_attribute(self, name: str, value: Element | str) -&gt; None:\n    \"\"\"Shortcut to accept a style object as a value.\"\"\"\n    if isinstance(value, Element):\n        value = str(value.name)  # type:ignore\n    return self.set_attribute(name, value)\n</code></pre>"},{"location":"reference.html#odfdo.Element.strip_elements","title":"<code>strip_elements(sub_elements)</code>","text":"<p>Remove the tags of provided elements, keeping inner childs and text.</p> <p>Return : the striped element.</p> <p>Warning : no clone in sub_elements list.</p> <p>Arguments:</p> <pre><code>sub_elements -- Element or list of Element\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def strip_elements(\n    self,\n    sub_elements: Element | Iterable[Element],\n) -&gt; Element | list:\n    \"\"\"Remove the tags of provided elements, keeping inner childs and text.\n\n    Return : the striped element.\n\n    Warning : no clone in sub_elements list.\n\n    Arguments:\n\n        sub_elements -- Element or list of Element\n    \"\"\"\n    if not sub_elements:\n        return self\n    if isinstance(sub_elements, Element):\n        sub_elements = (sub_elements,)\n    replacer = _get_lxml_tag(\"text:this-will-be-removed\")\n    for element in sub_elements:\n        element.__element.tag = replacer\n    strip = (\"text:this-will-be-removed\",)\n    return self.strip_tags(strip=strip, default=None)\n</code></pre>"},{"location":"reference.html#odfdo.Element.strip_tags","title":"<code>strip_tags(strip=None, protect=None, default='text:p')</code>","text":"<p>Remove the tags listed in strip, recursively, keeping inner childs and text. Tags listed in protect stop the removal one level depth. If the first level element is stripped, default is used to embed the content in the default element. If default is None and first level is striped, a list of text and children is returned. Return : the striped element.</p> <p>strip_tags should be used by on purpose methods (strip_span \u2026) (Method name taken from lxml).</p> <p>Arguments:</p> <pre><code>strip -- iterable list of str odf tags, or None\n\nprotect -- iterable list of str odf tags, or None\n\ndefault -- str odf tag, or None\n</code></pre> <p>Return:</p> <pre><code>Element.\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def strip_tags(\n    self,\n    strip: Iterable[str] | None = None,\n    protect: Iterable[str] | None = None,\n    default: str | None = \"text:p\",\n) -&gt; Element | list:\n    \"\"\"Remove the tags listed in strip, recursively, keeping inner childs\n    and text. Tags listed in protect stop the removal one level depth. If\n    the first level element is stripped, default is used to embed the\n    content in the default element. If default is None and first level is\n    striped, a list of text and children is returned. Return : the striped\n    element.\n\n    strip_tags should be used by on purpose methods (strip_span ...)\n    (Method name taken from lxml).\n\n    Arguments:\n\n        strip -- iterable list of str odf tags, or None\n\n        protect -- iterable list of str odf tags, or None\n\n        default -- str odf tag, or None\n\n    Return:\n\n        Element.\n    \"\"\"\n    if not strip:\n        return self\n    if not protect:\n        protect = ()\n    protected = False\n    element, modified = Element._strip_tags(self, strip, protect, protected)\n    if modified and isinstance(element, list) and default:\n        new = Element.from_tag(default)\n        for content in element:\n            if isinstance(content, Element):\n                new.append(content)\n            else:\n                new.text = content\n        element = new\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Element.xpath","title":"<code>xpath(xpath_query)</code>","text":"<p>Apply XPath query to the element and its subtree. Return list of Element or EText instances translated from the nodes found.</p> Source code in <code>odfdo/element.py</code> <pre><code>def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n    \"\"\"Apply XPath query to the element and its subtree. Return list of\n    Element or EText instances translated from the nodes found.\n    \"\"\"\n    element = self.__element\n    xpath_instance = xpath_compile(xpath_query)\n    elements = xpath_instance(element)\n    result: list[Element | EText] = []\n    if hasattr(elements, \"__iter__\"):\n        for obj in elements:  # type: ignore\n            if isinstance(obj, (str, bytes)):\n                result.append(EText(obj))\n            elif isinstance(obj, _Element):\n                result.append(Element.from_tag(obj))\n            # else:\n            #     result.append(obj)\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.ElementTyped","title":"<code>ElementTyped</code>","text":"<p>             Bases: <code>Element</code></p> Source code in <code>odfdo/element_typed.py</code> <pre><code>class ElementTyped(Element):\n    def set_value_and_type(  # noqa: C901\n        self,\n        value: Any,\n        value_type: str | None = None,\n        text: str | None = None,\n        currency: str | None = None,\n    ) -&gt; str | None:\n        # Remove possible previous value and type\n        for name in (\n            \"office:value-type\",\n            \"office:boolean-value\",\n            \"office:value\",\n            \"office:date-value\",\n            \"office:string-value\",\n            \"office:time-value\",\n            \"table:formula\",\n            \"office:currency\",\n            \"calcext:value-type\",\n            \"loext:value-type\",\n        ):\n            with contextlib.suppress(KeyError):\n                self.del_attribute(name)\n        if isinstance(value, bytes):\n            value = bytes_to_str(value)\n        if isinstance(value_type, bytes):\n            value_type = bytes_to_str(value_type)\n        if isinstance(text, bytes):\n            text = bytes_to_str(text)\n        if isinstance(currency, bytes):\n            currency = bytes_to_str(currency)\n        if value is None:\n            self._erase_text_content()\n            return text\n        if isinstance(value, bool):\n            if value_type is None:\n                value_type = \"boolean\"\n            if text is None:\n                text = \"true\" if value else \"false\"\n            value = Boolean.encode(value)\n        elif isinstance(value, (int, float, Decimal)):\n            if value_type == \"percentage\":\n                text = \"%d %%\" % int(value * 100)\n            if value_type is None:\n                value_type = \"float\"\n            if text is None:\n                text = str(value)\n            value = str(value)\n        elif isinstance(value, datetime):\n            if value_type is None:\n                value_type = \"date\"\n            if text is None:\n                text = str(DateTime.encode(value))\n            value = DateTime.encode(value)\n        elif isinstance(value, date):\n            if value_type is None:\n                value_type = \"date\"\n            if text is None:\n                text = str(Date.encode(value))\n            value = Date.encode(value)\n        elif isinstance(value, str):\n            if value_type is None:\n                value_type = \"string\"\n            if text is None:\n                text = value\n        elif isinstance(value, timedelta):\n            if value_type is None:\n                value_type = \"time\"\n            if text is None:\n                text = str(Duration.encode(value))\n            value = Duration.encode(value)\n        elif value is not None:\n            raise TypeError(f\"Type unknown: '{value!r}'\")\n\n        if value_type is not None:\n            self.set_attribute(\"office:value-type\", value_type)\n            self.set_attribute(\"calcext:value-type\", value_type)\n        if value_type == \"boolean\":\n            self.set_attribute(\"office:boolean-value\", value)\n        elif value_type == \"currency\":\n            self.set_attribute(\"office:value\", value)\n            self.set_attribute(\"office:currency\", currency)\n        elif value_type == \"date\":\n            self.set_attribute(\"office:date-value\", value)\n        elif value_type in (\"float\", \"percentage\"):\n            self.set_attribute(\"office:value\", value)\n            self.set_attribute(\"calcext:value\", value)\n        elif value_type == \"string\":\n            self.set_attribute(\"office:string-value\", value)\n        elif value_type == \"time\":\n            self.set_attribute(\"office:time-value\", value)\n\n        return text\n\n    def _get_typed_value(  # noqa: C901\n        self,\n        value_type: str | None = None,\n        try_get_text: bool = True,\n    ) -&gt; tuple[Any, str | None]:\n        \"\"\"Return Python typed value.\n\n        Only for \"with office:value-type\" elements, not for meta fields.\"\"\"\n        value: Decimal | str | bool | None = None\n        if value_type is None:\n            read_value_type = self.get_attribute(\"office:value-type\")\n            if isinstance(read_value_type, bool):\n                raise TypeError(\n                    f'Wrong type for \"office:value-type\": {type(read_value_type)}'\n                )\n            value_type = read_value_type\n        # value_type = to_str(value_type)\n        if value_type == \"boolean\":\n            value = self.get_attribute(\"office:boolean-value\")\n            return (value, value_type)\n        if value_type in {\"float\", \"percentage\", \"currency\"}:\n            read_number = self.get_attribute(\"office:value\")\n            if not isinstance(read_number, (Decimal, str)):\n                raise TypeError(f'Wrong type for \"office:value\": {type(read_number)}')\n            value = Decimal(read_number)\n            # Return 3 instead of 3.0 if possible\n            with contextlib.suppress(ValueError):\n                if int(value) == value:\n                    return (int(value), value_type)\n            return (value, value_type)\n        if value_type == \"date\":\n            read_attribute = self.get_attribute(\"office:date-value\")\n            if not isinstance(read_attribute, str):\n                raise TypeError(\n                    f'Wrong type for \"office:date-value\": {type(read_attribute)}'\n                )\n            if \"T\" in read_attribute:\n                return (DateTime.decode(read_attribute), value_type)\n            return (Date.decode(read_attribute), value_type)\n        if value_type == \"string\":\n            value = self.get_attribute(\"office:string-value\")\n            if value is not None:\n                return (str(value), value_type)\n            if try_get_text:\n                list_value = [\n                    para.text_recursive for para in self.get_elements(\"text:p\")\n                ]\n                if list_value:\n                    return (\"\\n\".join(list_value), value_type)\n            return (None, value_type)\n        if value_type == \"time\":\n            read_value = self.get_attribute(\"office:time-value\")\n            if not isinstance(read_value, str):\n                raise TypeError(\n                    f'Wrong type for \"office:time-value\": {type(read_value)}'\n                )\n            time_value = Duration.decode(read_value)\n            return (time_value, value_type)\n        if value_type is None:\n            return (None, None)\n        raise ValueError(f'Unexpected value type: \"{value_type}\"')\n\n    def get_value(\n        self,\n        value_type: str | None = None,\n        try_get_text: bool = True,\n        get_type: bool = False,\n    ) -&gt; Any | tuple[Any, str]:\n        \"\"\"Return Python typed value.\n\n        Only for \"with office:value-type\" elements, not for meta fields.\"\"\"\n        if get_type:\n            return self._get_typed_value(\n                value_type=value_type,\n                try_get_text=try_get_text,\n            )\n        return self._get_typed_value(\n            value_type=value_type,\n            try_get_text=try_get_text,\n        )[0]\n</code></pre>"},{"location":"reference.html#odfdo.ElementTyped.get_value","title":"<code>get_value(value_type=None, try_get_text=True, get_type=False)</code>","text":"<p>Return Python typed value.</p> <p>Only for \u201cwith office:value-type\u201d elements, not for meta fields.</p> Source code in <code>odfdo/element_typed.py</code> <pre><code>def get_value(\n    self,\n    value_type: str | None = None,\n    try_get_text: bool = True,\n    get_type: bool = False,\n) -&gt; Any | tuple[Any, str]:\n    \"\"\"Return Python typed value.\n\n    Only for \"with office:value-type\" elements, not for meta fields.\"\"\"\n    if get_type:\n        return self._get_typed_value(\n            value_type=value_type,\n            try_get_text=try_get_text,\n        )\n    return self._get_typed_value(\n        value_type=value_type,\n        try_get_text=try_get_text,\n    )[0]\n</code></pre>"},{"location":"reference.html#odfdo.EllipseShape","title":"<code>EllipseShape</code>","text":"<p>             Bases: <code>ShapeBase</code></p> <p>Create a ellipse shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\nposition -- (str, str)\n\nsize -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class EllipseShape(ShapeBase):\n    \"\"\"Create a ellipse shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        position -- (str, str)\n\n        size -- (str, str)\n\n    \"\"\"\n\n    _tag = \"draw:ellipse\"\n    _properties: tuple[PropDef, ...] = ()\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        position: tuple | None = None,\n        size: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n                \"size\": size,\n                \"position\": position,\n            }\n        )\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference.html#odfdo.Frame","title":"<code>Frame</code>","text":"<p>             Bases: <code>Element</code>, <code>AnchorMix</code>, <code>PosMix</code>, <code>ZMix</code>, <code>SizeMix</code></p> <p>ODF Frame \u201cdraw:frame\u201d</p> <p>Frames are not useful by themselves. You should consider calling Frame.image_frame() or Frame.text_frame directly.</p> Source code in <code>odfdo/frame.py</code> <pre><code>class Frame(Element, AnchorMix, PosMix, ZMix, SizeMix):\n    \"\"\"ODF Frame \"draw:frame\"\n\n    Frames are not useful by themselves. You should consider calling\n    Frame.image_frame() or Frame.text_frame directly.\n    \"\"\"\n\n    _tag = \"draw:frame\"\n    _properties = (\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"draw_id\", \"draw:id\"),\n        PropDef(\"width\", \"svg:width\"),\n        PropDef(\"height\", \"svg:height\"),\n        PropDef(\"style\", \"draw:style-name\"),\n        PropDef(\"pos_x\", \"svg:x\"),\n        PropDef(\"pos_y\", \"svg:y\"),\n        PropDef(\"presentation_class\", \"presentation:class\"),\n        PropDef(\"layer\", \"draw:layer\"),\n        PropDef(\"presentation_style\", \"presentation:style-name\"),\n    )\n\n    def __init__(  # noqa:  C901\n        self,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        size: tuple = (\"1cm\", \"1cm\"),\n        z_index: int = 0,\n        presentation_class: str | None = None,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        layer: str | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a frame element of the given size. Position is relative to the\n        context the frame is inserted in. If positioned by page, give the page\n        number and the x, y position.\n\n        Size is a (width, height) tuple and position is a (left, top) tuple; items\n        are strings including the unit, e.g. ('10cm', '15cm').\n\n        Frames are not useful by themselves. You should consider calling:\n            Frame.image_frame()\n        or\n            Frame.text_frame()\n\n\n        Arguments:\n\n            name -- str\n\n            draw_id -- str\n\n            style -- str\n\n            position -- (str, str)\n\n            size -- (str, str)\n\n            z_index -- int (default 0)\n\n            presentation_class -- str\n\n            anchor_type -- 'page', 'frame', 'paragraph', 'char' or 'as-char'\n\n            anchor_page -- int, page number is anchor_type is 'page'\n\n            layer -- str\n\n            presentation_style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.size = size\n            self.z_index = z_index\n            if name:\n                self.name = name\n            if draw_id is not None:\n                self.draw_id = draw_id\n            if style is not None:\n                self.style = style\n            if position is not None:\n                self.position = position\n            if presentation_class is not None:\n                self.presentation_class = presentation_class\n            if anchor_type:\n                self.anchor_type = anchor_type\n            if position and not anchor_type:\n                self.anchor_type = \"paragraph\"\n            if anchor_page is not None:\n                self.anchor_page = anchor_page\n            if layer is not None:\n                self.layer = layer\n            if presentation_style is not None:\n                self.presentation_style = presentation_style\n\n    @classmethod\n    def image_frame(\n        cls,\n        image: Element | str,\n        text: str | None = None,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        size: tuple = (\"1cm\", \"1cm\"),\n        z_index: int = 0,\n        presentation_class: str | None = None,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        layer: str | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Element:\n        \"\"\"Create a ready-to-use image, since image must be embedded in a\n        frame.\n\n        The optionnal text will appear above the image.\n\n        Arguments:\n\n            image -- DrawImage or str, DrawImage element or URL of the image\n\n            text -- str, text for the image\n\n            See Frame() initialization for the other arguments\n\n        Return: Frame\n        \"\"\"\n        frame = cls(\n            name=name,\n            draw_id=draw_id,\n            style=style,\n            position=position,\n            size=size,\n            z_index=z_index,\n            presentation_class=presentation_class,\n            anchor_type=anchor_type,\n            anchor_page=anchor_page,\n            layer=layer,\n            presentation_style=presentation_style,\n            **kwargs,\n        )\n        image_element = frame.set_image(image)\n        if text:\n            image_element.text_content = text\n        return frame\n\n    @classmethod\n    def text_frame(\n        cls,\n        text_or_element: Iterable[Element] | Element | str,\n        text_style: str | None = None,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        size: tuple = (\"1cm\", \"1cm\"),\n        z_index: int = 0,\n        presentation_class: str | None = None,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        layer: str | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Element:\n        \"\"\"Create a ready-to-use text box, since text box must be embedded in\n        a frame.\n\n        The optionnal text will appear above the image.\n\n        Arguments:\n\n            text_or_element -- str or Element, or list of them, text content\n                               of the text box.\n\n            text_style -- str, name of the style for the text\n\n            See Frame() initialization for the other arguments\n\n        Return: Frame\n        \"\"\"\n        frame = cls(\n            name=name,\n            draw_id=draw_id,\n            style=style,\n            position=position,\n            size=size,\n            z_index=z_index,\n            presentation_class=presentation_class,\n            anchor_type=anchor_type,\n            anchor_page=anchor_page,\n            layer=layer,\n            presentation_style=presentation_style,\n            **kwargs,\n        )\n        frame.set_text_box(text_or_element, text_style)\n        return frame\n\n    @property\n    def text_content(self) -&gt; str:\n        text_box = self.get_element(\"draw:text-box\")\n        if text_box is None:\n            return \"\"\n        return text_box.text_content\n\n    @text_content.setter\n    def text_content(self, text_or_element: Element | str) -&gt; None:\n        text_box = self.get_element(\"draw:text-box\")\n        if text_box is None:\n            text_box = Element.from_tag(\"draw:text-box\")\n            self.append(text_box)\n        if isinstance(text_or_element, Element):\n            text_box.clear()\n            text_box.append(text_or_element)\n        else:\n            text_box.text_content = text_or_element\n\n    def get_image(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        return self.get_element(\"draw:image\")\n\n    def set_image(self, url_or_element: Element | str) -&gt; Element:\n        image = self.get_image()\n        if image is None:\n            if isinstance(url_or_element, Element):\n                image = url_or_element\n                self.append(image)\n            else:\n                image = DrawImage(url_or_element)\n                self.append(image)\n        else:\n            if isinstance(url_or_element, Element):\n                image.delete()\n                image = url_or_element\n                self.append(image)\n            else:\n                image.set_url(url_or_element)  # type: ignore\n        return image\n\n    def get_text_box(self) -&gt; Element | None:\n        return self.get_element(\"draw:text-box\")\n\n    def set_text_box(\n        self,\n        text_or_element: Iterable[Element | str] | Element | str,\n        text_style: str | None = None,\n    ) -&gt; Element:\n        text_box = self.get_text_box()\n        if text_box is None:\n            text_box = Element.from_tag(\"draw:text-box\")\n            self.append(text_box)\n        else:\n            text_box.clear()\n        if isinstance(text_or_element, (Element, str)):\n            text_or_element_list: Iterable[Element | str] = [text_or_element]\n        else:\n            text_or_element_list = text_or_element\n        for item in text_or_element_list:\n            if isinstance(item, str):\n                text_box.append(Paragraph(item, style=text_style))\n            else:\n                text_box.append(item)\n        return text_box\n\n    @staticmethod\n    def _get_formatted_text_subresult(context: dict, element: Element) -&gt; str:\n        str_list = [\"  \"]\n        for child in element.children:\n            str_list.append(child.get_formatted_text(context))\n        subresult = \"\".join(str_list)\n        subresult = subresult.replace(\"\\n\", \"\\n  \")\n        return subresult.rstrip(\" \")\n\n    def get_formatted_text(  # noqa:  C901\n        self,\n        context: dict | None = None,\n    ) -&gt; str:\n        if not context:\n            context = {}\n        result = []\n        for element in self.children:\n            tag = element.tag\n            if tag == \"draw:image\":\n                if context[\"rst_mode\"]:\n                    filename = element.get_attribute(\"xlink:href\")\n\n                    # Compute width and height\n                    width, height = self.size\n                    if width is not None:\n                        width = Unit(width)\n                        width = width.convert(\"px\", DPI)\n                    if height is not None:\n                        height = Unit(height)\n                        height = height.convert(\"px\", DPI)\n\n                    # Insert or not ?\n                    if context[\"no_img_level\"]:\n                        context[\"img_counter\"] += 1\n                        ref = f\"|img{context['img_counter']}|\"\n                        result.append(ref)\n                        context[\"images\"].append((ref, filename, (width, height)))\n                    else:\n                        result.append(f\"\\n.. image:: {filename}\\n\")\n                        if width is not None:\n                            result.append(f\"   :width: {width}\\n\")\n                        if height is not None:\n                            result.append(f\"   :height: {height}\\n\")\n                else:\n                    result.append(f\"[Image {element.get_attribute('xlink:href')}]\\n\")\n            elif tag == \"draw:text-box\":\n                result.append(self._get_formatted_text_subresult(context, element))\n            else:\n                result.append(element.get_formatted_text(context))\n        result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Frame.__init__","title":"<code>__init__(name=None, draw_id=None, style=None, position=None, size=('1cm', '1cm'), z_index=0, presentation_class=None, anchor_type=None, anchor_page=None, layer=None, presentation_style=None, **kwargs)</code>","text":"<p>Create a frame element of the given size. Position is relative to the context the frame is inserted in. If positioned by page, give the page number and the x, y position.</p> <p>Size is a (width, height) tuple and position is a (left, top) tuple; items are strings including the unit, e.g. (\u201810cm\u2019, \u201815cm\u2019).</p> <p>Frames are not useful by themselves. You should consider calling:     Frame.image_frame() or     Frame.text_frame()</p> <p>Arguments:</p> <pre><code>name -- str\n\ndraw_id -- str\n\nstyle -- str\n\nposition -- (str, str)\n\nsize -- (str, str)\n\nz_index -- int (default 0)\n\npresentation_class -- str\n\nanchor_type -- 'page', 'frame', 'paragraph', 'char' or 'as-char'\n\nanchor_page -- int, page number is anchor_type is 'page'\n\nlayer -- str\n\npresentation_style -- str\n</code></pre> Source code in <code>odfdo/frame.py</code> <pre><code>def __init__(  # noqa:  C901\n    self,\n    name: str | None = None,\n    draw_id: str | None = None,\n    style: str | None = None,\n    position: tuple | None = None,\n    size: tuple = (\"1cm\", \"1cm\"),\n    z_index: int = 0,\n    presentation_class: str | None = None,\n    anchor_type: str | None = None,\n    anchor_page: int | None = None,\n    layer: str | None = None,\n    presentation_style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a frame element of the given size. Position is relative to the\n    context the frame is inserted in. If positioned by page, give the page\n    number and the x, y position.\n\n    Size is a (width, height) tuple and position is a (left, top) tuple; items\n    are strings including the unit, e.g. ('10cm', '15cm').\n\n    Frames are not useful by themselves. You should consider calling:\n        Frame.image_frame()\n    or\n        Frame.text_frame()\n\n\n    Arguments:\n\n        name -- str\n\n        draw_id -- str\n\n        style -- str\n\n        position -- (str, str)\n\n        size -- (str, str)\n\n        z_index -- int (default 0)\n\n        presentation_class -- str\n\n        anchor_type -- 'page', 'frame', 'paragraph', 'char' or 'as-char'\n\n        anchor_page -- int, page number is anchor_type is 'page'\n\n        layer -- str\n\n        presentation_style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.size = size\n        self.z_index = z_index\n        if name:\n            self.name = name\n        if draw_id is not None:\n            self.draw_id = draw_id\n        if style is not None:\n            self.style = style\n        if position is not None:\n            self.position = position\n        if presentation_class is not None:\n            self.presentation_class = presentation_class\n        if anchor_type:\n            self.anchor_type = anchor_type\n        if position and not anchor_type:\n            self.anchor_type = \"paragraph\"\n        if anchor_page is not None:\n            self.anchor_page = anchor_page\n        if layer is not None:\n            self.layer = layer\n        if presentation_style is not None:\n            self.presentation_style = presentation_style\n</code></pre>"},{"location":"reference.html#odfdo.Frame.image_frame","title":"<code>image_frame(image, text=None, name=None, draw_id=None, style=None, position=None, size=('1cm', '1cm'), z_index=0, presentation_class=None, anchor_type=None, anchor_page=None, layer=None, presentation_style=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ready-to-use image, since image must be embedded in a frame.</p> <p>The optionnal text will appear above the image.</p> <p>Arguments:</p> <pre><code>image -- DrawImage or str, DrawImage element or URL of the image\n\ntext -- str, text for the image\n\nSee Frame() initialization for the other arguments\n</code></pre> <p>Return: Frame</p> Source code in <code>odfdo/frame.py</code> <pre><code>@classmethod\ndef image_frame(\n    cls,\n    image: Element | str,\n    text: str | None = None,\n    name: str | None = None,\n    draw_id: str | None = None,\n    style: str | None = None,\n    position: tuple | None = None,\n    size: tuple = (\"1cm\", \"1cm\"),\n    z_index: int = 0,\n    presentation_class: str | None = None,\n    anchor_type: str | None = None,\n    anchor_page: int | None = None,\n    layer: str | None = None,\n    presentation_style: str | None = None,\n    **kwargs: Any,\n) -&gt; Element:\n    \"\"\"Create a ready-to-use image, since image must be embedded in a\n    frame.\n\n    The optionnal text will appear above the image.\n\n    Arguments:\n\n        image -- DrawImage or str, DrawImage element or URL of the image\n\n        text -- str, text for the image\n\n        See Frame() initialization for the other arguments\n\n    Return: Frame\n    \"\"\"\n    frame = cls(\n        name=name,\n        draw_id=draw_id,\n        style=style,\n        position=position,\n        size=size,\n        z_index=z_index,\n        presentation_class=presentation_class,\n        anchor_type=anchor_type,\n        anchor_page=anchor_page,\n        layer=layer,\n        presentation_style=presentation_style,\n        **kwargs,\n    )\n    image_element = frame.set_image(image)\n    if text:\n        image_element.text_content = text\n    return frame\n</code></pre>"},{"location":"reference.html#odfdo.Frame.text_frame","title":"<code>text_frame(text_or_element, text_style=None, name=None, draw_id=None, style=None, position=None, size=('1cm', '1cm'), z_index=0, presentation_class=None, anchor_type=None, anchor_page=None, layer=None, presentation_style=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ready-to-use text box, since text box must be embedded in a frame.</p> <p>The optionnal text will appear above the image.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or Element, or list of them, text content\n                   of the text box.\n\ntext_style -- str, name of the style for the text\n\nSee Frame() initialization for the other arguments\n</code></pre> <p>Return: Frame</p> Source code in <code>odfdo/frame.py</code> <pre><code>@classmethod\ndef text_frame(\n    cls,\n    text_or_element: Iterable[Element] | Element | str,\n    text_style: str | None = None,\n    name: str | None = None,\n    draw_id: str | None = None,\n    style: str | None = None,\n    position: tuple | None = None,\n    size: tuple = (\"1cm\", \"1cm\"),\n    z_index: int = 0,\n    presentation_class: str | None = None,\n    anchor_type: str | None = None,\n    anchor_page: int | None = None,\n    layer: str | None = None,\n    presentation_style: str | None = None,\n    **kwargs: Any,\n) -&gt; Element:\n    \"\"\"Create a ready-to-use text box, since text box must be embedded in\n    a frame.\n\n    The optionnal text will appear above the image.\n\n    Arguments:\n\n        text_or_element -- str or Element, or list of them, text content\n                           of the text box.\n\n        text_style -- str, name of the style for the text\n\n        See Frame() initialization for the other arguments\n\n    Return: Frame\n    \"\"\"\n    frame = cls(\n        name=name,\n        draw_id=draw_id,\n        style=style,\n        position=position,\n        size=size,\n        z_index=z_index,\n        presentation_class=presentation_class,\n        anchor_type=anchor_type,\n        anchor_page=anchor_page,\n        layer=layer,\n        presentation_style=presentation_style,\n        **kwargs,\n    )\n    frame.set_text_box(text_or_element, text_style)\n    return frame\n</code></pre>"},{"location":"reference.html#odfdo.Header","title":"<code>Header</code>","text":"<p>             Bases: <code>Paragraph</code></p> <p>Specialised paragraph for headings \u201ctext:h\u201d.</p> Source code in <code>odfdo/header.py</code> <pre><code>class Header(Paragraph):\n    \"\"\"Specialised paragraph for headings \"text:h\".\"\"\"\n\n    _tag = \"text:h\"\n    _properties = (\n        PropDef(\"level\", \"text:outline-level\"),\n        PropDef(\"restart_numbering\", \"text:restart-numbering\"),\n        PropDef(\"start_value\", \"text:start-value\"),\n        PropDef(\"suppress_numbering\", \"text:suppress-numbering\"),\n    )\n\n    def __init__(\n        self,\n        level: int = 1,\n        text: str | None = None,\n        restart_numbering: bool = False,\n        start_value: int | None = None,\n        suppress_numbering: bool = False,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a header element of the given style and level, containing the\n        optional given text.\n\n        Level count begins at 1.\n\n        Arguments:\n\n            level -- int\n\n            text -- str\n\n            restart_numbering -- bool\n\n            start_value -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.level = int(level)\n            if text:\n                self.text = text\n            if restart_numbering:\n                self.restart_numbering = True\n            if start_value is not None:\n                self.start_value = start_value\n            if suppress_numbering:\n                self.suppress_numbering = True\n            if style:\n                self.style = style\n\n    def get_formatted_text(\n        self,\n        context: dict | None = None,\n        simple: bool = False,\n    ) -&gt; str:\n        if not context:\n            context = {\n                \"document\": None,\n                \"footnotes\": [],\n                \"endnotes\": [],\n                \"annotations\": [],\n                \"rst_mode\": False,\n                \"img_counter\": 0,\n                \"images\": [],\n                \"no_img_level\": 0,\n            }\n        context[\"no_img_level\"] += 1\n        title = super().get_formatted_text(context)\n        context[\"no_img_level\"] -= 1\n        title = title.strip()\n        title = sub(r\"\\s+\", \" \", title)\n\n        # No rst_mode ?\n        if not context[\"rst_mode\"]:\n            return title\n        # If here in rst_mode!\n\n        # Get the level, max 5!\n        LEVEL_STYLES = \"#=-~`+^\u00b0'.\"\n        level = int(self.level)\n        if level &gt; len(LEVEL_STYLES):\n            raise ValueError(\"Too many levels of heading\")\n\n        # And return the result\n        result = [\"\\n\", title, \"\\n\", LEVEL_STYLES[level - 1] * len(title), \"\\n\"]\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Header.__init__","title":"<code>__init__(level=1, text=None, restart_numbering=False, start_value=None, suppress_numbering=False, style=None, **kwargs)</code>","text":"<p>Create a header element of the given style and level, containing the optional given text.</p> <p>Level count begins at 1.</p> <p>Arguments:</p> <pre><code>level -- int\n\ntext -- str\n\nrestart_numbering -- bool\n\nstart_value -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/header.py</code> <pre><code>def __init__(\n    self,\n    level: int = 1,\n    text: str | None = None,\n    restart_numbering: bool = False,\n    start_value: int | None = None,\n    suppress_numbering: bool = False,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a header element of the given style and level, containing the\n    optional given text.\n\n    Level count begins at 1.\n\n    Arguments:\n\n        level -- int\n\n        text -- str\n\n        restart_numbering -- bool\n\n        start_value -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.level = int(level)\n        if text:\n            self.text = text\n        if restart_numbering:\n            self.restart_numbering = True\n        if start_value is not None:\n            self.start_value = start_value\n        if suppress_numbering:\n            self.suppress_numbering = True\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Image","title":"<code>Image</code>","text":"<p>             Bases: <code>Body</code></p> <p>Image, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Image(Body):\n    \"\"\"Image, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:image\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.IndexTitle","title":"<code>IndexTitle</code>","text":"<p>             Bases: <code>Element</code></p> <p>The \u201ctext:index-title\u201d element contains the title of an index.</p> <p>The element has the following attributes: text:name, text:protected, text:protection-key, text:protection-key-digest-algorithm, text:style-name, xml:id.</p> <p>The actual title is stored in a child element</p> Source code in <code>odfdo/toc.py</code> <pre><code>class IndexTitle(Element):\n    \"\"\"The \"text:index-title\" element contains the title of an index.\n\n    The element has the following attributes:\n    text:name, text:protected, text:protection-key,\n    text:protection-key-digest-algorithm, text:style-name, xml:id.\n\n    The actual title is stored in a child element\n    \"\"\"\n\n    _tag = \"text:index-title\"\n    _properties = (\n        PropDef(\"name\", \"text:name\"),\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"xml_id\", \"xml:id\"),\n        PropDef(\"protected\", \"text:protected\"),\n        PropDef(\"protection_key\", \"text:protection-key\"),\n        PropDef(\n            \"protection_key_digest_algorithm\", \"text:protection-key-digest-algorithm\"\n        ),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        style: str | None = None,\n        title_text: str | None = None,\n        title_text_style: str | None = None,\n        xml_id: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if name:\n                self.name = name\n            if style:\n                self.style = style\n            if xml_id:\n                self.xml_id = xml_id\n            if title_text:\n                self.set_title_text(title_text, title_text_style)\n\n    def set_title_text(\n        self,\n        title_text: str,\n        title_text_style: str | None = None,\n    ) -&gt; None:\n        title = Paragraph(title_text, style=title_text_style)\n        self.append(title)\n</code></pre>"},{"location":"reference.html#odfdo.IndexTitleTemplate","title":"<code>IndexTitleTemplate</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF \u201ctext:index-title-template\u201d</p> <p>Arguments:</p> <pre><code>style -- str\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>class IndexTitleTemplate(Element):\n    \"\"\"ODF \"text:index-title-template\"\n\n    Arguments:\n\n        style -- str\n    \"\"\"\n\n    _tag = \"text:index-title-template\"\n    _properties = (PropDef(\"style\", \"text:style-name\"),)\n\n    def __init__(self, style: str | None = None, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init and style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.LineBreak","title":"<code>LineBreak</code>","text":"<p>             Bases: <code>Element</code></p> <p>This element represents a line break \u201ctext:line-break\u201d</p> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>class LineBreak(Element):\n    \"\"\"This element represents a line break \"text:line-break\" \"\"\"\n\n    _tag = \"text:line-break\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference.html#odfdo.LineShape","title":"<code>LineShape</code>","text":"<p>             Bases: <code>ShapeBase</code></p> <p>Create a line shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\np1 -- (str, str)\n\np2 -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class LineShape(ShapeBase):\n    \"\"\"Create a line shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        p1 -- (str, str)\n\n        p2 -- (str, str)\n    \"\"\"\n\n    _tag = \"draw:line\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"x1\", \"svg:x1\"),\n        PropDef(\"y1\", \"svg:y1\"),\n        PropDef(\"x2\", \"svg:x2\"),\n        PropDef(\"y2\", \"svg:y2\"),\n    )\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        p1: tuple | None = None,\n        p2: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n            }\n        )\n        super().__init__(**kwargs)\n        if self._do_init:\n            if p1:\n                self.x1 = p1[0]\n                self.y1 = p1[1]\n            if p2:\n                self.x2 = p2[0]\n                self.y2 = p2[1]\n</code></pre>"},{"location":"reference.html#odfdo.Link","title":"<code>Link</code>","text":"<p>             Bases: <code>ParagraphBase</code></p> <p>Link class, \u201ctext:a\u201d ODF element.</p> Source code in <code>odfdo/link.py</code> <pre><code>class Link(ParagraphBase):\n    \"\"\"Link class, \"text:a\" ODF element.\"\"\"\n\n    _tag = \"text:a\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"url\", \"xlink:href\"),\n        PropDef(\"name\", \"office:name\"),\n        PropDef(\"title\", \"office:title\"),\n        PropDef(\"target_frame\", \"office:target-frame-name\"),\n        PropDef(\"show\", \"xlink:show\"),\n        PropDef(\"visited_style\", \"text:visited-style-name\"),\n        PropDef(\"style\", \"text:style-name\"),\n    )\n\n    def __init__(\n        self,\n        url: str | None = \"\",\n        name: str | None = None,\n        title: str | None = None,\n        text: str | None = None,\n        target_frame: str | None = None,\n        style: str | None = None,\n        visited_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            url -- str\n\n            name -- str\n\n            title -- str\n\n            text -- str\n\n            target_frame -- '_self', '_blank', '_parent', '_top'\n\n            style -- str\n\n            visited_style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.url = url\n            if name is not None:\n                self.name = name\n            if title is not None:\n                self.title = title\n            if text is not None:\n                self.text = text\n            if target_frame is not None:\n                self.target_frame = target_frame\n                # show can be: 'new' or 'replace'\"\n                if target_frame == \"_blank\":\n                    self.show = \"new\"\n                else:\n                    self.show = \"replace\"\n            if style is not None:\n                self.style = style\n            if visited_style is not None:\n                self.visited_style = visited_style\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag} link={self.url}&gt;\"\n\n    def __str__(self) -&gt; str:\n        if self.name:\n            return f\"[{self.name}]({self.url})\"\n        return f\"({self.url})\"\n</code></pre>"},{"location":"reference.html#odfdo.Link.__init__","title":"<code>__init__(url='', name=None, title=None, text=None, target_frame=None, style=None, visited_style=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>url -- str\n\nname -- str\n\ntitle -- str\n\ntext -- str\n\ntarget_frame -- '_self', '_blank', '_parent', '_top'\n\nstyle -- str\n\nvisited_style -- str\n</code></pre> Source code in <code>odfdo/link.py</code> <pre><code>def __init__(\n    self,\n    url: str | None = \"\",\n    name: str | None = None,\n    title: str | None = None,\n    text: str | None = None,\n    target_frame: str | None = None,\n    style: str | None = None,\n    visited_style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        url -- str\n\n        name -- str\n\n        title -- str\n\n        text -- str\n\n        target_frame -- '_self', '_blank', '_parent', '_top'\n\n        style -- str\n\n        visited_style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.url = url\n        if name is not None:\n            self.name = name\n        if title is not None:\n            self.title = title\n        if text is not None:\n            self.text = text\n        if target_frame is not None:\n            self.target_frame = target_frame\n            # show can be: 'new' or 'replace'\"\n            if target_frame == \"_blank\":\n                self.show = \"new\"\n            else:\n                self.show = \"replace\"\n        if style is not None:\n            self.style = style\n        if visited_style is not None:\n            self.visited_style = visited_style\n</code></pre>"},{"location":"reference.html#odfdo.List","title":"<code>List</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF List \u201ctext:list\u201d.</p> Source code in <code>odfdo/list.py</code> <pre><code>class List(Element):\n    \"\"\"ODF List \"text:list\".\"\"\"\n\n    _tag = \"text:list\"\n    _properties = (PropDef(\"style\", \"text:style-name\"),)\n\n    def __init__(\n        self,\n        list_content: str | Element | Iterable[str | Element] | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a list element, optionaly loading the list by a list of\n        item (str or elements).\n\n        The list_content argument is just a shortcut for the most common case.\n        To create more complex lists, first create an empty list, and fill it\n        afterwards.\n\n        Arguments:\n\n            list_content -- str or Element, or a list of str or Element\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if list_content:\n                if isinstance(list_content, (Element, str)):\n                    self.append(ListItem(list_content))\n                elif hasattr(list_content, \"__iter__\"):\n                    for item in list_content:\n                        self.append(ListItem(item))\n            if style is not None:\n                self.style = style\n\n    def get_items(self, content: str | None = None) -&gt; list[Element]:\n        \"\"\"Return all the list items that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"text:list-item\", content=content)\n\n    def get_item(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the list item that matches the criteria. In nested lists,\n        return the list item that really contains that content.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        # Custom implementation because of nested lists\n        if content:\n            # Don't search recursively but on the very own paragraph(s) of\n            # each list item\n            for paragraph in self.get_elements(\"descendant::text:p\"):\n                if paragraph.match(content):\n                    return paragraph.get_element(\"parent::text:list-item\")\n            return None\n        return self._filtered_element(\"text:list-item\", position)\n\n    def set_list_header(\n        self,\n        text_or_element: str | Element | Iterable[str | Element],\n    ) -&gt; None:\n        if isinstance(text_or_element, (str, Element)):\n            actual_list: list[str | Element] | tuple = [text_or_element]\n        elif isinstance(text_or_element, (list, tuple)):\n            actual_list = text_or_element\n        else:\n            raise TypeError\n        # Remove existing header\n        for element in self.get_elements(\"text:p\"):\n            self.delete(element)\n        for paragraph in reversed(actual_list):\n            if isinstance(paragraph, str):\n                paragraph = Paragraph(paragraph)\n            self.insert(paragraph, FIRST_CHILD)\n\n    def insert_item(\n        self,\n        item: ListItem | str | Element | None,\n        position: int | None = None,\n        before: Element | None = None,\n        after: Element | None = None,\n    ) -&gt; None:\n        if not isinstance(item, ListItem):\n            item = ListItem(item)\n        if before is not None:\n            before.insert(item, xmlposition=PREV_SIBLING)\n        elif after is not None:\n            after.insert(item, xmlposition=NEXT_SIBLING)\n        elif position is not None:\n            self.insert(item, position=position)\n        else:\n            raise ValueError(\"Position must be defined\")\n\n    def append_item(\n        self,\n        item: ListItem | str | Element | None,\n    ) -&gt; None:\n        if not isinstance(item, ListItem):\n            item = ListItem(item)\n        self.append(item)\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        if context is None:\n            context = {}\n        rst_mode = context[\"rst_mode\"]\n        result = []\n        if rst_mode:\n            result.append(\"\\n\")\n        for list_item in self.get_elements(\"text:list-item\"):\n            textbuf = []\n            for child in list_item.children:\n                text = child.get_formatted_text(context)\n                tag = child.tag\n                if tag == \"text:h\":\n                    # A title in a list is a bug\n                    return text\n                if tag == \"text:list\" and not text.lstrip().startswith(\"-\"):\n                    # If the list didn't indent, don't either\n                    # (inner title)\n                    return text\n                textbuf.append(text)\n            text_sum = \"\".join(textbuf)\n            text_sum = text_sum.strip(\"\\n\")\n            # Indent the text\n            text_sum = text_sum.replace(\"\\n\", \"\\n  \")\n            text_sum = f\"- {text_sum}\\n\"\n            result.append(text_sum)\n        if rst_mode:\n            result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.List.__init__","title":"<code>__init__(list_content=None, style=None, **kwargs)</code>","text":"<p>Create a list element, optionaly loading the list by a list of item (str or elements).</p> <p>The list_content argument is just a shortcut for the most common case. To create more complex lists, first create an empty list, and fill it afterwards.</p> <p>Arguments:</p> <pre><code>list_content -- str or Element, or a list of str or Element\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/list.py</code> <pre><code>def __init__(\n    self,\n    list_content: str | Element | Iterable[str | Element] | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a list element, optionaly loading the list by a list of\n    item (str or elements).\n\n    The list_content argument is just a shortcut for the most common case.\n    To create more complex lists, first create an empty list, and fill it\n    afterwards.\n\n    Arguments:\n\n        list_content -- str or Element, or a list of str or Element\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if list_content:\n            if isinstance(list_content, (Element, str)):\n                self.append(ListItem(list_content))\n            elif hasattr(list_content, \"__iter__\"):\n                for item in list_content:\n                    self.append(ListItem(item))\n        if style is not None:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.List.get_item","title":"<code>get_item(position=0, content=None)</code>","text":"<p>Return the list item that matches the criteria. In nested lists, return the list item that really contains that content.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/list.py</code> <pre><code>def get_item(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the list item that matches the criteria. In nested lists,\n    return the list item that really contains that content.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    # Custom implementation because of nested lists\n    if content:\n        # Don't search recursively but on the very own paragraph(s) of\n        # each list item\n        for paragraph in self.get_elements(\"descendant::text:p\"):\n            if paragraph.match(content):\n                return paragraph.get_element(\"parent::text:list-item\")\n        return None\n    return self._filtered_element(\"text:list-item\", position)\n</code></pre>"},{"location":"reference.html#odfdo.List.get_items","title":"<code>get_items(content=None)</code>","text":"<p>Return all the list items that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/list.py</code> <pre><code>def get_items(self, content: str | None = None) -&gt; list[Element]:\n    \"\"\"Return all the list items that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"text:list-item\", content=content)\n</code></pre>"},{"location":"reference.html#odfdo.ListItem","title":"<code>ListItem</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF element \u201ctext:list-item\u201d, item of a List.</p> Source code in <code>odfdo/list.py</code> <pre><code>class ListItem(Element):\n    \"\"\"ODF element \"text:list-item\", item of a List.\"\"\"\n\n    _tag = \"text:list-item\"\n\n    def __init__(\n        self,\n        text_or_element: str | Element | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a list item element, optionaly passing at creation time a\n        string or Element as content.\n\n        Arguments:\n\n            text_or_element -- str or ODF Element\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if isinstance(text_or_element, str):\n                self.text_content = text_or_element\n            elif isinstance(text_or_element, Element):\n                self.append(text_or_element)\n            elif text_or_element is not None:\n                raise TypeError(\"Expected str or Element\")\n</code></pre>"},{"location":"reference.html#odfdo.ListItem.__init__","title":"<code>__init__(text_or_element=None, **kwargs)</code>","text":"<p>Create a list item element, optionaly passing at creation time a string or Element as content.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or ODF Element\n</code></pre> Source code in <code>odfdo/list.py</code> <pre><code>def __init__(\n    self,\n    text_or_element: str | Element | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a list item element, optionaly passing at creation time a\n    string or Element as content.\n\n    Arguments:\n\n        text_or_element -- str or ODF Element\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if isinstance(text_or_element, str):\n            self.text_content = text_or_element\n        elif isinstance(text_or_element, Element):\n            self.append(text_or_element)\n        elif text_or_element is not None:\n            raise TypeError(\"Expected str or Element\")\n</code></pre>"},{"location":"reference.html#odfdo.Manifest","title":"<code>Manifest</code>","text":"<p>             Bases: <code>XmlPart</code></p> Source code in <code>odfdo/manifest.py</code> <pre><code>class Manifest(XmlPart):\n    def get_paths(self) -&gt; list[Element | EText]:\n        \"\"\"Return the list of full paths in the manifest.\n\n        Return: list of str\n        \"\"\"\n        xpath_query = \"//manifest:file-entry/attribute::manifest:full-path\"\n        return self.xpath(xpath_query)\n\n    def _file_entry(self, full_path: str) -&gt; Element:\n        xpath_query = (\n            f'//manifest:file-entry[attribute::manifest:full-path=\"{full_path}\"]'\n        )\n        result = self.xpath(xpath_query)\n        if not result:\n            raise KeyError(f\"Path not found: '{full_path}'\")\n        return result[0]  # type: ignore\n\n    def get_path_medias(self) -&gt; list[tuple]:\n        \"\"\"Return the list of (full_path, media_type) pairs in the manifest.\n\n        Return: list of str tuples\n        \"\"\"\n        xpath_query = \"//manifest:file-entry\"\n        result = []\n        for file_entry in self.xpath(xpath_query):\n            if not isinstance(file_entry, Element):\n                continue\n            result.append(\n                (\n                    file_entry.get_attribute_string(\"manifest:full-path\"),\n                    file_entry.get_attribute_string(\"manifest:media-type\"),\n                )\n            )\n        return result\n\n    def get_media_type(self, full_path: str) -&gt; str | None:\n        \"\"\"Get the media type of an existing path.\n\n        Return: str\n        \"\"\"\n        xpath_query = (\n            f'//manifest:file-entry[attribute::manifest:full-path=\"{full_path}\"]'\n            \"/attribute::manifest:media-type\"\n        )\n        result = self.xpath(xpath_query)\n        if not result:\n            return None\n        return str(result[0])\n\n    def set_media_type(self, full_path: str, media_type: str) -&gt; None:\n        \"\"\"Set the media type of an existing path.\n\n        Arguments:\n\n            full_path -- str\n\n            media_type -- str\n        \"\"\"\n        file_entry = self._file_entry(full_path)\n        file_entry.set_attribute(\"manifest:media-type\", media_type)\n\n    @staticmethod\n    def make_file_entry(full_path: str, media_type: str) -&gt; Element:\n        tag = (\n            f\"&lt;manifest:file-entry \"\n            f'manifest:media-type=\"{media_type}\" '\n            f'manifest:full-path=\"{full_path}\"/&gt;'\n        )\n        return Element.from_tag(tag)\n\n    def add_full_path(self, full_path: str, media_type: str = \"\") -&gt; None:\n        # Existing?\n        existing = self.get_media_type(full_path)\n        if existing is not None:\n            self.set_media_type(full_path, media_type)\n        root = self.root\n        root.append(self.make_file_entry(full_path, media_type))\n\n    def del_full_path(self, full_path: str) -&gt; None:\n        file_entry = self._file_entry(full_path)\n        self.root.delete(file_entry)\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.get_media_type","title":"<code>get_media_type(full_path)</code>","text":"<p>Get the media type of an existing path.</p> <p>Return: str</p> Source code in <code>odfdo/manifest.py</code> <pre><code>def get_media_type(self, full_path: str) -&gt; str | None:\n    \"\"\"Get the media type of an existing path.\n\n    Return: str\n    \"\"\"\n    xpath_query = (\n        f'//manifest:file-entry[attribute::manifest:full-path=\"{full_path}\"]'\n        \"/attribute::manifest:media-type\"\n    )\n    result = self.xpath(xpath_query)\n    if not result:\n        return None\n    return str(result[0])\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.get_path_medias","title":"<code>get_path_medias()</code>","text":"<p>Return the list of (full_path, media_type) pairs in the manifest.</p> <p>Return: list of str tuples</p> Source code in <code>odfdo/manifest.py</code> <pre><code>def get_path_medias(self) -&gt; list[tuple]:\n    \"\"\"Return the list of (full_path, media_type) pairs in the manifest.\n\n    Return: list of str tuples\n    \"\"\"\n    xpath_query = \"//manifest:file-entry\"\n    result = []\n    for file_entry in self.xpath(xpath_query):\n        if not isinstance(file_entry, Element):\n            continue\n        result.append(\n            (\n                file_entry.get_attribute_string(\"manifest:full-path\"),\n                file_entry.get_attribute_string(\"manifest:media-type\"),\n            )\n        )\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.get_paths","title":"<code>get_paths()</code>","text":"<p>Return the list of full paths in the manifest.</p> <p>Return: list of str</p> Source code in <code>odfdo/manifest.py</code> <pre><code>def get_paths(self) -&gt; list[Element | EText]:\n    \"\"\"Return the list of full paths in the manifest.\n\n    Return: list of str\n    \"\"\"\n    xpath_query = \"//manifest:file-entry/attribute::manifest:full-path\"\n    return self.xpath(xpath_query)\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.set_media_type","title":"<code>set_media_type(full_path, media_type)</code>","text":"<p>Set the media type of an existing path.</p> <p>Arguments:</p> <pre><code>full_path -- str\n\nmedia_type -- str\n</code></pre> Source code in <code>odfdo/manifest.py</code> <pre><code>def set_media_type(self, full_path: str, media_type: str) -&gt; None:\n    \"\"\"Set the media type of an existing path.\n\n    Arguments:\n\n        full_path -- str\n\n        media_type -- str\n    \"\"\"\n    file_entry = self._file_entry(full_path)\n    file_entry.set_attribute(\"manifest:media-type\", media_type)\n</code></pre>"},{"location":"reference.html#odfdo.Meta","title":"<code>Meta</code>","text":"<p>             Bases: <code>XmlPart</code>, <code>DcCreatorMixin</code>, <code>DcDateMixin</code></p> Source code in <code>odfdo/meta.py</code> <pre><code>class Meta(XmlPart, DcCreatorMixin, DcDateMixin):\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self._generator_modified: bool = False\n\n    def get_meta_body(self) -&gt; Element:\n        return self.get_element(\"//office:meta\")\n\n    def get_title(self) -&gt; str | None:\n        \"\"\"Get the title of the document.\n\n        This is not the first heading but the title metadata.\n\n        (Also available as \"self.title\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//dc:title\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_title(self, title: str) -&gt; None:\n        \"\"\"Set the title of the document.\n\n        This is not the first heading but the title metadata.\n\n        (Also available as \"self.title\" property.)\n\n        Arguments:\n\n            title -- str\n        \"\"\"\n        element = self.get_element(\"//dc:title\")\n        if element is None:\n            element = Element.from_tag(\"dc:title\")\n            self.get_meta_body().append(element)\n        element.text = title\n\n    @property\n    def title(self) -&gt; str | None:\n        \"\"\"Get or set the title of the document &lt;dc:title&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_title()\n\n    @title.setter\n    def title(self, title: str) -&gt; None:\n        return self.set_title(title)\n\n    def get_description(self) -&gt; str | None:\n        \"\"\"Get the description of the document. Also known as comments.\n\n        (Also available as \"self.description\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//dc:description\")\n        if element is None:\n            return None\n        return element.text\n\n    # As named in OOo\n    get_comments = get_description\n\n    def set_description(self, description: str) -&gt; None:\n        \"\"\"Set the description of the document. Also known as comments.\n\n        (Also available as \"self.description\" property.)\n\n        Arguments:\n\n            description -- str\n        \"\"\"\n        element = self.get_element(\"//dc:description\")\n        if element is None:\n            element = Element.from_tag(\"dc:description\")\n            self.get_meta_body().append(element)\n        element.text = description\n\n    set_comments = set_description\n\n    @property\n    def description(self) -&gt; str | None:\n        \"\"\"Get or set the description of a document &lt;dc:description&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_description()\n\n    @description.setter\n    def description(self, description: str) -&gt; None:\n        return self.set_description(description)\n\n    def get_subject(self) -&gt; str | None:\n        \"\"\"Get the subject of the document.\n\n        (Also available as \"self.subject\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//dc:subject\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_subject(self, subject: str) -&gt; None:\n        \"\"\"Set the subject of the document.\n\n        (Also available as \"self.subject\" property.)\n\n        Arguments:\n\n            subject -- str\n        \"\"\"\n        element = self.get_element(\"//dc:subject\")\n        if element is None:\n            element = Element.from_tag(\"dc:subject\")\n            self.get_meta_body().append(element)\n        element.text = subject\n\n    @property\n    def subject(self) -&gt; str | None:\n        \"\"\"Get or set the subject of a document &lt;dc:subject&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_subject()\n\n    @subject.setter\n    def subject(self, subject: str) -&gt; None:\n        return self.set_subject(subject)\n\n    def get_language(self) -&gt; str | None:\n        \"\"\"Get the default language of the document.\n\n        (Also available as \"self.language\" property.)\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.get_language()\n            fr-FR\n        \"\"\"\n        element = self.get_element(\"//dc:language\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_language(self, language: str) -&gt; None:\n        \"\"\"Set the default language of the document.\n\n        (Also available as \"self.language\" property.)\n\n        Arguments:\n\n            language -- str\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_language('fr-FR')\n        \"\"\"\n        language = str(language)\n        if not self._is_RFC3066(language):\n            raise TypeError(\n                'Language must be \"xx\" lang or \"xx-YY\" lang-COUNTRY code (RFC3066)'\n            )\n        element = self.get_element(\"//dc:language\")\n        if element is None:\n            element = Element.from_tag(\"dc:language\")\n            self.get_meta_body().append(element)\n        element.text = language\n\n    @staticmethod\n    def _is_RFC3066(lang: str) -&gt; bool:\n        def test_part1(part1: str) -&gt; bool:\n            if not 2 &lt;= len(part1) &lt;= 3:\n                return False\n            return all(x in ascii_letters for x in part1)\n\n        def test_part2(part2: str) -&gt; bool:\n            return all(x in ascii_letters or x in digits for x in part2)\n\n        if not lang or not isinstance(lang, str):\n            return False\n        if \"-\" not in lang:\n            return test_part1(lang)\n        parts = lang.split(\"-\")\n        if len(parts) &gt; 3:\n            return False\n        if not test_part1(parts[0]):\n            return False\n        return all(test_part2(p) for p in parts[1:])\n\n    @property\n    def language(self) -&gt; str | None:\n        \"\"\"Get or set the default language of the document &lt;dc:language&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_language()\n\n    @language.setter\n    def language(self, language: str) -&gt; None:\n        return self.set_language(language)\n\n    def get_creation_date(self) -&gt; datetime | None:\n        \"\"\"Get the creation date of the document.\n\n        (Also available as \"self.creation_date\" property.)\n\n        Return: datetime (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:creation-date\")\n        if element is None:\n            return None\n        creation_date = element.text\n        return DateTime.decode(creation_date)\n\n    def set_creation_date(self, date: datetime | None = None) -&gt; None:\n        \"\"\"Set the creation date of the document.\n\n        If provided datetime is None, use current time.\n\n        (Also available as \"self.creation_date\" property.)\n\n        Arguments:\n\n            date -- datetime\n        \"\"\"\n        element = self.get_element(\"//meta:creation-date\")\n        if element is None:\n            element = Element.from_tag(\"meta:creation-date\")\n            self.get_meta_body().append(element)\n        if date is None:\n            date = datetime.now()\n        element.text = DateTime.encode(date)\n\n    @property\n    def creation_date(self) -&gt; datetime | None:\n        \"\"\"Get or set the date and time when a document was created\n        &lt;meta:creation-date&gt;.\n\n        If provided datetime is None, use current time.\n\n        Return: datetime (or None if inexistant)\n        \"\"\"\n        return self.get_creation_date()\n\n    @creation_date.setter\n    def creation_date(self, date: datetime | None = None) -&gt; None:\n        return self.set_creation_date(date)\n\n    @property\n    def print_date(self) -&gt; datetime | None:\n        \"\"\"Get or set the date and time when a document when a document was last printed\n        &lt;meta:print-date&gt;\n\n        If provided datetime is None, use current time.\n\n        Return: datetime (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:print-date\")\n        if element is None:\n            return None\n        date = element.text\n        return DateTime.decode(date)\n\n    @print_date.setter\n    def print_date(self, date: datetime | None = None) -&gt; None:\n        element = self.get_element(\"//meta:print-date\")\n        if element is None:\n            element = Element.from_tag(\"meta:print-date\")\n            self.get_meta_body().append(element)\n        if date is None:\n            date = datetime.now()\n        element.text = DateTime.encode(date)\n\n    def get_template(self) -&gt; MetaTemplate | None:\n        \"\"\"Get the MetaTemplate &lt;meta:template&gt; element or None.\"\"\"\n        element = self.get_element(\"//meta:template\")\n        if element is None:\n            return None\n        return element\n\n    @property\n    def template(self) -&gt; MetaTemplate | None:\n        \"\"\"Get the MetaTemplate &lt;meta:template&gt; element or None.\"\"\"\n        return self.get_template()\n\n    def set_template(\n        self,\n        date: datetime | None = None,\n        href: str = \"\",\n        title: str = \"\",\n    ) -&gt; None:\n        \"\"\"Set the MetaTemplate &lt;meta:template&gt; element.\"\"\"\n        template = MetaTemplate(date=date, href=href, title=title)\n        current = self.template\n        if isinstance(current, MetaTemplate):\n            current.delete()\n        self.get_meta_body().append(template)\n\n    def get_auto_reload(self) -&gt; MetaAutoReload | None:\n        \"\"\"Get the MetaAutoReload &lt;meta:auto-reload&gt; element or None.\"\"\"\n        element = self.get_element(\"//meta:auto-reload\")\n        if element is None:\n            return None\n        return element\n\n    @property\n    def auto_reload(self) -&gt; MetaAutoReload | None:\n        \"\"\"Get the MetaAutoReload &lt;meta:auto-reload&gt; element or None.\"\"\"\n        return self.get_auto_reload()\n\n    def set_auto_reload(self, delay: timedelta, href: str = \"\") -&gt; None:\n        \"\"\"Set the MetaAutoReload &lt;meta:auto-reload&gt; element.\"\"\"\n        autoreload = MetaAutoReload(delay=delay, href=href)\n        current = self.auto_reload\n        if isinstance(current, MetaAutoReload):\n            current.delete()\n        self.get_meta_body().append(autoreload)\n\n    def get_hyperlink_behaviour(self) -&gt; MetaHyperlinkBehaviour | None:\n        \"\"\"Get the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element or None.\"\"\"\n        element = self.get_element(\"//meta:hyperlink-behaviour\")\n        if element is None:\n            return None\n        return element\n\n    @property\n    def hyperlink_behaviour(self) -&gt; MetaAutoReload | None:\n        \"\"\"Get the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element or None.\"\"\"\n        return self.get_hyperlink_behaviour()\n\n    def set_hyperlink_behaviour(\n        self,\n        target_frame_name: str = \"_blank\",\n        show: str = \"replace\",\n    ) -&gt; None:\n        \"\"\"Set the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element.\"\"\"\n        behaviour = MetaHyperlinkBehaviour(\n            target_frame_name=target_frame_name, show=show\n        )\n        current = self.hyperlink_behaviour\n        if isinstance(current, MetaHyperlinkBehaviour):\n            current.delete()\n        self.get_meta_body().append(behaviour)\n\n    def get_initial_creator(self) -&gt; str | None:\n        \"\"\"Get the first creator of the document.\n\n        (Also available as \"self.initial_creator\" property.)\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.get_initial_creator()\n            Unknown\n        \"\"\"\n        element = self.get_element(\"//meta:initial-creator\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_initial_creator(self, creator: str) -&gt; None:\n        \"\"\"Set the first creator of the document.\n\n        (Also available as \"self.initial_creator\" property.)\n\n        Arguments:\n\n            creator -- str\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_initial_creator(\"Plato\")\n        \"\"\"\n        element = self.get_element(\"//meta:initial-creator\")\n        if element is None:\n            element = Element.from_tag(\"meta:initial-creator\")\n            self.get_meta_body().append(element)\n        element.text = creator\n\n    @property\n    def initial_creator(self) -&gt; str | None:\n        \"\"\"Get or set the initial creator of a document\n        &lt;meta:initial-creator&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_initial_creator()\n\n    @initial_creator.setter\n    def initial_creator(self, creator: str) -&gt; None:\n        return self.set_initial_creator(creator)\n\n    @property\n    def printed_by(self) -&gt; str | None:\n        \"\"\"Get or set the name of the last person who printed a document.\n        &lt;meta:printed-by&gt;\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:printed-by\")\n        if element is None:\n            return None\n        return element.text\n\n    @printed_by.setter\n    def printed_by(self, printed_by: str) -&gt; None:\n        element = self.get_element(\"//meta:printed-by\")\n        if element is None:\n            element = Element.from_tag(\"meta:printed-by\")\n            self.get_meta_body().append(element)\n        element.text = printed_by\n\n    def get_keywords(self) -&gt; str | None:\n        \"\"\"Get the keywords of the document. Return the field as-is, without\n        any assumption on the keyword separator.\n\n        (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:keyword\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_keywords(self, keywords: str) -&gt; None:\n        \"\"\"Set the keywords of the document. Although the name is plural, a\n        str string is required, so join your list first.\n\n        (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n        Arguments:\n\n            keywords -- str\n        \"\"\"\n        element = self.get_element(\"//meta:keyword\")\n        if element is None:\n            element = Element.from_tag(\"meta:keyword\")\n            self.get_meta_body().append(element)\n        element.text = keywords\n\n    @property\n    def keyword(self) -&gt; str | None:\n        \"\"\"Get or set some keyword(s) keyword pertaining to a document\n        &lt;dc:keyword&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_keywords()\n\n    @keyword.setter\n    def keyword(self, keyword: str) -&gt; None:\n        return self.set_keywords(keyword)\n\n    keywords = keyword\n\n    def get_editing_duration(self) -&gt; timedelta | None:\n        \"\"\"Get the time the document was edited, as reported by the\n        generator.\n\n        (Also available as \"self.editing_duration\" property.)\n\n        Return: timedelta (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:editing-duration\")\n        if element is None:\n            return None\n        duration = element.text\n        return Duration.decode(duration)\n\n    def set_editing_duration(self, duration: timedelta) -&gt; None:\n        \"\"\"Set the time the document was edited.\n\n        (Also available as \"self.editing_duration\" property.)\n\n        Arguments:\n\n            duration -- timedelta\n        \"\"\"\n        if not isinstance(duration, timedelta):\n            raise TypeError(\"duration must be a timedelta\")\n        element = self.get_element(\"//meta:editing-duration\")\n        if element is None:\n            element = Element.from_tag(\"meta:editing-duration\")\n            self.get_meta_body().append(element)\n        element.text = Duration.encode(duration)\n\n    @property\n    def editing_duration(self) -&gt; timedelta | None:\n        \"\"\"Get or set the total time spent editing a document\n        &lt;meta:editing-duration&gt;.\n\n        Return: timedelta (or None if inexistant)\n        \"\"\"\n        return self.get_editing_duration()\n\n    @editing_duration.setter\n    def editing_duration(self, duration: timedelta) -&gt; None:\n        return self.set_editing_duration(duration)\n\n    def get_editing_cycles(self) -&gt; int | None:\n        \"\"\"Get the number of times the document was edited, as reported by\n        the generator.\n\n        (Also available as \"self.editing_cycles\" property.)\n\n        Return: int (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:editing-cycles\")\n        if element is None:\n            return None\n        cycles = element.text\n        return int(cycles)\n\n    def set_editing_cycles(self, cycles: int) -&gt; None:\n        \"\"\"Set the number of times the document was edited.\n\n        (Also available as \"self.editing_cycles\" property.)\n\n        Arguments:\n\n            cycles -- int\n        \"\"\"\n        if not isinstance(cycles, int):\n            raise TypeError(\"cycles must be an int\")\n        if cycles &lt; 1:\n            raise ValueError(\"cycles must be a positive int\")\n        element = self.get_element(\"//meta:editing-cycles\")\n        if element is None:\n            element = Element.from_tag(\"meta:editing-cycles\")\n            self.get_meta_body().append(element)\n        element.text = str(cycles)\n\n    @property\n    def editing_cycles(self) -&gt; int | None:\n        \"\"\"Get or set the number of times a document has been edited\n        &lt;meta:editing-cycles&gt;.\n\n        When a document is created, this value is set to 1. Each time\n        a document is saved, the editing-cycles number is incremented by 1.\n\n        Return: int (or None if inexistant)\n        \"\"\"\n        return self.get_editing_cycles()\n\n    @editing_cycles.setter\n    def editing_cycles(self, cycles: int) -&gt; None:\n        return self.set_editing_cycles(cycles)\n\n    @property\n    def generator(self) -&gt; str | None:\n        \"\"\"Get or set the signature of the software that generated this\n        document.\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.generator\n            KOffice/2.0.0\n            &gt;&gt;&gt; document.meta.generator = \"Odfdo experiment\"\n        \"\"\"\n        element = self.get_element(\"//meta:generator\")\n        if element is None:\n            return None\n        return element.text\n\n    @generator.setter\n    def generator(self, generator: str) -&gt; None:\n        element = self.get_element(\"//meta:generator\")\n        if element is None:\n            element = Element.from_tag(\"meta:generator\")\n            self.get_meta_body().append(element)\n        element.text = generator\n        self._generator_modified = True\n\n    def get_generator(self) -&gt; str | None:\n        \"\"\"Get the signature of the software that generated this document.\n\n        (Also available as \"self.generator\" property.)\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.get_generator()\n            KOffice/2.0.0\n        \"\"\"\n        return self.generator\n\n    def set_generator(self, generator: str) -&gt; None:\n        \"\"\"Set the signature of the software that generated this document.\n\n        (Also available as \"self.generator\" property.)\n\n        Arguments:\n\n            generator -- str\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_generator(\"Odfdo experiment\")\n        \"\"\"\n        self.generator = generator\n\n    def set_generator_default(self) -&gt; None:\n        \"\"\"Set the signature of the software that generated this document\n        to ourself.\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_generator_default()\n        \"\"\"\n        if not self._generator_modified:\n            self.generator = GENERATOR\n\n    def get_statistic(self) -&gt; dict[str, int] | None:\n        \"\"\"Get the statistics about a document.\n\n        (Also available as \"self.statistic\" property.)\n\n        Return: dict (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.get_statistic():\n            {'meta:table-count': 1,\n             'meta:image-count': 2,\n             'meta:object-count': 3,\n             'meta:page-count': 4,\n             'meta:paragraph-count': 5,\n             'meta:word-count': 6,\n             'meta:character-count': 7}\n        \"\"\"\n        element = self.get_element(\"//meta:document-statistic\")\n        if element is None:\n            return None\n        statistic = {}\n        for key, value in element.attributes.items():\n            statistic[to_str(key)] = int(value)\n        return statistic\n\n    def set_statistic(self, statistic: dict[str, int]) -&gt; None:\n        \"\"\"Set the statistics about a document.\n\n        (Also available as \"self.statistic\" property.)\n\n        Arguments:\n\n            statistic -- dict\n\n        Example::\n\n            &gt;&gt;&gt; statistic = {'meta:table-count': 1,\n                             'meta:image-count': 2,\n                             'meta:object-count': 3,\n                             'meta:page-count': 4,\n                             'meta:paragraph-count': 5,\n                             'meta:word-count': 6,\n                             'meta:character-count': 7}\n            &gt;&gt;&gt; document.meta.set_statistic(statistic)\n        \"\"\"\n        if not isinstance(statistic, dict):\n            raise TypeError(\"Statistic must be a dict\")\n        element = self.get_element(\"//meta:document-statistic\")\n        for key, value in statistic.items():\n            try:\n                ivalue = int(value)\n            except ValueError as e:\n                raise TypeError(\"Statistic value must be a int\") from e\n            element.set_attribute(to_str(key), str(ivalue))\n\n    @property\n    def statistic(self) -&gt; dict[str, int] | None:\n        \"\"\"Get or set the statistics about a document\n        &lt;meta:document-statistic&gt;.\n\n        Return: dict (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.get_statistic():\n            {'meta:table-count': 1,\n             'meta:image-count': 2,\n             'meta:object-count': 3,\n             'meta:page-count': 4,\n             'meta:paragraph-count': 5,\n             'meta:word-count': 6,\n             'meta:character-count': 7}\n        \"\"\"\n        return self.get_statistic()\n\n    @statistic.setter\n    def statistic(self, statistic: dict[str, int]) -&gt; None:\n        return self.set_statistic(statistic)\n\n    def get_user_defined_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Get all additional user-defined metadata for a document.\n\n        (Also available as \"self.user_defined_metadata\" property.)\n\n        Return a dict of str/value mapping.\n\n        Value types can be: Decimal, date, time, boolean or str.\n        \"\"\"\n        result: dict[str, Any] = {}\n        for item in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(item, Element):\n                continue\n            # Read the values\n            name = item.get_attribute_string(\"meta:name\")\n            if name is None:\n                continue\n            value = self._get_meta_value(item)\n            result[name] = value\n        return result\n\n    def clear_user_defined_metadata(self) -&gt; None:\n        \"\"\"Remove all user-defined metadata.\"\"\"\n        while True:\n            element = self.get_element(\"//meta:user-defined\")\n            if isinstance(element, Element):\n                element.delete()\n                continue\n            break\n\n    @property\n    def user_defined_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Get or set all additional user-defined metadata for a document.\n\n        Return a dict of str/value mapping.\n\n        Value types can be: Decimal, date, time, boolean or str.\n        \"\"\"\n        return self.get_user_defined_metadata()\n\n    @user_defined_metadata.setter\n    def user_defined_metadata(self, metadata: dict[str, Any]) -&gt; None:\n        self.clear_user_defined_metadata()\n        for key, val in metadata.items():\n            self.set_user_defined_metadata(name=key, value=val)\n\n    def get_user_defined_metadata_of_name(self, keyname: str) -&gt; dict[str, Any] | None:\n        \"\"\"Return the content of the user defined metadata of that name.\n        Return None if no name matchs or a dic of fields.\n\n        Arguments:\n\n            name -- string, name (meta:name content)\n        \"\"\"\n        result = {}\n        found = False\n        for item in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(item, Element):\n                continue\n            # Read the values\n            name = item.get_attribute(\"meta:name\")\n            if name == keyname:\n                found = True\n                break\n        if not found:\n            return None\n        result[\"name\"] = name\n        value, value_type, text = self._get_meta_value(item, full=True)  # type: ignore\n        result[\"value\"] = value\n        result[\"value_type\"] = value_type\n        result[\"text\"] = text\n        return result\n\n    def set_user_defined_metadata(self, name: str, value: Any) -&gt; None:\n        if isinstance(value, bool):\n            value_type = \"boolean\"\n            value = \"true\" if value else \"false\"\n        elif isinstance(value, (int, float, Decimal)):\n            value_type = \"float\"\n            value = str(value)\n        elif isinstance(value, dtdate):\n            value_type = \"date\"\n            value = str(Date.encode(value))\n        elif isinstance(value, datetime):\n            value_type = \"date\"\n            value = str(DateTime.encode(value))\n        elif isinstance(value, str):\n            value_type = \"string\"\n        elif isinstance(value, timedelta):\n            value_type = \"time\"\n            value = str(Duration.encode(value))\n        else:\n            raise TypeError(f'unexpected type \"{type(value)}\" for value')\n        # Already the same element ?\n        for metadata in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(metadata, Element):\n                continue\n            if metadata.get_attribute(\"meta:name\") == name:\n                break\n        else:\n            metadata = Element.from_tag(\"meta:user-defined\")\n            metadata.set_attribute(\"meta:name\", name)\n            self.get_meta_body().append(metadata)\n        metadata.set_attribute(\"meta:value-type\", value_type)\n        metadata.text = value\n\n    def _get_meta_value(\n        self, element: Element, full: bool = False\n    ) -&gt; Any | tuple[Any, str, str]:\n        \"\"\"get_value() deicated to the meta data part, for one meta element.\"\"\"\n        if full:\n            return self._get_meta_value_full(element)\n        else:\n            return self._get_meta_value_full(element)[0]\n\n    @staticmethod\n    def _get_meta_value_full(element: Element) -&gt; tuple[Any, str, str]:\n        \"\"\"get_value deicated to the meta data part, for one meta element.\"\"\"\n        # name = element.get_attribute('meta:name')\n        value_type = element.get_attribute_string(\"meta:value-type\")\n        if value_type is None:\n            value_type = \"string\"\n        text = element.text\n        # Interpretation\n        if value_type == \"boolean\":\n            return (Boolean.decode(text), value_type, text)\n        if value_type in (\"float\", \"percentage\", \"currency\"):\n            return (Decimal(text), value_type, text)\n        if value_type == \"date\":\n            if \"T\" in text:\n                return (DateTime.decode(text), value_type, text)\n            else:\n                return (Date.decode(text), value_type, text)\n        if value_type == \"string\":\n            return (text, value_type, text)\n        if value_type == \"time\":\n            return (Duration.decode(text), value_type, text)\n        raise TypeError(f\"Unknown value type: '{value_type!r}'\")\n</code></pre>"},{"location":"reference.html#odfdo.Meta.auto_reload","title":"<code>auto_reload: MetaAutoReload | None</code>  <code>property</code>","text":"<p>Get the MetaAutoReload  element or None."},{"location":"reference.html#odfdo.Meta.creation_date","title":"<code>creation_date: datetime | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the date and time when a document was created . <p>If provided datetime is None, use current time.</p> <p>Return: datetime (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.description","title":"<code>description: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the description of a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.editing_cycles","title":"<code>editing_cycles: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the number of times a document has been edited . <p>When a document is created, this value is set to 1. Each time a document is saved, the editing-cycles number is incremented by 1.</p> <p>Return: int (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.editing_duration","title":"<code>editing_duration: timedelta | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the total time spent editing a document . <p>Return: timedelta (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.generator","title":"<code>generator: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the signature of the software that generated this document.</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.generator\nKOffice/2.0.0\n&gt;&gt;&gt; document.meta.generator = \"Odfdo experiment\"\n</code></pre>"},{"location":"reference.html#odfdo.Meta.hyperlink_behaviour","title":"<code>hyperlink_behaviour: MetaAutoReload | None</code>  <code>property</code>","text":"<p>Get the MetaHyperlinkBehaviour  element or None."},{"location":"reference.html#odfdo.Meta.initial_creator","title":"<code>initial_creator: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the initial creator of a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.keyword","title":"<code>keyword: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set some keyword(s) keyword pertaining to a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.language","title":"<code>language: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the default language of the document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.print_date","title":"<code>print_date: datetime | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the date and time when a document when a document was last printed  <p>If provided datetime is None, use current time.</p> <p>Return: datetime (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.printed_by","title":"<code>printed_by: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the name of the last person who printed a document.  <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.statistic","title":"<code>statistic: dict[str, int] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the statistics about a document . <p>Return: dict (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.get_statistic():\n{'meta:table-count': 1,\n 'meta:image-count': 2,\n 'meta:object-count': 3,\n 'meta:page-count': 4,\n 'meta:paragraph-count': 5,\n 'meta:word-count': 6,\n 'meta:character-count': 7}\n</code></pre>"},{"location":"reference.html#odfdo.Meta.subject","title":"<code>subject: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the subject of a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.template","title":"<code>template: MetaTemplate | None</code>  <code>property</code>","text":"<p>Get the MetaTemplate  element or None."},{"location":"reference.html#odfdo.Meta.title","title":"<code>title: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the title of the document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.user_defined_metadata","title":"<code>user_defined_metadata: dict[str, Any]</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set all additional user-defined metadata for a document.</p> <p>Return a dict of str/value mapping.</p> <p>Value types can be: Decimal, date, time, boolean or str.</p>"},{"location":"reference.html#odfdo.Meta.clear_user_defined_metadata","title":"<code>clear_user_defined_metadata()</code>","text":"<p>Remove all user-defined metadata.</p> Source code in <code>odfdo/meta.py</code> <pre><code>def clear_user_defined_metadata(self) -&gt; None:\n    \"\"\"Remove all user-defined metadata.\"\"\"\n    while True:\n        element = self.get_element(\"//meta:user-defined\")\n        if isinstance(element, Element):\n            element.delete()\n            continue\n        break\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_auto_reload","title":"<code>get_auto_reload()</code>","text":"<p>Get the MetaAutoReload  element or None. Source code in <code>odfdo/meta.py</code> <pre><code>def get_auto_reload(self) -&gt; MetaAutoReload | None:\n    \"\"\"Get the MetaAutoReload &lt;meta:auto-reload&gt; element or None.\"\"\"\n    element = self.get_element(\"//meta:auto-reload\")\n    if element is None:\n        return None\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_creation_date","title":"<code>get_creation_date()</code>","text":"<p>Get the creation date of the document.</p> <p>(Also available as \u201cself.creation_date\u201d property.)</p> <p>Return: datetime (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_creation_date(self) -&gt; datetime | None:\n    \"\"\"Get the creation date of the document.\n\n    (Also available as \"self.creation_date\" property.)\n\n    Return: datetime (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:creation-date\")\n    if element is None:\n        return None\n    creation_date = element.text\n    return DateTime.decode(creation_date)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_description","title":"<code>get_description()</code>","text":"<p>Get the description of the document. Also known as comments.</p> <p>(Also available as \u201cself.description\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_description(self) -&gt; str | None:\n    \"\"\"Get the description of the document. Also known as comments.\n\n    (Also available as \"self.description\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//dc:description\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_editing_cycles","title":"<code>get_editing_cycles()</code>","text":"<p>Get the number of times the document was edited, as reported by the generator.</p> <p>(Also available as \u201cself.editing_cycles\u201d property.)</p> <p>Return: int (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_editing_cycles(self) -&gt; int | None:\n    \"\"\"Get the number of times the document was edited, as reported by\n    the generator.\n\n    (Also available as \"self.editing_cycles\" property.)\n\n    Return: int (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:editing-cycles\")\n    if element is None:\n        return None\n    cycles = element.text\n    return int(cycles)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_editing_duration","title":"<code>get_editing_duration()</code>","text":"<p>Get the time the document was edited, as reported by the generator.</p> <p>(Also available as \u201cself.editing_duration\u201d property.)</p> <p>Return: timedelta (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_editing_duration(self) -&gt; timedelta | None:\n    \"\"\"Get the time the document was edited, as reported by the\n    generator.\n\n    (Also available as \"self.editing_duration\" property.)\n\n    Return: timedelta (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:editing-duration\")\n    if element is None:\n        return None\n    duration = element.text\n    return Duration.decode(duration)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_generator","title":"<code>get_generator()</code>","text":"<p>Get the signature of the software that generated this document.</p> <p>(Also available as \u201cself.generator\u201d property.)</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.get_generator()\nKOffice/2.0.0\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_generator(self) -&gt; str | None:\n    \"\"\"Get the signature of the software that generated this document.\n\n    (Also available as \"self.generator\" property.)\n\n    Return: str (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.get_generator()\n        KOffice/2.0.0\n    \"\"\"\n    return self.generator\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_hyperlink_behaviour","title":"<code>get_hyperlink_behaviour()</code>","text":"<p>Get the MetaHyperlinkBehaviour  element or None. Source code in <code>odfdo/meta.py</code> <pre><code>def get_hyperlink_behaviour(self) -&gt; MetaHyperlinkBehaviour | None:\n    \"\"\"Get the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element or None.\"\"\"\n    element = self.get_element(\"//meta:hyperlink-behaviour\")\n    if element is None:\n        return None\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_initial_creator","title":"<code>get_initial_creator()</code>","text":"<p>Get the first creator of the document.</p> <p>(Also available as \u201cself.initial_creator\u201d property.)</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.get_initial_creator()\nUnknown\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_initial_creator(self) -&gt; str | None:\n    \"\"\"Get the first creator of the document.\n\n    (Also available as \"self.initial_creator\" property.)\n\n    Return: str (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.get_initial_creator()\n        Unknown\n    \"\"\"\n    element = self.get_element(\"//meta:initial-creator\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_keywords","title":"<code>get_keywords()</code>","text":"<p>Get the keywords of the document. Return the field as-is, without any assumption on the keyword separator.</p> <p>(Also available as \u201cself.keyword\u201d and \u201cself.keywords\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_keywords(self) -&gt; str | None:\n    \"\"\"Get the keywords of the document. Return the field as-is, without\n    any assumption on the keyword separator.\n\n    (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:keyword\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_language","title":"<code>get_language()</code>","text":"<p>Get the default language of the document.</p> <p>(Also available as \u201cself.language\u201d property.)</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.get_language()\nfr-FR\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_language(self) -&gt; str | None:\n    \"\"\"Get the default language of the document.\n\n    (Also available as \"self.language\" property.)\n\n    Return: str (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.get_language()\n        fr-FR\n    \"\"\"\n    element = self.get_element(\"//dc:language\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_statistic","title":"<code>get_statistic()</code>","text":"<p>Get the statistics about a document.</p> <p>(Also available as \u201cself.statistic\u201d property.)</p> <p>Return: dict (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.get_statistic():\n{'meta:table-count': 1,\n 'meta:image-count': 2,\n 'meta:object-count': 3,\n 'meta:page-count': 4,\n 'meta:paragraph-count': 5,\n 'meta:word-count': 6,\n 'meta:character-count': 7}\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_statistic(self) -&gt; dict[str, int] | None:\n    \"\"\"Get the statistics about a document.\n\n    (Also available as \"self.statistic\" property.)\n\n    Return: dict (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.get_statistic():\n        {'meta:table-count': 1,\n         'meta:image-count': 2,\n         'meta:object-count': 3,\n         'meta:page-count': 4,\n         'meta:paragraph-count': 5,\n         'meta:word-count': 6,\n         'meta:character-count': 7}\n    \"\"\"\n    element = self.get_element(\"//meta:document-statistic\")\n    if element is None:\n        return None\n    statistic = {}\n    for key, value in element.attributes.items():\n        statistic[to_str(key)] = int(value)\n    return statistic\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_subject","title":"<code>get_subject()</code>","text":"<p>Get the subject of the document.</p> <p>(Also available as \u201cself.subject\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_subject(self) -&gt; str | None:\n    \"\"\"Get the subject of the document.\n\n    (Also available as \"self.subject\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//dc:subject\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_template","title":"<code>get_template()</code>","text":"<p>Get the MetaTemplate  element or None. Source code in <code>odfdo/meta.py</code> <pre><code>def get_template(self) -&gt; MetaTemplate | None:\n    \"\"\"Get the MetaTemplate &lt;meta:template&gt; element or None.\"\"\"\n    element = self.get_element(\"//meta:template\")\n    if element is None:\n        return None\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_title","title":"<code>get_title()</code>","text":"<p>Get the title of the document.</p> <p>This is not the first heading but the title metadata.</p> <p>(Also available as \u201cself.title\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_title(self) -&gt; str | None:\n    \"\"\"Get the title of the document.\n\n    This is not the first heading but the title metadata.\n\n    (Also available as \"self.title\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//dc:title\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_user_defined_metadata","title":"<code>get_user_defined_metadata()</code>","text":"<p>Get all additional user-defined metadata for a document.</p> <p>(Also available as \u201cself.user_defined_metadata\u201d property.)</p> <p>Return a dict of str/value mapping.</p> <p>Value types can be: Decimal, date, time, boolean or str.</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_user_defined_metadata(self) -&gt; dict[str, Any]:\n    \"\"\"Get all additional user-defined metadata for a document.\n\n    (Also available as \"self.user_defined_metadata\" property.)\n\n    Return a dict of str/value mapping.\n\n    Value types can be: Decimal, date, time, boolean or str.\n    \"\"\"\n    result: dict[str, Any] = {}\n    for item in self.get_elements(\"//meta:user-defined\"):\n        if not isinstance(item, Element):\n            continue\n        # Read the values\n        name = item.get_attribute_string(\"meta:name\")\n        if name is None:\n            continue\n        value = self._get_meta_value(item)\n        result[name] = value\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_user_defined_metadata_of_name","title":"<code>get_user_defined_metadata_of_name(keyname)</code>","text":"<p>Return the content of the user defined metadata of that name. Return None if no name matchs or a dic of fields.</p> <p>Arguments:</p> <pre><code>name -- string, name (meta:name content)\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_user_defined_metadata_of_name(self, keyname: str) -&gt; dict[str, Any] | None:\n    \"\"\"Return the content of the user defined metadata of that name.\n    Return None if no name matchs or a dic of fields.\n\n    Arguments:\n\n        name -- string, name (meta:name content)\n    \"\"\"\n    result = {}\n    found = False\n    for item in self.get_elements(\"//meta:user-defined\"):\n        if not isinstance(item, Element):\n            continue\n        # Read the values\n        name = item.get_attribute(\"meta:name\")\n        if name == keyname:\n            found = True\n            break\n    if not found:\n        return None\n    result[\"name\"] = name\n    value, value_type, text = self._get_meta_value(item, full=True)  # type: ignore\n    result[\"value\"] = value\n    result[\"value_type\"] = value_type\n    result[\"text\"] = text\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_auto_reload","title":"<code>set_auto_reload(delay, href='')</code>","text":"<p>Set the MetaAutoReload  element. Source code in <code>odfdo/meta.py</code> <pre><code>def set_auto_reload(self, delay: timedelta, href: str = \"\") -&gt; None:\n    \"\"\"Set the MetaAutoReload &lt;meta:auto-reload&gt; element.\"\"\"\n    autoreload = MetaAutoReload(delay=delay, href=href)\n    current = self.auto_reload\n    if isinstance(current, MetaAutoReload):\n        current.delete()\n    self.get_meta_body().append(autoreload)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_creation_date","title":"<code>set_creation_date(date=None)</code>","text":"<p>Set the creation date of the document.</p> <p>If provided datetime is None, use current time.</p> <p>(Also available as \u201cself.creation_date\u201d property.)</p> <p>Arguments:</p> <pre><code>date -- datetime\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_creation_date(self, date: datetime | None = None) -&gt; None:\n    \"\"\"Set the creation date of the document.\n\n    If provided datetime is None, use current time.\n\n    (Also available as \"self.creation_date\" property.)\n\n    Arguments:\n\n        date -- datetime\n    \"\"\"\n    element = self.get_element(\"//meta:creation-date\")\n    if element is None:\n        element = Element.from_tag(\"meta:creation-date\")\n        self.get_meta_body().append(element)\n    if date is None:\n        date = datetime.now()\n    element.text = DateTime.encode(date)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_description","title":"<code>set_description(description)</code>","text":"<p>Set the description of the document. Also known as comments.</p> <p>(Also available as \u201cself.description\u201d property.)</p> <p>Arguments:</p> <pre><code>description -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_description(self, description: str) -&gt; None:\n    \"\"\"Set the description of the document. Also known as comments.\n\n    (Also available as \"self.description\" property.)\n\n    Arguments:\n\n        description -- str\n    \"\"\"\n    element = self.get_element(\"//dc:description\")\n    if element is None:\n        element = Element.from_tag(\"dc:description\")\n        self.get_meta_body().append(element)\n    element.text = description\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_editing_cycles","title":"<code>set_editing_cycles(cycles)</code>","text":"<p>Set the number of times the document was edited.</p> <p>(Also available as \u201cself.editing_cycles\u201d property.)</p> <p>Arguments:</p> <pre><code>cycles -- int\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_editing_cycles(self, cycles: int) -&gt; None:\n    \"\"\"Set the number of times the document was edited.\n\n    (Also available as \"self.editing_cycles\" property.)\n\n    Arguments:\n\n        cycles -- int\n    \"\"\"\n    if not isinstance(cycles, int):\n        raise TypeError(\"cycles must be an int\")\n    if cycles &lt; 1:\n        raise ValueError(\"cycles must be a positive int\")\n    element = self.get_element(\"//meta:editing-cycles\")\n    if element is None:\n        element = Element.from_tag(\"meta:editing-cycles\")\n        self.get_meta_body().append(element)\n    element.text = str(cycles)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_editing_duration","title":"<code>set_editing_duration(duration)</code>","text":"<p>Set the time the document was edited.</p> <p>(Also available as \u201cself.editing_duration\u201d property.)</p> <p>Arguments:</p> <pre><code>duration -- timedelta\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_editing_duration(self, duration: timedelta) -&gt; None:\n    \"\"\"Set the time the document was edited.\n\n    (Also available as \"self.editing_duration\" property.)\n\n    Arguments:\n\n        duration -- timedelta\n    \"\"\"\n    if not isinstance(duration, timedelta):\n        raise TypeError(\"duration must be a timedelta\")\n    element = self.get_element(\"//meta:editing-duration\")\n    if element is None:\n        element = Element.from_tag(\"meta:editing-duration\")\n        self.get_meta_body().append(element)\n    element.text = Duration.encode(duration)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_generator","title":"<code>set_generator(generator)</code>","text":"<p>Set the signature of the software that generated this document.</p> <p>(Also available as \u201cself.generator\u201d property.)</p> <p>Arguments:</p> <pre><code>generator -- str\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_generator(\"Odfdo experiment\")\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_generator(self, generator: str) -&gt; None:\n    \"\"\"Set the signature of the software that generated this document.\n\n    (Also available as \"self.generator\" property.)\n\n    Arguments:\n\n        generator -- str\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_generator(\"Odfdo experiment\")\n    \"\"\"\n    self.generator = generator\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_generator_default","title":"<code>set_generator_default()</code>","text":"<p>Set the signature of the software that generated this document to ourself.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_generator_default()\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_generator_default(self) -&gt; None:\n    \"\"\"Set the signature of the software that generated this document\n    to ourself.\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_generator_default()\n    \"\"\"\n    if not self._generator_modified:\n        self.generator = GENERATOR\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_hyperlink_behaviour","title":"<code>set_hyperlink_behaviour(target_frame_name='_blank', show='replace')</code>","text":"<p>Set the MetaHyperlinkBehaviour  element. Source code in <code>odfdo/meta.py</code> <pre><code>def set_hyperlink_behaviour(\n    self,\n    target_frame_name: str = \"_blank\",\n    show: str = \"replace\",\n) -&gt; None:\n    \"\"\"Set the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element.\"\"\"\n    behaviour = MetaHyperlinkBehaviour(\n        target_frame_name=target_frame_name, show=show\n    )\n    current = self.hyperlink_behaviour\n    if isinstance(current, MetaHyperlinkBehaviour):\n        current.delete()\n    self.get_meta_body().append(behaviour)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_initial_creator","title":"<code>set_initial_creator(creator)</code>","text":"<p>Set the first creator of the document.</p> <p>(Also available as \u201cself.initial_creator\u201d property.)</p> <p>Arguments:</p> <pre><code>creator -- str\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_initial_creator(\"Plato\")\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_initial_creator(self, creator: str) -&gt; None:\n    \"\"\"Set the first creator of the document.\n\n    (Also available as \"self.initial_creator\" property.)\n\n    Arguments:\n\n        creator -- str\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_initial_creator(\"Plato\")\n    \"\"\"\n    element = self.get_element(\"//meta:initial-creator\")\n    if element is None:\n        element = Element.from_tag(\"meta:initial-creator\")\n        self.get_meta_body().append(element)\n    element.text = creator\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_keywords","title":"<code>set_keywords(keywords)</code>","text":"<p>Set the keywords of the document. Although the name is plural, a str string is required, so join your list first.</p> <p>(Also available as \u201cself.keyword\u201d and \u201cself.keywords\u201d property.)</p> <p>Arguments:</p> <pre><code>keywords -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_keywords(self, keywords: str) -&gt; None:\n    \"\"\"Set the keywords of the document. Although the name is plural, a\n    str string is required, so join your list first.\n\n    (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n    Arguments:\n\n        keywords -- str\n    \"\"\"\n    element = self.get_element(\"//meta:keyword\")\n    if element is None:\n        element = Element.from_tag(\"meta:keyword\")\n        self.get_meta_body().append(element)\n    element.text = keywords\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_language","title":"<code>set_language(language)</code>","text":"<p>Set the default language of the document.</p> <p>(Also available as \u201cself.language\u201d property.)</p> <p>Arguments:</p> <pre><code>language -- str\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_language('fr-FR')\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_language(self, language: str) -&gt; None:\n    \"\"\"Set the default language of the document.\n\n    (Also available as \"self.language\" property.)\n\n    Arguments:\n\n        language -- str\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_language('fr-FR')\n    \"\"\"\n    language = str(language)\n    if not self._is_RFC3066(language):\n        raise TypeError(\n            'Language must be \"xx\" lang or \"xx-YY\" lang-COUNTRY code (RFC3066)'\n        )\n    element = self.get_element(\"//dc:language\")\n    if element is None:\n        element = Element.from_tag(\"dc:language\")\n        self.get_meta_body().append(element)\n    element.text = language\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_statistic","title":"<code>set_statistic(statistic)</code>","text":"<p>Set the statistics about a document.</p> <p>(Also available as \u201cself.statistic\u201d property.)</p> <p>Arguments:</p> <pre><code>statistic -- dict\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; statistic = {'meta:table-count': 1,\n                 'meta:image-count': 2,\n                 'meta:object-count': 3,\n                 'meta:page-count': 4,\n                 'meta:paragraph-count': 5,\n                 'meta:word-count': 6,\n                 'meta:character-count': 7}\n&gt;&gt;&gt; document.meta.set_statistic(statistic)\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_statistic(self, statistic: dict[str, int]) -&gt; None:\n    \"\"\"Set the statistics about a document.\n\n    (Also available as \"self.statistic\" property.)\n\n    Arguments:\n\n        statistic -- dict\n\n    Example::\n\n        &gt;&gt;&gt; statistic = {'meta:table-count': 1,\n                         'meta:image-count': 2,\n                         'meta:object-count': 3,\n                         'meta:page-count': 4,\n                         'meta:paragraph-count': 5,\n                         'meta:word-count': 6,\n                         'meta:character-count': 7}\n        &gt;&gt;&gt; document.meta.set_statistic(statistic)\n    \"\"\"\n    if not isinstance(statistic, dict):\n        raise TypeError(\"Statistic must be a dict\")\n    element = self.get_element(\"//meta:document-statistic\")\n    for key, value in statistic.items():\n        try:\n            ivalue = int(value)\n        except ValueError as e:\n            raise TypeError(\"Statistic value must be a int\") from e\n        element.set_attribute(to_str(key), str(ivalue))\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_subject","title":"<code>set_subject(subject)</code>","text":"<p>Set the subject of the document.</p> <p>(Also available as \u201cself.subject\u201d property.)</p> <p>Arguments:</p> <pre><code>subject -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_subject(self, subject: str) -&gt; None:\n    \"\"\"Set the subject of the document.\n\n    (Also available as \"self.subject\" property.)\n\n    Arguments:\n\n        subject -- str\n    \"\"\"\n    element = self.get_element(\"//dc:subject\")\n    if element is None:\n        element = Element.from_tag(\"dc:subject\")\n        self.get_meta_body().append(element)\n    element.text = subject\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_template","title":"<code>set_template(date=None, href='', title='')</code>","text":"<p>Set the MetaTemplate  element. Source code in <code>odfdo/meta.py</code> <pre><code>def set_template(\n    self,\n    date: datetime | None = None,\n    href: str = \"\",\n    title: str = \"\",\n) -&gt; None:\n    \"\"\"Set the MetaTemplate &lt;meta:template&gt; element.\"\"\"\n    template = MetaTemplate(date=date, href=href, title=title)\n    current = self.template\n    if isinstance(current, MetaTemplate):\n        current.delete()\n    self.get_meta_body().append(template)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_title","title":"<code>set_title(title)</code>","text":"<p>Set the title of the document.</p> <p>This is not the first heading but the title metadata.</p> <p>(Also available as \u201cself.title\u201d property.)</p> <p>Arguments:</p> <pre><code>title -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_title(self, title: str) -&gt; None:\n    \"\"\"Set the title of the document.\n\n    This is not the first heading but the title metadata.\n\n    (Also available as \"self.title\" property.)\n\n    Arguments:\n\n        title -- str\n    \"\"\"\n    element = self.get_element(\"//dc:title\")\n    if element is None:\n        element = Element.from_tag(\"dc:title\")\n        self.get_meta_body().append(element)\n    element.text = title\n</code></pre>"},{"location":"reference.html#odfdo.MetaAutoReload","title":"<code>MetaAutoReload</code>","text":"<p>             Bases: <code>Element</code></p> Source code in <code>odfdo/meta_auto_reload.py</code> <pre><code>class MetaAutoReload(Element):\n    _tag = \"meta:auto-reload\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"delay\", \"meta:delay\"),\n        PropDef(\"actuate\", \"xlink:actuate\"),\n        PropDef(\"href\", \"xlink:href\"),\n        PropDef(\"show\", \"xlink:show\"),\n        PropDef(\"type\", \"xlink:type\"),\n    )\n\n    def __init__(\n        self,\n        delay: timedelta | None = None,\n        href: str = \"\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The &lt;meta:auto-reload&gt; element specifies whether a document is\n        reloaded or replaced by another document after a specified period\n        of time has elapsed.\n\n        Arguments:\n\n            delay -- timedelta\n\n            href -- str\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.actuate = \"onLoad\"\n        self.show = \"replace\"\n        self.type = \"simple\"\n        if self._do_init:\n            if not isinstance(delay, timedelta):\n                raise TypeError(\"delay must be a timedelta\")\n            self.delay = Duration.encode(delay)\n            self.href = href\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag} href={self.href} delay={Duration.decode(self.delay)}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return f\"({self.href})\"\n</code></pre>"},{"location":"reference.html#odfdo.MetaAutoReload.__init__","title":"<code>__init__(delay=None, href='', **kwargs)</code>","text":"<p>The  element specifies whether a document is reloaded or replaced by another document after a specified period of time has elapsed. <p>Arguments:</p> <pre><code>delay -- timedelta\n\nhref -- str\n</code></pre> Source code in <code>odfdo/meta_auto_reload.py</code> <pre><code>def __init__(\n    self,\n    delay: timedelta | None = None,\n    href: str = \"\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The &lt;meta:auto-reload&gt; element specifies whether a document is\n    reloaded or replaced by another document after a specified period\n    of time has elapsed.\n\n    Arguments:\n\n        delay -- timedelta\n\n        href -- str\n    \"\"\"\n    super().__init__(**kwargs)\n\n    self.actuate = \"onLoad\"\n    self.show = \"replace\"\n    self.type = \"simple\"\n    if self._do_init:\n        if not isinstance(delay, timedelta):\n            raise TypeError(\"delay must be a timedelta\")\n        self.delay = Duration.encode(delay)\n        self.href = href\n</code></pre>"},{"location":"reference.html#odfdo.MetaHyperlinkBehaviour","title":"<code>MetaHyperlinkBehaviour</code>","text":"<p>             Bases: <code>Element</code></p> Source code in <code>odfdo/meta_hyperlink_behaviour.py</code> <pre><code>class MetaHyperlinkBehaviour(Element):\n    _tag = \"meta:hyperlink-behaviour\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"target_frame_name\", \"office:target-frame-name\"),\n        PropDef(\"show\", \"xlink:show\"),\n    )\n\n    def __init__(\n        self,\n        target_frame_name: str = \"_blank\",\n        show: str = \"replace\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The &lt;meta:hyperlink-behaviour&gt; element specifies the default behavior\n        for hyperlinks in a document.\n\n        Arguments:\n\n            target_frame_name -- str\n\n            show -- str\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if self._do_init:\n            self.target_frame_name = target_frame_name\n            self.show = show\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;{self.__class__.__name__} tag={self.tag} \"\n            f\"target={self.target_frame_name} show={self.show}&gt;\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"({self.target_frame_name})\"\n</code></pre>"},{"location":"reference.html#odfdo.MetaHyperlinkBehaviour.__init__","title":"<code>__init__(target_frame_name='_blank', show='replace', **kwargs)</code>","text":"<p>The  element specifies the default behavior for hyperlinks in a document. <p>Arguments:</p> <pre><code>target_frame_name -- str\n\nshow -- str\n</code></pre> Source code in <code>odfdo/meta_hyperlink_behaviour.py</code> <pre><code>def __init__(\n    self,\n    target_frame_name: str = \"_blank\",\n    show: str = \"replace\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The &lt;meta:hyperlink-behaviour&gt; element specifies the default behavior\n    for hyperlinks in a document.\n\n    Arguments:\n\n        target_frame_name -- str\n\n        show -- str\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if self._do_init:\n        self.target_frame_name = target_frame_name\n        self.show = show\n</code></pre>"},{"location":"reference.html#odfdo.MetaTemplate","title":"<code>MetaTemplate</code>","text":"<p>             Bases: <code>Element</code></p> Source code in <code>odfdo/meta_template.py</code> <pre><code>class MetaTemplate(Element):\n    _tag = \"meta:template\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"date\", \"meta:date\"),\n        PropDef(\"actuate\", \"xlink:actuate\"),\n        PropDef(\"href\", \"xlink:href\"),\n        PropDef(\"title\", \"xlink:title\"),\n        PropDef(\"type\", \"xlink:type\"),\n    )\n\n    def __init__(\n        self,\n        date: datetime | None = None,\n        href: str = \"\",\n        title: str = \"\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The &lt;meta:template&gt; element specifies a IRI for the document template\n        that was used to create a document. The IRI is specified as an\n        Xlink.\n\n        Arguments:\n\n            date -- datetime or None\n\n            href -- str\n\n            title -- str\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.actuate = \"onRequest\"\n        self.type = \"simple\"\n        if self._do_init:\n            if date is None:\n                date = datetime.now()\n            self.date = DateTime.encode(date)\n            self.href = href\n            self.title = title\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag} href={self.href}&gt;\"\n\n    def __str__(self) -&gt; str:\n        if self.title:\n            return f\"[{self.title}]({self.href})\"\n        return f\"({self.href})\"\n</code></pre>"},{"location":"reference.html#odfdo.MetaTemplate.__init__","title":"<code>__init__(date=None, href='', title='', **kwargs)</code>","text":"<p>The  element specifies a IRI for the document template that was used to create a document. The IRI is specified as an Xlink. <p>Arguments:</p> <pre><code>date -- datetime or None\n\nhref -- str\n\ntitle -- str\n</code></pre> Source code in <code>odfdo/meta_template.py</code> <pre><code>def __init__(\n    self,\n    date: datetime | None = None,\n    href: str = \"\",\n    title: str = \"\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The &lt;meta:template&gt; element specifies a IRI for the document template\n    that was used to create a document. The IRI is specified as an\n    Xlink.\n\n    Arguments:\n\n        date -- datetime or None\n\n        href -- str\n\n        title -- str\n    \"\"\"\n    super().__init__(**kwargs)\n\n    self.actuate = \"onRequest\"\n    self.type = \"simple\"\n    if self._do_init:\n        if date is None:\n            date = datetime.now()\n        self.date = DateTime.encode(date)\n        self.href = href\n        self.title = title\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange","title":"<code>NamedRange</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF Named Range \u201ctable:named-range\u201d. Identifies inside the spreadsheet a range of cells of a table by a name and the name of the table.</p> <p>Name Ranges have the following attributes:</p> <pre><code>name -- name of the named range\n\ntable_name -- name of the table\n\nstart -- first cell of the named range, tuple (x, y)\n\nend -- last cell of the named range, tuple (x, y)\n\ncrange -- range of the named range, tuple (x, y, z, t)\n\nusage -- None or str, usage of the named range.\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>class NamedRange(Element):\n    \"\"\"ODF Named Range \"table:named-range\". Identifies inside the spreadsheet\n    a range of cells of a table by a name and the name of the table.\n\n    Name Ranges have the following attributes:\n\n        name -- name of the named range\n\n        table_name -- name of the table\n\n        start -- first cell of the named range, tuple (x, y)\n\n        end -- last cell of the named range, tuple (x, y)\n\n        crange -- range of the named range, tuple (x, y, z, t)\n\n        usage -- None or str, usage of the named range.\n    \"\"\"\n\n    _tag = \"table:named-range\"\n\n    def __init__(\n        self,\n        name: str | None = None,\n        crange: str | tuple | list | None = None,\n        table_name: str | None = None,\n        usage: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a Named Range element. 'name' must contains only letters, digits\n           and '_', and must not be like a coordinate as 'A1'. 'table_name' must be\n           a correct table name (no \"'\" or \"/\" in it).\n\n        Arguments:\n\n             name -- str, name of the named range\n\n             crange -- str or tuple of int, cell or area coordinate\n\n             table_name -- str, name of the table\n\n             usage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n        \"\"\"\n        super().__init__(**kwargs)\n        self.usage = None\n        if self._do_init:\n            self.name = name or \"\"\n            self.table_name = _table_name_check(table_name)\n            self.set_range(crange or \"\")\n            self.set_usage(usage)\n        cell_range_address = self.get_attribute_string(\"table:cell-range-address\") or \"\"\n        if not cell_range_address:\n            self.table_name = \"\"\n            self.start = None\n            self.end = None\n            self.crange = None\n            self.usage = None\n            return\n        self.usage = self.get_attribute(\"table:range-usable-as\")\n        name_range = cell_range_address.replace(\"$\", \"\")\n        name, crange = name_range.split(\".\", 1)\n        if name.startswith(\"'\") and name.endswith(\"'\"):\n            name = name[1:-1]\n        self.table_name = name\n        crange = crange.replace(\".\", \"\")\n        self._set_range(crange)\n\n    def set_usage(self, usage: str | None = None) -&gt; None:\n        \"\"\"Set the usage of the Named Range. Usage can be None (default) or one\n        of :\n            'print-range'\n            'filter'\n            'repeat-column'\n            'repeat-row'\n\n        Arguments:\n\n            usage -- None or str\n        \"\"\"\n        if usage is not None:\n            usage = usage.strip().lower()\n            if usage not in (\"print-range\", \"filter\", \"repeat-column\", \"repeat-row\"):\n                usage = None\n        if usage is None:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:range-usable-as\")\n            self.usage = None\n        else:\n            self.set_attribute(\"table:range-usable-as\", usage)\n            self.usage = usage\n\n    @property\n    def name(self) -&gt; str | None:\n        \"\"\"Get / set the name of the table.\"\"\"\n        return self.get_attribute_string(\"table:name\")\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"Set the name of the Named Range. The name is mandatory, if a Named\n        Range of the same name exists, it will be replaced. Name must contains\n        only alphanumerics characters and '_', and can not be of a cell\n        coordinates form like 'AB12'.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name required.\")\n        for x in name:\n            if x in forbidden_in_named_range():\n                raise ValueError(f\"Character forbidden '{x}' \")\n        step = \"\"\n        for x in name:\n            if x in string.ascii_letters and step in (\"\", \"A\"):\n                step = \"A\"\n                continue\n            elif step in (\"A\", \"A1\") and x in string.digits:\n                step = \"A1\"\n                continue\n            else:\n                step = \"\"\n                break\n        if step == \"A1\":\n            raise ValueError(\"Name of the type 'ABC123' is not allowed.\")\n        with contextlib.suppress(Exception):\n            # we are not on an inserted in a document.\n            body = self.document_body\n            named_range = body.get_named_range(name)  # type: ignore\n            if named_range:\n                named_range.delete()\n        self.set_attribute(\"table:name\", name)\n\n    def set_table_name(self, name: str) -&gt; None:\n        \"\"\"Set the name of the table of the Named Range. The name is mandatory.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        self.table_name = _table_name_check(name)\n        self._update_attributes()\n\n    def _set_range(self, coord: tuple | list | str) -&gt; None:\n        digits = convert_coordinates(coord)\n        if len(digits) == 4:\n            x, y, z, t = digits\n        else:\n            x, y = digits\n            z, t = digits\n        self.start = x, y  # type: ignore\n        self.end = z, t  # type: ignore\n        self.crange = x, y, z, t  # type: ignore\n\n    def set_range(self, crange: str | tuple | list) -&gt; None:\n        \"\"\"Set the range of the named range. Range can be either one cell\n        (like 'A1') or an area ('A1:B2'). It can be provided as an alpha numeric\n        value like \"A1:B2' or a tuple like (0, 0, 1, 1) or (0, 0).\n\n        Arguments:\n\n            crange -- str or tuple of int, cell or area coordinate\n        \"\"\"\n        self._set_range(crange)\n        self._update_attributes()\n\n    def _update_attributes(self) -&gt; None:\n        self.set_attribute(\"table:base-cell-address\", self._make_base_cell_address())\n        self.set_attribute(\"table:cell-range-address\", self._make_cell_range_address())\n\n    def _make_base_cell_address(self) -&gt; str:\n        # assuming we got table_name and range\n        if \" \" in self.table_name:\n            name = f\"'{self.table_name}'\"\n        else:\n            name = self.table_name\n        return f\"${name}.${digit_to_alpha(self.start[0])}${self.start[1] + 1}\"  # type: ignore\n\n    def _make_cell_range_address(self) -&gt; str:\n        # assuming we got table_name and range\n        if \" \" in self.table_name:\n            name = f\"'{self.table_name}'\"\n        else:\n            name = self.table_name\n        if self.start == self.end:\n            return self._make_base_cell_address()\n        return (\n            f\"${name}.${digit_to_alpha(self.start[0])}${self.start[1] + 1}:\"  # type: ignore\n            f\".${digit_to_alpha(self.end[0])}${self.end[1] + 1}\"  # type: ignore\n        )\n\n    def get_values(\n        self,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n        flat: bool = False,\n    ) -&gt; list:\n        \"\"\"Shortcut to retrieve the values of the cells of the named range. See\n        table.get_values() for the arguments description and return format.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore\n\n    def get_value(self, get_type: bool = False) -&gt; Any:\n        \"\"\"Shortcut to retrieve the value of the first cell of the named range.\n        See table.get_value() for the arguments description and return format.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        return table.get_value(self.start, get_type)  # type: ignore\n\n    def set_values(\n        self,\n        values: list,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the values of the cells of the named range.\n        See table.set_values() for the arguments description.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        table.set_values(  # type: ignore\n            values,\n            coord=self.crange,\n            style=style,\n            cell_type=cell_type,\n            currency=currency,\n        )\n\n    def set_value(\n        self,\n        value: Any,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the value of the first cell of the named range.\n        See table.set_value() for the arguments description.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        table.set_value(  # type: ignore\n            coord=self.start,\n            value=value,\n            cell_type=cell_type,\n            currency=currency,\n            style=style,\n        )\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.name","title":"<code>name: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the name of the table.</p>"},{"location":"reference.html#odfdo.NamedRange.__init__","title":"<code>__init__(name=None, crange=None, table_name=None, usage=None, **kwargs)</code>","text":"<p>Create a Named Range element. \u2018name\u2019 must contains only letters, digits    and \u2018_\u2019, and must not be like a coordinate as \u2018A1\u2019. \u2018table_name\u2019 must be    a correct table name (no \u201c\u2019\u201d or \u201c/\u201d in it).</p> <p>Arguments:</p> <pre><code> name -- str, name of the named range\n\n crange -- str or tuple of int, cell or area coordinate\n\n table_name -- str, name of the table\n\n usage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    crange: str | tuple | list | None = None,\n    table_name: str | None = None,\n    usage: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a Named Range element. 'name' must contains only letters, digits\n       and '_', and must not be like a coordinate as 'A1'. 'table_name' must be\n       a correct table name (no \"'\" or \"/\" in it).\n\n    Arguments:\n\n         name -- str, name of the named range\n\n         crange -- str or tuple of int, cell or area coordinate\n\n         table_name -- str, name of the table\n\n         usage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n    \"\"\"\n    super().__init__(**kwargs)\n    self.usage = None\n    if self._do_init:\n        self.name = name or \"\"\n        self.table_name = _table_name_check(table_name)\n        self.set_range(crange or \"\")\n        self.set_usage(usage)\n    cell_range_address = self.get_attribute_string(\"table:cell-range-address\") or \"\"\n    if not cell_range_address:\n        self.table_name = \"\"\n        self.start = None\n        self.end = None\n        self.crange = None\n        self.usage = None\n        return\n    self.usage = self.get_attribute(\"table:range-usable-as\")\n    name_range = cell_range_address.replace(\"$\", \"\")\n    name, crange = name_range.split(\".\", 1)\n    if name.startswith(\"'\") and name.endswith(\"'\"):\n        name = name[1:-1]\n    self.table_name = name\n    crange = crange.replace(\".\", \"\")\n    self._set_range(crange)\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.get_value","title":"<code>get_value(get_type=False)</code>","text":"<p>Shortcut to retrieve the value of the first cell of the named range. See table.get_value() for the arguments description and return format.</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_value(self, get_type: bool = False) -&gt; Any:\n    \"\"\"Shortcut to retrieve the value of the first cell of the named range.\n    See table.get_value() for the arguments description and return format.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    return table.get_value(self.start, get_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.get_values","title":"<code>get_values(cell_type=None, complete=True, get_type=False, flat=False)</code>","text":"<p>Shortcut to retrieve the values of the cells of the named range. See table.get_values() for the arguments description and return format.</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_values(\n    self,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n    flat: bool = False,\n) -&gt; list:\n    \"\"\"Shortcut to retrieve the values of the cells of the named range. See\n    table.get_values() for the arguments description and return format.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_range","title":"<code>set_range(crange)</code>","text":"<p>Set the range of the named range. Range can be either one cell (like \u2018A1\u2019) or an area (\u2018A1:B2\u2019). It can be provided as an alpha numeric value like \u201cA1:B2\u2019 or a tuple like (0, 0, 1, 1) or (0, 0).</p> <p>Arguments:</p> <pre><code>crange -- str or tuple of int, cell or area coordinate\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_range(self, crange: str | tuple | list) -&gt; None:\n    \"\"\"Set the range of the named range. Range can be either one cell\n    (like 'A1') or an area ('A1:B2'). It can be provided as an alpha numeric\n    value like \"A1:B2' or a tuple like (0, 0, 1, 1) or (0, 0).\n\n    Arguments:\n\n        crange -- str or tuple of int, cell or area coordinate\n    \"\"\"\n    self._set_range(crange)\n    self._update_attributes()\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_table_name","title":"<code>set_table_name(name)</code>","text":"<p>Set the name of the table of the Named Range. The name is mandatory.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_table_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the table of the Named Range. The name is mandatory.\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    self.table_name = _table_name_check(name)\n    self._update_attributes()\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_usage","title":"<code>set_usage(usage=None)</code>","text":"<p>Set the usage of the Named Range. Usage can be None (default) or one of :     \u2018print-range\u2019     \u2018filter\u2019     \u2018repeat-column\u2019     \u2018repeat-row\u2019</p> <p>Arguments:</p> <pre><code>usage -- None or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_usage(self, usage: str | None = None) -&gt; None:\n    \"\"\"Set the usage of the Named Range. Usage can be None (default) or one\n    of :\n        'print-range'\n        'filter'\n        'repeat-column'\n        'repeat-row'\n\n    Arguments:\n\n        usage -- None or str\n    \"\"\"\n    if usage is not None:\n        usage = usage.strip().lower()\n        if usage not in (\"print-range\", \"filter\", \"repeat-column\", \"repeat-row\"):\n            usage = None\n    if usage is None:\n        with contextlib.suppress(KeyError):\n            self.del_attribute(\"table:range-usable-as\")\n        self.usage = None\n    else:\n        self.set_attribute(\"table:range-usable-as\", usage)\n        self.usage = usage\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_value","title":"<code>set_value(value, cell_type=None, currency=None, style=None)</code>","text":"<p>Shortcut to set the value of the first cell of the named range. See table.set_value() for the arguments description.</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_value(\n    self,\n    value: Any,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the value of the first cell of the named range.\n    See table.set_value() for the arguments description.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    table.set_value(  # type: ignore\n        coord=self.start,\n        value=value,\n        cell_type=cell_type,\n        currency=currency,\n        style=style,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_values","title":"<code>set_values(values, style=None, cell_type=None, currency=None)</code>","text":"<p>Shortcut to set the values of the cells of the named range. See table.set_values() for the arguments description.</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_values(\n    self,\n    values: list,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the values of the cells of the named range.\n    See table.set_values() for the arguments description.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    table.set_values(  # type: ignore\n        values,\n        coord=self.crange,\n        style=style,\n        cell_type=cell_type,\n        currency=currency,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Note","title":"<code>Note</code>","text":"<p>             Bases: <code>Element</code></p> <p>Either a footnote or a endnote element with the given text, optionally referencing it using the given note_id.</p> <p>Arguments:</p> <pre><code>note_class -- 'footnote' or 'endnote'\n\nnote_id -- str\n\ncitation -- str\n\nbody -- str or Element\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>class Note(Element):\n    \"\"\"Either a footnote or a endnote element with the given text,\n    optionally referencing it using the given note_id.\n\n    Arguments:\n\n        note_class -- 'footnote' or 'endnote'\n\n        note_id -- str\n\n        citation -- str\n\n        body -- str or Element\n    \"\"\"\n\n    _tag = \"text:note\"\n    _properties = (\n        PropDef(\"note_class\", \"text:note-class\"),\n        PropDef(\"note_id\", \"text:id\"),\n    )\n\n    def __init__(\n        self,\n        note_class: str = \"footnote\",\n        note_id: str | None = None,\n        citation: str | None = None,\n        body: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.insert(Element.from_tag(\"text:note-body\"), position=0)\n            self.insert(Element.from_tag(\"text:note-citation\"), position=0)\n            self.note_class = note_class\n            if note_id is not None:\n                self.note_id = note_id\n            if citation is not None:\n                self.citation = citation\n            if body is not None:\n                self.note_body = body\n\n    @property\n    def citation(self) -&gt; str:\n        note_citation = self.get_element(\"text:note-citation\")\n        if note_citation:\n            return note_citation.text\n        return \"\"\n\n    @citation.setter\n    def citation(self, text: str | None) -&gt; None:\n        note_citation = self.get_element(\"text:note-citation\")\n        if note_citation:\n            note_citation.text = text  # type:ignore\n\n    @property\n    def note_body(self) -&gt; str:\n        note_body = self.get_element(\"text:note-body\")\n        if note_body:\n            return note_body.text_content\n        return \"\"\n\n    @note_body.setter\n    def note_body(self, text_or_element: Element | str | None) -&gt; None:\n        note_body = self.get_element(\"text:note-body\")\n        if not note_body:\n            return None\n        if text_or_element is None:\n            note_body.text_content = \"\"\n        elif isinstance(text_or_element, str):\n            note_body.text_content = text_or_element\n        elif isinstance(text_or_element, Element):\n            note_body.clear()\n            note_body.append(text_or_element)\n        else:\n            raise TypeError(f'Unexpected type for body: \"{type(text_or_element)}\"')\n\n    def check_validity(self) -&gt; None:\n        if not self.note_class:\n            raise ValueError('Note class must be \"footnote\" or \"endnote\"')\n        if not self.note_id:\n            raise ValueError(\"Note must have an id\")\n        if not self.citation:\n            raise ValueError(\"Note must have a citation\")\n        if not self.note_body:\n            pass\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph","title":"<code>Paragraph</code>","text":"<p>             Bases: <code>ParagraphBase</code></p> <p>Specialised element for paragraphs \u201ctext:p\u201d. The \u201ctext:p\u201d element represents a paragraph, which is the basic unit of text in an OpenDocument file.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>class Paragraph(ParagraphBase):\n    \"\"\"Specialised element for paragraphs \"text:p\". The \"text:p\" element\n    represents a paragraph, which is the basic unit of text in an OpenDocument\n    file.\n    \"\"\"\n\n    _tag = \"text:p\"\n\n    def __init__(\n        self,\n        text_or_element: str | Element | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ):\n        \"\"\"Create a paragraph element of the given style containing the optional\n        given text.\n\n        Arguments:\n\n            text -- str or Element\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if isinstance(text_or_element, Element):\n                self.append(text_or_element)\n            else:\n                self.text = text_or_element  # type:ignore\n            if style is not None:\n                self.style = style\n\n    def insert_note(\n        self,\n        note_element: Note | None = None,\n        after: str | Element | None = None,\n        note_class: str = \"footnote\",\n        note_id: str | None = None,\n        citation: str | None = None,\n        body: str | None = None,\n    ) -&gt; None:\n        if note_element is None:\n            note_element = Note(\n                note_class=note_class, note_id=note_id, citation=citation, body=body\n            )\n        else:\n            # XXX clone or modify the argument?\n            if note_class:\n                note_element.note_class = note_class\n            if note_id:\n                note_element.note_id = note_id\n            if citation:\n                note_element.citation = citation\n            if body:\n                note_element.note_body = body\n        note_element.check_validity()\n        if isinstance(after, str):\n            self._insert(note_element, after=after, main_text=True)\n        elif isinstance(after, Element):\n            after.insert(note_element, FIRST_CHILD)\n        else:\n            self.insert(note_element, FIRST_CHILD)\n\n    def insert_annotation(  # noqa: C901\n        self,\n        annotation_element: Annotation | None = None,\n        before: str | None = None,\n        after: str | Element | None = None,\n        position: int | tuple = 0,\n        content: str | Element | None = None,\n        body: str | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n    ) -&gt; Annotation:\n        \"\"\"Insert an annotation, at the position defined by the regex (before,\n        after, content) or by positionnal argument (position). If content is\n        provided, the annotation covers the full content regex. Else, the\n        annotation is positionned either 'before' or 'after' provided regex.\n\n        If content is an odf element (ie: paragraph, span, ...), the full inner\n        content is covered by the annotation (of the position just after if\n        content is a single empty tag).\n\n        If content/before or after exists (regex) and return a group of matching\n        positions, the position value is the index of matching place to use.\n\n        annotation_element can contain a previously created annotation, else\n        the annotation is created from the body, creator and optional date\n        (current date by default).\n\n        Arguments:\n\n            annotation_element -- Annotation or None\n\n            before -- str regular expression or None\n\n            after -- str regular expression or Element or None\n\n            content -- str regular expression or None, or Element\n\n            position -- int or tuple of int\n\n            body -- str or Element\n\n            creator -- str\n\n            date -- datetime\n        \"\"\"\n\n        if annotation_element is None:\n            annotation_element = Annotation(\n                text_or_element=body, creator=creator, date=date, parent=self\n            )\n        else:\n            # XXX clone or modify the argument?\n            if body:\n                annotation_element.note_body = body\n            if creator:\n                annotation_element.creator = creator\n            if date:\n                annotation_element.date = date\n        annotation_element.check_validity()\n\n        # special case: content is an odf element (ie: a paragraph)\n        if isinstance(content, Element):\n            if content.is_empty():\n                content.insert(annotation_element, xmlposition=NEXT_SIBLING)\n                return annotation_element\n            content.insert(annotation_element, start=True)\n            annotation_end = AnnotationEnd(annotation_element)\n            content.append(annotation_end)\n            return annotation_element\n\n        # special case\n        if isinstance(after, Element):\n            after.insert(annotation_element, FIRST_CHILD)\n            return annotation_element\n\n        # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and content is not None\n            and isinstance(position, int)\n        ):\n            # Start tag\n            self._insert(\n                annotation_element, before=content, position=position, main_text=True\n            )\n            # End tag\n            annotation_end = AnnotationEnd(annotation_element)\n            self._insert(\n                annotation_end, after=content, position=position, main_text=True\n            )\n            return annotation_element\n\n        # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and content is None\n            and isinstance(position, tuple)\n        ):\n            # Start\n            self._insert(annotation_element, position=position[0], main_text=True)\n            # End\n            annotation_end = AnnotationEnd(annotation_element)\n            self._insert(annotation_end, position=position[1], main_text=True)\n            return annotation_element\n\n        # Without \"content\" nor \"position\"\n        if content is not None or not isinstance(position, int):\n            raise ValueError(\"Bad arguments\")\n\n        # Insert\n        self._insert(\n            annotation_element,\n            before=before,\n            after=after,\n            position=position,\n            main_text=True,\n        )\n        return annotation_element\n\n    def insert_annotation_end(\n        self,\n        annotation_element: Annotation,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n    ) -&gt; AnnotationEnd:\n        \"\"\"Insert an annotation end tag for an existing annotation. If some end\n        tag already exists, replace it. Annotation end tag is set at the\n        position defined by the regex (before or after).\n\n        If content/before or after (regex) returns a group of matching\n        positions, the position value is the index of matching place to use.\n\n        Arguments:\n\n            annotation_element -- Annotation (mandatory)\n\n            before -- str regular expression or None\n\n            after -- str regular expression or None\n\n            position -- int\n        \"\"\"\n\n        if annotation_element is None:\n            raise ValueError\n        if not isinstance(annotation_element, Annotation):\n            raise TypeError(\"Not a &lt;office:annotation&gt; Annotation\")\n\n        # remove existing end tag\n        name = annotation_element.name\n        existing_end_tag = self.get_annotation_end(name=name)\n        if existing_end_tag:\n            existing_end_tag.delete()\n\n        # create the end tag\n        end_tag = AnnotationEnd(annotation_element)\n\n        # Insert\n        self._insert(\n            end_tag, before=before, after=after, position=position, main_text=True\n        )\n        return end_tag\n\n    def set_reference_mark(\n        self,\n        name: str,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n        content: str | Element | None = None,\n    ) -&gt; Element:\n        \"\"\"Insert a reference mark, at the position defined by the regex\n        (before, after, content) or by positionnal argument (position). If\n        content is provided, the annotation covers the full range content regex\n        (instances of ReferenceMarkStart and ReferenceMarkEnd are\n        created). Else, an instance of ReferenceMark is positionned either\n        'before' or 'after' provided regex.\n\n        If content is an ODF Element (ie: Paragraph, Span, ...), the full inner\n        content is referenced (of the position just after if content is a single\n        empty tag).\n\n        If content/before or after exists (regex) and return a group of matching\n        positions, the position value is the index of matching place to use.\n\n        Name is mandatory and shall be unique in the document for the preference\n        mark range.\n\n        Arguments:\n\n            name -- str\n\n            before -- str regular expression or None\n\n            after -- str regular expression or None,\n\n            content -- str regular expression or None, or Element\n\n            position -- int or tuple of int\n\n        Return: the created ReferenceMark or ReferenceMarkStart\n        \"\"\"\n        # special case: content is an odf element (ie: a paragraph)\n        if isinstance(content, Element):\n            if content.is_empty():\n                reference = ReferenceMark(name)\n                content.insert(reference, xmlposition=NEXT_SIBLING)\n                return reference\n            reference_start = ReferenceMarkStart(name)\n            content.insert(reference_start, start=True)\n            reference_end = ReferenceMarkEnd(name)\n            content.append(reference_end)\n            return reference_start\n\n        # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n        # reference\n        if (\n            before is None\n            and after is None\n            and content is not None\n            and isinstance(position, int)\n        ):\n            # Start tag\n            reference_start = ReferenceMarkStart(name)\n            self._insert(\n                reference_start, before=content, position=position, main_text=True\n            )\n            # End tag\n            reference_end = ReferenceMarkEnd(name)\n            self._insert(\n                reference_end, after=content, position=position, main_text=True\n            )\n            return reference_start\n\n        # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n        if (\n            before is None\n            and after is None\n            and content is None\n            and isinstance(position, tuple)\n        ):\n            # Start\n            reference_start = ReferenceMarkStart(name)\n            self._insert(reference_start, position=position[0], main_text=True)\n            # End\n            reference_end = ReferenceMarkEnd(name)\n            self._insert(reference_end, position=position[1], main_text=True)\n            return reference_start\n\n        # Without \"content\" nor \"position\"\n        if content is not None or not isinstance(position, int):\n            raise ValueError(\"bad arguments\")\n\n        # Insert a positional reference mark\n        reference = ReferenceMark(name)\n        self._insert(\n            reference,\n            before=before,\n            after=after,\n            position=position,\n            main_text=True,\n        )\n        return reference\n\n    def set_reference_mark_end(\n        self,\n        reference_mark: Element,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n    ) -&gt; ReferenceMarkEnd:\n        \"\"\"Insert/move a ReferenceMarkEnd for an existing reference mark. If\n        some end tag already exists, replace it. Reference tag is set at the\n        position defined by the regex (before or after).\n\n        If content/before or after (regex) returns a group of matching\n        positions, the position value is the index of matching place to use.\n\n        Arguments:\n\n            reference_mark -- ReferenceMark or ReferenceMarkStart (mandatory)\n\n            before -- str regular expression or None\n\n            after -- str regular expression or None\n\n            position -- int\n        \"\"\"\n        if not isinstance(reference_mark, (ReferenceMark, ReferenceMarkStart)):\n            raise TypeError(\"Not a ReferenceMark or ReferenceMarkStart\")\n        name = reference_mark.name\n        if isinstance(reference_mark, ReferenceMark):\n            # change it to a range reference:\n            reference_mark.tag = ReferenceMarkStart._tag\n\n        existing_end_tag = self.get_reference_mark_end(name=name)\n        if existing_end_tag:\n            existing_end_tag.delete()\n\n        # create the end tag\n        end_tag = ReferenceMarkEnd(name)\n\n        # Insert\n        self._insert(\n            end_tag, before=before, after=after, position=position, main_text=True\n        )\n        return end_tag\n\n    def insert_variable(self, variable_element: Element, after: str | None) -&gt; None:\n        self._insert(variable_element, after=after, main_text=True)\n\n    @_by_regex_offset\n    def set_span(\n        self,\n        match: str,\n        tail: str,\n        style: str,\n        regex: str | None = None,\n        offset: int | None = None,\n        length: int = 0,\n    ) -&gt; Span:\n        \"\"\"\n        set_span(style, regex=None, offset=None, length=0)\n        Apply the given style to text content matching the regex OR the\n        positional arguments offset and length.\n\n        (match, tail: provided by regex decorator)\n\n        Arguments:\n\n            style -- str\n\n            regex -- str regular expression\n\n            offset -- int\n\n            length -- int\n        \"\"\"\n        span = Span(match, style=style)\n        span.tail = tail\n        return span\n\n    def remove_spans(self, keep_heading: bool = True) -&gt; Element | list:\n        \"\"\"Send back a copy of the element, without span styles.\n        If keep_heading is True (default), the first level heading style is left\n        unchanged.\n        \"\"\"\n        strip = (Span._tag,)\n        if keep_heading:\n            protect = (\"text:h\",)\n        else:\n            protect = None\n        return self.strip_tags(strip=strip, protect=protect)\n\n    def remove_span(self, spans: Element | list[Element]) -&gt; Element | list:\n        \"\"\"Send back a copy of the element, the spans (not a clone) removed.\n\n        Arguments:\n\n            spans -- Element or list of Element\n        \"\"\"\n        return self.strip_elements(spans)\n\n    @_by_regex_offset\n    def set_link(\n        self,\n        match: str,\n        tail: str,\n        url: str,\n        regex: str | None = None,\n        offset: int | None = None,\n        length: int = 0,\n    ) -&gt; Element:\n        \"\"\"\n        set_link(url, regex=None, offset=None, length=0)\n        Make a link to the provided url from text content matching the regex\n        OR the positional arguments offset and length.\n\n        (match, tail: provided by regex decorator)\n\n        Arguments:\n\n            url -- str\n\n            regex -- str regular expression\n\n            offset -- int\n\n            length -- int\n        \"\"\"\n        link = Link(url, text=match)\n        link.tail = tail\n        return link\n\n    def remove_links(self) -&gt; Element | list:\n        \"\"\"Send back a copy of the element, without links tags.\"\"\"\n        strip = (Link._tag,)\n        return self.strip_tags(strip=strip)\n\n    def remove_link(self, links: Link | list[Link]) -&gt; Element | list:\n        \"\"\"Send back a copy of the element (not a clone), with the sub links\n           removed.\n\n        Arguments:\n\n            links -- Link or list of Link\n        \"\"\"\n        return self.strip_elements(links)\n\n    def insert_reference(\n        self,\n        name: str,\n        ref_format: str = \"\",\n        before: str | None = None,\n        after: str | Element | None = None,\n        position: int = 0,\n        display: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create and insert a reference to a content marked by a reference\n        mark. The Reference element (\"text:reference-ref\") represents a\n        field that references a \"text:reference-mark-start\" or\n        \"text:reference-mark\" element. Its \"text:reference-format\" attribute\n        specifies what is displayed from the referenced element. Default is\n        'page'. Actual content is not automatically updated except for the 'text'\n        format.\n\n        name is mandatory and should represent an existing reference mark of the\n        document.\n\n        ref_format is the argument for format reference (default is 'page').\n\n        The reference is inserted the position defined by the regex (before /\n        after), or by positionnal argument (position). If 'display' is provided,\n        it will be used as the text value for the reference.\n\n        If after is an ODF Element, the reference is inserted as first child of\n        this element.\n\n        Arguments:\n\n            name -- str\n\n            ref_format -- one of : 'chapter', 'direction', 'page', 'text',\n                                    'caption', 'category-and-value', 'value',\n                                    'number', 'number-all-superior',\n                                    'number-no-superior'\n\n            before -- str regular expression or None\n\n            after -- str regular expression or odf element or None\n\n            position -- int\n\n            display -- str or None\n        \"\"\"\n        reference = Reference(name, ref_format)\n        if display is None and ref_format == \"text\":\n            # get reference content\n            body = self.document_body\n            if not body:\n                body = self.root\n            mark = body.get_reference_mark(name=name)\n            if mark:\n                display = mark.referenced_text  # type: ignore\n        if not display:\n            display = \" \"\n        reference.text = display\n        if isinstance(after, Element):\n            after.insert(reference, FIRST_CHILD)\n        else:\n            self._insert(\n                reference, before=before, after=after, position=position, main_text=True\n            )\n\n    def set_bookmark(\n        self,\n        name: str,\n        before: str | None = None,\n        after: str | None = None,\n        position: int | tuple = 0,\n        role: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | tuple[Element, Element]:\n        \"\"\"Insert a bookmark before or after the characters in the text which\n        match the regex before/after. When the regex matches more of one part\n        of the text, position can be set to choose which part must be used.\n        If before and after are None, we use only position that is the number\n        of characters.\n\n        So, by default, this function inserts a bookmark before the first\n        character of the content. Role can be None, \"start\" or \"end\", we\n        insert respectively a position bookmark a bookmark-start or a\n        bookmark-end.\n\n        If content is not None these 2 calls are equivalent:\n\n          paragraph.set_bookmark(\"bookmark\", content=\"xyz\")\n\n        and:\n\n          paragraph.set_bookmark(\"bookmark\", before=\"xyz\", role=\"start\")\n          paragraph.set_bookmark(\"bookmark\", after=\"xyz\", role=\"end\")\n\n\n        If position is a 2-tuple, these 2 calls are equivalent:\n\n          paragraph.set_bookmark(\"bookmark\", position=(10, 20))\n\n        and:\n\n          paragraph.set_bookmark(\"bookmark\", position=10, role=\"start\")\n          paragraph.set_bookmark(\"bookmark\", position=20, role=\"end\")\n\n\n        Arguments:\n\n            name -- str\n\n            before -- str regex\n\n            after -- str regex\n\n            position -- int or (int, int)\n\n            role -- None, \"start\" or \"end\"\n\n            content -- str regex\n        \"\"\"\n        # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and role is None\n            and content is not None\n            and isinstance(position, int)\n        ):\n            # Start\n            start = BookmarkStart(name)\n            self._insert(start, before=content, position=position, main_text=True)\n            # End\n            end = BookmarkEnd(name)\n            self._insert(end, after=content, position=position, main_text=True)\n            return start, end\n\n        # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and role is None\n            and content is None\n            and isinstance(position, tuple)\n        ):\n            # Start\n            start = BookmarkStart(name)\n            self._insert(start, position=position[0], main_text=True)\n            # End\n            end = BookmarkEnd(name)\n            self._insert(end, position=position[1], main_text=True)\n            return start, end\n\n        # Without \"content\" nor \"position\"\n        if content is not None or not isinstance(position, int):\n            raise ValueError(\"bad arguments\")\n\n        # Role\n        if role is None:\n            bookmark: Element = Bookmark(name)\n        elif role == \"start\":\n            bookmark = BookmarkStart(name)\n        elif role == \"end\":\n            bookmark = BookmarkEnd(name)\n        else:\n            raise ValueError(\"bad arguments\")\n\n        # Insert\n        self._insert(\n            bookmark, before=before, after=after, position=position, main_text=True\n        )\n\n        return bookmark\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.__init__","title":"<code>__init__(text_or_element=None, style=None, **kwargs)</code>","text":"<p>Create a paragraph element of the given style containing the optional given text.</p> <p>Arguments:</p> <pre><code>text -- str or Element\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def __init__(\n    self,\n    text_or_element: str | Element | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n):\n    \"\"\"Create a paragraph element of the given style containing the optional\n    given text.\n\n    Arguments:\n\n        text -- str or Element\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if isinstance(text_or_element, Element):\n            self.append(text_or_element)\n        else:\n            self.text = text_or_element  # type:ignore\n        if style is not None:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.insert_annotation","title":"<code>insert_annotation(annotation_element=None, before=None, after=None, position=0, content=None, body=None, creator=None, date=None)</code>","text":"<p>Insert an annotation, at the position defined by the regex (before, after, content) or by positionnal argument (position). If content is provided, the annotation covers the full content regex. Else, the annotation is positionned either \u2018before\u2019 or \u2018after\u2019 provided regex.</p> <p>If content is an odf element (ie: paragraph, span, \u2026), the full inner content is covered by the annotation (of the position just after if content is a single empty tag).</p> <p>If content/before or after exists (regex) and return a group of matching positions, the position value is the index of matching place to use.</p> <p>annotation_element can contain a previously created annotation, else the annotation is created from the body, creator and optional date (current date by default).</p> <p>Arguments:</p> <pre><code>annotation_element -- Annotation or None\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or Element or None\n\ncontent -- str regular expression or None, or Element\n\nposition -- int or tuple of int\n\nbody -- str or Element\n\ncreator -- str\n\ndate -- datetime\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def insert_annotation(  # noqa: C901\n    self,\n    annotation_element: Annotation | None = None,\n    before: str | None = None,\n    after: str | Element | None = None,\n    position: int | tuple = 0,\n    content: str | Element | None = None,\n    body: str | None = None,\n    creator: str | None = None,\n    date: datetime | None = None,\n) -&gt; Annotation:\n    \"\"\"Insert an annotation, at the position defined by the regex (before,\n    after, content) or by positionnal argument (position). If content is\n    provided, the annotation covers the full content regex. Else, the\n    annotation is positionned either 'before' or 'after' provided regex.\n\n    If content is an odf element (ie: paragraph, span, ...), the full inner\n    content is covered by the annotation (of the position just after if\n    content is a single empty tag).\n\n    If content/before or after exists (regex) and return a group of matching\n    positions, the position value is the index of matching place to use.\n\n    annotation_element can contain a previously created annotation, else\n    the annotation is created from the body, creator and optional date\n    (current date by default).\n\n    Arguments:\n\n        annotation_element -- Annotation or None\n\n        before -- str regular expression or None\n\n        after -- str regular expression or Element or None\n\n        content -- str regular expression or None, or Element\n\n        position -- int or tuple of int\n\n        body -- str or Element\n\n        creator -- str\n\n        date -- datetime\n    \"\"\"\n\n    if annotation_element is None:\n        annotation_element = Annotation(\n            text_or_element=body, creator=creator, date=date, parent=self\n        )\n    else:\n        # XXX clone or modify the argument?\n        if body:\n            annotation_element.note_body = body\n        if creator:\n            annotation_element.creator = creator\n        if date:\n            annotation_element.date = date\n    annotation_element.check_validity()\n\n    # special case: content is an odf element (ie: a paragraph)\n    if isinstance(content, Element):\n        if content.is_empty():\n            content.insert(annotation_element, xmlposition=NEXT_SIBLING)\n            return annotation_element\n        content.insert(annotation_element, start=True)\n        annotation_end = AnnotationEnd(annotation_element)\n        content.append(annotation_end)\n        return annotation_element\n\n    # special case\n    if isinstance(after, Element):\n        after.insert(annotation_element, FIRST_CHILD)\n        return annotation_element\n\n    # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and content is not None\n        and isinstance(position, int)\n    ):\n        # Start tag\n        self._insert(\n            annotation_element, before=content, position=position, main_text=True\n        )\n        # End tag\n        annotation_end = AnnotationEnd(annotation_element)\n        self._insert(\n            annotation_end, after=content, position=position, main_text=True\n        )\n        return annotation_element\n\n    # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and content is None\n        and isinstance(position, tuple)\n    ):\n        # Start\n        self._insert(annotation_element, position=position[0], main_text=True)\n        # End\n        annotation_end = AnnotationEnd(annotation_element)\n        self._insert(annotation_end, position=position[1], main_text=True)\n        return annotation_element\n\n    # Without \"content\" nor \"position\"\n    if content is not None or not isinstance(position, int):\n        raise ValueError(\"Bad arguments\")\n\n    # Insert\n    self._insert(\n        annotation_element,\n        before=before,\n        after=after,\n        position=position,\n        main_text=True,\n    )\n    return annotation_element\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.insert_annotation_end","title":"<code>insert_annotation_end(annotation_element, before=None, after=None, position=0)</code>","text":"<p>Insert an annotation end tag for an existing annotation. If some end tag already exists, replace it. Annotation end tag is set at the position defined by the regex (before or after).</p> <p>If content/before or after (regex) returns a group of matching positions, the position value is the index of matching place to use.</p> <p>Arguments:</p> <pre><code>annotation_element -- Annotation (mandatory)\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or None\n\nposition -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def insert_annotation_end(\n    self,\n    annotation_element: Annotation,\n    before: str | None = None,\n    after: str | None = None,\n    position: int = 0,\n) -&gt; AnnotationEnd:\n    \"\"\"Insert an annotation end tag for an existing annotation. If some end\n    tag already exists, replace it. Annotation end tag is set at the\n    position defined by the regex (before or after).\n\n    If content/before or after (regex) returns a group of matching\n    positions, the position value is the index of matching place to use.\n\n    Arguments:\n\n        annotation_element -- Annotation (mandatory)\n\n        before -- str regular expression or None\n\n        after -- str regular expression or None\n\n        position -- int\n    \"\"\"\n\n    if annotation_element is None:\n        raise ValueError\n    if not isinstance(annotation_element, Annotation):\n        raise TypeError(\"Not a &lt;office:annotation&gt; Annotation\")\n\n    # remove existing end tag\n    name = annotation_element.name\n    existing_end_tag = self.get_annotation_end(name=name)\n    if existing_end_tag:\n        existing_end_tag.delete()\n\n    # create the end tag\n    end_tag = AnnotationEnd(annotation_element)\n\n    # Insert\n    self._insert(\n        end_tag, before=before, after=after, position=position, main_text=True\n    )\n    return end_tag\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.insert_reference","title":"<code>insert_reference(name, ref_format='', before=None, after=None, position=0, display=None)</code>","text":"<p>Create and insert a reference to a content marked by a reference mark. The Reference element (\u201ctext:reference-ref\u201d) represents a field that references a \u201ctext:reference-mark-start\u201d or \u201ctext:reference-mark\u201d element. Its \u201ctext:reference-format\u201d attribute specifies what is displayed from the referenced element. Default is \u2018page\u2019. Actual content is not automatically updated except for the \u2018text\u2019 format.</p> <p>name is mandatory and should represent an existing reference mark of the document.</p> <p>ref_format is the argument for format reference (default is \u2018page\u2019).</p> <p>The reference is inserted the position defined by the regex (before / after), or by positionnal argument (position). If \u2018display\u2019 is provided, it will be used as the text value for the reference.</p> <p>If after is an ODF Element, the reference is inserted as first child of this element.</p> <p>Arguments:</p> <pre><code>name -- str\n\nref_format -- one of : 'chapter', 'direction', 'page', 'text',\n                        'caption', 'category-and-value', 'value',\n                        'number', 'number-all-superior',\n                        'number-no-superior'\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or odf element or None\n\nposition -- int\n\ndisplay -- str or None\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def insert_reference(\n    self,\n    name: str,\n    ref_format: str = \"\",\n    before: str | None = None,\n    after: str | Element | None = None,\n    position: int = 0,\n    display: str | None = None,\n) -&gt; None:\n    \"\"\"Create and insert a reference to a content marked by a reference\n    mark. The Reference element (\"text:reference-ref\") represents a\n    field that references a \"text:reference-mark-start\" or\n    \"text:reference-mark\" element. Its \"text:reference-format\" attribute\n    specifies what is displayed from the referenced element. Default is\n    'page'. Actual content is not automatically updated except for the 'text'\n    format.\n\n    name is mandatory and should represent an existing reference mark of the\n    document.\n\n    ref_format is the argument for format reference (default is 'page').\n\n    The reference is inserted the position defined by the regex (before /\n    after), or by positionnal argument (position). If 'display' is provided,\n    it will be used as the text value for the reference.\n\n    If after is an ODF Element, the reference is inserted as first child of\n    this element.\n\n    Arguments:\n\n        name -- str\n\n        ref_format -- one of : 'chapter', 'direction', 'page', 'text',\n                                'caption', 'category-and-value', 'value',\n                                'number', 'number-all-superior',\n                                'number-no-superior'\n\n        before -- str regular expression or None\n\n        after -- str regular expression or odf element or None\n\n        position -- int\n\n        display -- str or None\n    \"\"\"\n    reference = Reference(name, ref_format)\n    if display is None and ref_format == \"text\":\n        # get reference content\n        body = self.document_body\n        if not body:\n            body = self.root\n        mark = body.get_reference_mark(name=name)\n        if mark:\n            display = mark.referenced_text  # type: ignore\n    if not display:\n        display = \" \"\n    reference.text = display\n    if isinstance(after, Element):\n        after.insert(reference, FIRST_CHILD)\n    else:\n        self._insert(\n            reference, before=before, after=after, position=position, main_text=True\n        )\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_link","title":"<code>remove_link(links)</code>","text":"<p>Send back a copy of the element (not a clone), with the sub links    removed.</p> <p>Arguments:</p> <pre><code>links -- Link or list of Link\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_link(self, links: Link | list[Link]) -&gt; Element | list:\n    \"\"\"Send back a copy of the element (not a clone), with the sub links\n       removed.\n\n    Arguments:\n\n        links -- Link or list of Link\n    \"\"\"\n    return self.strip_elements(links)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_links","title":"<code>remove_links()</code>","text":"<p>Send back a copy of the element, without links tags.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_links(self) -&gt; Element | list:\n    \"\"\"Send back a copy of the element, without links tags.\"\"\"\n    strip = (Link._tag,)\n    return self.strip_tags(strip=strip)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_span","title":"<code>remove_span(spans)</code>","text":"<p>Send back a copy of the element, the spans (not a clone) removed.</p> <p>Arguments:</p> <pre><code>spans -- Element or list of Element\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_span(self, spans: Element | list[Element]) -&gt; Element | list:\n    \"\"\"Send back a copy of the element, the spans (not a clone) removed.\n\n    Arguments:\n\n        spans -- Element or list of Element\n    \"\"\"\n    return self.strip_elements(spans)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_spans","title":"<code>remove_spans(keep_heading=True)</code>","text":"<p>Send back a copy of the element, without span styles. If keep_heading is True (default), the first level heading style is left unchanged.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_spans(self, keep_heading: bool = True) -&gt; Element | list:\n    \"\"\"Send back a copy of the element, without span styles.\n    If keep_heading is True (default), the first level heading style is left\n    unchanged.\n    \"\"\"\n    strip = (Span._tag,)\n    if keep_heading:\n        protect = (\"text:h\",)\n    else:\n        protect = None\n    return self.strip_tags(strip=strip, protect=protect)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_bookmark","title":"<code>set_bookmark(name, before=None, after=None, position=0, role=None, content=None)</code>","text":"<p>Insert a bookmark before or after the characters in the text which match the regex before/after. When the regex matches more of one part of the text, position can be set to choose which part must be used. If before and after are None, we use only position that is the number of characters.</p> <p>So, by default, this function inserts a bookmark before the first character of the content. Role can be None, \u201cstart\u201d or \u201cend\u201d, we insert respectively a position bookmark a bookmark-start or a bookmark-end.</p> <p>If content is not None these 2 calls are equivalent:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, content=\u201dxyz\u201d)</p> <p>and:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, before=\u201dxyz\u201d, role=\u201dstart\u201d)   paragraph.set_bookmark(\u201cbookmark\u201d, after=\u201dxyz\u201d, role=\u201dend\u201d)</p> <p>If position is a 2-tuple, these 2 calls are equivalent:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, position=(10, 20))</p> <p>and:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, position=10, role=\u201dstart\u201d)   paragraph.set_bookmark(\u201cbookmark\u201d, position=20, role=\u201dend\u201d)</p> <p>Arguments:</p> <pre><code>name -- str\n\nbefore -- str regex\n\nafter -- str regex\n\nposition -- int or (int, int)\n\nrole -- None, \"start\" or \"end\"\n\ncontent -- str regex\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def set_bookmark(\n    self,\n    name: str,\n    before: str | None = None,\n    after: str | None = None,\n    position: int | tuple = 0,\n    role: str | None = None,\n    content: str | None = None,\n) -&gt; Element | tuple[Element, Element]:\n    \"\"\"Insert a bookmark before or after the characters in the text which\n    match the regex before/after. When the regex matches more of one part\n    of the text, position can be set to choose which part must be used.\n    If before and after are None, we use only position that is the number\n    of characters.\n\n    So, by default, this function inserts a bookmark before the first\n    character of the content. Role can be None, \"start\" or \"end\", we\n    insert respectively a position bookmark a bookmark-start or a\n    bookmark-end.\n\n    If content is not None these 2 calls are equivalent:\n\n      paragraph.set_bookmark(\"bookmark\", content=\"xyz\")\n\n    and:\n\n      paragraph.set_bookmark(\"bookmark\", before=\"xyz\", role=\"start\")\n      paragraph.set_bookmark(\"bookmark\", after=\"xyz\", role=\"end\")\n\n\n    If position is a 2-tuple, these 2 calls are equivalent:\n\n      paragraph.set_bookmark(\"bookmark\", position=(10, 20))\n\n    and:\n\n      paragraph.set_bookmark(\"bookmark\", position=10, role=\"start\")\n      paragraph.set_bookmark(\"bookmark\", position=20, role=\"end\")\n\n\n    Arguments:\n\n        name -- str\n\n        before -- str regex\n\n        after -- str regex\n\n        position -- int or (int, int)\n\n        role -- None, \"start\" or \"end\"\n\n        content -- str regex\n    \"\"\"\n    # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and role is None\n        and content is not None\n        and isinstance(position, int)\n    ):\n        # Start\n        start = BookmarkStart(name)\n        self._insert(start, before=content, position=position, main_text=True)\n        # End\n        end = BookmarkEnd(name)\n        self._insert(end, after=content, position=position, main_text=True)\n        return start, end\n\n    # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and role is None\n        and content is None\n        and isinstance(position, tuple)\n    ):\n        # Start\n        start = BookmarkStart(name)\n        self._insert(start, position=position[0], main_text=True)\n        # End\n        end = BookmarkEnd(name)\n        self._insert(end, position=position[1], main_text=True)\n        return start, end\n\n    # Without \"content\" nor \"position\"\n    if content is not None or not isinstance(position, int):\n        raise ValueError(\"bad arguments\")\n\n    # Role\n    if role is None:\n        bookmark: Element = Bookmark(name)\n    elif role == \"start\":\n        bookmark = BookmarkStart(name)\n    elif role == \"end\":\n        bookmark = BookmarkEnd(name)\n    else:\n        raise ValueError(\"bad arguments\")\n\n    # Insert\n    self._insert(\n        bookmark, before=before, after=after, position=position, main_text=True\n    )\n\n    return bookmark\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_link","title":"<code>set_link(match, tail, url, regex=None, offset=None, length=0)</code>","text":"<p>set_link(url, regex=None, offset=None, length=0) Make a link to the provided url from text content matching the regex OR the positional arguments offset and length.</p> <p>(match, tail: provided by regex decorator)</p> <p>Arguments:</p> <pre><code>url -- str\n\nregex -- str regular expression\n\noffset -- int\n\nlength -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>@_by_regex_offset\ndef set_link(\n    self,\n    match: str,\n    tail: str,\n    url: str,\n    regex: str | None = None,\n    offset: int | None = None,\n    length: int = 0,\n) -&gt; Element:\n    \"\"\"\n    set_link(url, regex=None, offset=None, length=0)\n    Make a link to the provided url from text content matching the regex\n    OR the positional arguments offset and length.\n\n    (match, tail: provided by regex decorator)\n\n    Arguments:\n\n        url -- str\n\n        regex -- str regular expression\n\n        offset -- int\n\n        length -- int\n    \"\"\"\n    link = Link(url, text=match)\n    link.tail = tail\n    return link\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_reference_mark","title":"<code>set_reference_mark(name, before=None, after=None, position=0, content=None)</code>","text":"<p>Insert a reference mark, at the position defined by the regex (before, after, content) or by positionnal argument (position). If content is provided, the annotation covers the full range content regex (instances of ReferenceMarkStart and ReferenceMarkEnd are created). Else, an instance of ReferenceMark is positionned either \u2018before\u2019 or \u2018after\u2019 provided regex.</p> <p>If content is an ODF Element (ie: Paragraph, Span, \u2026), the full inner content is referenced (of the position just after if content is a single empty tag).</p> <p>If content/before or after exists (regex) and return a group of matching positions, the position value is the index of matching place to use.</p> <p>Name is mandatory and shall be unique in the document for the preference mark range.</p> <p>Arguments:</p> <pre><code>name -- str\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or None,\n\ncontent -- str regular expression or None, or Element\n\nposition -- int or tuple of int\n</code></pre> <p>Return: the created ReferenceMark or ReferenceMarkStart</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def set_reference_mark(\n    self,\n    name: str,\n    before: str | None = None,\n    after: str | None = None,\n    position: int = 0,\n    content: str | Element | None = None,\n) -&gt; Element:\n    \"\"\"Insert a reference mark, at the position defined by the regex\n    (before, after, content) or by positionnal argument (position). If\n    content is provided, the annotation covers the full range content regex\n    (instances of ReferenceMarkStart and ReferenceMarkEnd are\n    created). Else, an instance of ReferenceMark is positionned either\n    'before' or 'after' provided regex.\n\n    If content is an ODF Element (ie: Paragraph, Span, ...), the full inner\n    content is referenced (of the position just after if content is a single\n    empty tag).\n\n    If content/before or after exists (regex) and return a group of matching\n    positions, the position value is the index of matching place to use.\n\n    Name is mandatory and shall be unique in the document for the preference\n    mark range.\n\n    Arguments:\n\n        name -- str\n\n        before -- str regular expression or None\n\n        after -- str regular expression or None,\n\n        content -- str regular expression or None, or Element\n\n        position -- int or tuple of int\n\n    Return: the created ReferenceMark or ReferenceMarkStart\n    \"\"\"\n    # special case: content is an odf element (ie: a paragraph)\n    if isinstance(content, Element):\n        if content.is_empty():\n            reference = ReferenceMark(name)\n            content.insert(reference, xmlposition=NEXT_SIBLING)\n            return reference\n        reference_start = ReferenceMarkStart(name)\n        content.insert(reference_start, start=True)\n        reference_end = ReferenceMarkEnd(name)\n        content.append(reference_end)\n        return reference_start\n\n    # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n    # reference\n    if (\n        before is None\n        and after is None\n        and content is not None\n        and isinstance(position, int)\n    ):\n        # Start tag\n        reference_start = ReferenceMarkStart(name)\n        self._insert(\n            reference_start, before=content, position=position, main_text=True\n        )\n        # End tag\n        reference_end = ReferenceMarkEnd(name)\n        self._insert(\n            reference_end, after=content, position=position, main_text=True\n        )\n        return reference_start\n\n    # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n    if (\n        before is None\n        and after is None\n        and content is None\n        and isinstance(position, tuple)\n    ):\n        # Start\n        reference_start = ReferenceMarkStart(name)\n        self._insert(reference_start, position=position[0], main_text=True)\n        # End\n        reference_end = ReferenceMarkEnd(name)\n        self._insert(reference_end, position=position[1], main_text=True)\n        return reference_start\n\n    # Without \"content\" nor \"position\"\n    if content is not None or not isinstance(position, int):\n        raise ValueError(\"bad arguments\")\n\n    # Insert a positional reference mark\n    reference = ReferenceMark(name)\n    self._insert(\n        reference,\n        before=before,\n        after=after,\n        position=position,\n        main_text=True,\n    )\n    return reference\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_reference_mark_end","title":"<code>set_reference_mark_end(reference_mark, before=None, after=None, position=0)</code>","text":"<p>Insert/move a ReferenceMarkEnd for an existing reference mark. If some end tag already exists, replace it. Reference tag is set at the position defined by the regex (before or after).</p> <p>If content/before or after (regex) returns a group of matching positions, the position value is the index of matching place to use.</p> <p>Arguments:</p> <pre><code>reference_mark -- ReferenceMark or ReferenceMarkStart (mandatory)\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or None\n\nposition -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def set_reference_mark_end(\n    self,\n    reference_mark: Element,\n    before: str | None = None,\n    after: str | None = None,\n    position: int = 0,\n) -&gt; ReferenceMarkEnd:\n    \"\"\"Insert/move a ReferenceMarkEnd for an existing reference mark. If\n    some end tag already exists, replace it. Reference tag is set at the\n    position defined by the regex (before or after).\n\n    If content/before or after (regex) returns a group of matching\n    positions, the position value is the index of matching place to use.\n\n    Arguments:\n\n        reference_mark -- ReferenceMark or ReferenceMarkStart (mandatory)\n\n        before -- str regular expression or None\n\n        after -- str regular expression or None\n\n        position -- int\n    \"\"\"\n    if not isinstance(reference_mark, (ReferenceMark, ReferenceMarkStart)):\n        raise TypeError(\"Not a ReferenceMark or ReferenceMarkStart\")\n    name = reference_mark.name\n    if isinstance(reference_mark, ReferenceMark):\n        # change it to a range reference:\n        reference_mark.tag = ReferenceMarkStart._tag\n\n    existing_end_tag = self.get_reference_mark_end(name=name)\n    if existing_end_tag:\n        existing_end_tag.delete()\n\n    # create the end tag\n    end_tag = ReferenceMarkEnd(name)\n\n    # Insert\n    self._insert(\n        end_tag, before=before, after=after, position=position, main_text=True\n    )\n    return end_tag\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_span","title":"<code>set_span(match, tail, style, regex=None, offset=None, length=0)</code>","text":"<p>set_span(style, regex=None, offset=None, length=0) Apply the given style to text content matching the regex OR the positional arguments offset and length.</p> <p>(match, tail: provided by regex decorator)</p> <p>Arguments:</p> <pre><code>style -- str\n\nregex -- str regular expression\n\noffset -- int\n\nlength -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>@_by_regex_offset\ndef set_span(\n    self,\n    match: str,\n    tail: str,\n    style: str,\n    regex: str | None = None,\n    offset: int | None = None,\n    length: int = 0,\n) -&gt; Span:\n    \"\"\"\n    set_span(style, regex=None, offset=None, length=0)\n    Apply the given style to text content matching the regex OR the\n    positional arguments offset and length.\n\n    (match, tail: provided by regex decorator)\n\n    Arguments:\n\n        style -- str\n\n        regex -- str regular expression\n\n        offset -- int\n\n        length -- int\n    \"\"\"\n    span = Span(match, style=style)\n    span.tail = tail\n    return span\n</code></pre>"},{"location":"reference.html#odfdo.Presentation","title":"<code>Presentation</code>","text":"<p>             Bases: <code>Body</code></p> <p>Presentation, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Presentation(Body):\n    \"\"\"Presentation, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:presentation\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.RectangleShape","title":"<code>RectangleShape</code>","text":"<p>             Bases: <code>ShapeBase</code></p> <p>Create a rectangle shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\nposition -- (str, str)\n\nsize -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class RectangleShape(ShapeBase):\n    \"\"\"Create a rectangle shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        position -- (str, str)\n\n        size -- (str, str)\n\n    \"\"\"\n\n    _tag = \"draw:rect\"\n    _properties: tuple[PropDef, ...] = ()\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        position: tuple | None = None,\n        size: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n                \"size\": size,\n                \"position\": position,\n            }\n        )\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference.html#odfdo.Reference","title":"<code>Reference</code>","text":"<p>             Bases: <code>Element</code></p> <p>A reference to a content marked by a reference mark. The odf_reference element (\u201ctext:reference-ref\u201d) represents a field that references a \u201ctext:reference-mark-start\u201d or \u201ctext:reference-mark\u201d element. Its text:reference-format attribute specifies what is displayed from the referenced element. Default is \u2018page\u2019 Actual content is not updated except for the \u2018text\u2019 format by the update() method.</p> <p>Creation of references can be tricky, consider using this method:     odfdo.paragraph.insert_reference()</p> <p>Values for text:reference-format :     The defined values for the text:reference-format attribute supported by     all reference fields are:       - \u2018chapter\u2019: displays the number of the chapter in which the         referenced item appears.       - \u2018direction\u2019: displays whether the referenced item is above or         below the reference field.       - \u2018page\u2019: displays the number of the page on which the referenced         item appears.       - \u2018text\u2019: displays the text of the referenced item.     Additional defined values for the text:reference-format attribute     supported by references to sequence fields are:       - \u2018caption\u2019: displays the caption in which the sequence is used.       - \u2018category-and-value\u2019: displays the name and value of the sequence.       - \u2018value\u2019: displays the value of the sequence.</p> <pre><code>References to bookmarks and other references support additional values,\nwhich display the list label of the referenced item. If the referenced\nitem is contained in a list or a numbered paragraph, the list label is\nthe formatted number of the paragraph which contains the referenced\nitem. If the referenced item is not contained in a list or numbered\nparagraph, the list label is empty, and the referenced field therefore\ndisplays nothing. If the referenced bookmark or reference contains more\nthan one paragraph, the list label of the paragraph at which the\nbookmark or reference starts is taken.\n\nAdditional defined values for the text:reference-format attribute\nsupported by all references to bookmark's or other reference fields\nare:\n  - 'number': displays the list label of the referenced item. [...]\n  - 'number-all-superior': displays the list label of the referenced\n    item and adds the contents of all list labels of superior levels\n    in front of it. [...]\n  - 'number-no-superior': displays the contents of the list label of\n    the referenced item.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>class Reference(Element):\n    \"\"\"A reference to a content marked by a reference mark.\n    The odf_reference element (\"text:reference-ref\") represents a field that\n    references a \"text:reference-mark-start\" or \"text:reference-mark\" element.\n    Its text:reference-format attribute specifies what is displayed from the\n    referenced element. Default is 'page'\n    Actual content is not updated except for the 'text' format by the\n    update() method.\n\n\n    Creation of references can be tricky, consider using this method:\n        odfdo.paragraph.insert_reference()\n\n    Values for text:reference-format :\n        The defined values for the text:reference-format attribute supported by\n        all reference fields are:\n          - 'chapter': displays the number of the chapter in which the\n            referenced item appears.\n          - 'direction': displays whether the referenced item is above or\n            below the reference field.\n          - 'page': displays the number of the page on which the referenced\n            item appears.\n          - 'text': displays the text of the referenced item.\n        Additional defined values for the text:reference-format attribute\n        supported by references to sequence fields are:\n          - 'caption': displays the caption in which the sequence is used.\n          - 'category-and-value': displays the name and value of the sequence.\n          - 'value': displays the value of the sequence.\n\n        References to bookmarks and other references support additional values,\n        which display the list label of the referenced item. If the referenced\n        item is contained in a list or a numbered paragraph, the list label is\n        the formatted number of the paragraph which contains the referenced\n        item. If the referenced item is not contained in a list or numbered\n        paragraph, the list label is empty, and the referenced field therefore\n        displays nothing. If the referenced bookmark or reference contains more\n        than one paragraph, the list label of the paragraph at which the\n        bookmark or reference starts is taken.\n\n        Additional defined values for the text:reference-format attribute\n        supported by all references to bookmark's or other reference fields\n        are:\n          - 'number': displays the list label of the referenced item. [...]\n          - 'number-all-superior': displays the list label of the referenced\n            item and adds the contents of all list labels of superior levels\n            in front of it. [...]\n          - 'number-no-superior': displays the contents of the list label of\n            the referenced item.\n    \"\"\"\n\n    _tag = \"text:reference-ref\"\n    _properties = (PropDef(\"name\", \"text:ref-name\"),)\n    format_allowed = (\n        \"chapter\",\n        \"direction\",\n        \"page\",\n        \"text\",\n        \"caption\",\n        \"category-and-value\",\n        \"value\",\n        \"number\",\n        \"number-all-superior\",\n        \"number-no-superior\",\n    )\n\n    def __init__(self, name: str = \"\", ref_format: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"Create a reference to a content marked by a reference mark. An\n        actual reference mark with the provided name should exist.\n\n        Consider using: odfdo.paragraph.insert_reference()\n\n        The text:ref-name attribute identifies a \"text:reference-mark\" or\n        \"text:referencemark-start\" element by the value of that element's\n        text:name attribute.\n        If ref_format is 'text', the current text content of the reference_mark\n        is retrieved.\n\n        Arguments:\n\n            name -- str : name of the reference mark\n\n            ref_format -- str : format of the field. Default is 'page', allowed\n                            values are 'chapter', 'direction', 'page', 'text',\n                            'caption', 'category-and-value', 'value', 'number',\n                            'number-all-superior', 'number-no-superior'.\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n            self.ref_format = ref_format\n\n    @property\n    def ref_format(self) -&gt; str | None:\n        reference = self.get_attribute(\"text:reference-format\")\n        if isinstance(reference, str):\n            return reference\n        return None\n\n    @ref_format.setter\n    def ref_format(self, ref_format: str) -&gt; None:\n        \"\"\"Set the text:reference-format attribute.\n\n        Arguments:\n\n            ref_format -- str\n        \"\"\"\n        if not ref_format or ref_format not in self.format_allowed:\n            ref_format = \"page\"\n        self.set_attribute(\"text:reference-format\", ref_format)\n\n    def update(self) -&gt; None:\n        \"\"\"Update the content of the reference text field. Currently only\n        'text' format is implemented. Other values, for example the 'page' text\n        field, may need to be refreshed through a visual ODF parser.\n        \"\"\"\n        ref_format = self.ref_format\n        if ref_format != \"text\":\n            # only 'text' is implemented\n            return None\n        body = self.document_body\n        if not body:\n            body = self.root\n        name = self.name\n        reference = body.get_reference_mark(name=name)\n        if not reference:\n            return None\n        # we know it is a ReferenceMarkStart:\n        self.text = reference.referenced_text()  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Reference.__init__","title":"<code>__init__(name='', ref_format='', **kwargs)</code>","text":"<p>Create a reference to a content marked by a reference mark. An actual reference mark with the provided name should exist.</p> <p>Consider using: odfdo.paragraph.insert_reference()</p> <p>The text:ref-name attribute identifies a \u201ctext:reference-mark\u201d or \u201ctext:referencemark-start\u201d element by the value of that element\u2019s text:name attribute. If ref_format is \u2018text\u2019, the current text content of the reference_mark is retrieved.</p> <p>Arguments:</p> <pre><code>name -- str : name of the reference mark\n\nref_format -- str : format of the field. Default is 'page', allowed\n                values are 'chapter', 'direction', 'page', 'text',\n                'caption', 'category-and-value', 'value', 'number',\n                'number-all-superior', 'number-no-superior'.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", ref_format: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"Create a reference to a content marked by a reference mark. An\n    actual reference mark with the provided name should exist.\n\n    Consider using: odfdo.paragraph.insert_reference()\n\n    The text:ref-name attribute identifies a \"text:reference-mark\" or\n    \"text:referencemark-start\" element by the value of that element's\n    text:name attribute.\n    If ref_format is 'text', the current text content of the reference_mark\n    is retrieved.\n\n    Arguments:\n\n        name -- str : name of the reference mark\n\n        ref_format -- str : format of the field. Default is 'page', allowed\n                        values are 'chapter', 'direction', 'page', 'text',\n                        'caption', 'category-and-value', 'value', 'number',\n                        'number-all-superior', 'number-no-superior'.\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n        self.ref_format = ref_format\n</code></pre>"},{"location":"reference.html#odfdo.Reference.update","title":"<code>update()</code>","text":"<p>Update the content of the reference text field. Currently only \u2018text\u2019 format is implemented. Other values, for example the \u2018page\u2019 text field, may need to be refreshed through a visual ODF parser.</p> Source code in <code>odfdo/reference.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the content of the reference text field. Currently only\n    'text' format is implemented. Other values, for example the 'page' text\n    field, may need to be refreshed through a visual ODF parser.\n    \"\"\"\n    ref_format = self.ref_format\n    if ref_format != \"text\":\n        # only 'text' is implemented\n        return None\n    body = self.document_body\n    if not body:\n        body = self.root\n    name = self.name\n    reference = body.get_reference_mark(name=name)\n    if not reference:\n        return None\n    # we know it is a ReferenceMarkStart:\n    self.text = reference.referenced_text()  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMark","title":"<code>ReferenceMark</code>","text":"<p>             Bases: <code>Element</code></p> <p>A point reference. A point reference marks a position in text and is represented by a single \u201ctext:reference-mark\u201d element.</p> Source code in <code>odfdo/reference.py</code> <pre><code>class ReferenceMark(Element):\n    \"\"\"A point reference.\n    A point reference marks a position in text and is represented by a single\n    \"text:reference-mark\" element.\n    \"\"\"\n\n    _tag = \"text:reference-mark\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"A point reference. A point reference marks a position in text and is\n        represented by a single \"text:reference-mark\" element.\n        Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMark.__init__","title":"<code>__init__(name='', **kwargs)</code>","text":"<p>A point reference. A point reference marks a position in text and is represented by a single \u201ctext:reference-mark\u201d element. Consider using the wrapper: odfdo.paragraph.set_reference_mark()</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"A point reference. A point reference marks a position in text and is\n    represented by a single \"text:reference-mark\" element.\n    Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkEnd","title":"<code>ReferenceMarkEnd</code>","text":"<p>             Bases: <code>Element</code></p> <p>The \u201ctext:reference-mark-end\u201d element represents the end of a range reference.</p> Source code in <code>odfdo/reference.py</code> <pre><code>class ReferenceMarkEnd(Element):\n    \"\"\"The \"text:reference-mark-end\" element represents the end of a range\n    reference.\n    \"\"\"\n\n    _tag = \"text:reference-mark-end\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"The \"text:reference-mark-end\" element represent the end of a range\n        reference.\n        Consider using the wrappers: odfdo.paragraph.set_reference_mark() and\n        odfdo.paragraph.set_reference_mark_end()\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n\n    def referenced_text(self) -&gt; str:\n        \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n        name = self.name\n        request = (\n            f\"//text()\"\n            f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n            f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n        )\n        result = \" \".join(str(x) for x in self.xpath(request))\n        return result\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkEnd.__init__","title":"<code>__init__(name='', **kwargs)</code>","text":"<p>The \u201ctext:reference-mark-end\u201d element represent the end of a range reference. Consider using the wrappers: odfdo.paragraph.set_reference_mark() and odfdo.paragraph.set_reference_mark_end()</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"The \"text:reference-mark-end\" element represent the end of a range\n    reference.\n    Consider using the wrappers: odfdo.paragraph.set_reference_mark() and\n    odfdo.paragraph.set_reference_mark_end()\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkEnd.referenced_text","title":"<code>referenced_text()</code>","text":"<p>Return the text between reference-mark-start and reference-mark-end.</p> Source code in <code>odfdo/reference.py</code> <pre><code>def referenced_text(self) -&gt; str:\n    \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n    name = self.name\n    request = (\n        f\"//text()\"\n        f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n        f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n    )\n    result = \" \".join(str(x) for x in self.xpath(request))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart","title":"<code>ReferenceMarkStart</code>","text":"<p>             Bases: <code>Element</code></p> <p>The \u201ctext:reference-mark-start\u201d element represents the start of a range reference.</p> Source code in <code>odfdo/reference.py</code> <pre><code>class ReferenceMarkStart(Element):\n    \"\"\"The \"text:reference-mark-start\" element represents the start of a\n    range reference.\n    \"\"\"\n\n    _tag = \"text:reference-mark-start\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"The \"text:reference-mark-start\" element represent the start of a range\n        reference.\n        Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n\n    def referenced_text(self) -&gt; str:\n        \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n        name = self.name\n        request = (\n            f\"//text()\"\n            f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n            f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n        )\n        result = \" \".join(str(x) for x in self.xpath(request))\n        return result\n\n    def get_referenced(\n        self,\n        no_header: bool = False,\n        clean: bool = True,\n        as_xml: bool = False,\n        as_list: bool = False,\n    ) -&gt; Element | list | str | None:\n        \"\"\"Return the document content between the start and end tags of the\n        reference. The content returned by this method can spread over several\n        headers and paragraphs.\n        By default, the content is returned as an \"office:text\" odf element.\n\n\n        Arguments:\n\n            no_header -- boolean (default to False), translate existing headers\n                         tags \"text:h\" into paragraphs \"text:p\".\n\n            clean -- boolean (default to True), suppress unwanted tags. Striped\n                     tags are : 'text:change', 'text:change-start',\n                     'text:change-end', 'text:reference-mark',\n                     'text:reference-mark-start', 'text:reference-mark-end'.\n\n            as_xml -- boolean (default to False), format the returned content as\n                      a XML string (serialization).\n\n            as_list -- boolean (default to False), do not embed the returned\n                       content in a \"office:text'\" element, instead simply\n                       return a raw list of odf elements.\n        \"\"\"\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Reference need some upper document part\")\n        body = self.document_body\n        if not body:\n            body = parent\n        end = body.get_reference_mark_end(name=name)\n        if end is None:\n            raise ValueError(\"No reference-end found\")\n        start = self\n        return _get_referenced(body, start, end, no_header, clean, as_xml, as_list)\n\n    def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        For odf_reference_mark_start : delete the reference-end tag if exists.\n\n        Arguments:\n\n            child -- Element\n\n            keep_tail -- boolean (default to True), True for most usages.\n        \"\"\"\n        if child is not None:  # act like normal delete\n            return super().delete(child, keep_tail)\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can't delete the root element\")\n        body = self.document_body\n        if not body:\n            body = parent\n        end = body.get_reference_mark_end(name=name)\n        if end:\n            end.delete()\n        # act like normal delete\n        return super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.__init__","title":"<code>__init__(name='', **kwargs)</code>","text":"<p>The \u201ctext:reference-mark-start\u201d element represent the start of a range reference. Consider using the wrapper: odfdo.paragraph.set_reference_mark()</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"The \"text:reference-mark-start\" element represent the start of a range\n    reference.\n    Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>For odf_reference_mark_start : delete the reference-end tag if exists.</p> <p>Arguments:</p> <pre><code>child -- Element\n\nkeep_tail -- boolean (default to True), True for most usages.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    For odf_reference_mark_start : delete the reference-end tag if exists.\n\n    Arguments:\n\n        child -- Element\n\n        keep_tail -- boolean (default to True), True for most usages.\n    \"\"\"\n    if child is not None:  # act like normal delete\n        return super().delete(child, keep_tail)\n    name = self.name\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Can't delete the root element\")\n    body = self.document_body\n    if not body:\n        body = parent\n    end = body.get_reference_mark_end(name=name)\n    if end:\n        end.delete()\n    # act like normal delete\n    return super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.get_referenced","title":"<code>get_referenced(no_header=False, clean=True, as_xml=False, as_list=False)</code>","text":"<p>Return the document content between the start and end tags of the reference. The content returned by this method can spread over several headers and paragraphs. By default, the content is returned as an \u201coffice:text\u201d odf element.</p> <p>Arguments:</p> <pre><code>no_header -- boolean (default to False), translate existing headers\n             tags \"text:h\" into paragraphs \"text:p\".\n\nclean -- boolean (default to True), suppress unwanted tags. Striped\n         tags are : 'text:change', 'text:change-start',\n         'text:change-end', 'text:reference-mark',\n         'text:reference-mark-start', 'text:reference-mark-end'.\n\nas_xml -- boolean (default to False), format the returned content as\n          a XML string (serialization).\n\nas_list -- boolean (default to False), do not embed the returned\n           content in a \"office:text'\" element, instead simply\n           return a raw list of odf elements.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def get_referenced(\n    self,\n    no_header: bool = False,\n    clean: bool = True,\n    as_xml: bool = False,\n    as_list: bool = False,\n) -&gt; Element | list | str | None:\n    \"\"\"Return the document content between the start and end tags of the\n    reference. The content returned by this method can spread over several\n    headers and paragraphs.\n    By default, the content is returned as an \"office:text\" odf element.\n\n\n    Arguments:\n\n        no_header -- boolean (default to False), translate existing headers\n                     tags \"text:h\" into paragraphs \"text:p\".\n\n        clean -- boolean (default to True), suppress unwanted tags. Striped\n                 tags are : 'text:change', 'text:change-start',\n                 'text:change-end', 'text:reference-mark',\n                 'text:reference-mark-start', 'text:reference-mark-end'.\n\n        as_xml -- boolean (default to False), format the returned content as\n                  a XML string (serialization).\n\n        as_list -- boolean (default to False), do not embed the returned\n                   content in a \"office:text'\" element, instead simply\n                   return a raw list of odf elements.\n    \"\"\"\n    name = self.name\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Reference need some upper document part\")\n    body = self.document_body\n    if not body:\n        body = parent\n    end = body.get_reference_mark_end(name=name)\n    if end is None:\n        raise ValueError(\"No reference-end found\")\n    start = self\n    return _get_referenced(body, start, end, no_header, clean, as_xml, as_list)\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.referenced_text","title":"<code>referenced_text()</code>","text":"<p>Return the text between reference-mark-start and reference-mark-end.</p> Source code in <code>odfdo/reference.py</code> <pre><code>def referenced_text(self) -&gt; str:\n    \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n    name = self.name\n    request = (\n        f\"//text()\"\n        f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n        f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n    )\n    result = \" \".join(str(x) for x in self.xpath(request))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Row","title":"<code>Row</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF table row \u201ctable:table-row\u201d</p> Source code in <code>odfdo/row.py</code> <pre><code>class Row(Element):\n    \"\"\"ODF table row \"table:table-row\" \"\"\"\n\n    _tag = \"table:table-row\"\n    _caching = True\n    _append = Element.append\n\n    def __init__(\n        self,\n        width: int | None = None,\n        repeated: int | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"create a Row, optionally filled with \"width\" number of cells.\n\n        Rows contain cells, their number determine the number of columns.\n\n        You don't generally have to create rows by hand, use the Table API.\n\n        Arguments:\n\n            width -- int\n\n            repeated -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self.y = None\n        if not hasattr(self, \"_indexes\"):\n            self._indexes = {}\n            self._indexes[\"_rmap\"] = {}\n        if not hasattr(self, \"_rmap\"):\n            self._compute_row_cache()\n            if not hasattr(self, \"_tmap\"):\n                self._tmap = []\n                self._cmap = []\n        if self._do_init:\n            if width is not None:\n                for _i in range(width):\n                    self.append(Cell())  # type:ignore\n            if repeated:\n                self.repeated = repeated\n            if style is not None:\n                self.style = style\n            self._compute_row_cache()\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} y={self.y}&gt;\"\n\n    def _get_cells(self) -&gt; list[Element]:\n        return self.get_elements(_xpath_cell)\n\n    def _translate_row_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, int | None]:\n        xyzt = convert_coordinates(coord)\n        if len(xyzt) == 2:\n            x, z = xyzt\n        else:\n            x, _, z, __ = xyzt\n        if x and x &lt; 0:\n            x = increment(x, self.width)\n        if z and z &lt; 0:\n            z = increment(z, self.width)\n        return (x, z)\n\n    def _compute_row_cache(self) -&gt; None:\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_cell, \"table:number-columns-repeated\"\n        )\n        self._rmap = make_cache_map(idx_repeated_seq)\n\n    # Public API\n\n    @property\n    def clone(self) -&gt; Row:\n        clone = Element.clone.fget(self)  # type: ignore\n        clone.y = self.y\n        if hasattr(self, \"_tmap\"):\n            if hasattr(self, \"_rmap\"):\n                clone._rmap = self._rmap[:]\n            clone._tmap = self._tmap[:]\n            clone._cmap = self._cmap[:]\n        return clone\n\n    def _set_repeated(self, repeated: int | None) -&gt; None:\n        \"\"\"Method Internal only. Set the numnber of times the row is\n        repeated, or None to delete it. Without changing cache.\n\n        Arguments:\n\n            repeated -- int\n        \"\"\"\n        if repeated is None or repeated &lt; 2:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:number-rows-repeated\")\n            return\n        self.set_attribute(\"table:number-rows-repeated\", str(repeated))\n\n    @property\n    def repeated(self) -&gt; int | None:\n        \"\"\"Get / set the number of times the row is repeated.\n\n        Always None when using the table API.\n\n        Return: int or None\n        \"\"\"\n        repeated = self.get_attribute(\"table:number-rows-repeated\")\n        if repeated is None:\n            return None\n        return int(repeated)\n\n    @repeated.setter\n    def repeated(self, repeated: int | None) -&gt; None:\n        self._set_repeated(repeated)\n        # update cache\n        current: Element = self\n        while True:\n            # look for Table, parent may be group of rows\n            upper = current.parent\n            if not upper:\n                # lonely row\n                return\n            # parent may be group of rows, not table\n            if isinstance(upper, Element) and upper._tag == \"table:table\":\n                break\n            current = upper\n        # fixme : need to optimize this\n        if isinstance(upper, Element) and upper._tag == \"table:table\":\n            upper._compute_table_cache()\n            if hasattr(self, \"_tmap\"):\n                del self._tmap[:]\n                self._tmap.extend(upper._tmap)\n            else:\n                self._tmap = upper._tmap\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get /set the style of the row itself.\n\n        Return: str\n        \"\"\"\n        return self.get_attribute(\"table:style-name\")  # type: ignore\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Get the number of expected cells in the row, i.e. addition\n        repetitions.\n\n        Return: int\n        \"\"\"\n        try:\n            value = self._rmap[-1] + 1\n        except Exception:\n            value = 0\n        return value\n\n    def _translate_x_from_any(self, x: str | int) -&gt; int:\n        return translate_from_any(x, self.width, 0)\n\n    def traverse(  # noqa: C901\n        self,\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; Iterator[Cell]:\n        \"\"\"Yield as many cell elements as expected cells in the row, i.e.\n        expand repetitions by returning the same cell as many times as\n        necessary.\n\n            Arguments:\n\n                start -- int\n\n                end -- int\n\n        Copies are returned, use set_cell() to push them back.\n        \"\"\"\n        idx = -1\n        before = -1\n        x = 0\n        cell: Cell\n        if start is None and end is None:\n            for juska in self._rmap:\n                idx += 1\n                if idx in self._indexes[\"_rmap\"]:\n                    cell = self._indexes[\"_rmap\"][idx]\n                else:\n                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                    if not isinstance(cell, Cell):\n                        raise TypeError(f\"Not a cell: {cell!r}\")\n                    self._indexes[\"_rmap\"][idx] = cell\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    # Return a copy without the now obsolete repetition\n                    if cell is None:\n                        cell = Cell()\n                    else:\n                        cell = cell.clone\n                        if repeated &gt; 1:\n                            cell.repeated = None\n                    cell.y = self.y\n                    cell.x = x\n                    x += 1\n                    yield cell\n        else:\n            if start is None:\n                start = 0\n            start = max(0, start)\n            if end is None:\n                try:\n                    end = self._rmap[-1]\n                except Exception:\n                    end = -1\n            start_map = find_odf_idx(self._rmap, start)\n            if start_map is None:\n                return\n            if start_map &gt; 0:\n                before = self._rmap[start_map - 1]\n            idx = start_map - 1\n            before = start - 1\n            x = start\n            for juska in self._rmap[start_map:]:\n                idx += 1\n                if idx in self._indexes[\"_rmap\"]:\n                    cell = self._indexes[\"_rmap\"][idx]\n                else:\n                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                    if not isinstance(cell, Cell):\n                        raise TypeError(f\"Not a cell: {cell!r}\")\n                    self._indexes[\"_rmap\"][idx] = cell\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    if x &lt;= end:\n                        if cell is None:\n                            cell = Cell()\n                        else:\n                            cell = cell.clone\n                            if repeated &gt; 1 or (x == start and start &gt; 0):\n                                cell.repeated = None\n                        cell.y = self.y\n                        cell.x = x\n                        x += 1\n                        yield cell\n\n    def get_cells(\n        self,\n        coord: str | tuple | None = None,\n        style: str | None = None,\n        content: str | None = None,\n        cell_type: str | None = None,\n    ) -&gt; list[Cell]:\n        \"\"\"Get the list of cells matching the criteria.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n\n        Filter by coordinates will retrieve the amount of cells defined by\n        'coord', minus the other filters.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            content -- str regex\n\n            style -- str\n\n        Return: list of Cell\n        \"\"\"\n        # fixme : not clones ?\n        if coord:\n            x, z = self._translate_row_coordinates(coord)\n        else:\n            x = None\n            z = None\n        if cell_type:\n            cell_type = cell_type.lower().strip()\n        cells: list[Cell] = []\n        for cell in self.traverse(start=x, end=z):\n            # Filter the cells by cell_type\n            if cell_type:\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    continue\n            # Filter the cells with the regex\n            if content and not cell.match(content):\n                continue\n            # Filter the cells with the style\n            if style and style != cell.style:\n                continue\n            cells.append(cell)\n        return cells\n\n    @property\n    def cells(self) -&gt; list[Cell]:\n        \"\"\"Get the list of all cells.\n\n        Return: list of Cell\n        \"\"\"\n        # fixme : not clones ?\n        return list(self.traverse())\n\n    def _get_cell2(self, x: int, clone: bool = True) -&gt; Cell | None:\n        if x &gt;= self.width:\n            return Cell()\n        if clone:\n            return self._get_cell2_base(x).clone  # type: ignore\n        else:\n            return self._get_cell2_base(x)\n\n    def _get_cell2_base(self, x: int) -&gt; Cell | None:\n        idx = find_odf_idx(self._rmap, x)\n        cell: Cell\n        if idx is not None:\n            if idx in self._indexes[\"_rmap\"]:\n                cell = self._indexes[\"_rmap\"][idx]\n            else:\n                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                self._indexes[\"_rmap\"][idx] = cell\n            return cell\n        return None\n\n    def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:\n        \"\"\"Get the cell at position \"x\" starting from 0. Alphabetical\n        positions like \"D\" are accepted.\n\n        A  copy is returned, use set_cell() to push it back.\n\n        Arguments:\n\n            x -- int or str\n\n        Return: Cell | None\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        cell = self._get_cell2(x, clone=clone)\n        if not cell:\n            return None\n        cell.y = self.y\n        cell.x = x\n        return cell\n\n    def get_value(\n        self,\n        x: int | str,\n        get_type: bool = False,\n    ) -&gt; Any | tuple[Any, str]:\n        \"\"\"Shortcut to get the value of the cell at position \"x\".\n        If get_type is True, returns the tuples (value, ODF type).\n\n        If the cell is empty, returns None or (None, None)\n\n        See get_cell() and Cell.get_value().\n        \"\"\"\n        if get_type:\n            x = self._translate_x_from_any(x)\n            cell = self._get_cell2_base(x)\n            if cell is None:\n                return (None, None)\n            return cell.get_value(get_type=get_type)\n        x = self._translate_x_from_any(x)\n        cell = self._get_cell2_base(x)\n        if cell is None:\n            return None\n        return cell.get_value()\n\n    def set_cell(\n        self,\n        x: int | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Push the cell back in the row at position \"x\" starting from 0.\n        Alphabetical positions like \"D\" are accepted.\n\n        Arguments:\n\n            x -- int or str\n\n        returns the cell with x and y updated\n        \"\"\"\n        cell_back: Cell\n        if cell is None:\n            cell = Cell()\n            repeated = 1\n            clone = False\n        else:\n            repeated = cell.repeated or 1\n        x = self._translate_x_from_any(x)\n        # Outside the defined row\n        diff = x - self.width\n        if diff == 0:\n            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n        elif diff &gt; 0:\n            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n        else:\n            # Inside the defined row\n            set_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\", clone=clone)\n            cell.x = x\n            cell.y = self.y\n            cell_back = cell\n        return cell_back\n\n    def set_value(\n        self,\n        x: int | str,\n        value: Any,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the value of the cell at position \"x\".\n\n        Arguments:\n\n            x -- int or str\n\n            value -- Python type\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n\n        See get_cell() and Cell.get_value().\n        \"\"\"\n        self.set_cell(\n            x,\n            Cell(value, style=style, cell_type=cell_type, currency=currency),\n            clone=False,\n        )\n\n    def insert_cell(\n        self,\n        x: int | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Insert the given cell at position \"x\" starting from 0. If no cell\n        is given, an empty one is created.\n\n        Alphabetical positions like \"D\" are accepted.\n\n        Do not use when working on a table, use Table.insert_cell().\n\n        Arguments:\n\n            x -- int or str\n\n            cell -- Cell\n\n        returns the cell with x and y updated\n        \"\"\"\n        cell_back: Cell\n        if cell is None:\n            cell = Cell()\n        x = self._translate_x_from_any(x)\n        # Outside the defined row\n        diff = x - self.width\n        if diff &lt; 0:\n            insert_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\")\n            cell.x = x\n            cell.y = self.y\n            cell_back = cell\n        elif diff == 0:\n            cell_back = self.append_cell(cell, clone=clone)\n        else:\n            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n            cell_back = self.append_cell(cell, clone=clone)\n        return cell_back\n\n    def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:\n        if cells is None:\n            cells = []\n        self.extend(cells)\n        self._compute_row_cache()\n\n    def append_cell(\n        self,\n        cell: Cell | None = None,\n        clone: bool = True,\n        _repeated: int | None = None,\n    ) -&gt; Cell:\n        \"\"\"Append the given cell at the end of the row. Repeated cells are\n        accepted. If no cell is given, an empty one is created.\n\n        Do not use when working on a table, use Table.append_cell().\n\n        Arguments:\n\n            cell -- Cell\n\n            _repeated -- (optional), repeated value of the row\n\n        returns the cell with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        if clone:\n            cell = cell.clone\n        self._append(cell)\n        if _repeated is None:\n            _repeated = cell.repeated or 1\n        self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)\n        cell.x = self.width - 1\n        cell.y = self.y\n        return cell\n\n    # fix for unit test and typos\n    append = append_cell  # type: ignore\n\n    def delete_cell(self, x: int | str) -&gt; None:\n        \"\"\"Delete the cell at the given position \"x\" starting from 0.\n        Alphabetical positions like \"D\" are accepted.\n\n        Cells on the right will be shifted to the left. In a table, other\n        rows remain unaffected.\n\n        Arguments:\n\n            x -- int or str\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        if x &gt;= self.width:\n            return\n        delete_item_in_vault(x, self, _xpath_cell_idx, \"_rmap\")\n\n    def get_values(\n        self,\n        coord: str | tuple | None = None,\n        cell_type: str | None = None,\n        complete: bool = False,\n        get_type: bool = False,\n    ) -&gt; list[Any | tuple[Any, Any]]:\n        \"\"\"Shortcut to get the cell values in this row.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n        If cell_type is used and complete is True, missing values are\n        replaced by None.\n        If cell_type is None, complete is always True : with no cell type\n        queried, get_values() returns None for each empty cell, the length\n        of the list is equal to the length of the row (depending on\n        coordinates use).\n\n        If get_type is True, returns a tuple (value, ODF type of value), or\n        (None, None) for empty cells if complete is True.\n\n        Filter by coordinates will retrieve the amount of cells defined by\n        coordinates with None for empty cells, except when using cell_type.\n\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates in row\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of Python types, or list of tuples.\n        \"\"\"\n        if coord:\n            x, z = self._translate_row_coordinates(coord)\n        else:\n            x = None\n            z = None\n        if cell_type:\n            cell_type = cell_type.lower().strip()\n            values: list[Any | tuple[Any, Any]] = []\n            for cell in self.traverse(start=x, end=z):\n                # Filter the cells by cell_type\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    if complete:\n                        if get_type:\n                            values.append((None, None))\n                        else:\n                            values.append(None)\n                    continue\n                values.append(cell.get_value(get_type=get_type))\n            return values\n        else:\n            return [\n                cell.get_value(get_type=get_type)\n                for cell in self.traverse(start=x, end=z)\n            ]\n\n    def set_cells(\n        self,\n        cells: list[Cell] | tuple[Cell] | None = None,\n        start: int | str = 0,\n        clone: bool = True,\n    ) -&gt; None:\n        \"\"\"Set the cells in the row, from the 'start' column.\n        This method does not clear the row, use row.clear() before to start\n        with an empty row.\n\n        Arguments:\n\n            cells -- list of cells\n\n            start -- int or str\n        \"\"\"\n        if cells is None:\n            cells = []\n        if start is None:\n            start = 0\n        else:\n            start = self._translate_x_from_any(start)\n        if start == 0 and clone is False and (len(cells) &gt;= self.width):\n            self.clear()\n            self.extend_cells(cells)\n        else:\n            x = start\n            for cell in cells:\n                self.set_cell(x, cell, clone=clone)\n                if cell:\n                    x += cell.repeated or 1\n                else:\n                    x += 1\n\n    def set_values(\n        self,\n        values: list[Any],\n        start: int | str = 0,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the value of cells in the row, from the 'start'\n        column vith values.\n        This method does not clear the row, use row.clear() before to start\n        with an empty row.\n\n        Arguments:\n\n            values -- list of Python types\n\n            start -- int or str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency' or 'percentage'\n\n            currency -- three-letter str\n\n            style -- cell style\n        \"\"\"\n        # fixme : if values n, n+ are same, use repeat\n        if start is None:\n            start = 0\n        else:\n            start = self._translate_x_from_any(start)\n        if start == 0 and (len(values) &gt;= self.width):\n            self.clear()\n            cells = [\n                Cell(value, style=style, cell_type=cell_type, currency=currency)\n                for value in values\n            ]\n            self.extend_cells(cells)\n        else:\n            x = start\n            for value in values:\n                self.set_cell(\n                    x,\n                    Cell(value, style=style, cell_type=cell_type, currency=currency),\n                    clone=False,\n                )\n                x += 1\n\n    def rstrip(self, aggressive: bool = False) -&gt; None:\n        \"\"\"Remove *in-place* empty cells at the right of the row. An empty\n        cell has no value but can have style. If \"aggressive\" is True, style\n        is ignored.\n\n        Arguments:\n\n            aggressive -- bool\n        \"\"\"\n        for cell in reversed(self._get_cells()):\n            if not cell.is_empty(aggressive=aggressive):  # type: ignore\n                break\n            self.delete(cell)\n        self._compute_row_cache()\n        self._indexes[\"_rmap\"] = {}\n\n    def _current_length(self) -&gt; int:\n        \"\"\"Return the current estimated length of the row.\n\n        Return: int\n        \"\"\"\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_cell, \"table:number-columns-repeated\"\n        )\n        repeated = [item[1] for item in idx_repeated_seq]\n        if repeated:\n            return sum(repeated)\n        return 1\n\n    def minimized_width(self) -&gt; int:\n        \"\"\"Return the length of the row if the last repeated sequence is\n        reduced to one.\n\n        Return: int\n        \"\"\"\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_cell, \"table:number-columns-repeated\"\n        )\n        repeated = [item[1] for item in idx_repeated_seq]\n        if repeated:\n            cell = self.last_cell()\n            if cell is not None and cell.is_empty(aggressive=True):\n                repeated[-1] = 1\n            min_width = sum(repeated)\n        else:\n            min_width = 1\n        self._compute_row_cache()\n        self._indexes[\"_rmap\"] = {}\n        return min_width\n\n    def last_cell(self) -&gt; Cell | None:\n        \"\"\"Return the las cell of the row.\n\n        Return Cell | None\n        \"\"\"\n        try:\n            return self._get_cells()[-1]  # type: ignore\n        except IndexError:\n            return None\n\n    def force_width(self, width: int) -&gt; None:\n        \"\"\"Change the repeated property of the last cell of the row\n        to comply with the required max width.\n\n        Arguments:\n\n            width -- int\n        \"\"\"\n        cell = self.last_cell()\n        if cell is None or not cell.is_empty(aggressive=True):\n            return\n        repeated = cell.repeated\n        if repeated is None:\n            return\n        # empty repeated cell\n        delta = self._current_length() - width\n        if delta &gt; 0:\n            cell._set_repeated(repeated - delta)\n            self._compute_row_cache()\n\n    def is_empty(self, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return whether every cell in the row has no value or the value\n        evaluates to False (empty string), and no style.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            aggressive -- bool\n\n        Return: bool\n        \"\"\"\n        return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Row.cells","title":"<code>cells: list[Cell]</code>  <code>property</code>","text":"<p>Get the list of all cells.</p> <p>Return: list of Cell</p>"},{"location":"reference.html#odfdo.Row.repeated","title":"<code>repeated: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the number of times the row is repeated.</p> <p>Always None when using the table API.</p> <p>Return: int or None</p>"},{"location":"reference.html#odfdo.Row.style","title":"<code>style: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get /set the style of the row itself.</p> <p>Return: str</p>"},{"location":"reference.html#odfdo.Row.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>Get the number of expected cells in the row, i.e. addition repetitions.</p> <p>Return: int</p>"},{"location":"reference.html#odfdo.Row.__init__","title":"<code>__init__(width=None, repeated=None, style=None, **kwargs)</code>","text":"<p>create a Row, optionally filled with \u201cwidth\u201d number of cells.</p> <p>Rows contain cells, their number determine the number of columns.</p> <p>You don\u2019t generally have to create rows by hand, use the Table API.</p> <p>Arguments:</p> <pre><code>width -- int\n\nrepeated -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def __init__(\n    self,\n    width: int | None = None,\n    repeated: int | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"create a Row, optionally filled with \"width\" number of cells.\n\n    Rows contain cells, their number determine the number of columns.\n\n    You don't generally have to create rows by hand, use the Table API.\n\n    Arguments:\n\n        width -- int\n\n        repeated -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self.y = None\n    if not hasattr(self, \"_indexes\"):\n        self._indexes = {}\n        self._indexes[\"_rmap\"] = {}\n    if not hasattr(self, \"_rmap\"):\n        self._compute_row_cache()\n        if not hasattr(self, \"_tmap\"):\n            self._tmap = []\n            self._cmap = []\n    if self._do_init:\n        if width is not None:\n            for _i in range(width):\n                self.append(Cell())  # type:ignore\n        if repeated:\n            self.repeated = repeated\n        if style is not None:\n            self.style = style\n        self._compute_row_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Row.append_cell","title":"<code>append_cell(cell=None, clone=True, _repeated=None)</code>","text":"<p>Append the given cell at the end of the row. Repeated cells are accepted. If no cell is given, an empty one is created.</p> <p>Do not use when working on a table, use Table.append_cell().</p> <p>Arguments:</p> <pre><code>cell -- Cell\n\n_repeated -- (optional), repeated value of the row\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/row.py</code> <pre><code>def append_cell(\n    self,\n    cell: Cell | None = None,\n    clone: bool = True,\n    _repeated: int | None = None,\n) -&gt; Cell:\n    \"\"\"Append the given cell at the end of the row. Repeated cells are\n    accepted. If no cell is given, an empty one is created.\n\n    Do not use when working on a table, use Table.append_cell().\n\n    Arguments:\n\n        cell -- Cell\n\n        _repeated -- (optional), repeated value of the row\n\n    returns the cell with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    if clone:\n        cell = cell.clone\n    self._append(cell)\n    if _repeated is None:\n        _repeated = cell.repeated or 1\n    self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)\n    cell.x = self.width - 1\n    cell.y = self.y\n    return cell\n</code></pre>"},{"location":"reference.html#odfdo.Row.delete_cell","title":"<code>delete_cell(x)</code>","text":"<p>Delete the cell at the given position \u201cx\u201d starting from 0. Alphabetical positions like \u201cD\u201d are accepted.</p> <p>Cells on the right will be shifted to the left. In a table, other rows remain unaffected.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def delete_cell(self, x: int | str) -&gt; None:\n    \"\"\"Delete the cell at the given position \"x\" starting from 0.\n    Alphabetical positions like \"D\" are accepted.\n\n    Cells on the right will be shifted to the left. In a table, other\n    rows remain unaffected.\n\n    Arguments:\n\n        x -- int or str\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    if x &gt;= self.width:\n        return\n    delete_item_in_vault(x, self, _xpath_cell_idx, \"_rmap\")\n</code></pre>"},{"location":"reference.html#odfdo.Row.force_width","title":"<code>force_width(width)</code>","text":"<p>Change the repeated property of the last cell of the row to comply with the required max width.</p> <p>Arguments:</p> <pre><code>width -- int\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def force_width(self, width: int) -&gt; None:\n    \"\"\"Change the repeated property of the last cell of the row\n    to comply with the required max width.\n\n    Arguments:\n\n        width -- int\n    \"\"\"\n    cell = self.last_cell()\n    if cell is None or not cell.is_empty(aggressive=True):\n        return\n    repeated = cell.repeated\n    if repeated is None:\n        return\n    # empty repeated cell\n    delta = self._current_length() - width\n    if delta &gt; 0:\n        cell._set_repeated(repeated - delta)\n        self._compute_row_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_cell","title":"<code>get_cell(x, clone=True)</code>","text":"<p>Get the cell at position \u201cx\u201d starting from 0. Alphabetical positions like \u201cD\u201d are accepted.</p> <p>A  copy is returned, use set_cell() to push it back.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> <p>Return: Cell | None</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:\n    \"\"\"Get the cell at position \"x\" starting from 0. Alphabetical\n    positions like \"D\" are accepted.\n\n    A  copy is returned, use set_cell() to push it back.\n\n    Arguments:\n\n        x -- int or str\n\n    Return: Cell | None\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    cell = self._get_cell2(x, clone=clone)\n    if not cell:\n        return None\n    cell.y = self.y\n    cell.x = x\n    return cell\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_cells","title":"<code>get_cells(coord=None, style=None, content=None, cell_type=None)</code>","text":"<p>Get the list of cells matching the criteria.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells.</p> <p>Filter by coordinates will retrieve the amount of cells defined by \u2018coord\u2019, minus the other filters.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncontent -- str regex\n\nstyle -- str\n</code></pre> <p>Return: list of Cell</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_cells(\n    self,\n    coord: str | tuple | None = None,\n    style: str | None = None,\n    content: str | None = None,\n    cell_type: str | None = None,\n) -&gt; list[Cell]:\n    \"\"\"Get the list of cells matching the criteria.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n\n    Filter by coordinates will retrieve the amount of cells defined by\n    'coord', minus the other filters.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        content -- str regex\n\n        style -- str\n\n    Return: list of Cell\n    \"\"\"\n    # fixme : not clones ?\n    if coord:\n        x, z = self._translate_row_coordinates(coord)\n    else:\n        x = None\n        z = None\n    if cell_type:\n        cell_type = cell_type.lower().strip()\n    cells: list[Cell] = []\n    for cell in self.traverse(start=x, end=z):\n        # Filter the cells by cell_type\n        if cell_type:\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                continue\n        # Filter the cells with the regex\n        if content and not cell.match(content):\n            continue\n        # Filter the cells with the style\n        if style and style != cell.style:\n            continue\n        cells.append(cell)\n    return cells\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_value","title":"<code>get_value(x, get_type=False)</code>","text":"<p>Shortcut to get the value of the cell at position \u201cx\u201d. If get_type is True, returns the tuples (value, ODF type).</p> <p>If the cell is empty, returns None or (None, None)</p> <p>See get_cell() and Cell.get_value().</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_value(\n    self,\n    x: int | str,\n    get_type: bool = False,\n) -&gt; Any | tuple[Any, str]:\n    \"\"\"Shortcut to get the value of the cell at position \"x\".\n    If get_type is True, returns the tuples (value, ODF type).\n\n    If the cell is empty, returns None or (None, None)\n\n    See get_cell() and Cell.get_value().\n    \"\"\"\n    if get_type:\n        x = self._translate_x_from_any(x)\n        cell = self._get_cell2_base(x)\n        if cell is None:\n            return (None, None)\n        return cell.get_value(get_type=get_type)\n    x = self._translate_x_from_any(x)\n    cell = self._get_cell2_base(x)\n    if cell is None:\n        return None\n    return cell.get_value()\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_values","title":"<code>get_values(coord=None, cell_type=None, complete=False, get_type=False)</code>","text":"<p>Shortcut to get the cell values in this row.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells. If cell_type is used and complete is True, missing values are replaced by None. If cell_type is None, complete is always True : with no cell type queried, get_values() returns None for each empty cell, the length of the list is equal to the length of the row (depending on coordinates use).</p> <p>If get_type is True, returns a tuple (value, ODF type of value), or (None, None) for empty cells if complete is True.</p> <p>Filter by coordinates will retrieve the amount of cells defined by coordinates with None for empty cells, except when using cell_type.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates in row\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of Python types, or list of tuples.</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_values(\n    self,\n    coord: str | tuple | None = None,\n    cell_type: str | None = None,\n    complete: bool = False,\n    get_type: bool = False,\n) -&gt; list[Any | tuple[Any, Any]]:\n    \"\"\"Shortcut to get the cell values in this row.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n    If cell_type is used and complete is True, missing values are\n    replaced by None.\n    If cell_type is None, complete is always True : with no cell type\n    queried, get_values() returns None for each empty cell, the length\n    of the list is equal to the length of the row (depending on\n    coordinates use).\n\n    If get_type is True, returns a tuple (value, ODF type of value), or\n    (None, None) for empty cells if complete is True.\n\n    Filter by coordinates will retrieve the amount of cells defined by\n    coordinates with None for empty cells, except when using cell_type.\n\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates in row\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of Python types, or list of tuples.\n    \"\"\"\n    if coord:\n        x, z = self._translate_row_coordinates(coord)\n    else:\n        x = None\n        z = None\n    if cell_type:\n        cell_type = cell_type.lower().strip()\n        values: list[Any | tuple[Any, Any]] = []\n        for cell in self.traverse(start=x, end=z):\n            # Filter the cells by cell_type\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                if complete:\n                    if get_type:\n                        values.append((None, None))\n                    else:\n                        values.append(None)\n                continue\n            values.append(cell.get_value(get_type=get_type))\n        return values\n    else:\n        return [\n            cell.get_value(get_type=get_type)\n            for cell in self.traverse(start=x, end=z)\n        ]\n</code></pre>"},{"location":"reference.html#odfdo.Row.insert_cell","title":"<code>insert_cell(x, cell=None, clone=True)</code>","text":"<p>Insert the given cell at position \u201cx\u201d starting from 0. If no cell is given, an empty one is created.</p> <p>Alphabetical positions like \u201cD\u201d are accepted.</p> <p>Do not use when working on a table, use Table.insert_cell().</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncell -- Cell\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/row.py</code> <pre><code>def insert_cell(\n    self,\n    x: int | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Insert the given cell at position \"x\" starting from 0. If no cell\n    is given, an empty one is created.\n\n    Alphabetical positions like \"D\" are accepted.\n\n    Do not use when working on a table, use Table.insert_cell().\n\n    Arguments:\n\n        x -- int or str\n\n        cell -- Cell\n\n    returns the cell with x and y updated\n    \"\"\"\n    cell_back: Cell\n    if cell is None:\n        cell = Cell()\n    x = self._translate_x_from_any(x)\n    # Outside the defined row\n    diff = x - self.width\n    if diff &lt; 0:\n        insert_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\")\n        cell.x = x\n        cell.y = self.y\n        cell_back = cell\n    elif diff == 0:\n        cell_back = self.append_cell(cell, clone=clone)\n    else:\n        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n        cell_back = self.append_cell(cell, clone=clone)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Row.is_empty","title":"<code>is_empty(aggressive=False)</code>","text":"<p>Return whether every cell in the row has no value or the value evaluates to False (empty string), and no style.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> <p>Return: bool</p> Source code in <code>odfdo/row.py</code> <pre><code>def is_empty(self, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return whether every cell in the row has no value or the value\n    evaluates to False (empty string), and no style.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        aggressive -- bool\n\n    Return: bool\n    \"\"\"\n    return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Row.last_cell","title":"<code>last_cell()</code>","text":"<p>Return the las cell of the row.</p> <p>Return Cell | None</p> Source code in <code>odfdo/row.py</code> <pre><code>def last_cell(self) -&gt; Cell | None:\n    \"\"\"Return the las cell of the row.\n\n    Return Cell | None\n    \"\"\"\n    try:\n        return self._get_cells()[-1]  # type: ignore\n    except IndexError:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Row.minimized_width","title":"<code>minimized_width()</code>","text":"<p>Return the length of the row if the last repeated sequence is reduced to one.</p> <p>Return: int</p> Source code in <code>odfdo/row.py</code> <pre><code>def minimized_width(self) -&gt; int:\n    \"\"\"Return the length of the row if the last repeated sequence is\n    reduced to one.\n\n    Return: int\n    \"\"\"\n    idx_repeated_seq = self.elements_repeated_sequence(\n        _xpath_cell, \"table:number-columns-repeated\"\n    )\n    repeated = [item[1] for item in idx_repeated_seq]\n    if repeated:\n        cell = self.last_cell()\n        if cell is not None and cell.is_empty(aggressive=True):\n            repeated[-1] = 1\n        min_width = sum(repeated)\n    else:\n        min_width = 1\n    self._compute_row_cache()\n    self._indexes[\"_rmap\"] = {}\n    return min_width\n</code></pre>"},{"location":"reference.html#odfdo.Row.rstrip","title":"<code>rstrip(aggressive=False)</code>","text":"<p>Remove in-place empty cells at the right of the row. An empty cell has no value but can have style. If \u201caggressive\u201d is True, style is ignored.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def rstrip(self, aggressive: bool = False) -&gt; None:\n    \"\"\"Remove *in-place* empty cells at the right of the row. An empty\n    cell has no value but can have style. If \"aggressive\" is True, style\n    is ignored.\n\n    Arguments:\n\n        aggressive -- bool\n    \"\"\"\n    for cell in reversed(self._get_cells()):\n        if not cell.is_empty(aggressive=aggressive):  # type: ignore\n            break\n        self.delete(cell)\n    self._compute_row_cache()\n    self._indexes[\"_rmap\"] = {}\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_cell","title":"<code>set_cell(x, cell=None, clone=True)</code>","text":"<p>Push the cell back in the row at position \u201cx\u201d starting from 0. Alphabetical positions like \u201cD\u201d are accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/row.py</code> <pre><code>def set_cell(\n    self,\n    x: int | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Push the cell back in the row at position \"x\" starting from 0.\n    Alphabetical positions like \"D\" are accepted.\n\n    Arguments:\n\n        x -- int or str\n\n    returns the cell with x and y updated\n    \"\"\"\n    cell_back: Cell\n    if cell is None:\n        cell = Cell()\n        repeated = 1\n        clone = False\n    else:\n        repeated = cell.repeated or 1\n    x = self._translate_x_from_any(x)\n    # Outside the defined row\n    diff = x - self.width\n    if diff == 0:\n        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n    elif diff &gt; 0:\n        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n    else:\n        # Inside the defined row\n        set_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\", clone=clone)\n        cell.x = x\n        cell.y = self.y\n        cell_back = cell\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_cells","title":"<code>set_cells(cells=None, start=0, clone=True)</code>","text":"<p>Set the cells in the row, from the \u2018start\u2019 column. This method does not clear the row, use row.clear() before to start with an empty row.</p> <p>Arguments:</p> <pre><code>cells -- list of cells\n\nstart -- int or str\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def set_cells(\n    self,\n    cells: list[Cell] | tuple[Cell] | None = None,\n    start: int | str = 0,\n    clone: bool = True,\n) -&gt; None:\n    \"\"\"Set the cells in the row, from the 'start' column.\n    This method does not clear the row, use row.clear() before to start\n    with an empty row.\n\n    Arguments:\n\n        cells -- list of cells\n\n        start -- int or str\n    \"\"\"\n    if cells is None:\n        cells = []\n    if start is None:\n        start = 0\n    else:\n        start = self._translate_x_from_any(start)\n    if start == 0 and clone is False and (len(cells) &gt;= self.width):\n        self.clear()\n        self.extend_cells(cells)\n    else:\n        x = start\n        for cell in cells:\n            self.set_cell(x, cell, clone=clone)\n            if cell:\n                x += cell.repeated or 1\n            else:\n                x += 1\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_value","title":"<code>set_value(x, value, style=None, cell_type=None, currency=None)</code>","text":"<p>Shortcut to set the value of the cell at position \u201cx\u201d.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\nvalue -- Python type\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n         'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> <p>See get_cell() and Cell.get_value().</p> Source code in <code>odfdo/row.py</code> <pre><code>def set_value(\n    self,\n    x: int | str,\n    value: Any,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the value of the cell at position \"x\".\n\n    Arguments:\n\n        x -- int or str\n\n        value -- Python type\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                 'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n\n    See get_cell() and Cell.get_value().\n    \"\"\"\n    self.set_cell(\n        x,\n        Cell(value, style=style, cell_type=cell_type, currency=currency),\n        clone=False,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_values","title":"<code>set_values(values, start=0, style=None, cell_type=None, currency=None)</code>","text":"<p>Shortcut to set the value of cells in the row, from the \u2018start\u2019 column vith values. This method does not clear the row, use row.clear() before to start with an empty row.</p> <p>Arguments:</p> <pre><code>values -- list of Python types\n\nstart -- int or str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency' or 'percentage'\n\ncurrency -- three-letter str\n\nstyle -- cell style\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def set_values(\n    self,\n    values: list[Any],\n    start: int | str = 0,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the value of cells in the row, from the 'start'\n    column vith values.\n    This method does not clear the row, use row.clear() before to start\n    with an empty row.\n\n    Arguments:\n\n        values -- list of Python types\n\n        start -- int or str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency' or 'percentage'\n\n        currency -- three-letter str\n\n        style -- cell style\n    \"\"\"\n    # fixme : if values n, n+ are same, use repeat\n    if start is None:\n        start = 0\n    else:\n        start = self._translate_x_from_any(start)\n    if start == 0 and (len(values) &gt;= self.width):\n        self.clear()\n        cells = [\n            Cell(value, style=style, cell_type=cell_type, currency=currency)\n            for value in values\n        ]\n        self.extend_cells(cells)\n    else:\n        x = start\n        for value in values:\n            self.set_cell(\n                x,\n                Cell(value, style=style, cell_type=cell_type, currency=currency),\n                clone=False,\n            )\n            x += 1\n</code></pre>"},{"location":"reference.html#odfdo.Row.traverse","title":"<code>traverse(start=None, end=None)</code>","text":"<p>Yield as many cell elements as expected cells in the row, i.e. expand repetitions by returning the same cell as many times as necessary.</p> <pre><code>Arguments:\n\n    start -- int\n\n    end -- int\n</code></pre> <p>Copies are returned, use set_cell() to push them back.</p> Source code in <code>odfdo/row.py</code> <pre><code>def traverse(  # noqa: C901\n    self,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; Iterator[Cell]:\n    \"\"\"Yield as many cell elements as expected cells in the row, i.e.\n    expand repetitions by returning the same cell as many times as\n    necessary.\n\n        Arguments:\n\n            start -- int\n\n            end -- int\n\n    Copies are returned, use set_cell() to push them back.\n    \"\"\"\n    idx = -1\n    before = -1\n    x = 0\n    cell: Cell\n    if start is None and end is None:\n        for juska in self._rmap:\n            idx += 1\n            if idx in self._indexes[\"_rmap\"]:\n                cell = self._indexes[\"_rmap\"][idx]\n            else:\n                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                if not isinstance(cell, Cell):\n                    raise TypeError(f\"Not a cell: {cell!r}\")\n                self._indexes[\"_rmap\"][idx] = cell\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                # Return a copy without the now obsolete repetition\n                if cell is None:\n                    cell = Cell()\n                else:\n                    cell = cell.clone\n                    if repeated &gt; 1:\n                        cell.repeated = None\n                cell.y = self.y\n                cell.x = x\n                x += 1\n                yield cell\n    else:\n        if start is None:\n            start = 0\n        start = max(0, start)\n        if end is None:\n            try:\n                end = self._rmap[-1]\n            except Exception:\n                end = -1\n        start_map = find_odf_idx(self._rmap, start)\n        if start_map is None:\n            return\n        if start_map &gt; 0:\n            before = self._rmap[start_map - 1]\n        idx = start_map - 1\n        before = start - 1\n        x = start\n        for juska in self._rmap[start_map:]:\n            idx += 1\n            if idx in self._indexes[\"_rmap\"]:\n                cell = self._indexes[\"_rmap\"][idx]\n            else:\n                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                if not isinstance(cell, Cell):\n                    raise TypeError(f\"Not a cell: {cell!r}\")\n                self._indexes[\"_rmap\"][idx] = cell\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                if x &lt;= end:\n                    if cell is None:\n                        cell = Cell()\n                    else:\n                        cell = cell.clone\n                        if repeated &gt; 1 or (x == start and start &gt; 0):\n                            cell.repeated = None\n                    cell.y = self.y\n                    cell.x = x\n                    x += 1\n                    yield cell\n</code></pre>"},{"location":"reference.html#odfdo.RowGroup","title":"<code>RowGroup</code>","text":"<p>             Bases: <code>Element</code></p> <p>\u201ctable:table-row-group\u201d group rows with common properties.</p> Source code in <code>odfdo/table.py</code> <pre><code>class RowGroup(Element):\n    \"\"\" \"table:table-row-group\" group rows with common properties.\"\"\"\n\n    # TODO\n    _tag = \"table:table-row-group\"\n    _caching = True\n\n    def __init__(\n        self,\n        height: int | None = None,\n        width: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a group of rows, optionnaly filled with \"height\" number of\n        rows, of \"width\" cells each.\n\n        Row group bear style information applied to a series of rows.\n\n        Arguments:\n\n            height -- int\n\n            width -- int\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init and height is not None:\n            for _i in range(height):\n                row = Row(width=width)\n                self.append(row)\n</code></pre>"},{"location":"reference.html#odfdo.RowGroup.__init__","title":"<code>__init__(height=None, width=None, **kwargs)</code>","text":"<p>Create a group of rows, optionnaly filled with \u201cheight\u201d number of rows, of \u201cwidth\u201d cells each.</p> <p>Row group bear style information applied to a series of rows.</p> <p>Arguments:</p> <pre><code>height -- int\n\nwidth -- int\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    height: int | None = None,\n    width: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a group of rows, optionnaly filled with \"height\" number of\n    rows, of \"width\" cells each.\n\n    Row group bear style information applied to a series of rows.\n\n    Arguments:\n\n        height -- int\n\n        width -- int\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init and height is not None:\n        for _i in range(height):\n            row = Row(width=width)\n            self.append(row)\n</code></pre>"},{"location":"reference.html#odfdo.Section","title":"<code>Section</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF section \u201ctext:section\u201d</p> <p>Arguments:</p> <pre><code>style -- str\n\nname -- str\n</code></pre> Source code in <code>odfdo/section.py</code> <pre><code>class Section(Element):\n    \"\"\"ODF section \"text:section\"\n\n    Arguments:\n\n        style -- str\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:section\"\n    _properties = (\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"name\", \"text:name\"),\n    )\n\n    def __init__(\n        self,\n        style: str | None = None,\n        name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style:\n                self.style = style\n            if name:\n                self.name = name\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        result = [element.get_formatted_text(context) for element in self.children]\n        result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Spacer","title":"<code>Spacer</code>","text":"<p>             Bases: <code>Element</code></p> <p>This element shall be used to represent the second and all following \u201c \u201c (U+0020, SPACE) characters in a sequence of \u201c \u201c (U+0020, SPACE) characters. Note: It is not an error if the character preceding the element is not a white space character, but it is good practice to use this element only for the second and all following SPACE characters in a sequence.</p> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>class Spacer(Element):\n    \"\"\"This element shall be used to represent the second and all following \u201c \u201c\n    (U+0020, SPACE) characters in a sequence of \u201c \u201c (U+0020, SPACE) characters.\n    Note: It is not an error if the character preceding the element is not a\n    white space character, but it is good practice to use this element only for\n    the second and all following SPACE characters in a sequence.\n    \"\"\"\n\n    _tag = \"text:s\"\n    _properties: tuple[PropDef, ...] = (PropDef(\"number\", \"text:c\"),)\n\n    def __init__(self, number: int = 1, **kwargs: Any):\n        \"\"\"\n        Arguments:\n\n            number -- int\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.number = str(number)\n</code></pre>"},{"location":"reference.html#odfdo.Spacer.__init__","title":"<code>__init__(number=1, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>number -- int\n</code></pre> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>def __init__(self, number: int = 1, **kwargs: Any):\n    \"\"\"\n    Arguments:\n\n        number -- int\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.number = str(number)\n</code></pre>"},{"location":"reference.html#odfdo.Span","title":"<code>Span</code>","text":"<p>             Bases: <code>Paragraph</code></p> <p>Create a span element \u201ctext:span\u201d of the given style containing the optional given text.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>class Span(Paragraph):\n    \"\"\"Create a span element \"text:span\" of the given style containing the optional\n    given text.\n    \"\"\"\n\n    _tag = \"text:span\"\n    _properties = (\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"class_names\", \"text:class-names\"),\n    )\n\n    def __init__(\n        self,\n        text: str | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            text -- str\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if text:\n                self.text = text\n            if style:\n                self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Span.__init__","title":"<code>__init__(text=None, style=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>text -- str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        text -- str\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if text:\n            self.text = text\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Spreadsheet","title":"<code>Spreadsheet</code>","text":"<p>             Bases: <code>Body</code></p> <p>Spreadsheet, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Spreadsheet(Body):\n    \"\"\"Spreadsheet, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:spreadsheet\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.Style","title":"<code>Style</code>","text":"<p>             Bases: <code>Element</code></p> <p>Style class for all these tags:</p> <p>\u2018style:style\u2019 \u2018number:date-style\u2019, \u2018number:number-style\u2019, \u2018number:percentage-style\u2019, \u2018number:time-style\u2019 \u2018style:font-face\u2019, \u2018style:master-page\u2019, \u2018style:page-layout\u2019, \u2018style:presentation-page-layout\u2019, \u2018text:list-style\u2019, \u2018text:outline-style\u2019, \u2018style:tab-stops\u2019, \u2026</p> Source code in <code>odfdo/style.py</code> <pre><code>class Style(Element):\n    \"\"\"Style class for all these tags:\n\n    'style:style'\n    'number:date-style',\n    'number:number-style',\n    'number:percentage-style',\n    'number:time-style'\n    'style:font-face',\n    'style:master-page',\n    'style:page-layout',\n    'style:presentation-page-layout',\n    'text:list-style',\n    'text:outline-style',\n    'style:tab-stops',\n    ...\n    \"\"\"\n\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"page_layout\", \"style:page-layout-name\", \"master-page\"),\n        PropDef(\"next_style\", \"style:next-style-name\", \"master-page\"),\n        PropDef(\"name\", \"style:name\"),\n        PropDef(\"parent_style\", \"style:parent-style-name\"),\n        PropDef(\"display_name\", \"style:display-name\"),\n        PropDef(\"svg_font_family\", \"svg:font-family\"),\n        PropDef(\"font_family_generic\", \"style:font-family-generic\"),\n        PropDef(\"font_pitch\", \"style:font-pitch\"),\n        PropDef(\"text_style\", \"text:style-name\"),\n        PropDef(\"master_page\", \"style:master-page-name\", \"paragraph\"),\n        PropDef(\"master_page\", \"style:master-page-name\", \"paragraph\"),\n        PropDef(\"master_page\", \"style:master-page-name\", \"paragraph\"),\n        # style:tab-stop\n        PropDef(\"style_type\", \"style:type\"),\n        PropDef(\"leader_style\", \"style:leader-style\"),\n        PropDef(\"leader_text\", \"style:leader-text\"),\n        PropDef(\"style_position\", \"style:position\"),\n        PropDef(\"leader_text\", \"style:position\"),\n    )\n\n    def __init__(  # noqa: C901\n        self,\n        family: str | None = None,\n        name: str | None = None,\n        display_name: str | None = None,\n        parent_style: str | None = None,\n        # Where properties apply\n        area: str | None = None,\n        # For family 'text':\n        color: str | tuple | None = None,\n        background_color: str | tuple | None = None,\n        italic: bool = False,\n        bold: bool = False,\n        # For family 'paragraph'\n        master_page: str | None = None,\n        # For family 'master-page'\n        page_layout: str | None = None,\n        next_style: str | None = None,\n        # For family 'table-cell'\n        data_style: str | None = None,  # unused\n        border: str | None = None,\n        border_top: str | None = None,\n        border_right: str | None = None,\n        border_bottom: str | None = None,\n        border_left: str | None = None,\n        padding: str | None = None,\n        padding_top: str | None = None,\n        padding_bottom: str | None = None,\n        padding_left: str | None = None,\n        padding_right: str | None = None,\n        shadow: str | None = None,\n        # For family 'table-row'\n        height: str | None = None,\n        use_optimal_height: bool = False,\n        # For family 'table-column'\n        width: str | None = None,\n        break_before: str | None = None,\n        break_after: str | None = None,\n        # For family 'graphic'\n        min_height: str | None = None,\n        # For family 'font-face'\n        font_name: str | None = None,\n        font_family: str | None = None,\n        font_family_generic: str | None = None,\n        font_pitch: str = \"variable\",\n        # Every other property\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a style of the given family. The name is not mandatory at this\n        point but will become required when inserting in a document as a common\n        style.\n\n        The display name is the name the user sees in an office application.\n\n        The parent_style is the name of the style this style will inherit from.\n\n        To set properties, pass them as keyword arguments. The area properties\n        apply to is optional and defaults to the family.\n\n        Arguments:\n\n            family -- 'paragraph', 'text', 'section', 'table', 'table-column',\n                      'table-row', 'table-cell', 'table-page', 'chart',\n                      'drawing-page', 'graphic', 'presentation',\n                      'control', 'ruby', 'list', 'number', 'page-layout'\n                      'font-face', or 'master-page'\n\n            name -- str\n\n            display_name -- str\n\n            parent_style -- str\n\n            area -- str\n\n        'text' Properties:\n\n            italic -- bool\n\n            bold -- bool\n\n        'paragraph' Properties:\n\n            master_page -- str\n\n        'master-page' Properties:\n\n            page_layout -- str\n\n            next_style -- str\n\n        'table-cell' Properties:\n\n            border, border_top, border_right, border_bottom, border_left -- str,\n            e.g. \"0.002cm solid #000000\" or 'none'\n\n            padding, padding_top, padding_right, padding_bottom, padding_left -- str,\n            e.g. \"0.002cm\" or 'none'\n\n            shadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\n        'table-row' Properties:\n\n            height -- str, e.g. '5cm'\n\n            use_optimal_height -- bool\n\n        'table-column' Properties:\n\n            width -- str, e.g. '5cm'\n\n            break_before -- 'page', 'column' or 'auto'\n\n            break_after -- 'page', 'column' or 'auto'\n        \"\"\"\n        self._family: str | None = None\n        tag_or_elem = kwargs.get(\"tag_or_elem\", None)\n        if tag_or_elem is None:\n            family = to_str(family)\n            if family not in FAMILY_MAPPING:\n                raise ValueError(f\"Unknown family value: '{family}'\")\n            kwargs[\"tag\"] = FAMILY_MAPPING[family]\n        super().__init__(**kwargs)\n        if self._do_init and family not in SUBCLASSED_STYLES:\n            kwargs.pop(\"tag\", None)\n            kwargs.pop(\"tag_or_elem\", None)\n            self.family = family  # relevant test made by property\n            # Common attributes\n            if name:\n                self.name = name\n            if display_name:\n                self.display_name = display_name\n            if parent_style:\n                self.parent_style = parent_style\n            # Paragraph\n            if family == \"paragraph\":\n                if master_page:\n                    self.master_page = master_page\n            # Master Page\n            elif family == \"master-page\":\n                if page_layout:\n                    self.page_layout = page_layout\n                if next_style:\n                    self.next_style = next_style\n            # Font face\n            elif family == \"font-face\":\n                if not font_name:\n                    raise ValueError(\"A font_name is required for 'font-face' style\")\n                self.set_font(\n                    font_name,\n                    family=font_family,\n                    family_generic=font_family_generic,\n                    pitch=font_pitch,\n                )\n            # Properties\n            if area is None:\n                area = family\n            area = to_str(area)\n            # Text\n            if area == \"text\":\n                if color:\n                    kwargs[\"fo:color\"] = color\n                if background_color:\n                    kwargs[\"fo:background-color\"] = background_color\n                if italic:\n                    kwargs[\"fo:font-style\"] = \"italic\"\n                    kwargs[\"style:font-style-asian\"] = \"italic\"\n                    kwargs[\"style:font-style-complex\"] = \"italic\"\n                if bold:\n                    kwargs[\"fo:font-weight\"] = \"bold\"\n                    kwargs[\"style:font-weight-asian\"] = \"bold\"\n                    kwargs[\"style:font-weight-complex\"] = \"bold\"\n            # Table cell\n            elif area == \"table-cell\":\n                if border:\n                    kwargs[\"fo:border\"] = border\n                elif border_top or border_right or border_bottom or border_left:\n                    kwargs[\"fo:border-top\"] = border_top or \"none\"\n                    kwargs[\"fo:border-right\"] = border_right or \"none\"\n                    kwargs[\"fo:border-bottom\"] = border_bottom or \"none\"\n                    kwargs[\"fo:border-left\"] = border_left or \"none\"\n                else:  # no border_top, ... neither border are defined\n                    pass  # left untouched\n                if padding:\n                    kwargs[\"fo:padding\"] = padding\n                elif padding_top or padding_right or padding_bottom or padding_left:\n                    kwargs[\"fo:padding-top\"] = padding_top or \"none\"\n                    kwargs[\"fo:padding-right\"] = padding_right or \"none\"\n                    kwargs[\"fo:padding-bottom\"] = padding_bottom or \"none\"\n                    kwargs[\"fo:padding-left\"] = padding_left or \"none\"\n                else:  # no border_top, ... neither border are defined\n                    pass  # left untouched\n                if shadow:\n                    kwargs[\"style:shadow\"] = shadow\n                if background_color:\n                    kwargs[\"fo:background-color\"] = background_color\n            # Table row\n            elif area == \"table-row\":\n                if height:\n                    kwargs[\"style:row-height\"] = height\n                if use_optimal_height:\n                    kwargs[\"style:use-optimal-row-height\"] = Boolean.encode(\n                        use_optimal_height\n                    )\n                if background_color:\n                    kwargs[\"fo:background-color\"] = background_color\n            # Table column\n            elif area == \"table-column\":\n                if width:\n                    kwargs[\"style:column-width\"] = width\n                if break_before:\n                    kwargs[\"fo:break-before\"] = break_before\n                if break_after:\n                    kwargs[\"fo:break-after\"] = break_after\n            # Graphic\n            elif area == \"graphic\":\n                if min_height:\n                    kwargs[\"fo:min-height\"] = min_height\n            # Every other properties\n            if kwargs:\n                self.set_properties(kwargs, area=area)\n\n    @property\n    def family(self) -&gt; str | None:\n        if self._family is None:\n            self._family = FALSE_FAMILY_MAP_REVERSE.get(\n                self.tag, self.get_attribute_string(\"style:family\")\n            )\n        return self._family\n\n    @family.setter\n    def family(self, family: str | None) -&gt; None:\n        self._family = family\n        if family in FAMILY_ODF_STD and self.tag == \"style:style\":\n            self.set_attribute(\"style:family\", family)\n\n    def get_properties(self, area: str | None = None) -&gt; dict[str, str | dict] | None:\n        \"\"\"Get the mapping of all properties of this style. By default the\n        properties of the same family, e.g. a paragraph style and its\n        paragraph properties. Specify the area to get the text properties of\n        a paragraph style for example.\n\n        Arguments:\n\n            area -- str\n\n        Return: dict\n        \"\"\"\n        if area is None:\n            area = self.family\n        element = self.get_element(f\"style:{area}-properties\")\n        if element is None:\n            return None\n        properties: dict[str, str | dict] = element.attributes  # type: ignore\n        # Nested properties are nested dictionaries\n        for child in element.children:\n            properties[child.tag] = child.attributes\n        return properties\n\n    def set_properties(  # noqa: C901\n        self,\n        properties: dict[str, str | dict] | None = None,\n        style: Style | None = None,\n        area: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Set the properties of the \"area\" type of this style. Properties\n        are given either as a dict or as named arguments (or both). The area\n        is identical to the style family by default. If the properties\n        element is missing, it is created.\n\n        Instead of properties, you can pass a style with properties of the\n        same area. These will be copied.\n\n        Arguments:\n\n            properties -- dict\n\n            style -- Style\n\n            area -- 'paragraph', 'text'...\n        \"\"\"\n        if properties is None:\n            properties = {}\n        if area is None:\n            if isinstance(self.family, bool):\n                area = None\n            else:\n                area = self.family\n        element = self.get_element(f\"style:{area}-properties\")\n        if element is None:\n            element = Element.from_tag(f\"style:{area}-properties\")\n            self.append(element)\n        if properties or kwargs:\n            properties = _expand_properties_dict(_merge_dicts(properties, kwargs))\n        elif style is not None:\n            properties = style.get_properties(area=area)\n            if properties is None:\n                return\n        if properties is None:\n            return\n        for key, value in properties.items():\n            if value is None:\n                element.del_attribute(key)\n            elif isinstance(value, (str, bool, tuple)):\n                element.set_attribute(key, value)\n            else:\n                pass\n\n    def del_properties(\n        self,\n        properties: list[str] | None = None,\n        area: str | None = None,\n    ) -&gt; None:\n        \"\"\"Delete the given properties, either by list argument or\n        positional argument (or both). Remove only from the given area,\n        identical to the style family by default.\n\n        Arguments:\n\n            properties -- list\n\n            area -- str\n        \"\"\"\n        if properties is None:\n            properties = []\n        if area is None:\n            area = self.family\n        element = self.get_element(f\"style:{area}-properties\")\n        if element is None:\n            raise ValueError(\n                f\"properties element is inexistent for: style:{area}-properties\"\n            )\n        for key in _expand_properties_list(properties):\n            element.del_attribute(key)\n\n    def set_background(  # noqa: C901\n        self,\n        color: str | None = None,\n        url: str | None = None,\n        position: str | None = \"center\",\n        repeat: str | None = None,\n        opacity: str | None = None,\n        filter: str | None = None,  # noqa: A002\n    ) -&gt; None:\n        \"\"\"Set the background color of a text style, or the background color\n        or image of a paragraph style or page layout.\n\n        With no argument, remove any existing background.\n\n        The position is one or two of 'center', 'left', 'right', 'top' or\n        'bottom'.\n\n        The repeat is 'no-repeat', 'repeat' or 'stretch'.\n\n        The opacity is a percentage integer (not a string with the '%s' sign)\n\n        The filter is an application-specific filter name defined elsewhere.\n\n        Though this method is defined on the base style class, it will raise\n        an error if the style type is not compatible.\n\n        Arguments:\n\n            color -- '#rrggbb'\n\n            url -- str\n\n            position -- str\n\n            repeat -- str\n\n            opacity -- int\n\n            filter -- str\n        \"\"\"\n        family = self.family\n        if family not in {\n            \"text\",\n            \"paragraph\",\n            \"page-layout\",\n            \"section\",\n            \"table\",\n            \"table-row\",\n            \"table-cell\",\n            \"graphic\",\n        }:\n            raise TypeError(\"No background support for this family\")\n        if url is not None and family == \"text\":\n            raise TypeError(\"No background image for text styles\")\n        properties = self.get_element(f\"style:{family}-properties\")\n        bg_image: BackgroundImage | None = None\n        if properties is not None:\n            bg_image = properties.get_element(\"style:background-image\")  # type:ignore\n        # Erasing\n        if color is None and url is None:\n            if properties is None:\n                return\n            properties.del_attribute(\"fo:background-color\")\n            if bg_image is not None:\n                properties.delete(bg_image)\n            return\n        # Add the properties if necessary\n        if properties is None:\n            properties = Element.from_tag(f\"style:{family}-properties\")\n            self.append(properties)\n        # Add the color...\n        if color:\n            properties.set_attribute(\"fo:background-color\", color)\n            if bg_image is not None:\n                properties.delete(bg_image)\n        # ... or the background\n        elif url:\n            properties.set_attribute(\"fo:background-color\", \"transparent\")\n            if bg_image is None:\n                bg_image = Element.from_tag(\"style:background-image\")  # type:ignore\n                properties.append(bg_image)  # type:ignore\n            bg_image.url = url  # type:ignore\n            if position:\n                bg_image.position = position  # type:ignore\n            if repeat:\n                bg_image.repeat = repeat  # type:ignore\n            if opacity:\n                bg_image.opacity = opacity  # type:ignore\n            if filter:\n                bg_image.filter = filter  # type:ignore\n\n    # list-style only:\n\n    def get_level_style(self, level: int) -&gt; Style | None:\n        if self.family != \"list\":\n            return None\n        level_styles = (\n            \"(text:list-level-style-number\"\n            \"|text:list-level-style-bullet\"\n            \"|text:list-level-style-image)\"\n        )\n        return self._filtered_element(level_styles, 0, level=level)  # type: ignore\n\n    def set_level_style(  # noqa: C901\n        self,\n        level: int,\n        num_format: str | None = None,\n        bullet_char: str | None = None,\n        url: str | None = None,\n        display_levels: int | None = None,\n        prefix: str | None = None,\n        suffix: str | None = None,\n        start_value: int | None = None,\n        style: str | None = None,\n        clone: Style | None = None,\n    ) -&gt; Style | None:\n        \"\"\"\n        Arguments:\n\n            level -- int\n\n            num_format (for number) -- int\n\n            bullet_char (for bullet) -- str\n\n            url (for image) -- str\n\n            display_levels -- int\n\n            prefix -- str\n\n            suffix -- str\n\n            start_value -- int\n\n            style -- str\n\n            clone -- List Style\n\n        Return:\n            level_style created\n        \"\"\"\n        if self.family != \"list\":\n            return None\n        # Expected name\n        if num_format is not None:\n            level_style_name = \"text:list-level-style-number\"\n        elif bullet_char is not None:\n            level_style_name = \"text:list-level-style-bullet\"\n        elif url is not None:\n            level_style_name = \"text:list-level-style-image\"\n        elif clone is not None:\n            level_style_name = clone.tag\n        else:\n            raise ValueError(\"unknown level style type\")\n        was_created = False\n        # Cloning or reusing an existing element\n        level_style: Style | None = None\n        if clone is not None:\n            level_style = clone.clone  # type: ignore\n            was_created = True\n        else:\n            level_style = self.get_level_style(level)\n            if level_style is None:\n                level_style = Element.from_tag(level_style_name)  # type: ignore\n                was_created = True\n        if level_style is None:\n            return None\n        # Transmute if the type changed\n        if level_style.tag != level_style_name:\n            print(\"Warn: different style\", level_style_name, level_style.tag)\n            level_style.tag = level_style_name\n        # Set the level\n        level_style.set_attribute(\"text:level\", str(level))\n        # Set the main attribute\n        if num_format is not None:\n            level_style.set_attribute(\"fo:num-format\", num_format)\n        elif bullet_char is not None:\n            level_style.set_attribute(\"text:bullet-char\", bullet_char)\n        elif url is not None:\n            level_style.set_attribute(\"xlink:href\", url)\n        # Set attributes\n        if prefix:\n            level_style.set_attribute(\"style:num-prefix\", prefix)\n        if suffix:\n            level_style.set_attribute(\"style:num-suffix\", suffix)\n        if display_levels:\n            level_style.set_attribute(\"text:display-levels\", str(display_levels))\n        if start_value:\n            level_style.set_attribute(\"text:start-value\", str(start_value))\n        if style:\n            level_style.text_style = style  # type: ignore\n        # Commit the creation\n        if was_created:\n            self.append(level_style)\n        return level_style\n\n    # page-layout only:\n\n    def get_header_style(self) -&gt; Element | None:\n        if self.family != \"page-layout\":\n            return None\n        return self.get_element(\"style:header-style\")\n\n    def set_header_style(self, new_style: Style) -&gt; None:\n        if self.family != \"page-layout\":\n            return\n        header_style = self.get_header_style()\n        if header_style is not None:\n            self.delete(header_style)\n        self.append(new_style)\n\n    def get_footer_style(self) -&gt; Style | None:\n        if self.family != \"page-layout\":\n            return None\n        return self.get_element(\"style:footer-style\")  # type: ignore\n\n    def set_footer_style(self, new_style: Style) -&gt; None:\n        if self.family != \"page-layout\":\n            return\n        footer_style = self.get_footer_style()\n        if footer_style is not None:\n            self.delete(footer_style)\n        self.append(new_style)\n\n    # master-page only:\n\n    def _set_header_or_footer(\n        self,\n        text_or_element: str | Element | list[Element | str],\n        name: str = \"header\",\n        style: str = \"Header\",\n    ) -&gt; None:\n        if name == \"header\":\n            header_or_footer = self.get_page_header()\n        else:\n            header_or_footer = self.get_page_footer()\n        if header_or_footer is None:\n            header_or_footer = Element.from_tag(\"style:\" + name)\n            self.append(header_or_footer)\n        else:\n            header_or_footer.clear()\n        if (\n            isinstance(text_or_element, Element)\n            and text_or_element.tag == f\"style:{name}\"\n        ):\n            # Already a header or footer?\n            self.delete(header_or_footer)\n            self.append(text_or_element)\n            return\n        if isinstance(text_or_element, (Element, str)):\n            elem_list: list[Element | str] = [text_or_element]\n        else:\n            elem_list = text_or_element\n        for item in elem_list:\n            if isinstance(item, str):\n                paragraph = Element.from_tag(\"text:p\")\n                paragraph.style = style  # type: ignore\n                header_or_footer.append(paragraph)\n            elif isinstance(item, Element):\n                header_or_footer.append(item)\n\n    def get_page_header(self) -&gt; Element | None:\n        \"\"\"Get the element that contains the header contents.\n\n        If None, no header was set.\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        return self.get_element(\"style:header\")\n\n    def set_page_header(\n        self,\n        text_or_element: str | Element | list[Element | str],\n    ) -&gt; None:\n        \"\"\"Create or replace the header by the given content. It can already\n        be a complete header.\n\n        If you only want to update the existing header, get it and use the\n        API.\n\n        Arguments:\n\n            text_or_element -- str or Element or a list of them\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        self._set_header_or_footer(text_or_element)\n\n    def get_page_footer(self) -&gt; Element | None:\n        \"\"\"Get the element that contains the footer contents.\n\n        If None, no footer was set.\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        return self.get_element(\"style:footer\")\n\n    def set_page_footer(\n        self,\n        text_or_element: str | Element | list[Element | str],\n    ) -&gt; None:\n        \"\"\"Create or replace the footer by the given content. It can already\n        be a complete footer.\n\n        If you only want to update the existing footer, get it and use the\n        API.\n\n        Arguments:\n\n            text_or_element -- str or Element or a list of them\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        self._set_header_or_footer(text_or_element, name=\"footer\", style=\"Footer\")\n\n    # font-face only:\n\n    def set_font(\n        self,\n        name: str,\n        family: str | None = None,\n        family_generic: str | None = None,\n        pitch: str = \"variable\",\n    ) -&gt; None:\n        if self.family != \"font-face\":\n            return\n        self.name = name\n        if family is None:\n            family = name\n        self.svg_font_family = f'\"{family}\"'\n        if family_generic is not None:\n            self.font_family_generic = family_generic\n        self.font_pitch = pitch\n</code></pre>"},{"location":"reference.html#odfdo.Style.__init__","title":"<code>__init__(family=None, name=None, display_name=None, parent_style=None, area=None, color=None, background_color=None, italic=False, bold=False, master_page=None, page_layout=None, next_style=None, data_style=None, border=None, border_top=None, border_right=None, border_bottom=None, border_left=None, padding=None, padding_top=None, padding_bottom=None, padding_left=None, padding_right=None, shadow=None, height=None, use_optimal_height=False, width=None, break_before=None, break_after=None, min_height=None, font_name=None, font_family=None, font_family_generic=None, font_pitch='variable', **kwargs)</code>","text":"<p>Create a style of the given family. The name is not mandatory at this point but will become required when inserting in a document as a common style.</p> <p>The display name is the name the user sees in an office application.</p> <p>The parent_style is the name of the style this style will inherit from.</p> <p>To set properties, pass them as keyword arguments. The area properties apply to is optional and defaults to the family.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text', 'section', 'table', 'table-column',\n          'table-row', 'table-cell', 'table-page', 'chart',\n          'drawing-page', 'graphic', 'presentation',\n          'control', 'ruby', 'list', 'number', 'page-layout'\n          'font-face', or 'master-page'\n\nname -- str\n\ndisplay_name -- str\n\nparent_style -- str\n\narea -- str\n</code></pre> <p>\u2018text\u2019 Properties:</p> <pre><code>italic -- bool\n\nbold -- bool\n</code></pre> <p>\u2018paragraph\u2019 Properties:</p> <pre><code>master_page -- str\n</code></pre> <p>\u2018master-page\u2019 Properties:</p> <pre><code>page_layout -- str\n\nnext_style -- str\n</code></pre> <p>\u2018table-cell\u2019 Properties:</p> <pre><code>border, border_top, border_right, border_bottom, border_left -- str,\ne.g. \"0.002cm solid #000000\" or 'none'\n\npadding, padding_top, padding_right, padding_bottom, padding_left -- str,\ne.g. \"0.002cm\" or 'none'\n\nshadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n</code></pre> <p>\u2018table-row\u2019 Properties:</p> <pre><code>height -- str, e.g. '5cm'\n\nuse_optimal_height -- bool\n</code></pre> <p>\u2018table-column\u2019 Properties:</p> <pre><code>width -- str, e.g. '5cm'\n\nbreak_before -- 'page', 'column' or 'auto'\n\nbreak_after -- 'page', 'column' or 'auto'\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def __init__(  # noqa: C901\n    self,\n    family: str | None = None,\n    name: str | None = None,\n    display_name: str | None = None,\n    parent_style: str | None = None,\n    # Where properties apply\n    area: str | None = None,\n    # For family 'text':\n    color: str | tuple | None = None,\n    background_color: str | tuple | None = None,\n    italic: bool = False,\n    bold: bool = False,\n    # For family 'paragraph'\n    master_page: str | None = None,\n    # For family 'master-page'\n    page_layout: str | None = None,\n    next_style: str | None = None,\n    # For family 'table-cell'\n    data_style: str | None = None,  # unused\n    border: str | None = None,\n    border_top: str | None = None,\n    border_right: str | None = None,\n    border_bottom: str | None = None,\n    border_left: str | None = None,\n    padding: str | None = None,\n    padding_top: str | None = None,\n    padding_bottom: str | None = None,\n    padding_left: str | None = None,\n    padding_right: str | None = None,\n    shadow: str | None = None,\n    # For family 'table-row'\n    height: str | None = None,\n    use_optimal_height: bool = False,\n    # For family 'table-column'\n    width: str | None = None,\n    break_before: str | None = None,\n    break_after: str | None = None,\n    # For family 'graphic'\n    min_height: str | None = None,\n    # For family 'font-face'\n    font_name: str | None = None,\n    font_family: str | None = None,\n    font_family_generic: str | None = None,\n    font_pitch: str = \"variable\",\n    # Every other property\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a style of the given family. The name is not mandatory at this\n    point but will become required when inserting in a document as a common\n    style.\n\n    The display name is the name the user sees in an office application.\n\n    The parent_style is the name of the style this style will inherit from.\n\n    To set properties, pass them as keyword arguments. The area properties\n    apply to is optional and defaults to the family.\n\n    Arguments:\n\n        family -- 'paragraph', 'text', 'section', 'table', 'table-column',\n                  'table-row', 'table-cell', 'table-page', 'chart',\n                  'drawing-page', 'graphic', 'presentation',\n                  'control', 'ruby', 'list', 'number', 'page-layout'\n                  'font-face', or 'master-page'\n\n        name -- str\n\n        display_name -- str\n\n        parent_style -- str\n\n        area -- str\n\n    'text' Properties:\n\n        italic -- bool\n\n        bold -- bool\n\n    'paragraph' Properties:\n\n        master_page -- str\n\n    'master-page' Properties:\n\n        page_layout -- str\n\n        next_style -- str\n\n    'table-cell' Properties:\n\n        border, border_top, border_right, border_bottom, border_left -- str,\n        e.g. \"0.002cm solid #000000\" or 'none'\n\n        padding, padding_top, padding_right, padding_bottom, padding_left -- str,\n        e.g. \"0.002cm\" or 'none'\n\n        shadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\n    'table-row' Properties:\n\n        height -- str, e.g. '5cm'\n\n        use_optimal_height -- bool\n\n    'table-column' Properties:\n\n        width -- str, e.g. '5cm'\n\n        break_before -- 'page', 'column' or 'auto'\n\n        break_after -- 'page', 'column' or 'auto'\n    \"\"\"\n    self._family: str | None = None\n    tag_or_elem = kwargs.get(\"tag_or_elem\", None)\n    if tag_or_elem is None:\n        family = to_str(family)\n        if family not in FAMILY_MAPPING:\n            raise ValueError(f\"Unknown family value: '{family}'\")\n        kwargs[\"tag\"] = FAMILY_MAPPING[family]\n    super().__init__(**kwargs)\n    if self._do_init and family not in SUBCLASSED_STYLES:\n        kwargs.pop(\"tag\", None)\n        kwargs.pop(\"tag_or_elem\", None)\n        self.family = family  # relevant test made by property\n        # Common attributes\n        if name:\n            self.name = name\n        if display_name:\n            self.display_name = display_name\n        if parent_style:\n            self.parent_style = parent_style\n        # Paragraph\n        if family == \"paragraph\":\n            if master_page:\n                self.master_page = master_page\n        # Master Page\n        elif family == \"master-page\":\n            if page_layout:\n                self.page_layout = page_layout\n            if next_style:\n                self.next_style = next_style\n        # Font face\n        elif family == \"font-face\":\n            if not font_name:\n                raise ValueError(\"A font_name is required for 'font-face' style\")\n            self.set_font(\n                font_name,\n                family=font_family,\n                family_generic=font_family_generic,\n                pitch=font_pitch,\n            )\n        # Properties\n        if area is None:\n            area = family\n        area = to_str(area)\n        # Text\n        if area == \"text\":\n            if color:\n                kwargs[\"fo:color\"] = color\n            if background_color:\n                kwargs[\"fo:background-color\"] = background_color\n            if italic:\n                kwargs[\"fo:font-style\"] = \"italic\"\n                kwargs[\"style:font-style-asian\"] = \"italic\"\n                kwargs[\"style:font-style-complex\"] = \"italic\"\n            if bold:\n                kwargs[\"fo:font-weight\"] = \"bold\"\n                kwargs[\"style:font-weight-asian\"] = \"bold\"\n                kwargs[\"style:font-weight-complex\"] = \"bold\"\n        # Table cell\n        elif area == \"table-cell\":\n            if border:\n                kwargs[\"fo:border\"] = border\n            elif border_top or border_right or border_bottom or border_left:\n                kwargs[\"fo:border-top\"] = border_top or \"none\"\n                kwargs[\"fo:border-right\"] = border_right or \"none\"\n                kwargs[\"fo:border-bottom\"] = border_bottom or \"none\"\n                kwargs[\"fo:border-left\"] = border_left or \"none\"\n            else:  # no border_top, ... neither border are defined\n                pass  # left untouched\n            if padding:\n                kwargs[\"fo:padding\"] = padding\n            elif padding_top or padding_right or padding_bottom or padding_left:\n                kwargs[\"fo:padding-top\"] = padding_top or \"none\"\n                kwargs[\"fo:padding-right\"] = padding_right or \"none\"\n                kwargs[\"fo:padding-bottom\"] = padding_bottom or \"none\"\n                kwargs[\"fo:padding-left\"] = padding_left or \"none\"\n            else:  # no border_top, ... neither border are defined\n                pass  # left untouched\n            if shadow:\n                kwargs[\"style:shadow\"] = shadow\n            if background_color:\n                kwargs[\"fo:background-color\"] = background_color\n        # Table row\n        elif area == \"table-row\":\n            if height:\n                kwargs[\"style:row-height\"] = height\n            if use_optimal_height:\n                kwargs[\"style:use-optimal-row-height\"] = Boolean.encode(\n                    use_optimal_height\n                )\n            if background_color:\n                kwargs[\"fo:background-color\"] = background_color\n        # Table column\n        elif area == \"table-column\":\n            if width:\n                kwargs[\"style:column-width\"] = width\n            if break_before:\n                kwargs[\"fo:break-before\"] = break_before\n            if break_after:\n                kwargs[\"fo:break-after\"] = break_after\n        # Graphic\n        elif area == \"graphic\":\n            if min_height:\n                kwargs[\"fo:min-height\"] = min_height\n        # Every other properties\n        if kwargs:\n            self.set_properties(kwargs, area=area)\n</code></pre>"},{"location":"reference.html#odfdo.Style.del_properties","title":"<code>del_properties(properties=None, area=None)</code>","text":"<p>Delete the given properties, either by list argument or positional argument (or both). Remove only from the given area, identical to the style family by default.</p> <p>Arguments:</p> <pre><code>properties -- list\n\narea -- str\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def del_properties(\n    self,\n    properties: list[str] | None = None,\n    area: str | None = None,\n) -&gt; None:\n    \"\"\"Delete the given properties, either by list argument or\n    positional argument (or both). Remove only from the given area,\n    identical to the style family by default.\n\n    Arguments:\n\n        properties -- list\n\n        area -- str\n    \"\"\"\n    if properties is None:\n        properties = []\n    if area is None:\n        area = self.family\n    element = self.get_element(f\"style:{area}-properties\")\n    if element is None:\n        raise ValueError(\n            f\"properties element is inexistent for: style:{area}-properties\"\n        )\n    for key in _expand_properties_list(properties):\n        element.del_attribute(key)\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_page_footer","title":"<code>get_page_footer()</code>","text":"<p>Get the element that contains the footer contents.</p> <p>If None, no footer was set.</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_page_footer(self) -&gt; Element | None:\n    \"\"\"Get the element that contains the footer contents.\n\n    If None, no footer was set.\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    return self.get_element(\"style:footer\")\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_page_header","title":"<code>get_page_header()</code>","text":"<p>Get the element that contains the header contents.</p> <p>If None, no header was set.</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_page_header(self) -&gt; Element | None:\n    \"\"\"Get the element that contains the header contents.\n\n    If None, no header was set.\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    return self.get_element(\"style:header\")\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_properties","title":"<code>get_properties(area=None)</code>","text":"<p>Get the mapping of all properties of this style. By default the properties of the same family, e.g. a paragraph style and its paragraph properties. Specify the area to get the text properties of a paragraph style for example.</p> <p>Arguments:</p> <pre><code>area -- str\n</code></pre> <p>Return: dict</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_properties(self, area: str | None = None) -&gt; dict[str, str | dict] | None:\n    \"\"\"Get the mapping of all properties of this style. By default the\n    properties of the same family, e.g. a paragraph style and its\n    paragraph properties. Specify the area to get the text properties of\n    a paragraph style for example.\n\n    Arguments:\n\n        area -- str\n\n    Return: dict\n    \"\"\"\n    if area is None:\n        area = self.family\n    element = self.get_element(f\"style:{area}-properties\")\n    if element is None:\n        return None\n    properties: dict[str, str | dict] = element.attributes  # type: ignore\n    # Nested properties are nested dictionaries\n    for child in element.children:\n        properties[child.tag] = child.attributes\n    return properties\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_background","title":"<code>set_background(color=None, url=None, position='center', repeat=None, opacity=None, filter=None)</code>","text":"<p>Set the background color of a text style, or the background color or image of a paragraph style or page layout.</p> <p>With no argument, remove any existing background.</p> <p>The position is one or two of \u2018center\u2019, \u2018left\u2019, \u2018right\u2019, \u2018top\u2019 or \u2018bottom\u2019.</p> <p>The repeat is \u2018no-repeat\u2019, \u2018repeat\u2019 or \u2018stretch\u2019.</p> <p>The opacity is a percentage integer (not a string with the \u2018%s\u2019 sign)</p> <p>The filter is an application-specific filter name defined elsewhere.</p> <p>Though this method is defined on the base style class, it will raise an error if the style type is not compatible.</p> <p>Arguments:</p> <pre><code>color -- '#rrggbb'\n\nurl -- str\n\nposition -- str\n\nrepeat -- str\n\nopacity -- int\n\nfilter -- str\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_background(  # noqa: C901\n    self,\n    color: str | None = None,\n    url: str | None = None,\n    position: str | None = \"center\",\n    repeat: str | None = None,\n    opacity: str | None = None,\n    filter: str | None = None,  # noqa: A002\n) -&gt; None:\n    \"\"\"Set the background color of a text style, or the background color\n    or image of a paragraph style or page layout.\n\n    With no argument, remove any existing background.\n\n    The position is one or two of 'center', 'left', 'right', 'top' or\n    'bottom'.\n\n    The repeat is 'no-repeat', 'repeat' or 'stretch'.\n\n    The opacity is a percentage integer (not a string with the '%s' sign)\n\n    The filter is an application-specific filter name defined elsewhere.\n\n    Though this method is defined on the base style class, it will raise\n    an error if the style type is not compatible.\n\n    Arguments:\n\n        color -- '#rrggbb'\n\n        url -- str\n\n        position -- str\n\n        repeat -- str\n\n        opacity -- int\n\n        filter -- str\n    \"\"\"\n    family = self.family\n    if family not in {\n        \"text\",\n        \"paragraph\",\n        \"page-layout\",\n        \"section\",\n        \"table\",\n        \"table-row\",\n        \"table-cell\",\n        \"graphic\",\n    }:\n        raise TypeError(\"No background support for this family\")\n    if url is not None and family == \"text\":\n        raise TypeError(\"No background image for text styles\")\n    properties = self.get_element(f\"style:{family}-properties\")\n    bg_image: BackgroundImage | None = None\n    if properties is not None:\n        bg_image = properties.get_element(\"style:background-image\")  # type:ignore\n    # Erasing\n    if color is None and url is None:\n        if properties is None:\n            return\n        properties.del_attribute(\"fo:background-color\")\n        if bg_image is not None:\n            properties.delete(bg_image)\n        return\n    # Add the properties if necessary\n    if properties is None:\n        properties = Element.from_tag(f\"style:{family}-properties\")\n        self.append(properties)\n    # Add the color...\n    if color:\n        properties.set_attribute(\"fo:background-color\", color)\n        if bg_image is not None:\n            properties.delete(bg_image)\n    # ... or the background\n    elif url:\n        properties.set_attribute(\"fo:background-color\", \"transparent\")\n        if bg_image is None:\n            bg_image = Element.from_tag(\"style:background-image\")  # type:ignore\n            properties.append(bg_image)  # type:ignore\n        bg_image.url = url  # type:ignore\n        if position:\n            bg_image.position = position  # type:ignore\n        if repeat:\n            bg_image.repeat = repeat  # type:ignore\n        if opacity:\n            bg_image.opacity = opacity  # type:ignore\n        if filter:\n            bg_image.filter = filter  # type:ignore\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_level_style","title":"<code>set_level_style(level, num_format=None, bullet_char=None, url=None, display_levels=None, prefix=None, suffix=None, start_value=None, style=None, clone=None)</code>","text":"<p>Arguments:</p> <pre><code>level -- int\n\nnum_format (for number) -- int\n\nbullet_char (for bullet) -- str\n\nurl (for image) -- str\n\ndisplay_levels -- int\n\nprefix -- str\n\nsuffix -- str\n\nstart_value -- int\n\nstyle -- str\n\nclone -- List Style\n</code></pre> Return <p>level_style created</p> Source code in <code>odfdo/style.py</code> <pre><code>def set_level_style(  # noqa: C901\n    self,\n    level: int,\n    num_format: str | None = None,\n    bullet_char: str | None = None,\n    url: str | None = None,\n    display_levels: int | None = None,\n    prefix: str | None = None,\n    suffix: str | None = None,\n    start_value: int | None = None,\n    style: str | None = None,\n    clone: Style | None = None,\n) -&gt; Style | None:\n    \"\"\"\n    Arguments:\n\n        level -- int\n\n        num_format (for number) -- int\n\n        bullet_char (for bullet) -- str\n\n        url (for image) -- str\n\n        display_levels -- int\n\n        prefix -- str\n\n        suffix -- str\n\n        start_value -- int\n\n        style -- str\n\n        clone -- List Style\n\n    Return:\n        level_style created\n    \"\"\"\n    if self.family != \"list\":\n        return None\n    # Expected name\n    if num_format is not None:\n        level_style_name = \"text:list-level-style-number\"\n    elif bullet_char is not None:\n        level_style_name = \"text:list-level-style-bullet\"\n    elif url is not None:\n        level_style_name = \"text:list-level-style-image\"\n    elif clone is not None:\n        level_style_name = clone.tag\n    else:\n        raise ValueError(\"unknown level style type\")\n    was_created = False\n    # Cloning or reusing an existing element\n    level_style: Style | None = None\n    if clone is not None:\n        level_style = clone.clone  # type: ignore\n        was_created = True\n    else:\n        level_style = self.get_level_style(level)\n        if level_style is None:\n            level_style = Element.from_tag(level_style_name)  # type: ignore\n            was_created = True\n    if level_style is None:\n        return None\n    # Transmute if the type changed\n    if level_style.tag != level_style_name:\n        print(\"Warn: different style\", level_style_name, level_style.tag)\n        level_style.tag = level_style_name\n    # Set the level\n    level_style.set_attribute(\"text:level\", str(level))\n    # Set the main attribute\n    if num_format is not None:\n        level_style.set_attribute(\"fo:num-format\", num_format)\n    elif bullet_char is not None:\n        level_style.set_attribute(\"text:bullet-char\", bullet_char)\n    elif url is not None:\n        level_style.set_attribute(\"xlink:href\", url)\n    # Set attributes\n    if prefix:\n        level_style.set_attribute(\"style:num-prefix\", prefix)\n    if suffix:\n        level_style.set_attribute(\"style:num-suffix\", suffix)\n    if display_levels:\n        level_style.set_attribute(\"text:display-levels\", str(display_levels))\n    if start_value:\n        level_style.set_attribute(\"text:start-value\", str(start_value))\n    if style:\n        level_style.text_style = style  # type: ignore\n    # Commit the creation\n    if was_created:\n        self.append(level_style)\n    return level_style\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_page_footer","title":"<code>set_page_footer(text_or_element)</code>","text":"<p>Create or replace the footer by the given content. It can already be a complete footer.</p> <p>If you only want to update the existing footer, get it and use the API.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or Element or a list of them\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_page_footer(\n    self,\n    text_or_element: str | Element | list[Element | str],\n) -&gt; None:\n    \"\"\"Create or replace the footer by the given content. It can already\n    be a complete footer.\n\n    If you only want to update the existing footer, get it and use the\n    API.\n\n    Arguments:\n\n        text_or_element -- str or Element or a list of them\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    self._set_header_or_footer(text_or_element, name=\"footer\", style=\"Footer\")\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_page_header","title":"<code>set_page_header(text_or_element)</code>","text":"<p>Create or replace the header by the given content. It can already be a complete header.</p> <p>If you only want to update the existing header, get it and use the API.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or Element or a list of them\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_page_header(\n    self,\n    text_or_element: str | Element | list[Element | str],\n) -&gt; None:\n    \"\"\"Create or replace the header by the given content. It can already\n    be a complete header.\n\n    If you only want to update the existing header, get it and use the\n    API.\n\n    Arguments:\n\n        text_or_element -- str or Element or a list of them\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    self._set_header_or_footer(text_or_element)\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_properties","title":"<code>set_properties(properties=None, style=None, area=None, **kwargs)</code>","text":"<p>Set the properties of the \u201carea\u201d type of this style. Properties are given either as a dict or as named arguments (or both). The area is identical to the style family by default. If the properties element is missing, it is created.</p> <p>Instead of properties, you can pass a style with properties of the same area. These will be copied.</p> <p>Arguments:</p> <pre><code>properties -- dict\n\nstyle -- Style\n\narea -- 'paragraph', 'text'...\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_properties(  # noqa: C901\n    self,\n    properties: dict[str, str | dict] | None = None,\n    style: Style | None = None,\n    area: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Set the properties of the \"area\" type of this style. Properties\n    are given either as a dict or as named arguments (or both). The area\n    is identical to the style family by default. If the properties\n    element is missing, it is created.\n\n    Instead of properties, you can pass a style with properties of the\n    same area. These will be copied.\n\n    Arguments:\n\n        properties -- dict\n\n        style -- Style\n\n        area -- 'paragraph', 'text'...\n    \"\"\"\n    if properties is None:\n        properties = {}\n    if area is None:\n        if isinstance(self.family, bool):\n            area = None\n        else:\n            area = self.family\n    element = self.get_element(f\"style:{area}-properties\")\n    if element is None:\n        element = Element.from_tag(f\"style:{area}-properties\")\n        self.append(element)\n    if properties or kwargs:\n        properties = _expand_properties_dict(_merge_dicts(properties, kwargs))\n    elif style is not None:\n        properties = style.get_properties(area=area)\n        if properties is None:\n            return\n    if properties is None:\n        return\n    for key, value in properties.items():\n        if value is None:\n            element.del_attribute(key)\n        elif isinstance(value, (str, bool, tuple)):\n            element.set_attribute(key, value)\n        else:\n            pass\n</code></pre>"},{"location":"reference.html#odfdo.Styles","title":"<code>Styles</code>","text":"<p>             Bases: <code>XmlPart</code></p> Source code in <code>odfdo/styles.py</code> <pre><code>class Styles(XmlPart):\n    def _get_style_contexts(\n        self, family: str, automatic: bool = False\n    ) -&gt; list[Element]:\n        if automatic:\n            return [self.get_element(\"//office:automatic-styles\")]\n        if not family:\n            # All possibilities\n            return [\n                self.get_element(\"//office:automatic-styles\"),\n                self.get_element(\"//office:styles\"),\n                self.get_element(\"//office:master-styles\"),\n                self.get_element(\"//office:font-face-decls\"),\n            ]\n        queries = CONTEXT_MAPPING.get(family)\n        if queries is None:\n            raise ValueError(f\"unknown family: {family}\")\n        # print('q:', queries)\n        return [self.get_element(query) for query in queries]\n\n    def get_styles(self, family: str = \"\", automatic: bool = False) -&gt; list[Element]:\n        \"\"\"Return the list of styles in the Content part, optionally limited\n        to the given family, optionaly limited to automatic styles.\n\n        Arguments:\n\n            family -- str\n\n            automatic -- bool\n\n        Return: list of Style\n        \"\"\"\n        result = []\n        for context in self._get_style_contexts(family, automatic=automatic):\n            if context is None:\n                continue\n            # print('-ctx----', automatic)\n            # print(context.tag)\n            # print(context.__class__)\n            # print(context.serialize())\n            result.extend(context.get_styles(family=family))\n        return result\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Style | None = None,\n        display_name: str | None = None,\n    ) -&gt; Style | None:\n        \"\"\"Return the style uniquely identified by the name/family pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is None, the default style is fetched.\n\n        If the name is not the internal name but the name you gave in the\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                      'number', 'page-layout', 'master-page'\n\n            name_or_element -- str, odf_style or None\n\n            display_name -- str or None\n\n        Return: odf_style or None if not found\n        \"\"\"\n        for context in self._get_style_contexts(family):\n            if context is None:\n                continue\n            style = context.get_style(\n                family,\n                name_or_element=name_or_element,\n                display_name=display_name,\n            )\n            if style is not None:\n                return style  # type: ignore\n        return None\n\n    def get_master_pages(self) -&gt; list[Element]:\n        query = make_xpath_query(\"descendant::style:master-page\")\n        return self.get_elements(query)  # type:ignore\n\n    def get_master_page(self, position: int = 0) -&gt; Element | None:\n        results = self.get_master_pages()\n        try:\n            return results[position]\n        except IndexError:\n            return None\n</code></pre>"},{"location":"reference.html#odfdo.Styles.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the name/family pair. If the argument is already a style object, it will return it.</p> <p>If the name is None, the default style is fetched.</p> <p>If the name is not the internal name but the name you gave in the desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n          'number', 'page-layout', 'master-page'\n\nname_or_element -- str, odf_style or None\n\ndisplay_name -- str or None\n</code></pre> <p>Return: odf_style or None if not found</p> Source code in <code>odfdo/styles.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Style | None = None,\n    display_name: str | None = None,\n) -&gt; Style | None:\n    \"\"\"Return the style uniquely identified by the name/family pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is None, the default style is fetched.\n\n    If the name is not the internal name but the name you gave in the\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                  'number', 'page-layout', 'master-page'\n\n        name_or_element -- str, odf_style or None\n\n        display_name -- str or None\n\n    Return: odf_style or None if not found\n    \"\"\"\n    for context in self._get_style_contexts(family):\n        if context is None:\n            continue\n        style = context.get_style(\n            family,\n            name_or_element=name_or_element,\n            display_name=display_name,\n        )\n        if style is not None:\n            return style  # type: ignore\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Styles.get_styles","title":"<code>get_styles(family='', automatic=False)</code>","text":"<p>Return the list of styles in the Content part, optionally limited to the given family, optionaly limited to automatic styles.</p> <p>Arguments:</p> <pre><code>family -- str\n\nautomatic -- bool\n</code></pre> <p>Return: list of Style</p> Source code in <code>odfdo/styles.py</code> <pre><code>def get_styles(self, family: str = \"\", automatic: bool = False) -&gt; list[Element]:\n    \"\"\"Return the list of styles in the Content part, optionally limited\n    to the given family, optionaly limited to automatic styles.\n\n    Arguments:\n\n        family -- str\n\n        automatic -- bool\n\n    Return: list of Style\n    \"\"\"\n    result = []\n    for context in self._get_style_contexts(family, automatic=automatic):\n        if context is None:\n            continue\n        # print('-ctx----', automatic)\n        # print(context.tag)\n        # print(context.__class__)\n        # print(context.serialize())\n        result.extend(context.get_styles(family=family))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.TOC","title":"<code>TOC</code>","text":"<p>             Bases: <code>Element</code></p> <p>Table of content. The \u201ctext:table-of-content\u201d element represents a table of contents for a document. The items that can be listed in a table of contents are:   - Headings (as defined by the outline structure of the document), up to     a selected level.   - Table of contents index marks.   - Paragraphs formatted with specified paragraph styles.</p> <p>Implementation: Default parameters are what most people use: protected from manual modifications and not limited in title levels.</p> <p>The name is mandatory and derived automatically from the title if not given. Provide one in case of a conflict with other TOCs in the same document.</p> <p>The \u201ctext:table-of-content\u201d element has the following attributes: text:name, text:protected, text:protection-key, text:protection-key-digest-algorithm, text:style-name and xml:id.</p> <p>Arguments:</p> <pre><code>title -- str\n\nname -- str\n\nprotected -- bool\n\noutline_level -- int\n\nstyle -- str\n\ntitle_style -- str\n\nentry_style -- str\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>class TOC(Element):\n    \"\"\"Table of content.\n    The \"text:table-of-content\" element represents a table of contents for a\n    document. The items that can be listed in a table of contents are:\n      - Headings (as defined by the outline structure of the document), up to\n        a selected level.\n      - Table of contents index marks.\n      - Paragraphs formatted with specified paragraph styles.\n\n\n    Implementation:\n    Default parameters are what most people use: protected from manual\n    modifications and not limited in title levels.\n\n    The name is mandatory and derived automatically from the title if not\n    given. Provide one in case of a conflict with other TOCs in the same\n    document.\n\n    The \"text:table-of-content\" element has the following attributes:\n    text:name, text:protected, text:protection-key,\n    text:protection-key-digest-algorithm, text:style-name and xml:id.\n\n    Arguments:\n\n        title -- str\n\n        name -- str\n\n        protected -- bool\n\n        outline_level -- int\n\n        style -- str\n\n        title_style -- str\n\n        entry_style -- str\n    \"\"\"\n\n    _tag = \"text:table-of-content\"\n    _properties = (\n        PropDef(\"name\", \"text:name\"),\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"xml_id\", \"xml:id\"),\n        PropDef(\"protected\", \"text:protected\"),\n        PropDef(\"protection_key\", \"text:protection-key\"),\n        PropDef(\n            \"protection_key_digest_algorithm\", \"text:protection-key-digest-algorithm\"\n        ),\n    )\n\n    def __init__(\n        self,\n        title: str = \"Table of Contents\",\n        name: str | None = None,\n        protected: bool = True,\n        outline_level: int = 0,\n        style: str | None = None,\n        title_style: str = \"Contents_20_Heading\",\n        entry_style: str = \"Contents_20_%d\",\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style:\n                self.style = style\n            if protected:\n                self.protected = protected\n            if name is None:\n                self.name = f\"{title}1\"\n            # Create the source template\n            toc_source = self.create_toc_source(\n                title, outline_level, title_style, entry_style\n            )\n            self.append(toc_source)\n            # Create the index body automatically with the index title\n            if title:\n                # This style is in the template document\n                self.set_toc_title(title, text_style=title_style)\n\n    @staticmethod\n    def create_toc_source(\n        title: str,\n        outline_level: int,\n        title_style: str,\n        entry_style: str,\n    ) -&gt; Element:\n        toc_source = Element.from_tag(\"text:table-of-content-source\")\n        toc_source.set_attribute(\"text:outline-level\", str(outline_level))\n        if title:\n            title_template = IndexTitleTemplate()\n            if title_style:\n                # This style is in the template document\n                title_template.style = title_style\n            title_template.text = title\n            toc_source.append(title_template)\n        for level in range(1, 11):\n            template = TocEntryTemplate(outline_level=level)\n            if entry_style:\n                template.style = entry_style % level\n            toc_source.append(template)\n        return toc_source\n\n    def __str__(self) -&gt; str:\n        return self.get_formatted_text()\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        index_body = self.get_element(\"text:index-body\")\n\n        if index_body is None:\n            return \"\"\n        if context is None:\n            context = {}\n        if context.get(\"rst_mode\"):\n            return \"\\n.. contents::\\n\\n\"\n\n        result = []\n        for element in index_body.children:\n            if element.tag == \"text:index-title\":\n                for child_element in element.children:\n                    result.append(child_element.get_formatted_text(context).strip())\n            else:\n                result.append(element.get_formatted_text(context).strip())\n        return \"\\n\".join(result)\n\n    @property\n    def outline_level(self) -&gt; int | None:\n        source = self.get_element(\"text:table-of-content-source\")\n        if source is None:\n            return None\n        return source.get_attribute_integer(\"text:outline-level\")\n\n    @outline_level.setter\n    def outline_level(self, level: int) -&gt; None:\n        source = self.get_element(\"text:table-of-content-source\")\n        if source is None:\n            source = Element.from_tag(\"text:table-of-content-source\")\n            self.insert(source, FIRST_CHILD)\n        source.set_attribute(\"text:outline-level\", str(level))\n\n    @property\n    def body(self) -&gt; Element | None:\n        return self.get_element(\"text:index-body\")\n\n    @body.setter\n    def body(self, body: Element | None = None) -&gt; Element | None:\n        old_body = self.body\n        if old_body is not None:\n            self.delete(old_body)\n        if body is None:\n            body = Element.from_tag(\"text:index-body\")\n        self.append(body)\n        return body\n\n    def get_title(self) -&gt; str:\n        index_body = self.body\n        if index_body is None:\n            return \"\"\n        index_title = index_body.get_element(IndexTitle._tag)\n        if index_title is None:\n            return \"\"\n        return index_title.text_content\n\n    def set_toc_title(\n        self,\n        title: str,\n        style: str | None = None,\n        text_style: str | None = None,\n    ) -&gt; None:\n        index_body = self.body\n        if index_body is None:\n            self.body = None\n            index_body = self.body\n        index_title = index_body.get_element(IndexTitle._tag)  # type: ignore\n        if index_title is None:\n            name = f\"{self.name}_Head\"\n            index_title = IndexTitle(\n                name=name, style=style, title_text=title, text_style=text_style\n            )\n            index_body.append(index_title)  # type: ignore\n        else:\n            if style:\n                index_title.style = style  # type: ignore\n            paragraph = index_title.get_paragraph()\n            if paragraph is None:\n                paragraph = Paragraph()\n                index_title.append(paragraph)\n            if text_style:\n                paragraph.style = text_style  # type: ignore\n            paragraph.text = title\n\n    @staticmethod\n    def _header_numbering(level_indexes: dict[int, int], level: int) -&gt; str:\n        \"\"\"Return the header hierarchical number (like \"1.2.3.\").\"\"\"\n        numbers: list[int] = []\n        # before header level\n        for idx in range(1, level):\n            numbers.append(level_indexes.setdefault(idx, 1))\n        # header level\n        index = level_indexes.get(level, 0) + 1\n        level_indexes[level] = index\n        numbers.append(index)\n        # after header level\n        idx = level + 1\n        while idx in level_indexes:\n            del level_indexes[idx]\n            idx += 1\n        return \".\".join(str(x) for x in numbers) + \".\"\n\n    def fill(  # noqa: C901\n        self,\n        document: Document | None = None,\n        use_default_styles: bool = True,\n    ) -&gt; None:\n        \"\"\"Fill the TOC with the titles found in the document. A TOC is not\n        contextual so it will catch all titles before and after its insertion.\n        If the TOC is not attached to a document, attach it beforehand or\n        provide one as argument.\n\n        For having a pretty TOC, let use_default_styles by default.\n\n        Arguments:\n\n            document -- Document\n\n            use_default_styles -- bool\n        \"\"\"\n        # Find the body\n        if document is not None:\n            body: Element | None = document.body\n        else:\n            body = self.document_body\n        if body is None:\n            raise ValueError(\"The TOC must be related to a document somehow\")\n\n        # Save the title\n        index_body = self.body\n        title = index_body.get_element(\"text:index-title\")  # type: ignore\n\n        # Clean the old index-body\n        self.body = None\n        index_body = self.body\n\n        # Restore the title\n        if title and str(title):\n            index_body.insert(title, position=0)  # type: ignore\n\n        # Insert default TOC style\n        if use_default_styles:\n            automatic_styles = body.get_element(\"//office:automatic-styles\")\n            if isinstance(automatic_styles, Element):\n                for level in range(1, 11):\n                    if (\n                        automatic_styles.get_style(\n                            \"paragraph\", _toc_entry_style_name(level)\n                        )\n                        is None\n                    ):\n                        level_style = default_toc_level_style(level)\n                        automatic_styles.append(level_style)\n\n        # Auto-fill the index\n        outline_level = self.outline_level or 10\n        level_indexes: dict[int, int] = {}\n        for header in body.headers:\n            level = header.get_attribute_integer(\"text:outline-level\") or 0\n            if level is None or level &gt; outline_level:\n                continue\n            number_str = self._header_numbering(level_indexes, level)\n            # Make the title with \"1.2.3. Title\" format\n            paragraph = Paragraph(f\"{number_str} {header}\")\n            if use_default_styles:\n                paragraph.style = _toc_entry_style_name(level)\n            index_body.append(paragraph)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.TOC.fill","title":"<code>fill(document=None, use_default_styles=True)</code>","text":"<p>Fill the TOC with the titles found in the document. A TOC is not contextual so it will catch all titles before and after its insertion. If the TOC is not attached to a document, attach it beforehand or provide one as argument.</p> <p>For having a pretty TOC, let use_default_styles by default.</p> <p>Arguments:</p> <pre><code>document -- Document\n\nuse_default_styles -- bool\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>def fill(  # noqa: C901\n    self,\n    document: Document | None = None,\n    use_default_styles: bool = True,\n) -&gt; None:\n    \"\"\"Fill the TOC with the titles found in the document. A TOC is not\n    contextual so it will catch all titles before and after its insertion.\n    If the TOC is not attached to a document, attach it beforehand or\n    provide one as argument.\n\n    For having a pretty TOC, let use_default_styles by default.\n\n    Arguments:\n\n        document -- Document\n\n        use_default_styles -- bool\n    \"\"\"\n    # Find the body\n    if document is not None:\n        body: Element | None = document.body\n    else:\n        body = self.document_body\n    if body is None:\n        raise ValueError(\"The TOC must be related to a document somehow\")\n\n    # Save the title\n    index_body = self.body\n    title = index_body.get_element(\"text:index-title\")  # type: ignore\n\n    # Clean the old index-body\n    self.body = None\n    index_body = self.body\n\n    # Restore the title\n    if title and str(title):\n        index_body.insert(title, position=0)  # type: ignore\n\n    # Insert default TOC style\n    if use_default_styles:\n        automatic_styles = body.get_element(\"//office:automatic-styles\")\n        if isinstance(automatic_styles, Element):\n            for level in range(1, 11):\n                if (\n                    automatic_styles.get_style(\n                        \"paragraph\", _toc_entry_style_name(level)\n                    )\n                    is None\n                ):\n                    level_style = default_toc_level_style(level)\n                    automatic_styles.append(level_style)\n\n    # Auto-fill the index\n    outline_level = self.outline_level or 10\n    level_indexes: dict[int, int] = {}\n    for header in body.headers:\n        level = header.get_attribute_integer(\"text:outline-level\") or 0\n        if level is None or level &gt; outline_level:\n            continue\n        number_str = self._header_numbering(level_indexes, level)\n        # Make the title with \"1.2.3. Title\" format\n        paragraph = Paragraph(f\"{number_str} {header}\")\n        if use_default_styles:\n            paragraph.style = _toc_entry_style_name(level)\n        index_body.append(paragraph)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Tab","title":"<code>Tab</code>","text":"<p>             Bases: <code>Element</code></p> <p>This element represents the [UNICODE] tab character (HORIZONTAL TABULATION, U+0009).</p> <p>The position attribute contains the number of the tab-stop to which a tab character refers. The position 0 marks the start margin of a paragraph. Note: The position attribute is only a hint to help non-layout oriented consumers to determine the tab/tab-stop association. Layout oriented consumers should determine the tab positions based on the style information</p> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>class Tab(Element):\n    \"\"\"This element represents the [UNICODE] tab character (HORIZONTAL\n    TABULATION, U+0009).\n\n    The position attribute contains the number of the tab-stop to which\n    a tab character refers. The position 0 marks the start margin of a\n    paragraph. Note: The position attribute is only a hint to help non-layout\n    oriented consumers to determine the tab/tab-stop association. Layout\n    oriented consumers should determine the tab positions based on the style\n    information\n    \"\"\"\n\n    _tag = \"text:tab\"\n    _properties: tuple[PropDef, ...] = (PropDef(\"position\", \"text:tab-ref\"),)\n\n    def __init__(self, position: int | None = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            position -- int\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init and position is not None and position &gt;= 0:\n            self.position = str(position)\n</code></pre>"},{"location":"reference.html#odfdo.Tab.__init__","title":"<code>__init__(position=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>position -- int\n</code></pre> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>def __init__(self, position: int | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        position -- int\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init and position is not None and position &gt;= 0:\n        self.position = str(position)\n</code></pre>"},{"location":"reference.html#odfdo.TabStopStyle","title":"<code>TabStopStyle</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF \u201cstyle:tab-stop\u201d Base style for a TOC entryBase style for a TOC entry</p> Source code in <code>odfdo/toc.py</code> <pre><code>class TabStopStyle(Element):\n    \"\"\"ODF \"style:tab-stop\"\n    Base style for a TOC entryBase style for a TOC entry\n    \"\"\"\n\n    _tag = \"style:tab-stop\"\n    _properties = (\n        PropDef(\"style_char\", \"style:char\"),\n        PropDef(\"leader_color\", \"style:leader-color\"),\n        PropDef(\"leader_style\", \"style:leader-style\"),\n        PropDef(\"leader_text\", \"style:leader-text\"),\n        PropDef(\"leader_text_style\", \"style:leader-text-style\"),\n        PropDef(\"leader_type\", \"style:leader-type\"),\n        PropDef(\"leader_width\", \"style:leader-width\"),\n        PropDef(\"style_position\", \"style:position\"),\n        PropDef(\"style_type\", \"style:type\"),\n    )\n\n    def __init__(  # noqa: C901\n        self,\n        style_char: str | None = None,\n        leader_color: str | None = None,\n        leader_style: str | None = None,\n        leader_text: str | None = None,\n        leader_text_style: str | None = None,\n        leader_type: str | None = None,\n        leader_width: str | None = None,\n        style_position: str | None = None,\n        style_type: str | None = None,\n        **kwargs: Any,\n    ):\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style_char:\n                self.style_char = style_char\n            if leader_color:\n                self.leader_color = leader_color\n            if leader_style:\n                self.leader_style = leader_style\n            if leader_text:\n                self.leader_text = leader_text\n            if leader_text_style:\n                self.leader_text_style = leader_text_style\n            if leader_type:\n                self.leader_type = leader_type\n            if leader_width:\n                self.leader_width = leader_width\n            if style_position:\n                self.style_position = style_position\n            if style_type:\n                self.style_type = style_type\n</code></pre>"},{"location":"reference.html#odfdo.Table","title":"<code>Table</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF table \u201ctable:table\u201d</p> Source code in <code>odfdo/table.py</code> <pre><code>class Table(Element):\n    \"\"\"ODF table \"table:table\" \"\"\"\n\n    _tag = \"table:table\"\n    _caching = True\n    _append = Element.append\n\n    def __init__(\n        self,\n        name: str | None = None,\n        width: int | None = None,\n        height: int | None = None,\n        protected: bool = False,\n        protection_key: str | None = None,\n        display: bool = True,\n        printable: bool = True,\n        print_ranges: list[str] | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a table element, optionally prefilled with \"height\" rows of\n        \"width\" cells each.\n\n        If the table is to be protected, a protection key must be provided,\n        i.e. a hash value of the password.\n\n        If the table must not be displayed, set \"display\" to False.\n\n        If the table must not be printed, set \"printable\" to False. The table\n        will not be printed when it is not displayed, whatever the value of\n        this argument.\n\n        Ranges of cells to print can be provided as a list of cell ranges,\n        e.g. ['E6:K12', 'P6:R12'] or directly as a raw string, e.g.\n        \"E6:K12 P6:R12\".\n\n        You can access and modify the XML tree manually, but you probably want\n        to use the API to access and alter cells. It will save you from\n        handling repetitions and the same number of cells for each row.\n\n        If you use both the table API and the XML API, you are on your own for\n        ensuiring model integrity.\n\n        Arguments:\n\n            name -- str\n\n            width -- int\n\n            height -- int\n\n            protected -- bool\n\n            protection_key -- str\n\n            display -- bool\n\n            printable -- bool\n\n            print_ranges -- list\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self._indexes = {}\n        self._indexes[\"_cmap\"] = {}\n        self._indexes[\"_tmap\"] = {}\n        if self._do_init:\n            self.name = name\n            if protected:\n                self.protected = protected\n                self.set_protection_key = protection_key\n            if not display:\n                self.displayed = display\n            if not printable:\n                self.printable = printable\n            if print_ranges:\n                self.print_ranges = print_ranges\n            if style:\n                self.style = style\n            # Prefill the table\n            if width is not None or height is not None:\n                width = width or 1\n                height = height or 1\n                # Column groups for style information\n                columns = Column(repeated=width)\n                self._append(columns)\n                for _i in range(height):\n                    row = Row(width)\n                    self._append(row)\n        self._compute_table_cache()\n\n    def __str__(self) -&gt; str:\n        def write_content(csv_writer: object) -&gt; None:\n            for values in self.iter_values():\n                line = []\n                for value in values:\n                    if value is None:\n                        value = \"\"\n                    if isinstance(value, str):\n                        value = value.strip()\n                    line.append(value)\n                csv_writer.writerow(line)  # type: ignore\n\n        out = StringIO(newline=os.linesep)\n        csv_writer = csv.writer(\n            out,\n            delimiter=\" \",\n            doublequote=False,\n            escapechar=\"\\\\\",\n            lineterminator=os.linesep,\n            quotechar='\"',\n            quoting=csv.QUOTE_NONNUMERIC,\n        )\n        write_content(csv_writer)\n        return out.getvalue()\n\n    def _translate_y_from_any(self, y: str | int) -&gt; int:\n        # \"3\" (couting from 1) -&gt; 2 (couting from 0)\n        return translate_from_any(y, self.height, 1)\n\n    def _translate_table_coordinates_list(\n        self,\n        coord: tuple | list,\n    ) -&gt; tuple[int | None, ...]:\n        height = self.height\n        width = self.width\n        # assuming we got int values\n        if len(coord) == 1:\n            # It is a row\n            y = coord[0]\n            if y and y &lt; 0:\n                y = increment(y, height)\n            return (None, y, None, y)\n        if len(coord) == 2:\n            # It is a row range, not a cell, because context is table\n            y = coord[0]\n            if y and y &lt; 0:\n                y = increment(y, height)\n            t = coord[1]\n            if t and t &lt; 0:\n                t = increment(t, height)\n            return (None, y, None, t)\n        # should be 4 int\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_table_coordinates_str(\n        self,\n        coord_str: str,\n    ) -&gt; tuple[int | None, ...]:\n        height = self.height\n        width = self.width\n        coord = convert_coordinates(coord_str)\n        if len(coord) == 2:\n            x, y = coord\n            if x and x &lt; 0:\n                x = increment(x, width)\n            if y and y &lt; 0:\n                y = increment(y, height)\n            # extent to an area :\n            return (x, y, x, y)\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_table_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, ...]:\n        if isinstance(coord, str):\n            return self._translate_table_coordinates_str(coord)\n        return self._translate_table_coordinates_list(coord)\n\n    def _translate_column_coordinates_str(\n        self,\n        coord_str: str,\n    ) -&gt; tuple[int | None, ...]:\n        width = self.width\n        height = self.height\n        coord = convert_coordinates(coord_str)\n        if len(coord) == 2:\n            x, y = coord\n            if x and x &lt; 0:\n                x = increment(x, width)\n            if y and y &lt; 0:\n                y = increment(y, height)\n            # extent to an area :\n            return (x, y, x, y)\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_column_coordinates_list(\n        self,\n        coord: tuple | list,\n    ) -&gt; tuple[int | None, ...]:\n        width = self.width\n        height = self.height\n        # assuming we got int values\n        if len(coord) == 1:\n            # It is a column\n            x = coord[0]\n            if x and x &lt; 0:\n                x = increment(x, width)\n            return (x, None, x, None)\n        if len(coord) == 2:\n            # It is a column range, not a cell, because context is table\n            x = coord[0]\n            if x and x &lt; 0:\n                x = increment(x, width)\n            z = coord[1]\n            if z and z &lt; 0:\n                z = increment(z, width)\n            return (x, None, z, None)\n        # should be 4 int\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_column_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, ...]:\n        if isinstance(coord, str):\n            return self._translate_column_coordinates_str(coord)\n        return self._translate_column_coordinates_list(coord)\n\n    def _translate_cell_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, int | None]:\n        # we want an x,y result\n        coord = convert_coordinates(coord)\n        if len(coord) == 2:\n            x, y = coord\n        # If we got an area, take the first cell\n        elif len(coord) == 4:\n            x, y, z, t = coord\n        else:\n            raise ValueError(str(coord))\n        if x and x &lt; 0:\n            x = increment(x, self.width)\n        if y and y &lt; 0:\n            y = increment(y, self.height)\n        return (x, y)\n\n    def _compute_table_cache(self) -&gt; None:\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_row, \"table:number-rows-repeated\"\n        )\n        self._tmap = make_cache_map(idx_repeated_seq)\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_column, \"table:number-columns-repeated\"\n        )\n        self._cmap = make_cache_map(idx_repeated_seq)\n\n    def _update_width(self, row: Row) -&gt; None:\n        \"\"\"Synchronize the number of columns if the row is bigger.\n\n        Append, don't insert, not to disturb the current layout.\n        \"\"\"\n        diff = row.width - self.width\n        if diff &gt; 0:\n            self.append_column(Column(repeated=diff))\n\n    def _get_formatted_text_normal(self, context: dict | None) -&gt; str:\n        result = []\n        for row in self.traverse():\n            for cell in row.traverse():\n                value = cell.get_value(try_get_text=False)\n                # None ?\n                if value is None:\n                    # Try with get_formatted_text on the elements\n                    value = []\n                    for element in cell.children:\n                        value.append(element.get_formatted_text(context))\n                    value = \"\".join(value)\n                else:\n                    value = str(value)\n                result.append(value)\n                result.append(\"\\n\")\n            result.append(\"\\n\")\n        return \"\".join(result)\n\n    def _get_formatted_text_rst(self, context: dict) -&gt; str:  # noqa: C901\n        context[\"no_img_level\"] += 1\n        # Strip the table =&gt; We must clone\n        table = self.clone\n        table.rstrip(aggressive=True)  # type: ignore\n\n        # Fill the rows\n        rows = []\n        cols_nb = 0\n        cols_size: dict[int, int] = {}\n        for odf_row in table.traverse():  # type: ignore\n            row = []\n            for i, cell in enumerate(odf_row.traverse()):\n                value = cell.get_value(try_get_text=False)\n                # None ?\n                if value is None:\n                    # Try with get_formatted_text on the elements\n                    value = []\n                    for element in cell.children:\n                        value.append(element.get_formatted_text(context))\n                    value = \"\".join(value)\n                else:\n                    value = str(value)\n                value = value.strip()\n                # Strip the empty columns\n                if value:\n                    cols_nb = max(cols_nb, i + 1)\n                # Compute the size of each columns (at least 2)\n                cols_size[i] = max(cols_size.get(i, 2), len(value))\n                # Append\n                row.append(value)\n            rows.append(row)\n\n        # Nothing ?\n        if cols_nb == 0:\n            return \"\"\n\n        # Prevent a crash with empty columns (by example with images)\n        for col, size in cols_size.items():\n            if size == 0:\n                cols_size[col] = 1\n\n        # Update cols_size\n        LINE_MAX = 100\n        COL_MIN = 16\n\n        free_size = LINE_MAX - (cols_nb - 1) * 3 - 4\n        real_size = sum([cols_size[i] for i in range(cols_nb)])\n        if real_size &gt; free_size:\n            factor = float(free_size) / real_size\n\n            for i in range(cols_nb):\n                old_size = cols_size[i]\n\n                # The cell is already small\n                if old_size &lt;= COL_MIN:\n                    continue\n\n                new_size = int(factor * old_size)\n\n                if new_size &lt; COL_MIN:\n                    new_size = COL_MIN\n                cols_size[i] = new_size\n\n        # Convert !\n        result: list[str] = [\"\"]\n        # Construct the first/last line\n        line: list[str] = []\n        for i in range(cols_nb):\n            line.append(\"=\" * cols_size[i])\n            line.append(\" \")\n        line_str = \"\".join(line)\n\n        # Add the lines\n        result.append(line_str)\n        for row in rows:\n            # Wrap the row\n            wrapped_row = []\n            for i, value in enumerate(row[:cols_nb]):\n                wrapped_value = []\n                for part in value.split(\"\\n\"):\n                    # Hack to handle correctly the lists or the directives\n                    subsequent_indent = \"\"\n                    part_lstripped = part.lstrip()\n                    if part_lstripped.startswith(\"-\") or part_lstripped.startswith(\n                        \"..\"\n                    ):\n                        subsequent_indent = \" \" * (len(part) - len(part.lstrip()) + 2)\n                    wrapped_part = wrap(\n                        part, width=cols_size[i], subsequent_indent=subsequent_indent\n                    )\n                    if wrapped_part:\n                        wrapped_value.extend(wrapped_part)\n                    else:\n                        wrapped_value.append(\"\")\n                wrapped_row.append(wrapped_value)\n\n            # Append!\n            for j in range(max([1] + [len(values) for values in wrapped_row])):\n                txt_row: list[str] = []\n                for i in range(cols_nb):\n                    values = wrapped_row[i] if i &lt; len(wrapped_row) else []\n\n                    # An empty cell ?\n                    if len(values) - 1 &lt; j or not values[j]:\n                        if i == 0 and j == 0:\n                            txt_row.append(\"..\")\n                            txt_row.append(\" \" * (cols_size[i] - 1))\n                        else:\n                            txt_row.append(\" \" * (cols_size[i] + 1))\n                        continue\n\n                    # Not empty\n                    value = values[j]\n                    txt_row.append(value)\n                    txt_row.append(\" \" * (cols_size[i] - len(value) + 1))\n                result.append(\"\".join(txt_row))\n\n        result.append(line_str)\n        result.append(\"\")\n        result.append(\"\")\n        result_str = \"\\n\".join(result)\n\n        context[\"no_img_level\"] -= 1\n        return result_str\n\n    def _translate_x_from_any(self, x: str | int) -&gt; int:\n        return translate_from_any(x, self.width, 0)\n\n    #\n    # Public API\n    #\n\n    def append(self, something: Element | str) -&gt; None:\n        \"\"\"Dispatch .append() call to append_row() or append_column().\"\"\"\n        if isinstance(something, Row):\n            self.append_row(something)\n        elif isinstance(something, Column):\n            self.append_column(something)\n        else:\n            # probably still an error\n            self._append(something)\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Get the current height of the table.\n\n        Return: int\n        \"\"\"\n        try:\n            height = self._tmap[-1] + 1\n        except Exception:\n            height = 0\n        return height\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Get the current width of the table, measured on columns.\n\n        Rows may have different widths, use the Table API to ensure width\n        consistency.\n\n        Return: int\n        \"\"\"\n        # Columns are our reference for user expected width\n\n        try:\n            width = self._cmap[-1] + 1\n        except Exception:\n            width = 0\n\n        # columns = self._get_columns()\n        # repeated = self.xpath(\n        #        'table:table-column/@table:number-columns-repeated')\n        # unrepeated = len(columns) - len(repeated)\n        # ws = sum(int(r) for r in repeated) + unrepeated\n        # if w != ws:\n        #    print \"WARNING   ws\", ws, \"w\", w\n\n        return width\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        \"\"\"Shortcut to get the current width and height of the table.\n\n        Return: (int, int)\n        \"\"\"\n        return self.width, self.height\n\n    @property\n    def name(self) -&gt; str | None:\n        \"\"\"Get / set the name of the table.\"\"\"\n        return self.get_attribute_string(\"table:name\")\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        name = _table_name_check(name)\n        # first, update named ranges\n        # fixme : delete name ranges when deleting table, too.\n        for named_range in self.get_named_ranges(table_name=self.name):\n            named_range.set_table_name(name)\n        self.set_attribute(\"table:name\", name)\n\n    @property\n    def protected(self) -&gt; bool:\n        return bool(self.get_attribute(\"table:protected\"))\n\n    @protected.setter\n    def protected(self, protect: bool) -&gt; None:\n        self.set_attribute(\"table:protected\", protect)\n\n    @property\n    def protection_key(self) -&gt; str | None:\n        return self.get_attribute_string(\"table:protection-key\")\n\n    @protection_key.setter\n    def protection_key(self, key: str) -&gt; None:\n        self.set_attribute(\"table:protection-key\", key)\n\n    @property\n    def displayed(self) -&gt; bool:\n        return bool(self.get_attribute(\"table:display\"))\n\n    @displayed.setter\n    def displayed(self, display: bool) -&gt; None:\n        self.set_attribute(\"table:display\", display)\n\n    @property\n    def printable(self) -&gt; bool:\n        printable = self.get_attribute(\"table:print\")\n        # Default value\n        if printable is None:\n            return True\n        return bool(printable)\n\n    @printable.setter\n    def printable(self, printable: bool) -&gt; None:\n        self.set_attribute(\"table:print\", printable)\n\n    @property\n    def print_ranges(self) -&gt; list[str]:\n        ranges = self.get_attribute_string(\"table:print-ranges\")\n        if isinstance(ranges, str):\n            return ranges.split()\n        return []\n\n    @print_ranges.setter\n    def print_ranges(self, ranges: list[str] | None) -&gt; None:\n        if isinstance(ranges, (list, tuple)):\n            self.set_attribute(\"table:print-ranges\", \" \".join(ranges))\n        else:\n            self.set_attribute(\"table:print-ranges\", ranges)\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get / set the style of the table\n\n        Return: str\n        \"\"\"\n        return self.get_attribute_string(\"table:style-name\")\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        if context and context[\"rst_mode\"]:\n            return self._get_formatted_text_rst(context)\n        return self._get_formatted_text_normal(context)\n\n    def get_values(\n        self,\n        coord: tuple | list | str | None = None,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n        flat: bool = False,\n    ) -&gt; list:\n        \"\"\"Get a matrix of values of the table.\n\n        Filter by coordinates will parse the area defined by the coordinates.\n\n        If 'cell_type' is used and 'complete' is True (default), missing values\n        are replaced by None.\n        Filter by ' cell_type = \"all\" ' will retrieve cells of any\n        type, aka non empty cells.\n\n        If 'cell_type' is None, complete is always True : with no cell type\n        queried, get_values() returns None for each empty cell, the length\n        each lists is equal to the width of the table.\n\n        If get_type is True, returns tuples (value, ODF type of value), or\n        (None, None) for empty cells with complete True.\n\n        If flat is True, the methods return a single list of all the values.\n        By default, flat is False.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of area\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of lists of Python types\n        \"\"\"\n        if coord:\n            x, y, z, t = self._translate_table_coordinates(coord)\n        else:\n            x = y = z = t = None\n        data = []\n        for row in self.traverse(start=y, end=t):\n            if z is None:\n                width = self.width\n            else:\n                width = min(z + 1, self.width)\n            if x is not None:\n                width -= x\n            values = row.get_values(\n                (x, z),\n                cell_type=cell_type,\n                complete=complete,\n                get_type=get_type,\n            )\n            # complete row to match request width\n            if complete:\n                if get_type:\n                    values.extend([(None, None)] * (width - len(values)))\n                else:\n                    values.extend([None] * (width - len(values)))\n            if flat:\n                data.extend(values)\n            else:\n                data.append(values)\n        return data\n\n    def iter_values(\n        self,\n        coord: tuple | list | str | None = None,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n    ) -&gt; Iterator[list]:\n        \"\"\"Iterate through lines of Python values of the table.\n\n        Filter by coordinates will parse the area defined by the coordinates.\n\n        cell_type, complete, grt_type : see get_values()\n\n\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of area\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: iterator of lists\n        \"\"\"\n        if coord:\n            x, y, z, t = self._translate_table_coordinates(coord)\n        else:\n            x = y = z = t = None\n        for row in self.traverse(start=y, end=t):\n            if z is None:\n                width = self.width\n            else:\n                width = min(z + 1, self.width)\n            if x is not None:\n                width -= x\n            values = row.get_values(\n                (x, z),\n                cell_type=cell_type,\n                complete=complete,\n                get_type=get_type,\n            )\n            # complete row to match column width\n            if complete:\n                if get_type:\n                    values.extend([(None, None)] * (width - len(values)))\n                else:\n                    values.extend([None] * (width - len(values)))\n            yield values\n\n    def set_values(\n        self,\n        values: list,\n        coord: tuple | list | str | None = None,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set the value of cells in the table, from the 'coord' position\n        with values.\n\n        'coord' is the coordinate of the upper left cell to be modified by\n        values. If 'coord' is None, default to the position (0,0) (\"A1\").\n        If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n        area is used as coordinate.\n\n        The table is *not* cleared before the operation, to reset the table\n        before setting values, use table.clear().\n\n        A list of lists is expected, with as many lists as rows, and as many\n        items in each sublist as cells to be setted. None values in the list\n        will create empty cells with no cell type (but eventually a style).\n\n        Arguments:\n\n            coord -- tuple or str\n\n            values -- list of lists of python types\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n        \"\"\"\n        if coord:\n            x, y = self._translate_cell_coordinates(coord)\n        else:\n            x = y = 0\n        if y is None:\n            y = 0\n        if x is None:\n            x = 0\n        y -= 1\n        for row_values in values:\n            y += 1\n            if not row_values:\n                continue\n            row = self.get_row(y, clone=True)\n            repeated = row.repeated or 1\n            if repeated &gt;= 2:\n                row.repeated = None\n            row.set_values(\n                row_values,\n                start=x,\n                cell_type=cell_type,\n                currency=currency,\n                style=style,\n            )\n            self.set_row(y, row, clone=False)\n            self._update_width(row)\n\n    def rstrip(self, aggressive: bool = False) -&gt; None:\n        \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n        the table. Cells are empty if they contain no value or it evaluates\n        to False, and no style.\n\n        If aggressive is True, empty cells with style are removed too.\n\n        Argument:\n\n            aggressive -- bool\n        \"\"\"\n        # Step 1: remove empty rows below the table\n        for row in reversed(self._get_rows()):\n            if row.is_empty(aggressive=aggressive):\n                row.parent.delete(row)  # type: ignore\n            else:\n                break\n        # Step 2: rstrip remaining rows\n        max_width = 0\n        for row in self._get_rows():\n            row.rstrip(aggressive=aggressive)\n            # keep count of the biggest row\n            max_width = max(max_width, row.width)\n        # raz cache of rows\n        self._indexes[\"_tmap\"] = {}\n        # Step 3: trim columns to match max_width\n        columns = self._get_columns()\n        repeated_cols = self.xpath(\"table:table-column/@table:number-columns-repeated\")\n        if not isinstance(repeated_cols, list):\n            raise TypeError\n        unrepeated = len(columns) - len(repeated_cols)\n        column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore\n        diff = column_width - max_width\n        if diff &gt; 0:\n            for column in reversed(columns):\n                repeated = column.repeated or 1\n                repeated = repeated - diff\n                if repeated &gt; 0:\n                    column.repeated = repeated\n                    break\n                else:\n                    column.parent.delete(column)\n                    diff = -repeated\n                    if diff == 0:\n                        break\n        # raz cache of columns\n        self._indexes[\"_cmap\"] = {}\n        self._compute_table_cache()\n\n    def optimize_width(self) -&gt; None:\n        \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n        the table. Keep repeated styles of empty cells but minimize row width.\n        \"\"\"\n        self._optimize_width_trim_rows()\n        width = self._optimize_width_length()\n        self._optimize_width_rstrip_rows(width)\n        self._optimize_width_adapt_columns(width)\n\n    def _optimize_width_trim_rows(self) -&gt; None:\n        count = -1  # to keep one empty row\n        for row in reversed(self._get_rows()):\n            if row.is_empty(aggressive=False):\n                count += 1\n            else:\n                break\n        if count &gt; 0:\n            for row in reversed(self._get_rows()):\n                row.parent.delete(row)  # type: ignore\n                count -= 1\n                if count &lt;= 0:\n                    break\n        try:\n            last_row = self._get_rows()[-1]\n            last_row._set_repeated(None)\n        except IndexError:\n            pass\n        # raz cache of rows\n        self._indexes[\"_tmap\"] = {}\n\n    def _optimize_width_length(self) -&gt; int:\n        return max(row.minimized_width() for row in self._get_rows())\n\n    def _optimize_width_rstrip_rows(self, width: int) -&gt; None:\n        for row in self._get_rows():\n            row.force_width(width)\n\n    def _optimize_width_adapt_columns(self, width: int) -&gt; None:\n        # trim columns to match minimal_width\n        columns = self._get_columns()\n        repeated_cols = self.xpath(\"table:table-column/@table:number-columns-repeated\")\n        if not isinstance(repeated_cols, list):\n            raise TypeError\n        unrepeated = len(columns) - len(repeated_cols)\n        column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore\n        diff = column_width - width\n        if diff &gt; 0:\n            for column in reversed(columns):\n                repeated = column.repeated or 1\n                repeated = repeated - diff\n                if repeated &gt; 0:\n                    column.repeated = repeated\n                    break\n                else:\n                    column.parent.delete(column)\n                    diff = -repeated\n                    if diff == 0:\n                        break\n        # raz cache of columns\n        self._indexes[\"_cmap\"] = {}\n        self._compute_table_cache()\n\n    def transpose(self, coord: tuple | list | str | None = None) -&gt; None:  # noqa: C901\n        \"\"\"Swap *in-place* rows and columns of the table.\n\n        If 'coord' is not None, apply transpose only to the area defined by the\n        coordinates. Beware, if area is not square, some cells mays be over\n        written during the process.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of area\n\n            start -- int or str\n        \"\"\"\n        data = []\n        if coord is None:\n            for row in self.traverse():\n                data.append(list(row.traverse()))\n            transposed_data = zip_longest(*data)\n            self.clear()\n            # new_rows = []\n            for row_cells in transposed_data:\n                if not isiterable(row_cells):\n                    row_cells = (row_cells,)\n                row = Row()\n                row.extend_cells(row_cells)\n                self.append_row(row, clone=False)\n            self._compute_table_cache()\n        else:\n            x, y, z, t = self._translate_table_coordinates(coord)\n            if x is None:\n                x = 0\n            else:\n                x = min(x, self.width - 1)\n            if z is None:\n                z = self.width - 1\n            else:\n                z = min(z, self.width - 1)\n            if y is None:\n                y = 0\n            else:\n                y = min(y, self.height - 1)\n            if t is None:\n                t = self.height - 1\n            else:\n                t = min(t, self.height - 1)\n            for row in self.traverse(start=y, end=t):\n                data.append(list(row.traverse(start=x, end=z)))\n            transposed_data = zip_longest(*data)\n            # clear locally\n            w = z - x + 1\n            h = t - y + 1\n            if w != h:\n                nones = [[None] * w for i in range(h)]\n                self.set_values(nones, coord=(x, y, z, t))\n            # put transposed\n            filtered_data: list[tuple[Cell]] = []\n            for row_cells in transposed_data:\n                if isinstance(row_cells, (list, tuple)):\n                    filtered_data.append(row_cells)\n                else:\n                    filtered_data.append((row_cells,))\n            self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))\n            self._compute_table_cache()\n\n    def is_empty(self, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return whether every cell in the table has no value or the value\n        evaluates to False (empty string), and no style.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            aggressive -- bool\n        \"\"\"\n        return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())\n\n    #\n    # Rows\n    #\n\n    def _get_rows(self) -&gt; list[Row]:\n        return self.get_elements(_xpath_row)  # type: ignore\n\n    def traverse(  # noqa: C901\n        self,\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; Iterator[Row]:\n        \"\"\"Yield as many row elements as expected rows in the table, i.e.\n        expand repetitions by returning the same row as many times as\n        necessary.\n\n            Arguments:\n\n                start -- int\n\n                end -- int\n\n        Copies are returned, use set_row() to push them back.\n        \"\"\"\n        idx = -1\n        before = -1\n        y = 0\n        if start is None and end is None:\n            for juska in self._tmap:\n                idx += 1\n                if idx in self._indexes[\"_tmap\"]:\n                    row = self._indexes[\"_tmap\"][idx]\n                else:\n                    row = self._get_element_idx2(_xpath_row_idx, idx)\n                    self._indexes[\"_tmap\"][idx] = row\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    # Return a copy without the now obsolete repetition\n                    row = row.clone\n                    row.y = y\n                    y += 1\n                    if repeated &gt; 1:\n                        row.repeated = None\n                    yield row\n        else:\n            if start is None:\n                start = 0\n            start = max(0, start)\n            if end is None:\n                try:\n                    end = self._tmap[-1]\n                except Exception:\n                    end = -1\n            start_map = find_odf_idx(self._tmap, start)\n            if start_map is None:\n                return\n            if start_map &gt; 0:\n                before = self._tmap[start_map - 1]\n            idx = start_map - 1\n            before = start - 1\n            y = start\n            for juska in self._tmap[start_map:]:\n                idx += 1\n                if idx in self._indexes[\"_tmap\"]:\n                    row = self._indexes[\"_tmap\"][idx]\n                else:\n                    row = self._get_element_idx2(_xpath_row_idx, idx)\n                    self._indexes[\"_tmap\"][idx] = row\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    if y &lt;= end:\n                        row = row.clone\n                        row.y = y\n                        y += 1\n                        if repeated &gt; 1 or (y == start and start &gt; 0):\n                            row.repeated = None\n                        yield row\n\n    def get_rows(\n        self,\n        coord: tuple | list | str | None = None,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Row]:\n        \"\"\"Get the list of rows matching the criteria.\n\n        Filter by coordinates will parse the area defined by the coordinates.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of rows\n\n            content -- str regex\n\n            style -- str\n\n        Return: list of rows\n        \"\"\"\n        if coord:\n            _x, y, _z, t = self._translate_table_coordinates(coord)\n        else:\n            y = t = None\n        # fixme : not clones ?\n        if not content and not style:\n            return list(self.traverse(start=y, end=t))\n        rows = []\n        for row in self.traverse(start=y, end=t):\n            if content and not row.match(content):\n                continue\n            if style and style != row.style:\n                continue\n            rows.append(row)\n        return rows\n\n    @property\n    def rows(self) -&gt; list[Row]:\n        \"\"\"Get the list of all rows.\n\n        Return: list of rows\n        \"\"\"\n        # fixme : not clones ?\n        return list(self.traverse())\n\n    def _get_row2(self, y: int, clone: bool = True, create: bool = True) -&gt; Row:\n        if y &gt;= self.height:\n            if create:\n                return Row()\n            raise ValueError(\"Row not found\")\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError(\"Row not found\")\n        if clone:\n            return row.clone\n        return row\n\n    def _get_row2_base(self, y: int) -&gt; Row | None:\n        idx = find_odf_idx(self._tmap, y)\n        if idx is not None:\n            if idx in self._indexes[\"_tmap\"]:\n                row = self._indexes[\"_tmap\"][idx]\n            else:\n                row = self._get_element_idx2(_xpath_row_idx, idx)\n                self._indexes[\"_tmap\"][idx] = row\n            return row\n        return None\n\n    def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:\n        \"\"\"Get the row at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        A copy is returned, use set_cell() to push it back.\n\n        Arguments:\n\n            y -- int or str\n\n        Return: Row\n        \"\"\"\n        # fixme : keep repeat ? maybe an option to functions : \"raw=False\"\n        y = self._translate_y_from_any(y)\n        row = self._get_row2(y, clone=clone, create=create)\n        if row is None:\n            raise ValueError(\"Row not found\")\n        row.y = y\n        return row\n\n    def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:\n        \"\"\"Replace the row at the given position with the new one. Repetions of\n        the old row will be adjusted.\n\n        If row is None, a new empty row is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n\n            row -- Row\n\n        returns the row, with updated row.y\n        \"\"\"\n        if row is None:\n            row = Row()\n            repeated = 1\n            clone = False\n        else:\n            repeated = row.repeated or 1\n        y = self._translate_y_from_any(y)\n        row.y = y\n        # Outside the defined table ?\n        diff = y - self.height\n        if diff == 0:\n            row_back = self.append_row(row, _repeated=repeated, clone=clone)\n        elif diff &gt; 0:\n            self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)\n            row_back = self.append_row(row, _repeated=repeated, clone=clone)\n        else:\n            # Inside the defined table\n            row_back = set_item_in_vault(  # type: ignore\n                y, row, self, _xpath_row_idx, \"_tmap\", clone=clone\n            )\n        # print self.serialize(True)\n        # Update width if necessary\n        self._update_width(row_back)\n        return row_back\n\n    def insert_row(\n        self, y: str | int, row: Row | None = None, clone: bool = True\n    ) -&gt; Row:\n        \"\"\"Insert the row before the given \"y\" position. If no row is given,\n        an empty one is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        If row is None, a new empty row is created.\n\n        Arguments:\n\n            y -- int or str\n\n            row -- Row\n\n        returns the row, with updated row.y\n        \"\"\"\n        if row is None:\n            row = Row()\n            clone = False\n        y = self._translate_y_from_any(y)\n        diff = y - self.height\n        if diff &lt; 0:\n            row_back = insert_item_in_vault(y, row, self, _xpath_row_idx, \"_tmap\")\n        elif diff == 0:\n            row_back = self.append_row(row, clone=clone)\n        else:\n            self.append_row(Row(repeated=diff), _repeated=diff, clone=False)\n            row_back = self.append_row(row, clone=clone)\n        row_back.y = y  # type: ignore\n        # Update width if necessary\n        self._update_width(row_back)  # type: ignore\n        return row_back  # type: ignore\n\n    def extend_rows(self, rows: list[Row] | None = None) -&gt; None:\n        \"\"\"Append a list of rows at the end of the table.\n\n        Arguments:\n\n            rows -- list of Row\n        \"\"\"\n        if rows is None:\n            rows = []\n        self.extend(rows)\n        self._compute_table_cache()\n        # Update width if necessary\n        width = self.width\n        for row in self.traverse():\n            if row.width &gt; width:\n                width = row.width\n        diff = width - self.width\n        if diff &gt; 0:\n            self.append_column(Column(repeated=diff))\n\n    def append_row(\n        self,\n        row: Row | None = None,\n        clone: bool = True,\n        _repeated: int | None = None,\n    ) -&gt; Row:\n        \"\"\"Append the row at the end of the table. If no row is given, an\n        empty one is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Note the columns are automatically created when the first row is\n        inserted in an empty table. So better insert a filled row.\n\n        Arguments:\n\n            row -- Row\n\n            _repeated -- (optional), repeated value of the row\n\n        returns the row, with updated row.y\n        \"\"\"\n        if row is None:\n            row = Row()\n            _repeated = 1\n        elif clone:\n            row = row.clone\n        # Appending a repeated row accepted\n        # Do not insert next to the last row because it could be in a group\n        self._append(row)\n        if _repeated is None:\n            _repeated = row.repeated or 1\n        self._tmap = insert_map_once(self._tmap, len(self._tmap), _repeated)\n        row.y = self.height - 1\n        # Initialize columns\n        if not self._get_columns():\n            repeated = row.width\n            self.insert(Column(repeated=repeated), position=0)\n            self._compute_table_cache()\n        # Update width if necessary\n        self._update_width(row)\n        return row\n\n    def delete_row(self, y: int | str) -&gt; None:\n        \"\"\"Delete the row at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n        \"\"\"\n        y = self._translate_y_from_any(y)\n        # Outside the defined table\n        if y &gt;= self.height:\n            return\n        # Inside the defined table\n        delete_item_in_vault(y, self, _xpath_row_idx, \"_tmap\")\n\n    def get_row_values(\n        self,\n        y: int | str,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n    ) -&gt; list:\n        \"\"\"Shortcut to get the list of Python values for the cells of the row\n        at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n        If cell_type and complete is True, replace missing values by None.\n\n        If get_type is True, returns a tuple (value, ODF type of value)\n\n        Arguments:\n\n            y -- int, str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of lists of Python types\n        \"\"\"\n        values = self.get_row(y, clone=False).get_values(\n            cell_type=cell_type, complete=complete, get_type=get_type\n        )\n        # complete row to match column width\n        if complete:\n            if get_type:\n                values.extend([(None, None)] * (self.width - len(values)))\n            else:\n                values.extend([None] * (self.width - len(values)))\n        return values\n\n    def set_row_values(\n        self,\n        y: int | str,\n        values: list,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; Row:\n        \"\"\"Shortcut to set the values of *all* cells of the row at the given\n        \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n\n            values -- list of Python types\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n\n        returns the row, with updated row.y\n        \"\"\"\n        row = Row()  # needed if clones rows\n        row.set_values(values, style=style, cell_type=cell_type, currency=currency)\n        return self.set_row(y, row)  # needed if clones rows\n\n    def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:\n        \"\"\"Shortcut to set *all* the cells of the row at the given\n        \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n\n            cells -- list of Python types\n\n            style -- str\n\n        returns the row, with updated row.y\n        \"\"\"\n        if cells is None:\n            cells = []\n        row = Row()  # needed if clones rows\n        row.extend_cells(cells)\n        return self.set_row(y, row)  # needed if clones rows\n\n    def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return wether every cell in the row at the given \"y\" position has\n        no value or the value evaluates to False (empty string), and no style.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            y -- int or str\n\n            aggressive -- bool\n        \"\"\"\n        return self.get_row(y, clone=False).is_empty(aggressive=aggressive)\n\n    #\n    # Cells\n    #\n\n    def get_cells(\n        self,\n        coord: tuple | list | str | None = None,\n        cell_type: str | None = None,\n        style: str | None = None,\n        content: str | None = None,\n        flat: bool = False,\n    ) -&gt; list:\n        \"\"\"Get the cells matching the criteria. If 'coord' is None,\n        parse the whole table, else parse the area defined by 'coord'.\n\n        Filter by  cell_type = \"all\"  will retrieve cells of any\n        type, aka non empty cells.\n\n        If flat is True (default is False), the method return a single list\n        of all the values, else a list of lists of cells.\n\n        if cell_type, style and content are None, get_cells() will return\n        the exact number of cells of the area, including empty cells.\n\n        Arguments:\n\n            coordinates -- str or tuple of int : coordinates of area\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            content -- str regex\n\n            style -- str\n\n            flat -- boolean\n\n        Return: list of list of Cell\n        \"\"\"\n        if coord:\n            x, y, z, t = self._translate_table_coordinates(coord)\n        else:\n            x = y = z = t = None\n        if flat:\n            cells: list[Cell] = []\n            for row in self.traverse(start=y, end=t):\n                row_cells = row.get_cells(\n                    coord=(x, z),\n                    cell_type=cell_type,\n                    style=style,\n                    content=content,\n                )\n                cells.extend(row_cells)\n            return cells\n        else:\n            lcells: list[list[Cell]] = []\n            for row in self.traverse(start=y, end=t):\n                row_cells = row.get_cells(\n                    coord=(x, z),\n                    cell_type=cell_type,\n                    style=style,\n                    content=content,\n                )\n                lcells.append(row_cells)\n            return lcells\n\n    @property\n    def cells(self) -&gt; list:\n        \"\"\"Get all cells of the table.\n\n        Return: list of list of Cell\n        \"\"\"\n        lcells: list[list[Cell]] = []\n        for row in self.traverse():\n            lcells.append(row.cells)\n        return lcells\n\n    def get_cell(\n        self,\n        coord: tuple | list | str,\n        clone: bool = True,\n        keep_repeated: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Get the cell at the given coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        A copy is returned, use ``set_cell`` to push it back.\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n        Return: Cell\n        \"\"\"\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        # Outside the defined table\n        if y &gt;= self.height:\n            cell = Cell()\n        else:\n            # Inside the defined table\n            row = self._get_row2_base(y)\n            if row is None:\n                raise ValueError\n            read_cell = row.get_cell(x, clone=clone)\n            if read_cell is None:\n                raise ValueError\n            cell = read_cell\n            if not keep_repeated:\n                repeated = cell.repeated or 1\n                if repeated &gt;= 2:\n                    cell.repeated = None\n        cell.x = x\n        cell.y = y\n        return cell\n\n    def get_value(\n        self,\n        coord: tuple | list | str,\n        get_type: bool = False,\n    ) -&gt; Any:\n        \"\"\"Shortcut to get the Python value of the cell at the given\n        coordinates.\n\n        If get_type is True, returns the tuples (value, ODF type)\n\n        coord is either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\". If an Area is given, the upper\n        left position is used as coord.\n\n        Arguments:\n\n            coord -- (int, int) or str : coordinate\n\n        Return: Python type\n        \"\"\"\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        # Outside the defined table\n        if y &gt;= self.height:\n            if get_type:\n                return (None, None)\n            return None\n        else:\n            # Inside the defined table\n            row = self._get_row2_base(y)\n            if row is None:\n                raise ValueError\n            cell = row._get_cell2_base(x)\n            if cell is None:\n                if get_type:\n                    return (None, None)\n                return None\n            return cell.get_value(get_type=get_type)\n\n    def set_cell(\n        self,\n        coord: tuple | list | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Replace a cell of the table at the given coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Arguments:\n\n            coord -- (int, int) or str : coordinate\n\n            cell -- Cell\n\n        return the cell, with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        cell.x = x\n        cell.y = y\n        if y &gt;= self.height:\n            row = Row()\n            cell_back = row.set_cell(x, cell, clone=clone)\n            self.set_row(y, row, clone=False)\n        else:\n            row_read = self._get_row2_base(y)\n            if row_read is None:\n                raise ValueError\n            row = row_read\n            row.y = y\n            repeated = row.repeated or 1\n            if repeated &gt; 1:\n                row = row.clone\n                row.repeated = None\n                cell_back = row.set_cell(x, cell, clone=clone)\n                self.set_row(y, row, clone=False)\n            else:\n                cell_back = row.set_cell(x, cell, clone=clone)\n                # Update width if necessary, since we don't use set_row\n                self._update_width(row)\n        return cell_back\n\n    def set_cells(\n        self,\n        cells: list[list[Cell]] | list[tuple[Cell]],\n        coord: tuple | list | str | None = None,\n        clone: bool = True,\n    ) -&gt; None:\n        \"\"\"Set the cells in the table, from the 'coord' position.\n\n        'coord' is the coordinate of the upper left cell to be modified by\n        values. If 'coord' is None, default to the position (0,0) (\"A1\").\n        If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n        area is used as coordinate.\n\n        The table is *not* cleared before the operation, to reset the table\n        before setting cells, use table.clear().\n\n        A list of lists is expected, with as many lists as rows to be set, and\n        as many cell in each sublist as cells to be setted in the row.\n\n        Arguments:\n\n            cells -- list of list of cells\n\n            coord -- tuple or str\n\n            values -- list of lists of python types\n        \"\"\"\n        if coord:\n            x, y = self._translate_cell_coordinates(coord)\n        else:\n            x = y = 0\n        if y is None:\n            y = 0\n        if x is None:\n            x = 0\n        y -= 1\n        for row_cells in cells:\n            y += 1\n            if not row_cells:\n                continue\n            row = self.get_row(y, clone=True)\n            repeated = row.repeated or 1\n            if repeated &gt;= 2:\n                row.repeated = None\n            row.set_cells(row_cells, start=x, clone=clone)\n            self.set_row(y, row, clone=False)\n            self._update_width(row)\n\n    def set_value(\n        self,\n        coord: tuple | list | str,\n        value: Any,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set the Python value of the cell at the given coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n            value -- Python type\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n\n        \"\"\"\n        self.set_cell(\n            coord,\n            Cell(value, cell_type=cell_type, currency=currency, style=style),\n            clone=False,\n        )\n\n    def set_cell_image(\n        self,\n        coord: tuple | list | str,\n        image_frame: Frame,\n        doc_type: str | None = None,\n    ) -&gt; None:\n        \"\"\"Do all the magic to display an image in the cell at the given\n        coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        The frame element must contain the expected image position and\n        dimensions.\n\n        DrawImage insertion depends on the document type, so the type must be\n        provided or the table element must be already attached to a document.\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n            image_frame -- Frame including an image\n\n            doc_type -- 'spreadsheet' or 'text'\n        \"\"\"\n        # Test document type\n        if doc_type is None:\n            body = self.document_body\n            if body is None:\n                raise ValueError(\"document type not found\")\n            doc_type = {\"office:spreadsheet\": \"spreadsheet\", \"office:text\": \"text\"}.get(\n                body.tag\n            )\n            if doc_type is None:\n                raise ValueError(\"document type not supported for images\")\n        # We need the end address of the image\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        cell = self.get_cell((x, y))\n        image_frame = image_frame.clone  # type: ignore\n        # Remove any previous paragraph, frame, etc.\n        for child in cell.children:\n            cell.delete(child)\n        # Now it all depends on the document type\n        if doc_type == \"spreadsheet\":\n            image_frame.anchor_type = \"char\"\n            # The frame needs end coordinates\n            width, height = image_frame.size\n            image_frame.set_attribute(\"table:end-x\", width)\n            image_frame.set_attribute(\"table:end-y\", height)\n            # FIXME what happens when the address changes?\n            address = f\"{self.name}.{digit_to_alpha(x)}{y + 1}\"\n            image_frame.set_attribute(\"table:end-cell-address\", address)\n            # The frame is directly in the cell\n            cell.append(image_frame)\n        elif doc_type == \"text\":\n            # The frame must be in a paragraph\n            cell.set_value(\"\")\n            paragraph = cell.get_element(\"text:p\")\n            if paragraph is None:\n                raise ValueError\n            paragraph.append(image_frame)\n        self.set_cell(coord, cell)\n\n    def insert_cell(\n        self,\n        coord: tuple | list | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Insert the given cell at the given coordinates. If no cell is\n        given, an empty one is created.\n\n        Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Cells on the right are shifted. Other rows remain untouched.\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n            cell -- Cell\n\n        returns the cell with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        if clone:\n            cell = cell.clone\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        row = self._get_row2(y, clone=True)\n        row.y = y\n        row.repeated = None\n        cell_back = row.insert_cell(x, cell, clone=False)\n        self.set_row(y, row, clone=False)\n        # Update width if necessary\n        self._update_width(row)\n        return cell_back\n\n    def append_cell(\n        self,\n        y: int | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Append the given cell at the \"y\" coordinate. Repeated cells are\n        accepted. If no cell is given, an empty one is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Other rows remain untouched.\n\n        Arguments:\n\n            y -- int or str\n\n            cell -- Cell\n\n        returns the cell with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        if clone:\n            cell = cell.clone\n        y = self._translate_y_from_any(y)\n        row = self._get_row2(y)\n        row.y = y\n        cell_back = row.append_cell(cell, clone=False)\n        self.set_row(y, row)\n        # Update width if necessary\n        self._update_width(row)\n        return cell_back\n\n    def delete_cell(self, coord: tuple | list | str) -&gt; None:\n        \"\"\"Delete the cell at the given coordinates, so that next cells are\n        shifted to the left.\n\n        Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Use set_value() for erasing value.\n\n        Arguments:\n\n            coord -- (int, int) or str\n        \"\"\"\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        # Outside the defined table\n        if y &gt;= self.height:\n            return\n        # Inside the defined table\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError\n        row.delete_cell(x)\n        # self.set_row(y, row)\n\n    # Columns\n\n    def _get_columns(self) -&gt; list:\n        return self.get_elements(_xpath_column)\n\n    def traverse_columns(  # noqa: C901\n        self,\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; Iterator[Column]:\n        \"\"\"Yield as many column elements as expected columns in the table,\n        i.e. expand repetitions by returning the same column as many times as\n        necessary.\n\n            Arguments:\n\n                start -- int\n\n                end -- int\n\n        Copies are returned, use set_column() to push them back.\n        \"\"\"\n        idx = -1\n        before = -1\n        x = 0\n        if start is None and end is None:\n            for juska in self._cmap:\n                idx += 1\n                if idx in self._indexes[\"_cmap\"]:\n                    column = self._indexes[\"_cmap\"][idx]\n                else:\n                    column = self._get_element_idx2(_xpath_column_idx, idx)\n                    self._indexes[\"_cmap\"][idx] = column\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    # Return a copy without the now obsolete repetition\n                    column = column.clone\n                    column.x = x\n                    x += 1\n                    if repeated &gt; 1:\n                        column.repeated = None\n                    yield column\n        else:\n            if start is None:\n                start = 0\n            start = max(0, start)\n            if end is None:\n                try:\n                    end = self._cmap[-1]\n                except Exception:\n                    end = -1\n            start_map = find_odf_idx(self._cmap, start)\n            if start_map is None:\n                return\n            if start_map &gt; 0:\n                before = self._cmap[start_map - 1]\n            idx = start_map - 1\n            before = start - 1\n            x = start\n            for juska in self._cmap[start_map:]:\n                idx += 1\n                if idx in self._indexes[\"_cmap\"]:\n                    column = self._indexes[\"_cmap\"][idx]\n                else:\n                    column = self._get_element_idx2(_xpath_column_idx, idx)\n                    self._indexes[\"_cmap\"][idx] = column\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    if x &lt;= end:\n                        column = column.clone\n                        column.x = x\n                        x += 1\n                        if repeated &gt; 1 or (x == start and start &gt; 0):\n                            column.repeated = None\n                        yield column\n\n    def get_columns(\n        self,\n        coord: tuple | list | str | None = None,\n        style: str | None = None,\n    ) -&gt; list[Column]:\n        \"\"\"Get the list of columns matching the criteria.\n\n        Copies are returned, use set_column() to push them back.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of columns\n\n            style -- str\n\n        Return: list of columns\n        \"\"\"\n        if coord:\n            x, _y, _z, t = self._translate_column_coordinates(coord)\n        else:\n            x = t = None\n        if not style:\n            return list(self.traverse_columns(start=x, end=t))\n        columns = []\n        for column in self.traverse_columns(start=x, end=t):\n            if style != column.style:\n                continue\n            columns.append(column)\n        return columns\n\n    def _get_column2(self, x: int) -&gt; Column | None:\n        # Outside the defined table\n        if x &gt;= self.width:\n            return Column()\n        # Inside the defined table\n        odf_idx = find_odf_idx(self._cmap, x)\n        if odf_idx is not None:\n            column = self._get_element_idx2(_xpath_column_idx, odf_idx)\n            if column is None:\n                return None\n            # fixme : no clone here =&gt; change doc and unit tests\n            return column.clone  # type: ignore\n            # return row\n        return None\n\n    @property\n    def columns(self) -&gt; list[Column]:\n        \"\"\"Get the list of all columns matching the criteria.\n\n        Copies are returned, use set_column() to push them back.\n\n        Return: list of columns\n        \"\"\"\n        return list(self.traverse_columns())\n\n    def get_column(self, x: int | str) -&gt; Column:\n        \"\"\"Get the column at the given \"x\" position.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        A copy is returned, use set_column() to push it back.\n\n        Arguments:\n\n            x -- int or str\n\n        Return: Column\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        column = self._get_column2(x)\n        if column is None:\n            raise ValueError\n        column.x = x\n        return column\n\n    def set_column(\n        self,\n        x: int | str,\n        column: Column | None = None,\n    ) -&gt; Column:\n        \"\"\"Replace the column at the given \"x\" position.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            x -- int or str\n\n            column -- Column\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        if column is None:\n            column = Column()\n            repeated = 1\n        else:\n            repeated = column.repeated or 1\n        column.x = x\n        # Outside the defined table ?\n        diff = x - self.width\n        if diff == 0:\n            column_back = self.append_column(column, _repeated=repeated)\n        elif diff &gt; 0:\n            self.append_column(Column(repeated=diff), _repeated=diff)\n            column_back = self.append_column(column, _repeated=repeated)\n        else:\n            # Inside the defined table\n            column_back = set_item_in_vault(  # type: ignore\n                x, column, self, _xpath_column_idx, \"_cmap\"\n            )\n        return column_back\n\n    def insert_column(\n        self,\n        x: int | str,\n        column: Column | None = None,\n    ) -&gt; Column:\n        \"\"\"Insert the column before the given \"x\" position. If no column is\n        given, an empty one is created.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            x -- int or str\n\n            column -- Column\n        \"\"\"\n        if column is None:\n            column = Column()\n        x = self._translate_x_from_any(x)\n        diff = x - self.width\n        if diff &lt; 0:\n            column_back = insert_item_in_vault(\n                x, column, self, _xpath_column_idx, \"_cmap\"\n            )\n        elif diff == 0:\n            column_back = self.append_column(column.clone)\n        else:\n            self.append_column(Column(repeated=diff), _repeated=diff)\n            column_back = self.append_column(column.clone)\n        column_back.x = x  # type: ignore\n        # Repetitions are accepted\n        repeated = column.repeated or 1\n        # Update width on every row\n        for row in self._get_rows():\n            if row.width &gt; x:\n                row.insert_cell(x, Cell(repeated=repeated))\n            # Shorter rows don't need insert\n            # Longer rows shouldn't exist!\n        return column_back  # type: ignore\n\n    def append_column(\n        self,\n        column: Column | None = None,\n        _repeated: int | None = None,\n    ) -&gt; Column:\n        \"\"\"Append the column at the end of the table. If no column is given,\n        an empty one is created.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            column -- Column\n        \"\"\"\n        if column is None:\n            column = Column()\n        else:\n            column = column.clone\n        if not self._cmap:\n            position = 0\n        else:\n            odf_idx = len(self._cmap) - 1\n            last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)\n            if last_column is None:\n                raise ValueError\n            position = self.index(last_column) + 1\n        column.x = self.width\n        self.insert(column, position=position)\n        # Repetitions are accepted\n        if _repeated is None:\n            _repeated = column.repeated or 1\n        self._cmap = insert_map_once(self._cmap, len(self._cmap), _repeated)\n        # No need to update row widths\n        return column\n\n    def delete_column(self, x: int | str) -&gt; None:\n        \"\"\"Delete the column at the given position. ODF columns don't contain\n        cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            x -- int or str\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        # Outside the defined table\n        if x &gt;= self.width:\n            return\n        # Inside the defined table\n        delete_item_in_vault(x, self, _xpath_column_idx, \"_cmap\")\n        # Update width\n        width = self.width\n        for row in self._get_rows():\n            if row.width &gt;= width:\n                row.delete_cell(x)\n\n    def get_column_cells(  # noqa: C901\n        self,\n        x: int | str,\n        style: str | None = None,\n        content: str | None = None,\n        cell_type: str | None = None,\n        complete: bool = False,\n    ) -&gt; list[Cell | None]:\n        \"\"\"Get the list of cells at the given position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n\n        If complete is True, replace missing values by None.\n\n        Arguments:\n\n            x -- int or str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            content -- str regex\n\n            style -- str\n\n            complete -- boolean\n\n        Return: list of Cell\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        if cell_type:\n            cell_type = cell_type.lower().strip()\n        cells: list[Cell | None] = []\n        if not style and not content and not cell_type:\n            for row in self.traverse():\n                cells.append(row.get_cell(x, clone=True))\n            return cells\n        for row in self.traverse():\n            cell = row.get_cell(x, clone=True)\n            if cell is None:\n                raise ValueError\n            # Filter the cells by cell_type\n            if cell_type:\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    if complete:\n                        cells.append(None)\n                    continue\n            # Filter the cells with the regex\n            if content and not cell.match(content):\n                if complete:\n                    cells.append(None)\n                continue\n            # Filter the cells with the style\n            if style and style != cell.style:\n                if complete:\n                    cells.append(None)\n                continue\n            cells.append(cell)\n        return cells\n\n    def get_column_values(\n        self,\n        x: int | str,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n    ) -&gt; list[Any]:\n        \"\"\"Shortcut to get the list of Python values for the cells at the\n        given position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n        If cell_type and complete is True, replace missing values by None.\n\n        If get_type is True, returns a tuple (value, ODF type of value)\n\n        Arguments:\n\n            x -- int or str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of Python types\n        \"\"\"\n        cells = self.get_column_cells(\n            x, style=None, content=None, cell_type=cell_type, complete=complete\n        )\n        values: list[Any] = []\n        for cell in cells:\n            if cell is None:\n                if complete:\n                    if get_type:\n                        values.append((None, None))\n                    else:\n                        values.append(None)\n                continue\n            if cell_type:\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    if complete:\n                        if get_type:\n                            values.append((None, None))\n                        else:\n                            values.append(None)\n                    continue\n            values.append(cell.get_value(get_type=get_type))\n        return values\n\n    def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:\n        \"\"\"Shortcut to set the list of cells at the given position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        The list must have the same length than the table height.\n\n        Arguments:\n\n            x -- int or str\n\n            cells -- list of Cell\n        \"\"\"\n        height = self.height\n        if len(cells) != height:\n            raise ValueError(f\"col mismatch: {height} cells expected\")\n        cells_iterator = iter(cells)\n        for y, row in enumerate(self.traverse()):\n            row.set_cell(x, next(cells_iterator))\n            self.set_row(y, row)\n\n    def set_column_values(\n        self,\n        x: int | str,\n        values: list,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the list of Python values of cells at the given\n        position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        The list must have the same length than the table height.\n\n        Arguments:\n\n            x -- int or str\n\n            values -- list of Python types\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n        \"\"\"\n        cells = [\n            Cell(value, cell_type=cell_type, currency=currency, style=style)\n            for value in values\n        ]\n        self.set_column_cells(x, cells)\n\n    def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return wether every cell in the column at \"x\" position has no value\n        or the value evaluates to False (empty string), and no style.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Return: bool\n        \"\"\"\n        for cell in self.get_column_cells(x):\n            if cell is None:\n                continue\n            if not cell.is_empty(aggressive=aggressive):\n                return False\n        return True\n\n    # Named Range\n\n    def get_named_ranges(  # type: ignore\n        self,\n        table_name: str | list[str] | None = None,\n    ) -&gt; list[NamedRange]:\n        \"\"\"Returns the list of available Name Ranges of the spreadsheet. If\n        table_name is provided, limits the search to these tables.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            table_names -- str or list of str, names of tables\n\n        Return : list of table_range\n        \"\"\"\n        body = self.document_body\n        if not body:\n            return []\n        all_named_ranges = body.get_named_ranges()\n        if not table_name:\n            return all_named_ranges  # type:ignore\n        filter_ = []\n        if isinstance(table_name, str):\n            filter_.append(table_name)\n        elif isiterable(table_name):\n            filter_.extend(table_name)\n        else:\n            raise ValueError(\n                f\"table_name must be string or Iterable, not {type(table_name)}\"\n            )\n        return [\n            nr for nr in all_named_ranges if nr.table_name in filter_  # type:ignore\n        ]\n\n    def get_named_range(self, name: str) -&gt; NamedRange:\n        \"\"\"Returns the Name Ranges of the specified name. If\n        table_name is provided, limits the search to these tables.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            name -- str, name of the named range object\n\n        Return : NamedRange\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document\")\n        return body.get_named_range(name)  # type: ignore\n\n    def set_named_range(\n        self,\n        name: str,\n        crange: str | tuple | list,\n        table_name: str | None = None,\n        usage: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create a Named Range element and insert it in the document.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            name -- str, name of the named range\n\n            crange -- str or tuple of int, cell or area coordinate\n\n            table_name -- str, name of the table\n\n            uage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document\")\n        if not name:\n            raise ValueError(\"Name required.\")\n        if table_name is None:\n            table_name = self.name\n        named_range = NamedRange(name, crange, table_name, usage)\n        body.append_named_range(named_range)\n\n    def delete_named_range(self, name: str) -&gt; None:\n        \"\"\"Delete the Named Range of specified name from the spreadsheet.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name required.\")\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        body.delete_named_range(name)\n\n    #\n    # Cell span\n    #\n\n    def set_span(  # noqa: C901\n        self,\n        area: str | tuple | list,\n        merge: bool = False,\n    ) -&gt; bool:\n        \"\"\"Create a Cell Span : span the first cell of the area on several\n        columns and/or rows.\n        If merge is True, replace text of the cell by the concatenation of\n        existing text in covered cells.\n        Beware : if merge is True, old text is changed, if merge is False\n        (the default), old text in coverd cells is still present but not\n        displayed by most GUI.\n\n        If the area defines only one cell, the set span will do nothing.\n        It is not allowed to apply set span to an area whose one cell already\n        belongs to previous cell span.\n\n        Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n        be provided as an alpha numeric value like \"A1:B2' or a tuple like\n        (0, 0, 1, 1) or (0, 0).\n\n        Arguments:\n\n            area -- str or tuple of int, cell or area coordinate\n\n            merge -- boolean\n        \"\"\"\n        # get area\n        digits = convert_coordinates(area)\n        if len(digits) == 4:\n            x, y, z, t = digits\n        else:\n            x, y = digits\n            z, t = digits\n        start = x, y\n        end = z, t\n        if start == end:\n            # one cell : do nothing\n            return False\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        if z is None:\n            raise ValueError\n        if t is None:\n            raise ValueError\n        # check for previous span\n        good = True\n        # Check boundaries and empty cells : need to crate non existent cells\n        # so don't use get_cells directly, but get_cell\n        cells = []\n        for yy in range(y, t + 1):\n            row_cells = []\n            for xx in range(x, z + 1):\n                row_cells.append(\n                    self.get_cell((xx, yy), clone=True, keep_repeated=False)\n                )\n            cells.append(row_cells)\n        for row in cells:\n            for cell in row:\n                if cell.is_spanned():\n                    good = False\n                    break\n            if not good:\n                break\n        if not good:\n            return False\n        # Check boundaries\n        # if z &gt;= self.width or t &gt;= self.height:\n        #    self.set_cell(coord = end)\n        #    print area, z, t\n        #    cells = self.get_cells((x, y, z, t))\n        #    print cells\n        # do it:\n        if merge:\n            val_list = []\n            for row in cells:\n                for cell in row:\n                    if cell.is_empty(aggressive=True):\n                        continue\n                    val = cell.get_value()\n                    if val is not None:\n                        if isinstance(val, str):\n                            val.strip()\n                        if val != \"\":\n                            val_list.append(val)\n                        cell.clear()\n            if val_list:\n                if len(val_list) == 1:\n                    cells[0][0].set_value(val_list[0])\n                else:\n                    value = \" \".join([str(v) for v in val_list if v])\n                    cells[0][0].set_value(value)\n        cols = z - x + 1\n        cells[0][0].set_attribute(\"table:number-columns-spanned\", str(cols))\n        rows = t - y + 1\n        cells[0][0].set_attribute(\"table:number-rows-spanned\", str(rows))\n        for cell in cells[0][1:]:\n            cell.tag = \"table:covered-table-cell\"\n        for row in cells[1:]:\n            for cell in row:\n                cell.tag = \"table:covered-table-cell\"\n        # replace cells in table\n        self.set_cells(cells, coord=start, clone=False)\n        return True\n\n    def del_span(self, area: str | tuple | list) -&gt; bool:\n        \"\"\"Delete a Cell Span. 'area' is the cell coordiante of the upper left\n        cell of the spanned area.\n\n        Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n        be provided as an alpha numeric value like \"A1:B2' or a tuple like\n        (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell\n        is used.\n\n        Arguments:\n\n            area -- str or tuple of int, cell or area coordinate\n        \"\"\"\n        # get area\n        digits = convert_coordinates(area)\n        if len(digits) == 4:\n            x, y, _z, _t = digits\n        else:\n            x, y = digits\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        start = x, y\n        # check for previous span\n        cell0 = self.get_cell(start)\n        nb_cols = cell0.get_attribute_integer(\"table:number-columns-spanned\")\n        if nb_cols is None:\n            return False\n        nb_rows = cell0.get_attribute_integer(\"table:number-rows-spanned\")\n        if nb_rows is None:\n            return False\n        z = x + nb_cols - 1\n        t = y + nb_rows - 1\n        cells = self.get_cells((x, y, z, t))\n        cells[0][0].del_attribute(\"table:number-columns-spanned\")\n        cells[0][0].del_attribute(\"table:number-rows-spanned\")\n        for cell in cells[0][1:]:\n            cell.tag = \"table:table-cell\"\n        for row in cells[1:]:\n            for cell in row:\n                cell.tag = \"table:table-cell\"\n        # replace cells in table\n        self.set_cells(cells, coord=start, clone=False)\n        return True\n\n    # Utilities\n\n    def to_csv(\n        self,\n        path_or_file: str | Path | None = None,\n        dialect: str = \"excel\",\n    ) -&gt; Any:\n        \"\"\"Write the table as CSV in the file.\n\n        If the file is a string, it is opened as a local path. Else an\n        opened file-like is expected.\n\n        Arguments:\n\n            path_or_file -- str or file-like\n\n            dialect -- str, python csv.dialect, can be 'excel', 'unix'...\n        \"\"\"\n\n        def write_content(csv_writer: object) -&gt; None:\n            for values in self.iter_values():\n                line = []\n                for value in values:\n                    if value is None:\n                        value = \"\"\n                    if isinstance(value, str):\n                        value = value.strip()\n                    line.append(value)\n                csv_writer.writerow(line)  # type: ignore\n\n        out = StringIO(newline=\"\")\n        csv_writer = csv.writer(out, dialect=dialect)\n        write_content(csv_writer)\n        if path_or_file is None:\n            return out.getvalue()\n        path = Path(path_or_file)\n        path.write_text(out.getvalue())\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Table.cells","title":"<code>cells: list</code>  <code>property</code>","text":"<p>Get all cells of the table.</p> <p>Return: list of list of Cell</p>"},{"location":"reference.html#odfdo.Table.columns","title":"<code>columns: list[Column]</code>  <code>property</code>","text":"<p>Get the list of all columns matching the criteria.</p> <p>Copies are returned, use set_column() to push them back.</p> <p>Return: list of columns</p>"},{"location":"reference.html#odfdo.Table.height","title":"<code>height: int</code>  <code>property</code>","text":"<p>Get the current height of the table.</p> <p>Return: int</p>"},{"location":"reference.html#odfdo.Table.name","title":"<code>name: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the name of the table.</p>"},{"location":"reference.html#odfdo.Table.rows","title":"<code>rows: list[Row]</code>  <code>property</code>","text":"<p>Get the list of all rows.</p> <p>Return: list of rows</p>"},{"location":"reference.html#odfdo.Table.size","title":"<code>size: tuple[int, int]</code>  <code>property</code>","text":"<p>Shortcut to get the current width and height of the table.</p> <p>Return: (int, int)</p>"},{"location":"reference.html#odfdo.Table.style","title":"<code>style: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the style of the table</p> <p>Return: str</p>"},{"location":"reference.html#odfdo.Table.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>Get the current width of the table, measured on columns.</p> <p>Rows may have different widths, use the Table API to ensure width consistency.</p> <p>Return: int</p>"},{"location":"reference.html#odfdo.Table.__init__","title":"<code>__init__(name=None, width=None, height=None, protected=False, protection_key=None, display=True, printable=True, print_ranges=None, style=None, **kwargs)</code>","text":"<p>Create a table element, optionally prefilled with \u201cheight\u201d rows of \u201cwidth\u201d cells each.</p> <p>If the table is to be protected, a protection key must be provided, i.e. a hash value of the password.</p> <p>If the table must not be displayed, set \u201cdisplay\u201d to False.</p> <p>If the table must not be printed, set \u201cprintable\u201d to False. The table will not be printed when it is not displayed, whatever the value of this argument.</p> <p>Ranges of cells to print can be provided as a list of cell ranges, e.g. [\u2018E6:K12\u2019, \u2018P6:R12\u2019] or directly as a raw string, e.g. \u201cE6:K12 P6:R12\u201d.</p> <p>You can access and modify the XML tree manually, but you probably want to use the API to access and alter cells. It will save you from handling repetitions and the same number of cells for each row.</p> <p>If you use both the table API and the XML API, you are on your own for ensuiring model integrity.</p> <p>Arguments:</p> <pre><code>name -- str\n\nwidth -- int\n\nheight -- int\n\nprotected -- bool\n\nprotection_key -- str\n\ndisplay -- bool\n\nprintable -- bool\n\nprint_ranges -- list\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    width: int | None = None,\n    height: int | None = None,\n    protected: bool = False,\n    protection_key: str | None = None,\n    display: bool = True,\n    printable: bool = True,\n    print_ranges: list[str] | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a table element, optionally prefilled with \"height\" rows of\n    \"width\" cells each.\n\n    If the table is to be protected, a protection key must be provided,\n    i.e. a hash value of the password.\n\n    If the table must not be displayed, set \"display\" to False.\n\n    If the table must not be printed, set \"printable\" to False. The table\n    will not be printed when it is not displayed, whatever the value of\n    this argument.\n\n    Ranges of cells to print can be provided as a list of cell ranges,\n    e.g. ['E6:K12', 'P6:R12'] or directly as a raw string, e.g.\n    \"E6:K12 P6:R12\".\n\n    You can access and modify the XML tree manually, but you probably want\n    to use the API to access and alter cells. It will save you from\n    handling repetitions and the same number of cells for each row.\n\n    If you use both the table API and the XML API, you are on your own for\n    ensuiring model integrity.\n\n    Arguments:\n\n        name -- str\n\n        width -- int\n\n        height -- int\n\n        protected -- bool\n\n        protection_key -- str\n\n        display -- bool\n\n        printable -- bool\n\n        print_ranges -- list\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self._indexes = {}\n    self._indexes[\"_cmap\"] = {}\n    self._indexes[\"_tmap\"] = {}\n    if self._do_init:\n        self.name = name\n        if protected:\n            self.protected = protected\n            self.set_protection_key = protection_key\n        if not display:\n            self.displayed = display\n        if not printable:\n            self.printable = printable\n        if print_ranges:\n            self.print_ranges = print_ranges\n        if style:\n            self.style = style\n        # Prefill the table\n        if width is not None or height is not None:\n            width = width or 1\n            height = height or 1\n            # Column groups for style information\n            columns = Column(repeated=width)\n            self._append(columns)\n            for _i in range(height):\n                row = Row(width)\n                self._append(row)\n    self._compute_table_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Table.append","title":"<code>append(something)</code>","text":"<p>Dispatch .append() call to append_row() or append_column().</p> Source code in <code>odfdo/table.py</code> <pre><code>def append(self, something: Element | str) -&gt; None:\n    \"\"\"Dispatch .append() call to append_row() or append_column().\"\"\"\n    if isinstance(something, Row):\n        self.append_row(something)\n    elif isinstance(something, Column):\n        self.append_column(something)\n    else:\n        # probably still an error\n        self._append(something)\n</code></pre>"},{"location":"reference.html#odfdo.Table.append_cell","title":"<code>append_cell(y, cell=None, clone=True)</code>","text":"<p>Append the given cell at the \u201cy\u201d coordinate. Repeated cells are accepted. If no cell is given, an empty one is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Other rows remain untouched.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\ncell -- Cell\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/table.py</code> <pre><code>def append_cell(\n    self,\n    y: int | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Append the given cell at the \"y\" coordinate. Repeated cells are\n    accepted. If no cell is given, an empty one is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Other rows remain untouched.\n\n    Arguments:\n\n        y -- int or str\n\n        cell -- Cell\n\n    returns the cell with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    if clone:\n        cell = cell.clone\n    y = self._translate_y_from_any(y)\n    row = self._get_row2(y)\n    row.y = y\n    cell_back = row.append_cell(cell, clone=False)\n    self.set_row(y, row)\n    # Update width if necessary\n    self._update_width(row)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.append_column","title":"<code>append_column(column=None, _repeated=None)</code>","text":"<p>Append the column at the end of the table. If no column is given, an empty one is created.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>column -- Column\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def append_column(\n    self,\n    column: Column | None = None,\n    _repeated: int | None = None,\n) -&gt; Column:\n    \"\"\"Append the column at the end of the table. If no column is given,\n    an empty one is created.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        column -- Column\n    \"\"\"\n    if column is None:\n        column = Column()\n    else:\n        column = column.clone\n    if not self._cmap:\n        position = 0\n    else:\n        odf_idx = len(self._cmap) - 1\n        last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)\n        if last_column is None:\n            raise ValueError\n        position = self.index(last_column) + 1\n    column.x = self.width\n    self.insert(column, position=position)\n    # Repetitions are accepted\n    if _repeated is None:\n        _repeated = column.repeated or 1\n    self._cmap = insert_map_once(self._cmap, len(self._cmap), _repeated)\n    # No need to update row widths\n    return column\n</code></pre>"},{"location":"reference.html#odfdo.Table.append_row","title":"<code>append_row(row=None, clone=True, _repeated=None)</code>","text":"<p>Append the row at the end of the table. If no row is given, an empty one is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Note the columns are automatically created when the first row is inserted in an empty table. So better insert a filled row.</p> <p>Arguments:</p> <pre><code>row -- Row\n\n_repeated -- (optional), repeated value of the row\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def append_row(\n    self,\n    row: Row | None = None,\n    clone: bool = True,\n    _repeated: int | None = None,\n) -&gt; Row:\n    \"\"\"Append the row at the end of the table. If no row is given, an\n    empty one is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Note the columns are automatically created when the first row is\n    inserted in an empty table. So better insert a filled row.\n\n    Arguments:\n\n        row -- Row\n\n        _repeated -- (optional), repeated value of the row\n\n    returns the row, with updated row.y\n    \"\"\"\n    if row is None:\n        row = Row()\n        _repeated = 1\n    elif clone:\n        row = row.clone\n    # Appending a repeated row accepted\n    # Do not insert next to the last row because it could be in a group\n    self._append(row)\n    if _repeated is None:\n        _repeated = row.repeated or 1\n    self._tmap = insert_map_once(self._tmap, len(self._tmap), _repeated)\n    row.y = self.height - 1\n    # Initialize columns\n    if not self._get_columns():\n        repeated = row.width\n        self.insert(Column(repeated=repeated), position=0)\n        self._compute_table_cache()\n    # Update width if necessary\n    self._update_width(row)\n    return row\n</code></pre>"},{"location":"reference.html#odfdo.Table.del_span","title":"<code>del_span(area)</code>","text":"<p>Delete a Cell Span. \u2018area\u2019 is the cell coordiante of the upper left cell of the spanned area.</p> <p>Area can be either one cell (like \u2018A1\u2019) or an area (\u2018A1:B2\u2019). It can be provided as an alpha numeric value like \u201cA1:B2\u2019 or a tuple like (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell is used.</p> <p>Arguments:</p> <pre><code>area -- str or tuple of int, cell or area coordinate\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def del_span(self, area: str | tuple | list) -&gt; bool:\n    \"\"\"Delete a Cell Span. 'area' is the cell coordiante of the upper left\n    cell of the spanned area.\n\n    Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n    be provided as an alpha numeric value like \"A1:B2' or a tuple like\n    (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell\n    is used.\n\n    Arguments:\n\n        area -- str or tuple of int, cell or area coordinate\n    \"\"\"\n    # get area\n    digits = convert_coordinates(area)\n    if len(digits) == 4:\n        x, y, _z, _t = digits\n    else:\n        x, y = digits\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    start = x, y\n    # check for previous span\n    cell0 = self.get_cell(start)\n    nb_cols = cell0.get_attribute_integer(\"table:number-columns-spanned\")\n    if nb_cols is None:\n        return False\n    nb_rows = cell0.get_attribute_integer(\"table:number-rows-spanned\")\n    if nb_rows is None:\n        return False\n    z = x + nb_cols - 1\n    t = y + nb_rows - 1\n    cells = self.get_cells((x, y, z, t))\n    cells[0][0].del_attribute(\"table:number-columns-spanned\")\n    cells[0][0].del_attribute(\"table:number-rows-spanned\")\n    for cell in cells[0][1:]:\n        cell.tag = \"table:table-cell\"\n    for row in cells[1:]:\n        for cell in row:\n            cell.tag = \"table:table-cell\"\n    # replace cells in table\n    self.set_cells(cells, coord=start, clone=False)\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_cell","title":"<code>delete_cell(coord)</code>","text":"<p>Delete the cell at the given coordinates, so that next cells are shifted to the left.</p> <p>Coordinates are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Use set_value() for erasing value.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_cell(self, coord: tuple | list | str) -&gt; None:\n    \"\"\"Delete the cell at the given coordinates, so that next cells are\n    shifted to the left.\n\n    Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Use set_value() for erasing value.\n\n    Arguments:\n\n        coord -- (int, int) or str\n    \"\"\"\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    # Outside the defined table\n    if y &gt;= self.height:\n        return\n    # Inside the defined table\n    row = self._get_row2_base(y)\n    if row is None:\n        raise ValueError\n    row.delete_cell(x)\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_column","title":"<code>delete_column(x)</code>","text":"<p>Delete the column at the given position. ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_column(self, x: int | str) -&gt; None:\n    \"\"\"Delete the column at the given position. ODF columns don't contain\n    cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        x -- int or str\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    # Outside the defined table\n    if x &gt;= self.width:\n        return\n    # Inside the defined table\n    delete_item_in_vault(x, self, _xpath_column_idx, \"_cmap\")\n    # Update width\n    width = self.width\n    for row in self._get_rows():\n        if row.width &gt;= width:\n            row.delete_cell(x)\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_named_range","title":"<code>delete_named_range(name)</code>","text":"<p>Delete the Named Range of specified name from the spreadsheet. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_named_range(self, name: str) -&gt; None:\n    \"\"\"Delete the Named Range of specified name from the spreadsheet.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    name = name.strip()\n    if not name:\n        raise ValueError(\"Name required.\")\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    body.delete_named_range(name)\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_row","title":"<code>delete_row(y)</code>","text":"<p>Delete the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_row(self, y: int | str) -&gt; None:\n    \"\"\"Delete the row at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n    \"\"\"\n    y = self._translate_y_from_any(y)\n    # Outside the defined table\n    if y &gt;= self.height:\n        return\n    # Inside the defined table\n    delete_item_in_vault(y, self, _xpath_row_idx, \"_tmap\")\n</code></pre>"},{"location":"reference.html#odfdo.Table.extend_rows","title":"<code>extend_rows(rows=None)</code>","text":"<p>Append a list of rows at the end of the table.</p> <p>Arguments:</p> <pre><code>rows -- list of Row\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def extend_rows(self, rows: list[Row] | None = None) -&gt; None:\n    \"\"\"Append a list of rows at the end of the table.\n\n    Arguments:\n\n        rows -- list of Row\n    \"\"\"\n    if rows is None:\n        rows = []\n    self.extend(rows)\n    self._compute_table_cache()\n    # Update width if necessary\n    width = self.width\n    for row in self.traverse():\n        if row.width &gt; width:\n            width = row.width\n    diff = width - self.width\n    if diff &gt; 0:\n        self.append_column(Column(repeated=diff))\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_cell","title":"<code>get_cell(coord, clone=True, keep_repeated=True)</code>","text":"<p>Get the cell at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>A copy is returned, use <code>set_cell</code> to push it back.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n</code></pre> <p>Return: Cell</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_cell(\n    self,\n    coord: tuple | list | str,\n    clone: bool = True,\n    keep_repeated: bool = True,\n) -&gt; Cell:\n    \"\"\"Get the cell at the given coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    A copy is returned, use ``set_cell`` to push it back.\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n    Return: Cell\n    \"\"\"\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    # Outside the defined table\n    if y &gt;= self.height:\n        cell = Cell()\n    else:\n        # Inside the defined table\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError\n        read_cell = row.get_cell(x, clone=clone)\n        if read_cell is None:\n            raise ValueError\n        cell = read_cell\n        if not keep_repeated:\n            repeated = cell.repeated or 1\n            if repeated &gt;= 2:\n                cell.repeated = None\n    cell.x = x\n    cell.y = y\n    return cell\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_cells","title":"<code>get_cells(coord=None, cell_type=None, style=None, content=None, flat=False)</code>","text":"<p>Get the cells matching the criteria. If \u2018coord\u2019 is None, parse the whole table, else parse the area defined by \u2018coord\u2019.</p> <p>Filter by  cell_type = \u201call\u201d  will retrieve cells of any type, aka non empty cells.</p> <p>If flat is True (default is False), the method return a single list of all the values, else a list of lists of cells.</p> <p>if cell_type, style and content are None, get_cells() will return the exact number of cells of the area, including empty cells.</p> <p>Arguments:</p> <pre><code>coordinates -- str or tuple of int : coordinates of area\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncontent -- str regex\n\nstyle -- str\n\nflat -- boolean\n</code></pre> <p>Return: list of list of Cell</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_cells(\n    self,\n    coord: tuple | list | str | None = None,\n    cell_type: str | None = None,\n    style: str | None = None,\n    content: str | None = None,\n    flat: bool = False,\n) -&gt; list:\n    \"\"\"Get the cells matching the criteria. If 'coord' is None,\n    parse the whole table, else parse the area defined by 'coord'.\n\n    Filter by  cell_type = \"all\"  will retrieve cells of any\n    type, aka non empty cells.\n\n    If flat is True (default is False), the method return a single list\n    of all the values, else a list of lists of cells.\n\n    if cell_type, style and content are None, get_cells() will return\n    the exact number of cells of the area, including empty cells.\n\n    Arguments:\n\n        coordinates -- str or tuple of int : coordinates of area\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        content -- str regex\n\n        style -- str\n\n        flat -- boolean\n\n    Return: list of list of Cell\n    \"\"\"\n    if coord:\n        x, y, z, t = self._translate_table_coordinates(coord)\n    else:\n        x = y = z = t = None\n    if flat:\n        cells: list[Cell] = []\n        for row in self.traverse(start=y, end=t):\n            row_cells = row.get_cells(\n                coord=(x, z),\n                cell_type=cell_type,\n                style=style,\n                content=content,\n            )\n            cells.extend(row_cells)\n        return cells\n    else:\n        lcells: list[list[Cell]] = []\n        for row in self.traverse(start=y, end=t):\n            row_cells = row.get_cells(\n                coord=(x, z),\n                cell_type=cell_type,\n                style=style,\n                content=content,\n            )\n            lcells.append(row_cells)\n        return lcells\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_column","title":"<code>get_column(x)</code>","text":"<p>Get the column at the given \u201cx\u201d position.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>A copy is returned, use set_column() to push it back.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> <p>Return: Column</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_column(self, x: int | str) -&gt; Column:\n    \"\"\"Get the column at the given \"x\" position.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    A copy is returned, use set_column() to push it back.\n\n    Arguments:\n\n        x -- int or str\n\n    Return: Column\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    column = self._get_column2(x)\n    if column is None:\n        raise ValueError\n    column.x = x\n    return column\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_column_cells","title":"<code>get_column_cells(x, style=None, content=None, cell_type=None, complete=False)</code>","text":"<p>Get the list of cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells.</p> <p>If complete is True, replace missing values by None.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncontent -- str regex\n\nstyle -- str\n\ncomplete -- boolean\n</code></pre> <p>Return: list of Cell</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_column_cells(  # noqa: C901\n    self,\n    x: int | str,\n    style: str | None = None,\n    content: str | None = None,\n    cell_type: str | None = None,\n    complete: bool = False,\n) -&gt; list[Cell | None]:\n    \"\"\"Get the list of cells at the given position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n\n    If complete is True, replace missing values by None.\n\n    Arguments:\n\n        x -- int or str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        content -- str regex\n\n        style -- str\n\n        complete -- boolean\n\n    Return: list of Cell\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    if cell_type:\n        cell_type = cell_type.lower().strip()\n    cells: list[Cell | None] = []\n    if not style and not content and not cell_type:\n        for row in self.traverse():\n            cells.append(row.get_cell(x, clone=True))\n        return cells\n    for row in self.traverse():\n        cell = row.get_cell(x, clone=True)\n        if cell is None:\n            raise ValueError\n        # Filter the cells by cell_type\n        if cell_type:\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                if complete:\n                    cells.append(None)\n                continue\n        # Filter the cells with the regex\n        if content and not cell.match(content):\n            if complete:\n                cells.append(None)\n            continue\n        # Filter the cells with the style\n        if style and style != cell.style:\n            if complete:\n                cells.append(None)\n            continue\n        cells.append(cell)\n    return cells\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_column_values","title":"<code>get_column_values(x, cell_type=None, complete=True, get_type=False)</code>","text":"<p>Shortcut to get the list of Python values for the cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells. If cell_type and complete is True, replace missing values by None.</p> <p>If get_type is True, returns a tuple (value, ODF type of value)</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of Python types</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_column_values(\n    self,\n    x: int | str,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n) -&gt; list[Any]:\n    \"\"\"Shortcut to get the list of Python values for the cells at the\n    given position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n    If cell_type and complete is True, replace missing values by None.\n\n    If get_type is True, returns a tuple (value, ODF type of value)\n\n    Arguments:\n\n        x -- int or str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of Python types\n    \"\"\"\n    cells = self.get_column_cells(\n        x, style=None, content=None, cell_type=cell_type, complete=complete\n    )\n    values: list[Any] = []\n    for cell in cells:\n        if cell is None:\n            if complete:\n                if get_type:\n                    values.append((None, None))\n                else:\n                    values.append(None)\n            continue\n        if cell_type:\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                if complete:\n                    if get_type:\n                        values.append((None, None))\n                    else:\n                        values.append(None)\n                continue\n        values.append(cell.get_value(get_type=get_type))\n    return values\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_columns","title":"<code>get_columns(coord=None, style=None)</code>","text":"<p>Get the list of columns matching the criteria.</p> <p>Copies are returned, use set_column() to push them back.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of columns\n\nstyle -- str\n</code></pre> <p>Return: list of columns</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_columns(\n    self,\n    coord: tuple | list | str | None = None,\n    style: str | None = None,\n) -&gt; list[Column]:\n    \"\"\"Get the list of columns matching the criteria.\n\n    Copies are returned, use set_column() to push them back.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of columns\n\n        style -- str\n\n    Return: list of columns\n    \"\"\"\n    if coord:\n        x, _y, _z, t = self._translate_column_coordinates(coord)\n    else:\n        x = t = None\n    if not style:\n        return list(self.traverse_columns(start=x, end=t))\n    columns = []\n    for column in self.traverse_columns(start=x, end=t):\n        if style != column.style:\n            continue\n        columns.append(column)\n    return columns\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_named_range","title":"<code>get_named_range(name)</code>","text":"<p>Returns the Name Ranges of the specified name. If table_name is provided, limits the search to these tables. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>name -- str, name of the named range object\n</code></pre> <p>Return : NamedRange</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_named_range(self, name: str) -&gt; NamedRange:\n    \"\"\"Returns the Name Ranges of the specified name. If\n    table_name is provided, limits the search to these tables.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        name -- str, name of the named range object\n\n    Return : NamedRange\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document\")\n    return body.get_named_range(name)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_named_ranges","title":"<code>get_named_ranges(table_name=None)</code>","text":"<p>Returns the list of available Name Ranges of the spreadsheet. If table_name is provided, limits the search to these tables. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>table_names -- str or list of str, names of tables\n</code></pre> <p>Return : list of table_range</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_named_ranges(  # type: ignore\n    self,\n    table_name: str | list[str] | None = None,\n) -&gt; list[NamedRange]:\n    \"\"\"Returns the list of available Name Ranges of the spreadsheet. If\n    table_name is provided, limits the search to these tables.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        table_names -- str or list of str, names of tables\n\n    Return : list of table_range\n    \"\"\"\n    body = self.document_body\n    if not body:\n        return []\n    all_named_ranges = body.get_named_ranges()\n    if not table_name:\n        return all_named_ranges  # type:ignore\n    filter_ = []\n    if isinstance(table_name, str):\n        filter_.append(table_name)\n    elif isiterable(table_name):\n        filter_.extend(table_name)\n    else:\n        raise ValueError(\n            f\"table_name must be string or Iterable, not {type(table_name)}\"\n        )\n    return [\n        nr for nr in all_named_ranges if nr.table_name in filter_  # type:ignore\n    ]\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_row","title":"<code>get_row(y, clone=True, create=True)</code>","text":"<p>Get the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>A copy is returned, use set_cell() to push it back.</p> <p>Arguments:</p> <pre><code>y -- int or str\n</code></pre> <p>Return: Row</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:\n    \"\"\"Get the row at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    A copy is returned, use set_cell() to push it back.\n\n    Arguments:\n\n        y -- int or str\n\n    Return: Row\n    \"\"\"\n    # fixme : keep repeat ? maybe an option to functions : \"raw=False\"\n    y = self._translate_y_from_any(y)\n    row = self._get_row2(y, clone=clone, create=create)\n    if row is None:\n        raise ValueError(\"Row not found\")\n    row.y = y\n    return row\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_row_values","title":"<code>get_row_values(y, cell_type=None, complete=True, get_type=False)</code>","text":"<p>Shortcut to get the list of Python values for the cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells. If cell_type and complete is True, replace missing values by None.</p> <p>If get_type is True, returns a tuple (value, ODF type of value)</p> <p>Arguments:</p> <pre><code>y -- int, str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of lists of Python types</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_row_values(\n    self,\n    y: int | str,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n) -&gt; list:\n    \"\"\"Shortcut to get the list of Python values for the cells of the row\n    at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n    If cell_type and complete is True, replace missing values by None.\n\n    If get_type is True, returns a tuple (value, ODF type of value)\n\n    Arguments:\n\n        y -- int, str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of lists of Python types\n    \"\"\"\n    values = self.get_row(y, clone=False).get_values(\n        cell_type=cell_type, complete=complete, get_type=get_type\n    )\n    # complete row to match column width\n    if complete:\n        if get_type:\n            values.extend([(None, None)] * (self.width - len(values)))\n        else:\n            values.extend([None] * (self.width - len(values)))\n    return values\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_rows","title":"<code>get_rows(coord=None, style=None, content=None)</code>","text":"<p>Get the list of rows matching the criteria.</p> <p>Filter by coordinates will parse the area defined by the coordinates.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of rows\n\ncontent -- str regex\n\nstyle -- str\n</code></pre> <p>Return: list of rows</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_rows(\n    self,\n    coord: tuple | list | str | None = None,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Row]:\n    \"\"\"Get the list of rows matching the criteria.\n\n    Filter by coordinates will parse the area defined by the coordinates.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of rows\n\n        content -- str regex\n\n        style -- str\n\n    Return: list of rows\n    \"\"\"\n    if coord:\n        _x, y, _z, t = self._translate_table_coordinates(coord)\n    else:\n        y = t = None\n    # fixme : not clones ?\n    if not content and not style:\n        return list(self.traverse(start=y, end=t))\n    rows = []\n    for row in self.traverse(start=y, end=t):\n        if content and not row.match(content):\n            continue\n        if style and style != row.style:\n            continue\n        rows.append(row)\n    return rows\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_value","title":"<code>get_value(coord, get_type=False)</code>","text":"<p>Shortcut to get the Python value of the cell at the given coordinates.</p> <p>If get_type is True, returns the tuples (value, ODF type)</p> <p>coord is either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d. If an Area is given, the upper left position is used as coord.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str : coordinate\n</code></pre> <p>Return: Python type</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_value(\n    self,\n    coord: tuple | list | str,\n    get_type: bool = False,\n) -&gt; Any:\n    \"\"\"Shortcut to get the Python value of the cell at the given\n    coordinates.\n\n    If get_type is True, returns the tuples (value, ODF type)\n\n    coord is either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\". If an Area is given, the upper\n    left position is used as coord.\n\n    Arguments:\n\n        coord -- (int, int) or str : coordinate\n\n    Return: Python type\n    \"\"\"\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    # Outside the defined table\n    if y &gt;= self.height:\n        if get_type:\n            return (None, None)\n        return None\n    else:\n        # Inside the defined table\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError\n        cell = row._get_cell2_base(x)\n        if cell is None:\n            if get_type:\n                return (None, None)\n            return None\n        return cell.get_value(get_type=get_type)\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_values","title":"<code>get_values(coord=None, cell_type=None, complete=True, get_type=False, flat=False)</code>","text":"<p>Get a matrix of values of the table.</p> <p>Filter by coordinates will parse the area defined by the coordinates.</p> <p>If \u2018cell_type\u2019 is used and \u2018complete\u2019 is True (default), missing values are replaced by None. Filter by \u2018 cell_type = \u201call\u201d \u2018 will retrieve cells of any type, aka non empty cells.</p> <p>If \u2018cell_type\u2019 is None, complete is always True : with no cell type queried, get_values() returns None for each empty cell, the length each lists is equal to the width of the table.</p> <p>If get_type is True, returns tuples (value, ODF type of value), or (None, None) for empty cells with complete True.</p> <p>If flat is True, the methods return a single list of all the values. By default, flat is False.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of area\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of lists of Python types</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_values(\n    self,\n    coord: tuple | list | str | None = None,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n    flat: bool = False,\n) -&gt; list:\n    \"\"\"Get a matrix of values of the table.\n\n    Filter by coordinates will parse the area defined by the coordinates.\n\n    If 'cell_type' is used and 'complete' is True (default), missing values\n    are replaced by None.\n    Filter by ' cell_type = \"all\" ' will retrieve cells of any\n    type, aka non empty cells.\n\n    If 'cell_type' is None, complete is always True : with no cell type\n    queried, get_values() returns None for each empty cell, the length\n    each lists is equal to the width of the table.\n\n    If get_type is True, returns tuples (value, ODF type of value), or\n    (None, None) for empty cells with complete True.\n\n    If flat is True, the methods return a single list of all the values.\n    By default, flat is False.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of area\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of lists of Python types\n    \"\"\"\n    if coord:\n        x, y, z, t = self._translate_table_coordinates(coord)\n    else:\n        x = y = z = t = None\n    data = []\n    for row in self.traverse(start=y, end=t):\n        if z is None:\n            width = self.width\n        else:\n            width = min(z + 1, self.width)\n        if x is not None:\n            width -= x\n        values = row.get_values(\n            (x, z),\n            cell_type=cell_type,\n            complete=complete,\n            get_type=get_type,\n        )\n        # complete row to match request width\n        if complete:\n            if get_type:\n                values.extend([(None, None)] * (width - len(values)))\n            else:\n                values.extend([None] * (width - len(values)))\n        if flat:\n            data.extend(values)\n        else:\n            data.append(values)\n    return data\n</code></pre>"},{"location":"reference.html#odfdo.Table.insert_cell","title":"<code>insert_cell(coord, cell=None, clone=True)</code>","text":"<p>Insert the given cell at the given coordinates. If no cell is given, an empty one is created.</p> <p>Coordinates are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Cells on the right are shifted. Other rows remain untouched.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n\ncell -- Cell\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/table.py</code> <pre><code>def insert_cell(\n    self,\n    coord: tuple | list | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Insert the given cell at the given coordinates. If no cell is\n    given, an empty one is created.\n\n    Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Cells on the right are shifted. Other rows remain untouched.\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n        cell -- Cell\n\n    returns the cell with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    if clone:\n        cell = cell.clone\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    row = self._get_row2(y, clone=True)\n    row.y = y\n    row.repeated = None\n    cell_back = row.insert_cell(x, cell, clone=False)\n    self.set_row(y, row, clone=False)\n    # Update width if necessary\n    self._update_width(row)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.insert_column","title":"<code>insert_column(x, column=None)</code>","text":"<p>Insert the column before the given \u201cx\u201d position. If no column is given, an empty one is created.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncolumn -- Column\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def insert_column(\n    self,\n    x: int | str,\n    column: Column | None = None,\n) -&gt; Column:\n    \"\"\"Insert the column before the given \"x\" position. If no column is\n    given, an empty one is created.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        x -- int or str\n\n        column -- Column\n    \"\"\"\n    if column is None:\n        column = Column()\n    x = self._translate_x_from_any(x)\n    diff = x - self.width\n    if diff &lt; 0:\n        column_back = insert_item_in_vault(\n            x, column, self, _xpath_column_idx, \"_cmap\"\n        )\n    elif diff == 0:\n        column_back = self.append_column(column.clone)\n    else:\n        self.append_column(Column(repeated=diff), _repeated=diff)\n        column_back = self.append_column(column.clone)\n    column_back.x = x  # type: ignore\n    # Repetitions are accepted\n    repeated = column.repeated or 1\n    # Update width on every row\n    for row in self._get_rows():\n        if row.width &gt; x:\n            row.insert_cell(x, Cell(repeated=repeated))\n        # Shorter rows don't need insert\n        # Longer rows shouldn't exist!\n    return column_back  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Table.insert_row","title":"<code>insert_row(y, row=None, clone=True)</code>","text":"<p>Insert the row before the given \u201cy\u201d position. If no row is given, an empty one is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>If row is None, a new empty row is created.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\nrow -- Row\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def insert_row(\n    self, y: str | int, row: Row | None = None, clone: bool = True\n) -&gt; Row:\n    \"\"\"Insert the row before the given \"y\" position. If no row is given,\n    an empty one is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    If row is None, a new empty row is created.\n\n    Arguments:\n\n        y -- int or str\n\n        row -- Row\n\n    returns the row, with updated row.y\n    \"\"\"\n    if row is None:\n        row = Row()\n        clone = False\n    y = self._translate_y_from_any(y)\n    diff = y - self.height\n    if diff &lt; 0:\n        row_back = insert_item_in_vault(y, row, self, _xpath_row_idx, \"_tmap\")\n    elif diff == 0:\n        row_back = self.append_row(row, clone=clone)\n    else:\n        self.append_row(Row(repeated=diff), _repeated=diff, clone=False)\n        row_back = self.append_row(row, clone=clone)\n    row_back.y = y  # type: ignore\n    # Update width if necessary\n    self._update_width(row_back)  # type: ignore\n    return row_back  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Table.is_column_empty","title":"<code>is_column_empty(x, aggressive=False)</code>","text":"<p>Return wether every cell in the column at \u201cx\u201d position has no value or the value evaluates to False (empty string), and no style.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Return: bool</p> Source code in <code>odfdo/table.py</code> <pre><code>def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return wether every cell in the column at \"x\" position has no value\n    or the value evaluates to False (empty string), and no style.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Return: bool\n    \"\"\"\n    for cell in self.get_column_cells(x):\n        if cell is None:\n            continue\n        if not cell.is_empty(aggressive=aggressive):\n            return False\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Table.is_empty","title":"<code>is_empty(aggressive=False)</code>","text":"<p>Return whether every cell in the table has no value or the value evaluates to False (empty string), and no style.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def is_empty(self, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return whether every cell in the table has no value or the value\n    evaluates to False (empty string), and no style.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        aggressive -- bool\n    \"\"\"\n    return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())\n</code></pre>"},{"location":"reference.html#odfdo.Table.is_row_empty","title":"<code>is_row_empty(y, aggressive=False)</code>","text":"<p>Return wether every cell in the row at the given \u201cy\u201d position has no value or the value evaluates to False (empty string), and no style.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\naggressive -- bool\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return wether every cell in the row at the given \"y\" position has\n    no value or the value evaluates to False (empty string), and no style.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        y -- int or str\n\n        aggressive -- bool\n    \"\"\"\n    return self.get_row(y, clone=False).is_empty(aggressive=aggressive)\n</code></pre>"},{"location":"reference.html#odfdo.Table.iter_values","title":"<code>iter_values(coord=None, cell_type=None, complete=True, get_type=False)</code>","text":"<p>Iterate through lines of Python values of the table.</p> <p>Filter by coordinates will parse the area defined by the coordinates.</p> <p>cell_type, complete, grt_type : see get_values()</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of area\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: iterator of lists</p> Source code in <code>odfdo/table.py</code> <pre><code>def iter_values(\n    self,\n    coord: tuple | list | str | None = None,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n) -&gt; Iterator[list]:\n    \"\"\"Iterate through lines of Python values of the table.\n\n    Filter by coordinates will parse the area defined by the coordinates.\n\n    cell_type, complete, grt_type : see get_values()\n\n\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of area\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: iterator of lists\n    \"\"\"\n    if coord:\n        x, y, z, t = self._translate_table_coordinates(coord)\n    else:\n        x = y = z = t = None\n    for row in self.traverse(start=y, end=t):\n        if z is None:\n            width = self.width\n        else:\n            width = min(z + 1, self.width)\n        if x is not None:\n            width -= x\n        values = row.get_values(\n            (x, z),\n            cell_type=cell_type,\n            complete=complete,\n            get_type=get_type,\n        )\n        # complete row to match column width\n        if complete:\n            if get_type:\n                values.extend([(None, None)] * (width - len(values)))\n            else:\n                values.extend([None] * (width - len(values)))\n        yield values\n</code></pre>"},{"location":"reference.html#odfdo.Table.optimize_width","title":"<code>optimize_width()</code>","text":"<p>Remove in-place empty rows below and empty cells at the right of the table. Keep repeated styles of empty cells but minimize row width.</p> Source code in <code>odfdo/table.py</code> <pre><code>def optimize_width(self) -&gt; None:\n    \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n    the table. Keep repeated styles of empty cells but minimize row width.\n    \"\"\"\n    self._optimize_width_trim_rows()\n    width = self._optimize_width_length()\n    self._optimize_width_rstrip_rows(width)\n    self._optimize_width_adapt_columns(width)\n</code></pre>"},{"location":"reference.html#odfdo.Table.rstrip","title":"<code>rstrip(aggressive=False)</code>","text":"<p>Remove in-place empty rows below and empty cells at the right of the table. Cells are empty if they contain no value or it evaluates to False, and no style.</p> <p>If aggressive is True, empty cells with style are removed too.</p> <p>Argument:</p> <pre><code>aggressive -- bool\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def rstrip(self, aggressive: bool = False) -&gt; None:\n    \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n    the table. Cells are empty if they contain no value or it evaluates\n    to False, and no style.\n\n    If aggressive is True, empty cells with style are removed too.\n\n    Argument:\n\n        aggressive -- bool\n    \"\"\"\n    # Step 1: remove empty rows below the table\n    for row in reversed(self._get_rows()):\n        if row.is_empty(aggressive=aggressive):\n            row.parent.delete(row)  # type: ignore\n        else:\n            break\n    # Step 2: rstrip remaining rows\n    max_width = 0\n    for row in self._get_rows():\n        row.rstrip(aggressive=aggressive)\n        # keep count of the biggest row\n        max_width = max(max_width, row.width)\n    # raz cache of rows\n    self._indexes[\"_tmap\"] = {}\n    # Step 3: trim columns to match max_width\n    columns = self._get_columns()\n    repeated_cols = self.xpath(\"table:table-column/@table:number-columns-repeated\")\n    if not isinstance(repeated_cols, list):\n        raise TypeError\n    unrepeated = len(columns) - len(repeated_cols)\n    column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore\n    diff = column_width - max_width\n    if diff &gt; 0:\n        for column in reversed(columns):\n            repeated = column.repeated or 1\n            repeated = repeated - diff\n            if repeated &gt; 0:\n                column.repeated = repeated\n                break\n            else:\n                column.parent.delete(column)\n                diff = -repeated\n                if diff == 0:\n                    break\n    # raz cache of columns\n    self._indexes[\"_cmap\"] = {}\n    self._compute_table_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_cell","title":"<code>set_cell(coord, cell=None, clone=True)</code>","text":"<p>Replace a cell of the table at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str : coordinate\n\ncell -- Cell\n</code></pre> <p>return the cell, with x and y updated</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_cell(\n    self,\n    coord: tuple | list | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Replace a cell of the table at the given coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Arguments:\n\n        coord -- (int, int) or str : coordinate\n\n        cell -- Cell\n\n    return the cell, with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    cell.x = x\n    cell.y = y\n    if y &gt;= self.height:\n        row = Row()\n        cell_back = row.set_cell(x, cell, clone=clone)\n        self.set_row(y, row, clone=False)\n    else:\n        row_read = self._get_row2_base(y)\n        if row_read is None:\n            raise ValueError\n        row = row_read\n        row.y = y\n        repeated = row.repeated or 1\n        if repeated &gt; 1:\n            row = row.clone\n            row.repeated = None\n            cell_back = row.set_cell(x, cell, clone=clone)\n            self.set_row(y, row, clone=False)\n        else:\n            cell_back = row.set_cell(x, cell, clone=clone)\n            # Update width if necessary, since we don't use set_row\n            self._update_width(row)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_cell_image","title":"<code>set_cell_image(coord, image_frame, doc_type=None)</code>","text":"<p>Do all the magic to display an image in the cell at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>The frame element must contain the expected image position and dimensions.</p> <p>DrawImage insertion depends on the document type, so the type must be provided or the table element must be already attached to a document.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n\nimage_frame -- Frame including an image\n\ndoc_type -- 'spreadsheet' or 'text'\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_cell_image(\n    self,\n    coord: tuple | list | str,\n    image_frame: Frame,\n    doc_type: str | None = None,\n) -&gt; None:\n    \"\"\"Do all the magic to display an image in the cell at the given\n    coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    The frame element must contain the expected image position and\n    dimensions.\n\n    DrawImage insertion depends on the document type, so the type must be\n    provided or the table element must be already attached to a document.\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n        image_frame -- Frame including an image\n\n        doc_type -- 'spreadsheet' or 'text'\n    \"\"\"\n    # Test document type\n    if doc_type is None:\n        body = self.document_body\n        if body is None:\n            raise ValueError(\"document type not found\")\n        doc_type = {\"office:spreadsheet\": \"spreadsheet\", \"office:text\": \"text\"}.get(\n            body.tag\n        )\n        if doc_type is None:\n            raise ValueError(\"document type not supported for images\")\n    # We need the end address of the image\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    cell = self.get_cell((x, y))\n    image_frame = image_frame.clone  # type: ignore\n    # Remove any previous paragraph, frame, etc.\n    for child in cell.children:\n        cell.delete(child)\n    # Now it all depends on the document type\n    if doc_type == \"spreadsheet\":\n        image_frame.anchor_type = \"char\"\n        # The frame needs end coordinates\n        width, height = image_frame.size\n        image_frame.set_attribute(\"table:end-x\", width)\n        image_frame.set_attribute(\"table:end-y\", height)\n        # FIXME what happens when the address changes?\n        address = f\"{self.name}.{digit_to_alpha(x)}{y + 1}\"\n        image_frame.set_attribute(\"table:end-cell-address\", address)\n        # The frame is directly in the cell\n        cell.append(image_frame)\n    elif doc_type == \"text\":\n        # The frame must be in a paragraph\n        cell.set_value(\"\")\n        paragraph = cell.get_element(\"text:p\")\n        if paragraph is None:\n            raise ValueError\n        paragraph.append(image_frame)\n    self.set_cell(coord, cell)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_cells","title":"<code>set_cells(cells, coord=None, clone=True)</code>","text":"<p>Set the cells in the table, from the \u2018coord\u2019 position.</p> <p>\u2018coord\u2019 is the coordinate of the upper left cell to be modified by values. If \u2018coord\u2019 is None, default to the position (0,0) (\u201cA1\u201d). If \u2018coord\u2019 is an area (e.g. \u201cA2:B5\u201d), the upper left position of this area is used as coordinate.</p> <p>The table is not cleared before the operation, to reset the table before setting cells, use table.clear().</p> <p>A list of lists is expected, with as many lists as rows to be set, and as many cell in each sublist as cells to be setted in the row.</p> <p>Arguments:</p> <pre><code>cells -- list of list of cells\n\ncoord -- tuple or str\n\nvalues -- list of lists of python types\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_cells(\n    self,\n    cells: list[list[Cell]] | list[tuple[Cell]],\n    coord: tuple | list | str | None = None,\n    clone: bool = True,\n) -&gt; None:\n    \"\"\"Set the cells in the table, from the 'coord' position.\n\n    'coord' is the coordinate of the upper left cell to be modified by\n    values. If 'coord' is None, default to the position (0,0) (\"A1\").\n    If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n    area is used as coordinate.\n\n    The table is *not* cleared before the operation, to reset the table\n    before setting cells, use table.clear().\n\n    A list of lists is expected, with as many lists as rows to be set, and\n    as many cell in each sublist as cells to be setted in the row.\n\n    Arguments:\n\n        cells -- list of list of cells\n\n        coord -- tuple or str\n\n        values -- list of lists of python types\n    \"\"\"\n    if coord:\n        x, y = self._translate_cell_coordinates(coord)\n    else:\n        x = y = 0\n    if y is None:\n        y = 0\n    if x is None:\n        x = 0\n    y -= 1\n    for row_cells in cells:\n        y += 1\n        if not row_cells:\n            continue\n        row = self.get_row(y, clone=True)\n        repeated = row.repeated or 1\n        if repeated &gt;= 2:\n            row.repeated = None\n        row.set_cells(row_cells, start=x, clone=clone)\n        self.set_row(y, row, clone=False)\n        self._update_width(row)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_column","title":"<code>set_column(x, column=None)</code>","text":"<p>Replace the column at the given \u201cx\u201d position.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncolumn -- Column\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_column(\n    self,\n    x: int | str,\n    column: Column | None = None,\n) -&gt; Column:\n    \"\"\"Replace the column at the given \"x\" position.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        x -- int or str\n\n        column -- Column\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    if column is None:\n        column = Column()\n        repeated = 1\n    else:\n        repeated = column.repeated or 1\n    column.x = x\n    # Outside the defined table ?\n    diff = x - self.width\n    if diff == 0:\n        column_back = self.append_column(column, _repeated=repeated)\n    elif diff &gt; 0:\n        self.append_column(Column(repeated=diff), _repeated=diff)\n        column_back = self.append_column(column, _repeated=repeated)\n    else:\n        # Inside the defined table\n        column_back = set_item_in_vault(  # type: ignore\n            x, column, self, _xpath_column_idx, \"_cmap\"\n        )\n    return column_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_column_cells","title":"<code>set_column_cells(x, cells)</code>","text":"<p>Shortcut to set the list of cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>The list must have the same length than the table height.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncells -- list of Cell\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:\n    \"\"\"Shortcut to set the list of cells at the given position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    The list must have the same length than the table height.\n\n    Arguments:\n\n        x -- int or str\n\n        cells -- list of Cell\n    \"\"\"\n    height = self.height\n    if len(cells) != height:\n        raise ValueError(f\"col mismatch: {height} cells expected\")\n    cells_iterator = iter(cells)\n    for y, row in enumerate(self.traverse()):\n        row.set_cell(x, next(cells_iterator))\n        self.set_row(y, row)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_column_values","title":"<code>set_column_values(x, values, cell_type=None, currency=None, style=None)</code>","text":"<p>Shortcut to set the list of Python values of cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>The list must have the same length than the table height.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\nvalues -- list of Python types\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_column_values(\n    self,\n    x: int | str,\n    values: list,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the list of Python values of cells at the given\n    position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    The list must have the same length than the table height.\n\n    Arguments:\n\n        x -- int or str\n\n        values -- list of Python types\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n    \"\"\"\n    cells = [\n        Cell(value, cell_type=cell_type, currency=currency, style=style)\n        for value in values\n    ]\n    self.set_column_cells(x, cells)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_named_range","title":"<code>set_named_range(name, crange, table_name=None, usage=None)</code>","text":"<p>Create a Named Range element and insert it in the document. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>name -- str, name of the named range\n\ncrange -- str or tuple of int, cell or area coordinate\n\ntable_name -- str, name of the table\n\nuage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_named_range(\n    self,\n    name: str,\n    crange: str | tuple | list,\n    table_name: str | None = None,\n    usage: str | None = None,\n) -&gt; None:\n    \"\"\"Create a Named Range element and insert it in the document.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        name -- str, name of the named range\n\n        crange -- str or tuple of int, cell or area coordinate\n\n        table_name -- str, name of the table\n\n        uage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document\")\n    if not name:\n        raise ValueError(\"Name required.\")\n    if table_name is None:\n        table_name = self.name\n    named_range = NamedRange(name, crange, table_name, usage)\n    body.append_named_range(named_range)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_row","title":"<code>set_row(y, row=None, clone=True)</code>","text":"<p>Replace the row at the given position with the new one. Repetions of the old row will be adjusted.</p> <p>If row is None, a new empty row is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\nrow -- Row\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:\n    \"\"\"Replace the row at the given position with the new one. Repetions of\n    the old row will be adjusted.\n\n    If row is None, a new empty row is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n\n        row -- Row\n\n    returns the row, with updated row.y\n    \"\"\"\n    if row is None:\n        row = Row()\n        repeated = 1\n        clone = False\n    else:\n        repeated = row.repeated or 1\n    y = self._translate_y_from_any(y)\n    row.y = y\n    # Outside the defined table ?\n    diff = y - self.height\n    if diff == 0:\n        row_back = self.append_row(row, _repeated=repeated, clone=clone)\n    elif diff &gt; 0:\n        self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)\n        row_back = self.append_row(row, _repeated=repeated, clone=clone)\n    else:\n        # Inside the defined table\n        row_back = set_item_in_vault(  # type: ignore\n            y, row, self, _xpath_row_idx, \"_tmap\", clone=clone\n        )\n    # print self.serialize(True)\n    # Update width if necessary\n    self._update_width(row_back)\n    return row_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_row_cells","title":"<code>set_row_cells(y, cells=None)</code>","text":"<p>Shortcut to set all the cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\ncells -- list of Python types\n\nstyle -- str\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:\n    \"\"\"Shortcut to set *all* the cells of the row at the given\n    \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n\n        cells -- list of Python types\n\n        style -- str\n\n    returns the row, with updated row.y\n    \"\"\"\n    if cells is None:\n        cells = []\n    row = Row()  # needed if clones rows\n    row.extend_cells(cells)\n    return self.set_row(y, row)  # needed if clones rows\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_row_values","title":"<code>set_row_values(y, values, cell_type=None, currency=None, style=None)</code>","text":"<p>Shortcut to set the values of all cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\nvalues -- list of Python types\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_row_values(\n    self,\n    y: int | str,\n    values: list,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; Row:\n    \"\"\"Shortcut to set the values of *all* cells of the row at the given\n    \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n\n        values -- list of Python types\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n\n    returns the row, with updated row.y\n    \"\"\"\n    row = Row()  # needed if clones rows\n    row.set_values(values, style=style, cell_type=cell_type, currency=currency)\n    return self.set_row(y, row)  # needed if clones rows\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_span","title":"<code>set_span(area, merge=False)</code>","text":"<p>Create a Cell Span : span the first cell of the area on several columns and/or rows. If merge is True, replace text of the cell by the concatenation of existing text in covered cells. Beware : if merge is True, old text is changed, if merge is False (the default), old text in coverd cells is still present but not displayed by most GUI.</p> <p>If the area defines only one cell, the set span will do nothing. It is not allowed to apply set span to an area whose one cell already belongs to previous cell span.</p> <p>Area can be either one cell (like \u2018A1\u2019) or an area (\u2018A1:B2\u2019). It can be provided as an alpha numeric value like \u201cA1:B2\u2019 or a tuple like (0, 0, 1, 1) or (0, 0).</p> <p>Arguments:</p> <pre><code>area -- str or tuple of int, cell or area coordinate\n\nmerge -- boolean\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_span(  # noqa: C901\n    self,\n    area: str | tuple | list,\n    merge: bool = False,\n) -&gt; bool:\n    \"\"\"Create a Cell Span : span the first cell of the area on several\n    columns and/or rows.\n    If merge is True, replace text of the cell by the concatenation of\n    existing text in covered cells.\n    Beware : if merge is True, old text is changed, if merge is False\n    (the default), old text in coverd cells is still present but not\n    displayed by most GUI.\n\n    If the area defines only one cell, the set span will do nothing.\n    It is not allowed to apply set span to an area whose one cell already\n    belongs to previous cell span.\n\n    Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n    be provided as an alpha numeric value like \"A1:B2' or a tuple like\n    (0, 0, 1, 1) or (0, 0).\n\n    Arguments:\n\n        area -- str or tuple of int, cell or area coordinate\n\n        merge -- boolean\n    \"\"\"\n    # get area\n    digits = convert_coordinates(area)\n    if len(digits) == 4:\n        x, y, z, t = digits\n    else:\n        x, y = digits\n        z, t = digits\n    start = x, y\n    end = z, t\n    if start == end:\n        # one cell : do nothing\n        return False\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    if z is None:\n        raise ValueError\n    if t is None:\n        raise ValueError\n    # check for previous span\n    good = True\n    # Check boundaries and empty cells : need to crate non existent cells\n    # so don't use get_cells directly, but get_cell\n    cells = []\n    for yy in range(y, t + 1):\n        row_cells = []\n        for xx in range(x, z + 1):\n            row_cells.append(\n                self.get_cell((xx, yy), clone=True, keep_repeated=False)\n            )\n        cells.append(row_cells)\n    for row in cells:\n        for cell in row:\n            if cell.is_spanned():\n                good = False\n                break\n        if not good:\n            break\n    if not good:\n        return False\n    # Check boundaries\n    # if z &gt;= self.width or t &gt;= self.height:\n    #    self.set_cell(coord = end)\n    #    print area, z, t\n    #    cells = self.get_cells((x, y, z, t))\n    #    print cells\n    # do it:\n    if merge:\n        val_list = []\n        for row in cells:\n            for cell in row:\n                if cell.is_empty(aggressive=True):\n                    continue\n                val = cell.get_value()\n                if val is not None:\n                    if isinstance(val, str):\n                        val.strip()\n                    if val != \"\":\n                        val_list.append(val)\n                    cell.clear()\n        if val_list:\n            if len(val_list) == 1:\n                cells[0][0].set_value(val_list[0])\n            else:\n                value = \" \".join([str(v) for v in val_list if v])\n                cells[0][0].set_value(value)\n    cols = z - x + 1\n    cells[0][0].set_attribute(\"table:number-columns-spanned\", str(cols))\n    rows = t - y + 1\n    cells[0][0].set_attribute(\"table:number-rows-spanned\", str(rows))\n    for cell in cells[0][1:]:\n        cell.tag = \"table:covered-table-cell\"\n    for row in cells[1:]:\n        for cell in row:\n            cell.tag = \"table:covered-table-cell\"\n    # replace cells in table\n    self.set_cells(cells, coord=start, clone=False)\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_value","title":"<code>set_value(coord, value, cell_type=None, currency=None, style=None)</code>","text":"<p>Set the Python value of the cell at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n\nvalue -- Python type\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n         'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_value(\n    self,\n    coord: tuple | list | str,\n    value: Any,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; None:\n    \"\"\"Set the Python value of the cell at the given coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n        value -- Python type\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                 'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n\n    \"\"\"\n    self.set_cell(\n        coord,\n        Cell(value, cell_type=cell_type, currency=currency, style=style),\n        clone=False,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_values","title":"<code>set_values(values, coord=None, style=None, cell_type=None, currency=None)</code>","text":"<p>Set the value of cells in the table, from the \u2018coord\u2019 position with values.</p> <p>\u2018coord\u2019 is the coordinate of the upper left cell to be modified by values. If \u2018coord\u2019 is None, default to the position (0,0) (\u201cA1\u201d). If \u2018coord\u2019 is an area (e.g. \u201cA2:B5\u201d), the upper left position of this area is used as coordinate.</p> <p>The table is not cleared before the operation, to reset the table before setting values, use table.clear().</p> <p>A list of lists is expected, with as many lists as rows, and as many items in each sublist as cells to be setted. None values in the list will create empty cells with no cell type (but eventually a style).</p> <p>Arguments:</p> <pre><code>coord -- tuple or str\n\nvalues -- list of lists of python types\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_values(\n    self,\n    values: list,\n    coord: tuple | list | str | None = None,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Set the value of cells in the table, from the 'coord' position\n    with values.\n\n    'coord' is the coordinate of the upper left cell to be modified by\n    values. If 'coord' is None, default to the position (0,0) (\"A1\").\n    If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n    area is used as coordinate.\n\n    The table is *not* cleared before the operation, to reset the table\n    before setting values, use table.clear().\n\n    A list of lists is expected, with as many lists as rows, and as many\n    items in each sublist as cells to be setted. None values in the list\n    will create empty cells with no cell type (but eventually a style).\n\n    Arguments:\n\n        coord -- tuple or str\n\n        values -- list of lists of python types\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n    \"\"\"\n    if coord:\n        x, y = self._translate_cell_coordinates(coord)\n    else:\n        x = y = 0\n    if y is None:\n        y = 0\n    if x is None:\n        x = 0\n    y -= 1\n    for row_values in values:\n        y += 1\n        if not row_values:\n            continue\n        row = self.get_row(y, clone=True)\n        repeated = row.repeated or 1\n        if repeated &gt;= 2:\n            row.repeated = None\n        row.set_values(\n            row_values,\n            start=x,\n            cell_type=cell_type,\n            currency=currency,\n            style=style,\n        )\n        self.set_row(y, row, clone=False)\n        self._update_width(row)\n</code></pre>"},{"location":"reference.html#odfdo.Table.to_csv","title":"<code>to_csv(path_or_file=None, dialect='excel')</code>","text":"<p>Write the table as CSV in the file.</p> <p>If the file is a string, it is opened as a local path. Else an opened file-like is expected.</p> <p>Arguments:</p> <pre><code>path_or_file -- str or file-like\n\ndialect -- str, python csv.dialect, can be 'excel', 'unix'...\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def to_csv(\n    self,\n    path_or_file: str | Path | None = None,\n    dialect: str = \"excel\",\n) -&gt; Any:\n    \"\"\"Write the table as CSV in the file.\n\n    If the file is a string, it is opened as a local path. Else an\n    opened file-like is expected.\n\n    Arguments:\n\n        path_or_file -- str or file-like\n\n        dialect -- str, python csv.dialect, can be 'excel', 'unix'...\n    \"\"\"\n\n    def write_content(csv_writer: object) -&gt; None:\n        for values in self.iter_values():\n            line = []\n            for value in values:\n                if value is None:\n                    value = \"\"\n                if isinstance(value, str):\n                    value = value.strip()\n                line.append(value)\n            csv_writer.writerow(line)  # type: ignore\n\n    out = StringIO(newline=\"\")\n    csv_writer = csv.writer(out, dialect=dialect)\n    write_content(csv_writer)\n    if path_or_file is None:\n        return out.getvalue()\n    path = Path(path_or_file)\n    path.write_text(out.getvalue())\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Table.transpose","title":"<code>transpose(coord=None)</code>","text":"<p>Swap in-place rows and columns of the table.</p> <p>If \u2018coord\u2019 is not None, apply transpose only to the area defined by the coordinates. Beware, if area is not square, some cells mays be over written during the process.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of area\n\nstart -- int or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def transpose(self, coord: tuple | list | str | None = None) -&gt; None:  # noqa: C901\n    \"\"\"Swap *in-place* rows and columns of the table.\n\n    If 'coord' is not None, apply transpose only to the area defined by the\n    coordinates. Beware, if area is not square, some cells mays be over\n    written during the process.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of area\n\n        start -- int or str\n    \"\"\"\n    data = []\n    if coord is None:\n        for row in self.traverse():\n            data.append(list(row.traverse()))\n        transposed_data = zip_longest(*data)\n        self.clear()\n        # new_rows = []\n        for row_cells in transposed_data:\n            if not isiterable(row_cells):\n                row_cells = (row_cells,)\n            row = Row()\n            row.extend_cells(row_cells)\n            self.append_row(row, clone=False)\n        self._compute_table_cache()\n    else:\n        x, y, z, t = self._translate_table_coordinates(coord)\n        if x is None:\n            x = 0\n        else:\n            x = min(x, self.width - 1)\n        if z is None:\n            z = self.width - 1\n        else:\n            z = min(z, self.width - 1)\n        if y is None:\n            y = 0\n        else:\n            y = min(y, self.height - 1)\n        if t is None:\n            t = self.height - 1\n        else:\n            t = min(t, self.height - 1)\n        for row in self.traverse(start=y, end=t):\n            data.append(list(row.traverse(start=x, end=z)))\n        transposed_data = zip_longest(*data)\n        # clear locally\n        w = z - x + 1\n        h = t - y + 1\n        if w != h:\n            nones = [[None] * w for i in range(h)]\n            self.set_values(nones, coord=(x, y, z, t))\n        # put transposed\n        filtered_data: list[tuple[Cell]] = []\n        for row_cells in transposed_data:\n            if isinstance(row_cells, (list, tuple)):\n                filtered_data.append(row_cells)\n            else:\n                filtered_data.append((row_cells,))\n        self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))\n        self._compute_table_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Table.traverse","title":"<code>traverse(start=None, end=None)</code>","text":"<p>Yield as many row elements as expected rows in the table, i.e. expand repetitions by returning the same row as many times as necessary.</p> <pre><code>Arguments:\n\n    start -- int\n\n    end -- int\n</code></pre> <p>Copies are returned, use set_row() to push them back.</p> Source code in <code>odfdo/table.py</code> <pre><code>def traverse(  # noqa: C901\n    self,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; Iterator[Row]:\n    \"\"\"Yield as many row elements as expected rows in the table, i.e.\n    expand repetitions by returning the same row as many times as\n    necessary.\n\n        Arguments:\n\n            start -- int\n\n            end -- int\n\n    Copies are returned, use set_row() to push them back.\n    \"\"\"\n    idx = -1\n    before = -1\n    y = 0\n    if start is None and end is None:\n        for juska in self._tmap:\n            idx += 1\n            if idx in self._indexes[\"_tmap\"]:\n                row = self._indexes[\"_tmap\"][idx]\n            else:\n                row = self._get_element_idx2(_xpath_row_idx, idx)\n                self._indexes[\"_tmap\"][idx] = row\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                # Return a copy without the now obsolete repetition\n                row = row.clone\n                row.y = y\n                y += 1\n                if repeated &gt; 1:\n                    row.repeated = None\n                yield row\n    else:\n        if start is None:\n            start = 0\n        start = max(0, start)\n        if end is None:\n            try:\n                end = self._tmap[-1]\n            except Exception:\n                end = -1\n        start_map = find_odf_idx(self._tmap, start)\n        if start_map is None:\n            return\n        if start_map &gt; 0:\n            before = self._tmap[start_map - 1]\n        idx = start_map - 1\n        before = start - 1\n        y = start\n        for juska in self._tmap[start_map:]:\n            idx += 1\n            if idx in self._indexes[\"_tmap\"]:\n                row = self._indexes[\"_tmap\"][idx]\n            else:\n                row = self._get_element_idx2(_xpath_row_idx, idx)\n                self._indexes[\"_tmap\"][idx] = row\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                if y &lt;= end:\n                    row = row.clone\n                    row.y = y\n                    y += 1\n                    if repeated &gt; 1 or (y == start and start &gt; 0):\n                        row.repeated = None\n                    yield row\n</code></pre>"},{"location":"reference.html#odfdo.Table.traverse_columns","title":"<code>traverse_columns(start=None, end=None)</code>","text":"<p>Yield as many column elements as expected columns in the table, i.e. expand repetitions by returning the same column as many times as necessary.</p> <pre><code>Arguments:\n\n    start -- int\n\n    end -- int\n</code></pre> <p>Copies are returned, use set_column() to push them back.</p> Source code in <code>odfdo/table.py</code> <pre><code>def traverse_columns(  # noqa: C901\n    self,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; Iterator[Column]:\n    \"\"\"Yield as many column elements as expected columns in the table,\n    i.e. expand repetitions by returning the same column as many times as\n    necessary.\n\n        Arguments:\n\n            start -- int\n\n            end -- int\n\n    Copies are returned, use set_column() to push them back.\n    \"\"\"\n    idx = -1\n    before = -1\n    x = 0\n    if start is None and end is None:\n        for juska in self._cmap:\n            idx += 1\n            if idx in self._indexes[\"_cmap\"]:\n                column = self._indexes[\"_cmap\"][idx]\n            else:\n                column = self._get_element_idx2(_xpath_column_idx, idx)\n                self._indexes[\"_cmap\"][idx] = column\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                # Return a copy without the now obsolete repetition\n                column = column.clone\n                column.x = x\n                x += 1\n                if repeated &gt; 1:\n                    column.repeated = None\n                yield column\n    else:\n        if start is None:\n            start = 0\n        start = max(0, start)\n        if end is None:\n            try:\n                end = self._cmap[-1]\n            except Exception:\n                end = -1\n        start_map = find_odf_idx(self._cmap, start)\n        if start_map is None:\n            return\n        if start_map &gt; 0:\n            before = self._cmap[start_map - 1]\n        idx = start_map - 1\n        before = start - 1\n        x = start\n        for juska in self._cmap[start_map:]:\n            idx += 1\n            if idx in self._indexes[\"_cmap\"]:\n                column = self._indexes[\"_cmap\"][idx]\n            else:\n                column = self._get_element_idx2(_xpath_column_idx, idx)\n                self._indexes[\"_cmap\"][idx] = column\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                if x &lt;= end:\n                    column = column.clone\n                    column.x = x\n                    x += 1\n                    if repeated &gt; 1 or (x == start and start &gt; 0):\n                        column.repeated = None\n                    yield column\n</code></pre>"},{"location":"reference.html#odfdo.Text","title":"<code>Text</code>","text":"<p>             Bases: <code>Body</code></p> <p>Text, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Text(Body):\n    \"\"\"Text, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:text\"\n    _caching: bool = False\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.TextChange","title":"<code>TextChange</code>","text":"<p>             Bases: <code>Element</code></p> <p>The TextChange \u201ctext:change\u201d element marks a position in an empty region where text has been deleted.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChange(Element):\n    \"\"\"The TextChange \"text:change\" element marks a position in an empty\n    region where text has been deleted.\n    \"\"\"\n\n    _tag = \"text:change\"\n\n    def get_id(self) -&gt; str | None:\n        return self.get_attribute_string(\"text:change-id\")\n\n    def set_id(self, idx: str) -&gt; None:\n        self.set_attribute(\"text:change-id\", idx)\n\n    def _get_tracked_changes(self) -&gt; Element | None:\n        body = self.document_body\n        if not body:\n            raise ValueError\n        return body.get_tracked_changes()\n\n    def get_changed_region(\n        self,\n        tracked_changes: Element | None = None,\n    ) -&gt; Element | None:\n        if not tracked_changes:\n            tracked_changes = self._get_tracked_changes()\n        idx = self.get_id()\n        return tracked_changes.get_changed_region(text_id=idx)  # type: ignore\n\n    def get_change_info(\n        self,\n        tracked_changes: Element | None = None,\n    ) -&gt; Element | None:\n        changed_region = self.get_changed_region(tracked_changes=tracked_changes)\n        if not changed_region:\n            return None\n        return changed_region.get_change_info()  # type: ignore\n\n    def get_change_element(\n        self,\n        tracked_changes: Element | None = None,\n    ) -&gt; Element | None:\n        changed_region = self.get_changed_region(tracked_changes=tracked_changes)\n        if not changed_region:\n            return None\n        return changed_region.get_change_element()  # type: ignore\n\n    def get_deleted(\n        self,\n        tracked_changes: Element | None = None,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; Element | None:\n        \"\"\"Shortcut to get the deleted informations stored in the\n        TextDeletion stored in the tracked changes.\n\n        Return: Paragraph (or None).\"\n        \"\"\"\n        changed = self.get_change_element(tracked_changes=tracked_changes)\n        if not changed:\n            return None\n        return changed.get_deleted(  # type: ignore\n            as_text=as_text,\n            no_header=no_header,\n            clean=clean,\n        )\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Return None.\"\"\"\n        return None\n\n    def get_start(self) -&gt; TextChangeStart | None:\n        \"\"\"Return None.\"\"\"\n        return None\n\n    def get_end(self) -&gt; TextChangeEnd | None:\n        \"\"\"Return None.\"\"\"\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_deleted","title":"<code>get_deleted(tracked_changes=None, as_text=False, no_header=False, clean=True)</code>","text":"<p>Shortcut to get the deleted informations stored in the TextDeletion stored in the tracked changes.</p> <p>Return: Paragraph (or None).\u201d</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(\n    self,\n    tracked_changes: Element | None = None,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; Element | None:\n    \"\"\"Shortcut to get the deleted informations stored in the\n    TextDeletion stored in the tracked changes.\n\n    Return: Paragraph (or None).\"\n    \"\"\"\n    changed = self.get_change_element(tracked_changes=tracked_changes)\n    if not changed:\n        return None\n    return changed.get_deleted(  # type: ignore\n        as_text=as_text,\n        no_header=no_header,\n        clean=clean,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_end","title":"<code>get_end()</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_end(self) -&gt; TextChangeEnd | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_start","title":"<code>get_start()</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_start(self) -&gt; TextChangeStart | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd","title":"<code>TextChangeEnd</code>","text":"<p>             Bases: <code>TextChange</code></p> <p>The TextChangeEnd \u201ctext:change-end\u201d element marks the end of a region with content where text has been inserted or the format has been changed.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChangeEnd(TextChange):\n    \"\"\"The TextChangeEnd \"text:change-end\" element marks the end of a region\n    with content where text has been inserted or the format has been\n    changed.\n    \"\"\"\n\n    _tag = \"text:change-end\"\n\n    def get_start(self) -&gt; TextChangeStart | None:\n        \"\"\"Return the corresponding annotation starting tag or None.\"\"\"\n        idx = self.get_id()\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can not find end tag: no parent available.\")\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_text_change_start(idx=idx)  # type: ignore\n\n    def get_end(self) -&gt; TextChangeEnd | None:\n        \"\"\"Return self.\"\"\"\n        return self\n\n    def get_deleted(self, *args: Any, **kwargs: Any) -&gt; Element | None:\n        \"\"\"Return None.\"\"\"\n        return None\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Return the content between text:change-start and text:change-end.\n\n        If no content exists (deletion tag), returns None (or '' if text flag\n        is True).\n        If as_text is True: returns the text content.\n        If clean is True: suppress unwanted tags (deletions marks, ...)\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of Element, cleaned and with headers\n\n        Arguments:\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list or Element or text\n        \"\"\"\n\n        # idx = self.get_id()\n        start = self.get_start()\n        end = self.get_end()\n        if end is None or start is None:\n            if as_text:\n                return \"\"\n            return None\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_between(\n            start, end, as_text=as_text, no_header=no_header, clean=clean\n        )\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_deleted","title":"<code>get_deleted(*args, **kwargs)</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(self, *args: Any, **kwargs: Any) -&gt; Element | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_end","title":"<code>get_end()</code>","text":"<p>Return self.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_end(self) -&gt; TextChangeEnd | None:\n    \"\"\"Return self.\"\"\"\n    return self\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Return the content between text:change-start and text:change-end.</p> <p>If no content exists (deletion tag), returns None (or \u2018\u2019 if text flag is True). If as_text is True: returns the text content. If clean is True: suppress unwanted tags (deletions marks, \u2026) If no_header is True: existing text:h are changed in text:p By default: returns a list of Element, cleaned and with headers</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list or Element or text</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Return the content between text:change-start and text:change-end.\n\n    If no content exists (deletion tag), returns None (or '' if text flag\n    is True).\n    If as_text is True: returns the text content.\n    If clean is True: suppress unwanted tags (deletions marks, ...)\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of Element, cleaned and with headers\n\n    Arguments:\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list or Element or text\n    \"\"\"\n\n    # idx = self.get_id()\n    start = self.get_start()\n    end = self.get_end()\n    if end is None or start is None:\n        if as_text:\n            return \"\"\n        return None\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_between(\n        start, end, as_text=as_text, no_header=no_header, clean=clean\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_start","title":"<code>get_start()</code>","text":"<p>Return the corresponding annotation starting tag or None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_start(self) -&gt; TextChangeStart | None:\n    \"\"\"Return the corresponding annotation starting tag or None.\"\"\"\n    idx = self.get_id()\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Can not find end tag: no parent available.\")\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_text_change_start(idx=idx)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart","title":"<code>TextChangeStart</code>","text":"<p>             Bases: <code>TextChangeEnd</code></p> <p>The TextChangeStart \u201ctext:change-start\u201d element marks the start of a region with content where text has been inserted or the format has been changed.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChangeStart(TextChangeEnd):\n    \"\"\"The TextChangeStart \"text:change-start\" element marks the start of a\n    region with content where text has been inserted or the format has\n    been changed.\n    \"\"\"\n\n    _tag = \"text:change-start\"\n\n    def get_start(self) -&gt; TextChangeStart:\n        \"\"\"Return self.\"\"\"\n        return self\n\n    def get_end(self) -&gt; TextChangeEnd:\n        \"\"\"Return the corresponding change-end tag or None.\"\"\"\n        idx = self.get_id()\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can not find end tag: no parent available.\")\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_text_change_end(idx=idx)  # type: ignore\n\n    def delete(\n        self,\n        child: Element | None = None,\n        keep_tail: bool = True,\n    ) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        For TextChangeStart : delete also the end tag if exists.\n\n        Arguments:\n\n            child -- Element\n\n            keep_tail -- boolean (default to True), True for most usages.\n        \"\"\"\n        if child is not None:  # act like normal delete\n            return super().delete(child, keep_tail)\n        idx = self.get_id()\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"cannot delete the root element\")\n        body = self.document_body\n        if not body:\n            body = parent\n        end = body.get_text_change_end(idx=idx)\n        if end:\n            end.delete()\n        # act like normal delete\n        super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>For TextChangeStart : delete also the end tag if exists.</p> <p>Arguments:</p> <pre><code>child -- Element\n\nkeep_tail -- boolean (default to True), True for most usages.\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def delete(\n    self,\n    child: Element | None = None,\n    keep_tail: bool = True,\n) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    For TextChangeStart : delete also the end tag if exists.\n\n    Arguments:\n\n        child -- Element\n\n        keep_tail -- boolean (default to True), True for most usages.\n    \"\"\"\n    if child is not None:  # act like normal delete\n        return super().delete(child, keep_tail)\n    idx = self.get_id()\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"cannot delete the root element\")\n    body = self.document_body\n    if not body:\n        body = parent\n    end = body.get_text_change_end(idx=idx)\n    if end:\n        end.delete()\n    # act like normal delete\n    super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart.get_end","title":"<code>get_end()</code>","text":"<p>Return the corresponding change-end tag or None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_end(self) -&gt; TextChangeEnd:\n    \"\"\"Return the corresponding change-end tag or None.\"\"\"\n    idx = self.get_id()\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Can not find end tag: no parent available.\")\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_text_change_end(idx=idx)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart.get_start","title":"<code>get_start()</code>","text":"<p>Return self.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_start(self) -&gt; TextChangeStart:\n    \"\"\"Return self.\"\"\"\n    return self\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion","title":"<code>TextChangedRegion</code>","text":"<p>             Bases: <code>Element</code></p> <p>Each TextChangedRegion \u201ctext:changed-region\u201d element contains a single element, one of TextInsertion, TextDeletion or TextFormatChange that corresponds to a change being tracked within the scope of the \u201ctext:tracked-changes\u201d element that contains the \u201ctext:changed-region\u201d instance. The xml:id attribute of the TextChangedRegion is referenced from the \u201ctext:change\u201d, \u201ctext:change-start\u201d and \u201ctext:change-end\u201d elements that identify where the change applies to markup in the scope of the \u201ctext:tracked-changes\u201d element.</p> for this implementation, text:change should be referenced only <p>once in the scope, which is different from ODF 1.2 requirement:</p> <pre><code>     \" A \"text:changed-region\" can be referenced by more than one\n     change, but the corresponding referencing change mark elements\n     shall be of the same change type - insertion, format change or\n     deletion. \"\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChangedRegion(Element):\n    \"\"\"Each TextChangedRegion \"text:changed-region\" element contains a single\n    element, one of TextInsertion, TextDeletion or TextFormatChange that\n    corresponds to a change being tracked within the scope of the\n    \"text:tracked-changes\" element that contains the \"text:changed-region\"\n    instance.\n    The xml:id attribute of the TextChangedRegion is referenced\n    from the \"text:change\", \"text:change-start\" and \"text:change-end\"\n    elements that identify where the change applies to markup in the scope of\n    the \"text:tracked-changes\" element.\n\n    Warning : for this implementation, text:change should be referenced only\n              once in the scope, which is different from ODF 1.2 requirement:\n             \" A \"text:changed-region\" can be referenced by more than one\n             change, but the corresponding referencing change mark elements\n             shall be of the same change type - insertion, format change or\n             deletion. \"\n    \"\"\"\n\n    _tag = \"text:changed-region\"\n\n    def get_change_info(self) -&gt; Element | None:\n        \"\"\"Shortcut to get the ChangeInfo element of the change\n        element child.\n\n        Return: ChangeInfo element.\n        \"\"\"\n        return self.get_element(\"descendant::office:change-info\")\n\n    def set_change_info(\n        self,\n        change_info: Element | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        comments: Element | list[Element] | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the ChangeInfo element of the sub change element.\n        See TextInsertion.set_change_info() for details.\n\n        Arguments:\n\n             change_info -- ChangeInfo element (or None)\n\n             cretor -- str (or None)\n\n             date -- datetime (or None)\n\n             comments -- Paragraph or list of Paragraph elements (or None)\n        \"\"\"\n        child = self.get_change_element()\n        if not child:\n            raise ValueError\n        child.set_change_info(  # type: ignore\n            change_info=change_info, creator=creator, date=date, comments=comments\n        )\n\n    def get_change_element(self) -&gt; Element | None:\n        \"\"\"Get the change element child. It can be either: TextInsertion,\n        TextDeletion, or TextFormatChange as an Element object.\n\n        Return: Element.\n        \"\"\"\n        request = (\n            \"descendant::text:insertion \"\n            \"| descendant::text:deletion\"\n            \"| descendant::text:format-change\"\n        )\n        return self._filtered_element(request, 0)\n\n    def _get_text_id(self) -&gt; str | None:\n        return self.get_attribute_string(\"text:id\")\n\n    def _set_text_id(self, text_id: str) -&gt; None:\n        self.set_attribute(\"text:id\", text_id)\n\n    def _get_xml_id(self) -&gt; str | None:\n        return self.get_attribute_string(\"xml:id\")\n\n    def _set_xml_id(self, xml_id: str) -&gt; None:\n        self.set_attribute(\"xml:id\", xml_id)\n\n    def get_id(self) -&gt; str | None:\n        \"\"\"Get the \"text:id\" attribute.\n\n        Return: str\n        \"\"\"\n        return self._get_text_id()\n\n    def set_id(self, idx: str) -&gt; None:\n        \"\"\"Set both the \"text:id\" and \"xml:id\" attributes with same value.\"\"\"\n        self._set_text_id(idx)\n        self._set_xml_id(idx)\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.get_change_element","title":"<code>get_change_element()</code>","text":"<p>Get the change element child. It can be either: TextInsertion, TextDeletion, or TextFormatChange as an Element object.</p> <p>Return: Element.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_change_element(self) -&gt; Element | None:\n    \"\"\"Get the change element child. It can be either: TextInsertion,\n    TextDeletion, or TextFormatChange as an Element object.\n\n    Return: Element.\n    \"\"\"\n    request = (\n        \"descendant::text:insertion \"\n        \"| descendant::text:deletion\"\n        \"| descendant::text:format-change\"\n    )\n    return self._filtered_element(request, 0)\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.get_change_info","title":"<code>get_change_info()</code>","text":"<p>Shortcut to get the ChangeInfo element of the change element child.</p> <p>Return: ChangeInfo element.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_change_info(self) -&gt; Element | None:\n    \"\"\"Shortcut to get the ChangeInfo element of the change\n    element child.\n\n    Return: ChangeInfo element.\n    \"\"\"\n    return self.get_element(\"descendant::office:change-info\")\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.get_id","title":"<code>get_id()</code>","text":"<p>Get the \u201ctext:id\u201d attribute.</p> <p>Return: str</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_id(self) -&gt; str | None:\n    \"\"\"Get the \"text:id\" attribute.\n\n    Return: str\n    \"\"\"\n    return self._get_text_id()\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.set_change_info","title":"<code>set_change_info(change_info=None, creator=None, date=None, comments=None)</code>","text":"<p>Shortcut to set the ChangeInfo element of the sub change element. See TextInsertion.set_change_info() for details.</p> <p>Arguments:</p> <pre><code> change_info -- ChangeInfo element (or None)\n\n cretor -- str (or None)\n\n date -- datetime (or None)\n\n comments -- Paragraph or list of Paragraph elements (or None)\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_change_info(\n    self,\n    change_info: Element | None = None,\n    creator: str | None = None,\n    date: datetime | None = None,\n    comments: Element | list[Element] | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the ChangeInfo element of the sub change element.\n    See TextInsertion.set_change_info() for details.\n\n    Arguments:\n\n         change_info -- ChangeInfo element (or None)\n\n         cretor -- str (or None)\n\n         date -- datetime (or None)\n\n         comments -- Paragraph or list of Paragraph elements (or None)\n    \"\"\"\n    child = self.get_change_element()\n    if not child:\n        raise ValueError\n    child.set_change_info(  # type: ignore\n        change_info=change_info, creator=creator, date=date, comments=comments\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.set_id","title":"<code>set_id(idx)</code>","text":"<p>Set both the \u201ctext:id\u201d and \u201cxml:id\u201d attributes with same value.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_id(self, idx: str) -&gt; None:\n    \"\"\"Set both the \"text:id\" and \"xml:id\" attributes with same value.\"\"\"\n    self._set_text_id(idx)\n    self._set_xml_id(idx)\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion","title":"<code>TextDeletion</code>","text":"<p>             Bases: <code>TextInsertion</code></p> <p>The TextDeletion \u201ctext:deletion\u201d contains information that identifies the person responsible for a deletion and the date of that deletion. This information may also contain one or more Paragraph which contains a comment on the deletion. The TextDeletion element may also contain content that was deleted while change tracking was enabled. The position where the text was deleted is marked by a \u201ctext:change\u201d element. Deleted text is contained in a paragraph element. To reconstruct the original text, the paragraph containing the deleted text is merged with its surrounding paragraph or heading element. To reconstruct the text before a deletion took place:   - If the change mark is inside a paragraph, insert the content that was   deleted, but remove all leading start tags up to and including the   first \u201ctext:p\u201d element and all trailing end tags up to and including   the last \u201c/text:p\u201d or \u201c/text:h\u201d element. If the last trailing element   is a \u201c/text:h\u201d, change the end tag \u201c/text:p\u201d following this insertion   to a \u201c/text:h\u201d element.   - If the change mark is inside a heading, insert the content that was   deleted, but remove all leading start tags up to and including the   first \u201ctext:h\u201d element and all trailing end tags up to and including   the last \u201c/text:h\u201d or \u201c/text:p\u201d element. If the last trailing element   is a \u201c/text:p\u201d, change the end tag \u201c/text:h\u201d following this insertion   to a \u201c/text:p\u201d element.   - Otherwise, copy the text content of the \u201ctext:deletion\u201d element in   place of the change mark.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextDeletion(TextInsertion):\n    \"\"\"The TextDeletion \"text:deletion\" contains information that identifies\n    the person responsible for a deletion and the date of that deletion.\n    This information may also contain one or more Paragraph which contains\n    a comment on the deletion. The TextDeletion element may also contain\n    content that was deleted while change tracking was enabled. The position\n    where the text was deleted is marked by a \"text:change\" element. Deleted\n    text is contained in a paragraph element. To reconstruct the original\n    text, the paragraph containing the deleted text is merged with its\n    surrounding paragraph or heading element. To reconstruct the text before\n    a deletion took place:\n      - If the change mark is inside a paragraph, insert the content that was\n      deleted, but remove all leading start tags up to and including the\n      first \"text:p\" element and all trailing end tags up to and including\n      the last \"/text:p\" or \"/text:h\" element. If the last trailing element\n      is a \"/text:h\", change the end tag \"/text:p\" following this insertion\n      to a \"/text:h\" element.\n      - If the change mark is inside a heading, insert the content that was\n      deleted, but remove all leading start tags up to and including the\n      first \"text:h\" element and all trailing end tags up to and including\n      the last \"/text:h\" or \"/text:p\" element. If the last trailing element\n      is a \"/text:p\", change the end tag \"/text:h\" following this insertion\n      to a \"/text:p\" element.\n      - Otherwise, copy the text content of the \"text:deletion\" element in\n      place of the change mark.\n    \"\"\"\n\n    _tag = \"text:deletion\"\n\n    def get_deleted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n    ) -&gt; str | list[Element] | None:\n        \"\"\"Get the deleted informations stored in the TextDeletion.\n        If as_text is True: returns the text content.\n        If no_header is True: existing Heading are changed in Paragraph\n\n        Arguments:\n\n            as_text -- boolean\n\n            no_header -- boolean\n\n        Return: Paragraph and Header list\n        \"\"\"\n        children = self.children\n        inner = [elem for elem in children if elem.tag != \"office:change-info\"]\n        if no_header:  # crude replace t:h by t:p\n            new_inner = []\n            for element in inner:\n                if element.tag == \"text:h\":\n                    children = element.children\n                    text = element.text\n                    para = Element.from_tag(\"text:p\")\n                    para.text = text\n                    for child in children:\n                        para.append(child)\n                    new_inner.append(para)\n                else:\n                    new_inner.append(element)\n            inner = new_inner\n        if as_text:\n            return \"\\n\".join([elem.get_formatted_text(context=None) for elem in inner])\n        return inner\n\n    def set_deleted(self, paragraph_or_list: Element | list[Element]) -&gt; None:\n        \"\"\"Set the deleted informations stored in the TextDeletion. An\n        actual content that was deleted is expected, embeded in a Paragraph\n        element or Header.\n\n        Arguments:\n\n            paragraph_or_list -- Paragraph or Header element (or list)\n        \"\"\"\n        for element in self.get_deleted():  # type: ignore\n            self.delete(element)  # type: ignore\n        if isinstance(paragraph_or_list, Element):\n            paragraph_or_list = [paragraph_or_list]\n        for element in paragraph_or_list:\n            self.append(element)\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Return None.\"\"\"\n        if as_text:\n            return \"\"\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion.get_deleted","title":"<code>get_deleted(as_text=False, no_header=False)</code>","text":"<p>Get the deleted informations stored in the TextDeletion. If as_text is True: returns the text content. If no_header is True: existing Heading are changed in Paragraph</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: Paragraph and Header list</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n) -&gt; str | list[Element] | None:\n    \"\"\"Get the deleted informations stored in the TextDeletion.\n    If as_text is True: returns the text content.\n    If no_header is True: existing Heading are changed in Paragraph\n\n    Arguments:\n\n        as_text -- boolean\n\n        no_header -- boolean\n\n    Return: Paragraph and Header list\n    \"\"\"\n    children = self.children\n    inner = [elem for elem in children if elem.tag != \"office:change-info\"]\n    if no_header:  # crude replace t:h by t:p\n        new_inner = []\n        for element in inner:\n            if element.tag == \"text:h\":\n                children = element.children\n                text = element.text\n                para = Element.from_tag(\"text:p\")\n                para.text = text\n                for child in children:\n                    para.append(child)\n                new_inner.append(para)\n            else:\n                new_inner.append(element)\n        inner = new_inner\n    if as_text:\n        return \"\\n\".join([elem.get_formatted_text(context=None) for elem in inner])\n    return inner\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Return None.\"\"\"\n    if as_text:\n        return \"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion.set_deleted","title":"<code>set_deleted(paragraph_or_list)</code>","text":"<p>Set the deleted informations stored in the TextDeletion. An actual content that was deleted is expected, embeded in a Paragraph element or Header.</p> <p>Arguments:</p> <pre><code>paragraph_or_list -- Paragraph or Header element (or list)\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_deleted(self, paragraph_or_list: Element | list[Element]) -&gt; None:\n    \"\"\"Set the deleted informations stored in the TextDeletion. An\n    actual content that was deleted is expected, embeded in a Paragraph\n    element or Header.\n\n    Arguments:\n\n        paragraph_or_list -- Paragraph or Header element (or list)\n    \"\"\"\n    for element in self.get_deleted():  # type: ignore\n        self.delete(element)  # type: ignore\n    if isinstance(paragraph_or_list, Element):\n        paragraph_or_list = [paragraph_or_list]\n    for element in paragraph_or_list:\n        self.append(element)\n</code></pre>"},{"location":"reference.html#odfdo.TextFormatChange","title":"<code>TextFormatChange</code>","text":"<p>             Bases: <code>TextInsertion</code></p> <p>The TextFormatChange \u201ctext:format-change\u201d element represents any change in formatting attributes. The region where the change took place is marked by \u201ctext:change-start\u201d, \u201ctext:change-end\u201d or \u201ctext:change\u201d elements.</p> <p>Note: This element does not contain formatting changes that have taken place.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextFormatChange(TextInsertion):\n    \"\"\"The TextFormatChange \"text:format-change\" element represents any change\n    in formatting attributes. The region where the change took place is\n    marked by \"text:change-start\", \"text:change-end\" or \"text:change\"\n    elements.\n\n    Note: This element does not contain formatting changes that have taken\n    place.\n    \"\"\"\n\n    _tag = \"text:format-change\"\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion","title":"<code>TextInsertion</code>","text":"<p>             Bases: <code>Element</code></p> <p>The TextInsertion \u201ctext:insertion\u201d element contains the information that identifies the person responsible for a change and the date of that change. This information may also contain one or more \u201ctext:p\u201d Paragraph which contain a comment on the insertion. The TextInsertion element\u2019s parent \u201ctext:changed-region\u201d element has an xml:id or text:id attribute, the value of which binds that parent element to the text:change-id attribute on the \u201ctext:change-start\u201d and \u201ctext:change-end\u201d elements.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextInsertion(Element):\n    \"\"\"The TextInsertion \"text:insertion\" element contains the information\n    that identifies the person responsible for a change and the date of\n    that change. This information may also contain one or more \"text:p\"\n    Paragraph which contain a comment on the insertion. The\n    TextInsertion element's parent \"text:changed-region\" element has an\n    xml:id or text:id attribute, the value of which binds that parent\n    element to the text:change-id attribute on the \"text:change-start\"\n    and \"text:change-end\" elements.\n    \"\"\"\n\n    _tag = \"text:insertion\"\n\n    def get_deleted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n    ) -&gt; str | list[Element] | None:\n        \"\"\"Return: None.\"\"\"\n        if as_text:\n            return \"\"\n        return None\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Shortcut to text:change-start.get_inserted(). Return the content\n        between text:change-start and text:change-end.\n\n        If as_text is True: returns the text content.\n        If no_header is True: existing Heading are changed in Paragraph\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of Element, cleaned and with headers\n\n        Arguments:\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list or Element or text\n        \"\"\"\n        current = self.parent  # text:changed-region\n        if not current:\n            raise ValueError\n        idx = current.get_id()  # type: ignore\n        body = self.document_body\n        if not body:\n            body = self.root\n        text_change = body.get_text_change_start(idx=idx)\n        if not text_change:\n            raise ValueError\n        return text_change.get_inserted(  # type: ignore\n            as_text=as_text, no_header=no_header, clean=clean\n        )\n\n    def get_change_info(self) -&gt; Element | None:\n        \"\"\"Get the ChangeInfo child of the element.\n\n        Return: ChangeInfo element.\n        \"\"\"\n        return self.get_element(\"descendant::office:change-info\")\n\n    def set_change_info(\n        self,\n        change_info: Element | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        comments: Element | list[Element] | None = None,\n    ) -&gt; None:\n        \"\"\"Set the ChangeInfo element for the change element. If change_info\n        is not provided, creator, date and comments will be used to build a\n        suitable change info element. Default for creator is 'Unknown',\n        default for date is current time and default for comments is no\n        comment at all.\n        The new change info element will replace any existant ChangeInfo.\n\n        Arguments:\n\n             change_info -- ChangeInfo element (or None)\n\n             cretor -- str (or None)\n\n             date -- datetime (or None)\n\n             comments -- Paragraph or list of Paragraph elements (or None)\n        \"\"\"\n        if change_info is None:\n            new_change_info = ChangeInfo(creator, date)\n            if comments is not None:\n                if isinstance(comments, Element):\n                    # single pararagraph comment\n                    comments_list = [comments]\n                else:\n                    comments_list = comments\n                # assume iterable of Paragraph\n                for paragraph in comments_list:\n                    if not isinstance(paragraph, Paragraph):\n                        raise TypeError(f\"Not a Paragraph: '{paragraph!r}'\")\n                    new_change_info.insert(paragraph, xmlposition=LAST_CHILD)\n        else:\n            if not isinstance(change_info, ChangeInfo):\n                raise TypeError(f\"Not a ChangeInfo: '{change_info!r}'\")\n            new_change_info = change_info\n\n        old = self.get_change_info()\n        if old is not None:\n            self.replace_element(old, new_change_info)\n        else:\n            self.insert(new_change_info, xmlposition=FIRST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.get_change_info","title":"<code>get_change_info()</code>","text":"<p>Get the ChangeInfo child of the element.</p> <p>Return: ChangeInfo element.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_change_info(self) -&gt; Element | None:\n    \"\"\"Get the ChangeInfo child of the element.\n\n    Return: ChangeInfo element.\n    \"\"\"\n    return self.get_element(\"descendant::office:change-info\")\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.get_deleted","title":"<code>get_deleted(as_text=False, no_header=False)</code>","text":"<p>Return: None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n) -&gt; str | list[Element] | None:\n    \"\"\"Return: None.\"\"\"\n    if as_text:\n        return \"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Shortcut to text:change-start.get_inserted(). Return the content between text:change-start and text:change-end.</p> <p>If as_text is True: returns the text content. If no_header is True: existing Heading are changed in Paragraph If no_header is True: existing text:h are changed in text:p By default: returns a list of Element, cleaned and with headers</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list or Element or text</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Shortcut to text:change-start.get_inserted(). Return the content\n    between text:change-start and text:change-end.\n\n    If as_text is True: returns the text content.\n    If no_header is True: existing Heading are changed in Paragraph\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of Element, cleaned and with headers\n\n    Arguments:\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list or Element or text\n    \"\"\"\n    current = self.parent  # text:changed-region\n    if not current:\n        raise ValueError\n    idx = current.get_id()  # type: ignore\n    body = self.document_body\n    if not body:\n        body = self.root\n    text_change = body.get_text_change_start(idx=idx)\n    if not text_change:\n        raise ValueError\n    return text_change.get_inserted(  # type: ignore\n        as_text=as_text, no_header=no_header, clean=clean\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.set_change_info","title":"<code>set_change_info(change_info=None, creator=None, date=None, comments=None)</code>","text":"<p>Set the ChangeInfo element for the change element. If change_info is not provided, creator, date and comments will be used to build a suitable change info element. Default for creator is \u2018Unknown\u2019, default for date is current time and default for comments is no comment at all. The new change info element will replace any existant ChangeInfo.</p> <p>Arguments:</p> <pre><code> change_info -- ChangeInfo element (or None)\n\n cretor -- str (or None)\n\n date -- datetime (or None)\n\n comments -- Paragraph or list of Paragraph elements (or None)\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_change_info(\n    self,\n    change_info: Element | None = None,\n    creator: str | None = None,\n    date: datetime | None = None,\n    comments: Element | list[Element] | None = None,\n) -&gt; None:\n    \"\"\"Set the ChangeInfo element for the change element. If change_info\n    is not provided, creator, date and comments will be used to build a\n    suitable change info element. Default for creator is 'Unknown',\n    default for date is current time and default for comments is no\n    comment at all.\n    The new change info element will replace any existant ChangeInfo.\n\n    Arguments:\n\n         change_info -- ChangeInfo element (or None)\n\n         cretor -- str (or None)\n\n         date -- datetime (or None)\n\n         comments -- Paragraph or list of Paragraph elements (or None)\n    \"\"\"\n    if change_info is None:\n        new_change_info = ChangeInfo(creator, date)\n        if comments is not None:\n            if isinstance(comments, Element):\n                # single pararagraph comment\n                comments_list = [comments]\n            else:\n                comments_list = comments\n            # assume iterable of Paragraph\n            for paragraph in comments_list:\n                if not isinstance(paragraph, Paragraph):\n                    raise TypeError(f\"Not a Paragraph: '{paragraph!r}'\")\n                new_change_info.insert(paragraph, xmlposition=LAST_CHILD)\n    else:\n        if not isinstance(change_info, ChangeInfo):\n            raise TypeError(f\"Not a ChangeInfo: '{change_info!r}'\")\n        new_change_info = change_info\n\n    old = self.get_change_info()\n    if old is not None:\n        self.replace_element(old, new_change_info)\n    else:\n        self.insert(new_change_info, xmlposition=FIRST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.TocEntryTemplate","title":"<code>TocEntryTemplate</code>","text":"<p>             Bases: <code>Element</code></p> <p>ODF \u201ctext:table-of-content-entry-template\u201d</p> <p>Arguments:</p> <pre><code>style -- str\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>class TocEntryTemplate(Element):\n    \"\"\"ODF \"text:table-of-content-entry-template\"\n\n    Arguments:\n\n        style -- str\n    \"\"\"\n\n    _tag = \"text:table-of-content-entry-template\"\n    _properties = (PropDef(\"style\", \"text:style-name\"),)\n\n    def __init__(\n        self,\n        style: str | None = None,\n        outline_level: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style:\n                self.style = style\n            if outline_level:\n                self.outline_level = outline_level\n\n    @property\n    def outline_level(self) -&gt; int | None:\n        return self.get_attribute_integer(\"text:outline-level\")\n\n    @outline_level.setter\n    def outline_level(self, level: int) -&gt; None:\n        self.set_attribute(\"text:outline-level\", str(level))\n\n    def complete_defaults(self) -&gt; None:\n        self.append(Element.from_tag(\"text:index-entry-chapter\"))\n        self.append(Element.from_tag(\"text:index-entry-text\"))\n        self.append(Element.from_tag(\"text:index-entry-text\"))\n        ts = Element.from_tag(\"text:index-entry-text\")\n        ts.set_style_attribute(\"style:type\", \"right\")\n        ts.set_style_attribute(\"style:leader-char\", \".\")\n        self.append(ts)\n        self.append(Element.from_tag(\"text:index-entry-page-number\"))\n</code></pre>"},{"location":"reference.html#odfdo.TrackedChanges","title":"<code>TrackedChanges</code>","text":"<p>             Bases: <code>Element</code></p> <p>The TrackedChanges \u201ctext:tracked-changes\u201d element acts as a container for TextChangedRegion elements that represent changes in a certain scope of an OpenDocument document. This scope is the element in which the TrackedChanges element occurs. Changes in this scope shall be tracked by TextChangedRegion elements contained in the TrackedChanges element in this scope. If a TrackedChanges element is absent, there are no tracked changes in the corresponding scope. In this case, all change mark elements in this scope shall be ignored.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TrackedChanges(Element):\n    \"\"\"The TrackedChanges \"text:tracked-changes\" element acts as a container\n    for TextChangedRegion elements that represent changes in a certain\n    scope of an OpenDocument document. This scope is the element in which\n    the TrackedChanges element occurs. Changes in this scope shall be\n    tracked by TextChangedRegion elements contained in the\n    TrackedChanges element in this scope. If a TrackedChanges\n    element is absent, there are no tracked changes in the corresponding\n    scope. In this case, all change mark elements in this scope shall be\n    ignored.\n    \"\"\"\n\n    _tag = \"text:tracked-changes\"\n\n    def get_changed_regions(\n        self,\n        creator: str | None = None,\n        date: datetime | None = None,\n        content: str | None = None,\n        role: str | None = None,\n    ) -&gt; list[Element]:\n        changed_regions = self._filtered_elements(\n            \"text:changed-region\",\n            dc_creator=creator,\n            dc_date=date,\n            content=content,\n        )\n        if role is None:\n            return changed_regions\n        result: list[Element] = []\n        for regien in changed_regions:\n            changed = regien.get_change_element()  # type: ignore\n            if not changed:\n                continue\n            if changed.tag.endswith(role):\n                result.append(regien)\n        return result\n\n    def get_changed_region(\n        self,\n        position: int = 0,\n        text_id: str | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        return self._filtered_element(\n            \"text:changed-region\",\n            position,\n            text_id=text_id,\n            dc_creator=creator,\n            dc_date=date,\n            content=content,\n        )\n</code></pre>"},{"location":"reference.html#odfdo.UserDefined","title":"<code>UserDefined</code>","text":"<p>             Bases: <code>ElementTyped</code></p> <p>Return a user defined field \u201ctext:user-defined\u201d. If the current document is provided, try to extract the content of the meta user defined field of same name.</p> <p>Arguments:</p> <pre><code>name -- str, name of the user defined field\n\nvalue -- python typed value, value of the field\n\nvalue_type -- str, office:value-type known type\n\ntext -- str\n\nstyle -- str\n\nfrom_document -- ODF document\n</code></pre> Source code in <code>odfdo/variable.py</code> <pre><code>class UserDefined(ElementTyped):\n    \"\"\"Return a user defined field \"text:user-defined\". If the current\n    document is provided, try to extract the content of the meta user defined\n    field of same name.\n\n    Arguments:\n\n        name -- str, name of the user defined field\n\n        value -- python typed value, value of the field\n\n        value_type -- str, office:value-type known type\n\n        text -- str\n\n        style -- str\n\n        from_document -- ODF document\n    \"\"\"\n\n    _tag = \"text:user-defined\"\n    _properties = (\n        PropDef(\"name\", \"text:name\"),\n        PropDef(\"style\", \"style:data-style-name\"),\n    )\n\n    def __init__(\n        self,\n        name: str = \"\",\n        value: Any = None,\n        value_type: str | None = None,\n        text: str | None = None,\n        style: str | None = None,\n        from_document: Document | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if name:\n                self.name = name\n            if style:\n                self.style = style\n            if from_document is not None:\n                meta_infos = from_document.meta\n                content = meta_infos.get_user_defined_metadata_of_name(name)\n                if content is not None:\n                    value = content.get(\"value\", None)\n                    value_type = content.get(\"value_type\", None)\n                    text = content.get(\"text\", None)\n            text = self.set_value_and_type(\n                value=value, value_type=value_type, text=text\n            )\n            self.text = text  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.VarChapter","title":"<code>VarChapter</code>","text":"<p>             Bases: <code>Element</code></p> Source code in <code>odfdo/variable.py</code> <pre><code>class VarChapter(Element):\n    _tag = \"text:chapter\"\n    _properties = (\n        PropDef(\"display\", \"text:display\"),\n        PropDef(\"outline_level\", \"text:outline-level\"),\n    )\n    DISPLAY_VALUE_CHOICE = {  # noqa: RUF012\n        \"number\",\n        \"name\",\n        \"number-and-name\",\n        \"plain-number\",\n        \"plain-number-and-name\",\n    }\n\n    def __init__(\n        self,\n        display: str | None = \"name\",\n        outline_level: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"display can be: 'number', 'name', 'number-and-name', 'plain-number' or\n        'plain-number-and-name'\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if display not in VarChapter.DISPLAY_VALUE_CHOICE:\n                raise ValueError(f\"Unknown display value: '{display}'\")\n            self.display = display\n            if outline_level is not None:\n                self.outline_level = outline_level\n</code></pre>"},{"location":"reference.html#odfdo.VarChapter.__init__","title":"<code>__init__(display='name', outline_level=None, **kwargs)</code>","text":"<p>display can be: \u2018number\u2019, \u2018name\u2019, \u2018number-and-name\u2019, \u2018plain-number\u2019 or \u2018plain-number-and-name\u2019</p> Source code in <code>odfdo/variable.py</code> <pre><code>def __init__(\n    self,\n    display: str | None = \"name\",\n    outline_level: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"display can be: 'number', 'name', 'number-and-name', 'plain-number' or\n    'plain-number-and-name'\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if display not in VarChapter.DISPLAY_VALUE_CHOICE:\n            raise ValueError(f\"Unknown display value: '{display}'\")\n        self.display = display\n        if outline_level is not None:\n            self.outline_level = outline_level\n</code></pre>"},{"location":"reference.html#odfdo.VarFileName","title":"<code>VarFileName</code>","text":"<p>             Bases: <code>Element</code></p> Source code in <code>odfdo/variable.py</code> <pre><code>class VarFileName(Element):\n    _tag = \"text:file-name\"\n    _properties = (\n        PropDef(\"display\", \"text:display\"),\n        PropDef(\"fixed\", \"text:fixed\"),\n    )\n    DISPLAY_VALUE_CHOICE = {  # noqa: RUF012\n        \"full\",\n        \"path\",\n        \"name\",\n        \"name-and-extension\",\n    }\n\n    def __init__(\n        self,\n        display: str | None = \"full\",\n        fixed: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"display can be: 'full', 'path', 'name' or 'name-and-extension'\"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if display not in VarFileName.DISPLAY_VALUE_CHOICE:\n                raise ValueError(f\"Unknown display value: '{display}'\")\n            self.display = display\n            if fixed:\n                self.fixed = True\n</code></pre>"},{"location":"reference.html#odfdo.VarFileName.__init__","title":"<code>__init__(display='full', fixed=False, **kwargs)</code>","text":"<p>display can be: \u2018full\u2019, \u2018path\u2019, \u2018name\u2019 or \u2018name-and-extension\u2019</p> Source code in <code>odfdo/variable.py</code> <pre><code>def __init__(\n    self,\n    display: str | None = \"full\",\n    fixed: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"display can be: 'full', 'path', 'name' or 'name-and-extension'\"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if display not in VarFileName.DISPLAY_VALUE_CHOICE:\n            raise ValueError(f\"Unknown display value: '{display}'\")\n        self.display = display\n        if fixed:\n            self.fixed = True\n</code></pre>"},{"location":"reference.html#odfdo.VarPageNumber","title":"<code>VarPageNumber</code>","text":"<p>             Bases: <code>Element</code></p> <p>select_page \u2013 string in (\u2018previous\u2019, \u2018current\u2019, \u2018next\u2019)</p> <p>page_adjust \u2013 int (to add or subtract to the page number)</p> Source code in <code>odfdo/variable.py</code> <pre><code>class VarPageNumber(Element):\n    \"\"\"\n    select_page -- string in ('previous', 'current', 'next')\n\n    page_adjust -- int (to add or subtract to the page number)\n    \"\"\"\n\n    _tag = \"text:page-number\"\n    _properties = (\n        PropDef(\"select_page\", \"text:select-page\"),\n        PropDef(\"page_adjust\", \"text:page-adjust\"),\n    )\n\n    def __init__(\n        self,\n        select_page: str | None = None,\n        page_adjust: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if select_page is None:\n                select_page = \"current\"\n            self.select_page = select_page\n            if page_adjust is not None:\n                self.page_adjust = page_adjust\n</code></pre>"},{"location":"reference.html#odfdo.XmlPart","title":"<code>XmlPart</code>","text":"<p>Representation of an XML part.</p> <p>Abstraction of the XML library behind.</p> Source code in <code>odfdo/xmlpart.py</code> <pre><code>class XmlPart:\n    \"\"\"Representation of an XML part.\n\n    Abstraction of the XML library behind.\n    \"\"\"\n\n    def __init__(self, part_name: str, container: Container) -&gt; None:\n        self.part_name = part_name\n        self.container = container\n\n        # Internal state\n        self.__tree: _ElementTree | None = None\n        self.__root: Element | None = None\n\n    def _get_tree(self) -&gt; _ElementTree:\n        if self.__tree is None:\n            part = self.container.get_part(self.part_name)\n            self.__tree = parse(BytesIO(part))  # type: ignore\n        return self.__tree\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} part_name={self.part_name}&gt;\"\n\n    # Public API\n\n    @property\n    def root(self) -&gt; Element:\n        if self.__root is None:\n            tree = self._get_tree()\n            self.__root = Element.from_tag(tree.getroot())\n        return self.__root\n\n    @property\n    def body(self) -&gt; Element:\n        \"\"\"Get or set the document body : 'office:body'\"\"\"\n        body = self.root.document_body\n        if not isinstance(body, Element):\n            raise TypeError(f\"No body found in {self.part_name!r}\")\n        return body\n\n    @body.setter\n    def body(self, new_body: Element) -&gt; None:\n        body = self.root.document_body\n        if not isinstance(body, Element):\n            raise TypeError(\"//office:body not found in document\")\n        tail = body.tail\n        body.clear()\n        for item in new_body.children:\n            body.append(item)\n        if tail:\n            body.tail = tail\n\n    def get_elements(self, xpath_query: str) -&gt; list[Element | EText]:\n        root = self.root\n        return root.xpath(xpath_query)\n\n    def get_element(self, xpath_query: str) -&gt; Any:\n        result = self.get_elements(xpath_query)\n        if not result:\n            return None\n        return result[0]\n\n    def delete_element(self, child: Element) -&gt; None:\n        child.delete()\n\n    def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n        \"\"\"Apply XPath query to the XML part. Return list of Element or\n        EText instances translated from the nodes found.\n        \"\"\"\n        root = self.root\n        return root.xpath(xpath_query)\n\n    @property\n    def clone(self) -&gt; XmlPart:\n        clone = object.__new__(self.__class__)\n        for name in self.__dict__:\n            if name == \"container\":\n                setattr(clone, name, self.container.clone)\n            elif name in (\"_XmlPart__tree\",):\n                setattr(clone, name, None)\n            else:\n                value = getattr(self, name)\n                value = deepcopy(value)\n                setattr(clone, name, value)\n        return clone\n\n    def serialize(self, pretty: bool = False) -&gt; bytes:\n        tree = self._get_tree()\n        xml_header = b'&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n'\n        bytes_tree = tostring(\n            tree,\n            pretty_print=pretty,\n            encoding=\"utf8\",\n        )\n        # Lxml with pretty_print is adding a empty line\n        if pretty:\n            bytes_tree = bytes_tree.strip()\n        return xml_header + bytes_tree\n</code></pre>"},{"location":"reference.html#odfdo.XmlPart.body","title":"<code>body: Element</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the document body : \u2018office:body\u2019</p>"},{"location":"reference.html#odfdo.XmlPart.xpath","title":"<code>xpath(xpath_query)</code>","text":"<p>Apply XPath query to the XML part. Return list of Element or EText instances translated from the nodes found.</p> Source code in <code>odfdo/xmlpart.py</code> <pre><code>def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n    \"\"\"Apply XPath query to the XML part. Return list of Element or\n    EText instances translated from the nodes found.\n    \"\"\"\n    root = self.root\n    return root.xpath(xpath_query)\n</code></pre>"},{"location":"reference.html#odfdo.PageBreak","title":"<code>PageBreak()</code>","text":"<p>Return an empty paragraph with a manual page break.</p> Using this function requires to register the page break style with <p>document.add_page_break_style()</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def PageBreak() -&gt; Paragraph:\n    \"\"\"Return an empty paragraph with a manual page break.\n\n    Using this function requires to register the page break style with:\n        document.add_page_break_style()\n    \"\"\"\n    return Paragraph(\"\", style=\"odfdopagebreak\")\n</code></pre>"},{"location":"reference.html#odfdo.create_table_cell_style","title":"<code>create_table_cell_style(border=None, border_top=None, border_bottom=None, border_left=None, border_right=None, padding=None, padding_top=None, padding_bottom=None, padding_left=None, padding_right=None, background_color=None, shadow=None, color=None)</code>","text":"<p>Return a cell style.</p> <p>The borders arguments must be some style attribute strings or None, see the method \u2018make_table_cell_border_string\u2019 to generate them. If the \u2018border\u2019 argument as the value \u2018default\u2019, the default style \u201c0.06pt solid #000000\u201d is used for the 4 borders. If any value is used for border, it is used for the 4 borders, else any of the 4 borders can be specified by it\u2019s own string. If all the border, border_top, border_bottom, \u2026 arguments are None, an empty border is used (ODF value is fo:border=\u201dnone\u201d).</p> <p>Padding arguments are string specifying a length (e.g. \u201c0.5mm\u201d)\u201d. If \u2018padding\u2019 is provided, it is used for the 4 sides, else any of the 4 sides padding can be specified by it\u2019s own string. Default padding is no padding.</p> <p>Arguments:</p> <pre><code>border -- str, style string for borders on four sides\n\nborder_top -- str, style string for top if no 'border' argument\n\nborder_bottom -- str, style string for bottom if no 'border' argument\n\nborder_left -- str, style string for left if no 'border' argument\n\nborder_right -- str, style string for right if no 'border' argument\n\npadding -- str, style string for padding on four sides\n\npadding_top -- str, style string for top if no 'padding' argument\n\npadding_bottom -- str, style string for bottom if no 'padding' argument\n\npadding_left -- str, style string for left if no 'padding' argument\n\npadding_right -- str, style string for right if no 'padding' argument\n\nbackground_color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\nshadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\ncolor -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n</code></pre> <p>Return : Style</p> Source code in <code>odfdo/style.py</code> <pre><code>def create_table_cell_style(\n    border: str | None = None,\n    border_top: str | None = None,\n    border_bottom: str | None = None,\n    border_left: str | None = None,\n    border_right: str | None = None,\n    padding: str | None = None,\n    padding_top: str | None = None,\n    padding_bottom: str | None = None,\n    padding_left: str | None = None,\n    padding_right: str | None = None,\n    background_color: str | tuple | None = None,\n    shadow: str | None = None,\n    color: str | tuple | None = None,\n) -&gt; Style:\n    \"\"\"Return a cell style.\n\n    The borders arguments must be some style attribute strings or None, see the\n    method 'make_table_cell_border_string' to generate them.\n    If the 'border' argument as the value 'default', the default style\n    \"0.06pt solid #000000\" is used for the 4 borders.\n    If any value is used for border, it is used for the 4 borders, else any of\n    the 4 borders can be specified by it's own string. If all the border,\n    border_top, border_bottom, ... arguments are None, an empty border is used\n    (ODF value is fo:border=\"none\").\n\n    Padding arguments are string specifying a length (e.g. \"0.5mm\")\". If\n    'padding' is provided, it is used for the 4 sides, else any of\n    the 4 sides padding can be specified by it's own string. Default padding is\n    no padding.\n\n    Arguments:\n\n        border -- str, style string for borders on four sides\n\n        border_top -- str, style string for top if no 'border' argument\n\n        border_bottom -- str, style string for bottom if no 'border' argument\n\n        border_left -- str, style string for left if no 'border' argument\n\n        border_right -- str, style string for right if no 'border' argument\n\n        padding -- str, style string for padding on four sides\n\n        padding_top -- str, style string for top if no 'padding' argument\n\n        padding_bottom -- str, style string for bottom if no 'padding' argument\n\n        padding_left -- str, style string for left if no 'padding' argument\n\n        padding_right -- str, style string for right if no 'padding' argument\n\n        background_color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\n        shadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\n        color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\n    Return : Style\n    \"\"\"\n    if border == \"default\":\n        border = make_table_cell_border_string()  # default border\n    if border is not None:\n        # use the border value for 4 sides.\n        border_bottom = border_top = border_left = border_right = None\n    if (\n        border is None\n        and border_bottom is None\n        and border_top is None\n        and border_left is None\n        and border_right is None\n    ):\n        border = \"none\"\n    if padding is not None:\n        # use the padding value for 4 sides.\n        padding_bottom = padding_top = padding_left = padding_right = None\n    cell_style = Style(\n        \"table-cell\",\n        area=\"table-cell\",\n        border=border,\n        border_top=border_top,\n        border_bottom=border_bottom,\n        border_left=border_left,\n        border_right=border_right,\n        padding=padding,\n        padding_top=padding_top,\n        padding_bottom=padding_bottom,\n        padding_left=padding_left,\n        padding_right=padding_right,\n        background_color=background_color,\n        shadow=shadow,\n    )\n    if color:\n        cell_style.set_properties(area=\"text\", color=color)\n    return cell_style\n</code></pre>"},{"location":"reference.html#odfdo.default_frame_position_style","title":"<code>default_frame_position_style(name='FramePosition', horizontal_pos='from-left', vertical_pos='from-top', horizontal_rel='paragraph', vertical_rel='paragraph')</code>","text":"<p>Helper style for positioning frames in desktop applications that need it.</p> <p>Default arguments should be enough.</p> <p>Use the returned Style as the frame style or build a new graphic style with this style as the parent.</p> Source code in <code>odfdo/frame.py</code> <pre><code>def default_frame_position_style(\n    name: str = \"FramePosition\",\n    horizontal_pos: str = \"from-left\",\n    vertical_pos: str = \"from-top\",\n    horizontal_rel: str = \"paragraph\",\n    vertical_rel: str = \"paragraph\",\n) -&gt; Style:\n    \"\"\"Helper style for positioning frames in desktop applications that need\n    it.\n\n    Default arguments should be enough.\n\n    Use the returned Style as the frame style or build a new graphic style\n    with this style as the parent.\n    \"\"\"\n    return Style(\n        family=\"graphic\",\n        name=name,\n        horizontal_pos=horizontal_pos,\n        horizontal_rel=horizontal_rel,\n        vertical_pos=vertical_pos,\n        vertical_rel=vertical_rel,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.default_toc_level_style","title":"<code>default_toc_level_style(level)</code>","text":"<p>Generate an automatic default style for the given TOC level.</p> Source code in <code>odfdo/toc.py</code> <pre><code>def default_toc_level_style(level: int) -&gt; Style:\n    \"\"\"Generate an automatic default style for the given TOC level.\"\"\"\n    tab_stop = TabStopStyle(style_type=\"right\", leader_style=\"dotted\", leader_text=\".\")\n    position = 17.5 - (0.5 * level)\n    tab_stop.style_position = f\"{position}cm\"\n    tab_stops = Element.from_tag(\"style:tab-stops\")\n    tab_stops.append(tab_stop)\n    properties = Element.from_tag(\"style:paragraph-properties\")\n    properties.append(tab_stops)\n    toc_style_level = Style(\n        family=\"paragraph\",\n        name=_toc_entry_style_name(level),\n        parent=f\"Contents_20_{level}\",\n    )\n    toc_style_level.append(properties)\n    return toc_style_level\n</code></pre>"},{"location":"reference.html#odfdo.hex2rgb","title":"<code>hex2rgb(color)</code>","text":"<p>Turns a \u201c#RRGGBB\u201d hexadecimal color representation into a (R, G, B) tuple.</p> <p>Arguments:</p> <pre><code>color -- str\n</code></pre> <p>Return: tuple</p> Source code in <code>odfdo/utils/color.py</code> <pre><code>def hex2rgb(color: str) -&gt; tuple[int, int, int]:\n    \"\"\"Turns a \"#RRGGBB\" hexadecimal color representation into a (R, G, B)\n    tuple.\n\n    Arguments:\n\n        color -- str\n\n    Return: tuple\n    \"\"\"\n    code = color[1:]\n    if not (len(color) == 7 and color[0] == \"#\" and code.isalnum()):\n        raise ValueError(f'\"{color}\" is not a valid color')\n    red = int(code[:2], 16)\n    green = int(code[2:4], 16)\n    blue = int(code[4:6], 16)\n    return (red, green, blue)\n</code></pre>"},{"location":"reference.html#odfdo.hexa_color","title":"<code>hexa_color(color=None)</code>","text":"<p>Convert a color definition of type tuple or string to hexadecimal representation.</p> <p>Empty string is converted to black. None is converted to None.</p> <p>Arguments:</p> <pre><code>color -- str or tuple or None\n</code></pre> <p>Return: str or None</p> Source code in <code>odfdo/utils/color.py</code> <pre><code>def hexa_color(color: str | tuple[int, int, int] | None = None) -&gt; str | None:\n    \"\"\"Convert a color definition of type tuple or string to hexadecimal\n    representation.\n\n    Empty string is converted to black.\n    None is converted to None.\n\n    Arguments:\n\n        color -- str or tuple or None\n\n    Return: str or None\n    \"\"\"\n    if color is None:\n        return None\n    if isinstance(color, tuple):\n        return rgb2hex(color)\n    if not isinstance(color, str):\n        raise TypeError(f'Invalid color argument \"{color!r}\"')\n    color = color.strip()\n    if not color:\n        return \"#000000\"\n    if color.startswith(\"#\"):\n        return color\n    return rgb2hex(color)\n</code></pre>"},{"location":"reference.html#odfdo.make_table_cell_border_string","title":"<code>make_table_cell_border_string(thick=None, line=None, color=None)</code>","text":"<p>Returns a string for style:table-cell-properties fo:border, with default : \u201c0.06pt solid #000000\u201d</p> <pre><code>thick -- str or float or int\nline -- str\ncolor -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n</code></pre> <p>Returns : str</p> Source code in <code>odfdo/style.py</code> <pre><code>def make_table_cell_border_string(\n    thick: str | float | int | None = None,\n    line: str | None = None,\n    color: str | tuple | None = None,\n) -&gt; str:\n    \"\"\"Returns a string for style:table-cell-properties fo:border,\n    with default : \"0.06pt solid #000000\"\n\n        thick -- str or float or int\n        line -- str\n        color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\n    Returns : str\n    \"\"\"\n    thick_string = _make_thick_string(thick)\n    line_string = _make_line_string(line)\n    color_string = hexa_color(color) or \"#000000\"\n    return \" \".join((thick_string, line_string, color_string))\n</code></pre>"},{"location":"reference.html#odfdo.rgb2hex","title":"<code>rgb2hex(color)</code>","text":"<p>Turns a color name or a (R, G, B) color tuple into a \u201c#RRGGBB\u201d hexadecimal representation.</p> <p>Arguments:</p> <pre><code>color -- str or tuple\n</code></pre> <p>Return: str</p> <p>Examples::</p> <pre><code>&gt;&gt;&gt; rgb2hex('yellow')\n'#FFFF00'\n&gt;&gt;&gt; rgb2hex((238, 130, 238))\n'#EE82EE'\n</code></pre> Source code in <code>odfdo/utils/color.py</code> <pre><code>def rgb2hex(color: str | tuple[int, int, int]) -&gt; str:\n    \"\"\"Turns a color name or a (R, G, B) color tuple into a \"#RRGGBB\"\n    hexadecimal representation.\n\n    Arguments:\n\n        color -- str or tuple\n\n    Return: str\n\n    Examples::\n\n        &gt;&gt;&gt; rgb2hex('yellow')\n        '#FFFF00'\n        &gt;&gt;&gt; rgb2hex((238, 130, 238))\n        '#EE82EE'\n    \"\"\"\n    if isinstance(color, str):\n        try:\n            code = CSS3_COLORMAP[color.lower()]\n        except KeyError as e:\n            raise KeyError(f'Color \"{color}\" is unknown in CSS color list') from e\n    elif isinstance(color, tuple):\n        if len(color) != 3:\n            raise ValueError(\"Color must be a 3-tuple\")\n        code = color\n    else:\n        raise TypeError(f'Invalid color \"{color}\"')\n    for channel in code:\n        if not 0 &lt;= channel &lt;= 255:\n            raise ValueError(\n                f'Invalid color \"{color}\", channel must be between 0 and 255'\n            )\n    return f\"#{code[0]:02X}{code[1]:02X}{code[2]:02X}\"\n</code></pre>"}]}