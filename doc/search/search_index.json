{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"odfdo","text":"<p>OpenDocument Format (ODF, ISO/IEC 26300) library for Python</p> <p></p> <p><code>odfdo</code> is a Python library for programmatically creating, parsing, and editing OpenDocument Format (ODF) files.  It provides an interface for interacting with <code>.odt</code>, <code>.ods</code>, <code>.odp</code>, and other ODF file types. The library comes with a set of utilities and recipes for common actions to make it easier to use.</p> <ul> <li>Document Creation: Generate new ODF documents.</li> <li>Content Manipulation: Add, modify, or delete text, paragraphs or tables.</li> <li>Table Operations: Create, populate, and modify tables.</li> <li>Style Management: Control formatting through different ways.</li> <li>Drawing and Presentation: Less advanced features, but allow work with elements in <code>.odg</code> and <code>.odp</code> files.</li> <li>Metadata: Read and write document metadata.</li> </ul> <p>Project: https://github.com/jdum/odfdo</p> <p>Author: jerome.dumonteil@gmail.com</p> <p>License: Apache License, Version 2.0</p> <p><code>odfdo</code> is a derivative work of the former <code>lpod-python</code> project.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Installation from Pypi (recommended):</p> <pre><code>pip install odfdo\n</code></pre> <p>Installation from sources:</p> <pre><code>uv sync\n</code></pre> <p>After installation from sources, you can check everything is working</p> <pre><code>uv run pytest\n</code></pre> <p>The tests should run for a few minutes and issue no error.</p> <p>The full test suite uses <code>tox</code> to check different <code>Python</code> and <code>lxml</code> versions.</p> <p>A special effort is made to limit the dependencies of this library: the only dependency (outside development) is <code>lxml</code>. The <code>lxml</code> versions depend mainly on the version of Python used, see the <code>pyproject.toml</code> file for details.</p>"},{"location":"index.html#usage-overview","title":"Usage Overview","text":""},{"location":"index.html#creating-a-hello-world-text-document","title":"Creating a \u201cHello world\u201d Text Document","text":"<pre><code>from odfdo import Document, Paragraph\n\ndoc = Document('text')\ndoc.body.append(Paragraph(\"Hello world!\"))\n\ndoc.save(\"hello.odt\")\n</code></pre>"},{"location":"index.html#modifying-a-spreadsheet","title":"Modifying a Spreadsheet","text":"<pre><code>from odfdo import Document\n\ndoc = Document('existing_spreadsheet.ods')\nsheet = doc.body.get_table(0)\n\nprint(f\"Value of A1: {sheet.get_cell('A1').value}\")\nsheet.set_value('B2', 'Updated Value')\n\ndoc.save('modified_spreadsheet.ods')\n</code></pre>"},{"location":"index.html#utilities","title":"Utilities","text":"<p>A few scripts are provided with <code>odfdo</code>:</p> <ul> <li><code>odfdo-diff</code>: show a diff between two .odt document.</li> <li><code>odfdo-folder</code>: convert standard ODF file to folder and files, and reverse.</li> <li><code>odfdo-headers</code>: print the headers of an ODF file.</li> <li><code>odfdo-highlight</code>: highlight the text matching a pattern (regex) in an ODF file.</li> <li><code>odfdo-markdown</code>: export text document in Markdown format to stdout.</li> <li><code>odfdo-replace</code>: find a pattern (regex) in an ODF file and replace by some string.</li> <li><code>odfdo-show</code>: dump text from an ODF file to the standard output, and optionally styles and meta informations.</li> <li><code>odfdo-styles</code>: command line interface tool to manipulate styles of ODF files.</li> <li><code>odfdo-table-shrink</code>: shrink tables to optimize width and height.</li> <li><code>odfdo-userfield</code>: show or set the user-field content in an ODF file.</li> </ul>"},{"location":"index.html#tldr","title":"tl;dr","text":"<p>\u2018Intended Audience :: Developers\u2019</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>There is no detailed documentation or tutorial, but:</p> <ul> <li>the <code>recipes</code> folder contains more than 60 working sample scripts,</li> <li>the <code>doc</code> folder contains an API reference documentation (auto generated), including recipes.</li> </ul>"},{"location":"index.html#about-styles","title":"About styles","text":"<p>The best way to apply style is by merging styles from a template document into your generated document (See <code>odfdo-styles</code> script). Styles are a complex matter in ODF, so trying to generate styles programmatically is not recommended. Several recipes provide an example of manipulating styles, including: <code>change_paragraph_styles_methods.py</code>,<code>create_basic_text_styles</code>, <code>add_text_span_styles</code>.</p>"},{"location":"index.html#related-project","title":"Related project","text":"<p>I you work on <code>.ods</code> files (spreadsheet), you may be interested by these scripts using this library to parse/generate <code>.ods</code> files: <code>https://github.com/jdum/odsgenerator</code> and <code>https://github.com/jdum/odsparsator</code></p>"},{"location":"index.html#former-lpod-python-library","title":"Former lpod-python library","text":"<p><code>lpod-python</code> was written in 2009-2010 as a Python 2.x library, see: <code>https://github.com/lpod/lpod-python</code></p> <p><code>odfdo</code> is an adaptation of this former project to Python 3.x with several improvements.</p>"},{"location":"CHANGES.html","title":"Odfdo Release Notes","text":""},{"location":"CHANGES.html#3144-2025-06-21","title":"[3.14.4] - 2025-06-21","text":"<ul> <li>Technical updates: refactoring of some recipes\u2019 code and improvement of test coverage.</li> <li>Improve <code>README.md</code></li> </ul>"},{"location":"CHANGES.html#changed","title":"Changed","text":"<ul> <li>Refactor recipes: <code>remove_span_styles</code>, <code>make_a_presentation_from_text_with_different_styles</code>, <code>how_to_add_a_table_to_a_document</code>, <code>get_text_content_from_odt_file</code>, <code>change_image_in_many_documents</code>, <code>basic_presentation_hello_world</code>, <code>add_text_span_styles</code>, <code>add_private_annotations_to_a_document</code>, <code>add_logo_on_presentation</code>, <code>add_a_custom_footer_to_a_text_document</code>, <code>accessing_other_element_from_element_like_list</code>, <code>accessing_a_single_element.py accessing_a_list_of_elements</code>, <code>accessibility_check_on_a_document</code>.</li> <li>Improve tests for table coordinates, <code>MetaAutoReload</code>, <code>Link</code>, <code>Manifest</code>, <code>Meta</code>, <code>Content</code>, <code>MetaHyperlinkBehaviour</code>, <code>Row</code>.</li> </ul>"},{"location":"CHANGES.html#3143-2025-06-14","title":"[3.14.3] - 2025-06-14","text":"<ul> <li>The rarely used <code>RowGroup</code> class is moved to a dedicated module and tests are added for this class. A new property <code>Table.row_groups</code> returning the list of row groups of the table is available.</li> <li>A new recipe explains how to add a page footer by using the method <code>Style.set_page_footer()</code>.</li> <li>Compatibility with previous versions is maintained.</li> </ul>"},{"location":"CHANGES.html#changed_1","title":"Changed","text":"<ul> <li>The <code>RowGroup</code> class is moved to a dedicated module.</li> <li>Refactoring of the <code>RowGroup</code> class.</li> <li>Small refactoring of <code>Cell.repeated</code> setter.</li> <li>Refactor recipe <code>create_a_text_document_with_tables_in_it.py</code>.</li> <li>Update versions of development dependencies.</li> </ul>"},{"location":"CHANGES.html#added","title":"Added","text":"<ul> <li>Add a new property <code>Table.row_groups</code>.</li> <li>Add tests for the <code>RowGroup</code> class.</li> <li>Add recipe <code>add_a_custom_footer_to_a_text_document.py</code>.</li> </ul>"},{"location":"CHANGES.html#fixed","title":"Fixed","text":"<ul> <li>Fix some <code>Xpath</code> commands to fetch rows inside row groups.</li> <li>Fix <code>Style.set_page_footer()</code> when the new footer is a string.</li> </ul>"},{"location":"CHANGES.html#3142-2025-06-07","title":"[3.14.2] - 2025-06-07","text":"<ul> <li>The <code>Style</code> class for the <code>table</code> area accepts two new arguments useful for a table in a text context: \u2018width\u2019 and \u2018align\u2019. Example: <code>Style(\"table\", \"style_name\", width=\"5cm\", align=\"left\", margin_left=\"2cm\")</code>.</li> <li><code>Cell.date</code> property now returns <code>datetime.date</code> type (was <code>datetime.datetime</code>). <code>Cell.value</code> still returns a <code>datetime.datetime</code>. Note: OpenDocument format does not differentiate between \u201cdate\u201d and \u201cdatetime\u201d, so <code>Cell.date</code> and <code>Cell.datetime</code> are best guesses in case the user expects such a specific value.</li> <li>Allow to use string to define width and height in Table creation, ie <code>table = Table(\"table\", width=\"4\")</code></li> <li>Compatibility with previous versions is maintained, at the exception of <code>Cell.date</code> type.</li> </ul>"},{"location":"CHANGES.html#changed_2","title":"Changed","text":"<ul> <li><code>Cell.date</code> property now returns <code>datetime.date</code>.</li> <li>Allow use of string when defining Table height and width.</li> </ul>"},{"location":"CHANGES.html#added_1","title":"Added","text":"<ul> <li>Style class for area \u2018table\u2019 accepts two new argumaents: \u2018width\u2019 and \u2018align\u2019.</li> <li>Add more tests for Cell class coverage.</li> </ul>"},{"location":"CHANGES.html#fixed_1","title":"Fixed","text":"<ul> <li>Allow decode boolean from bytes (mostly for test coverage).</li> <li>An Exception type was missing in <code>Cell.decimal</code>.</li> <li>Fix docstrings of modules.</li> </ul>"},{"location":"CHANGES.html#3141-2025-06-01","title":"[3.14.1] - 2025-06-01","text":"<ul> <li>Technical updates: code refactoring. Compatibility with previous versions is maintained.</li> </ul>"},{"location":"CHANGES.html#changed_3","title":"Changed","text":"<ul> <li>Refactor <code>Paragraph._by_regex_offset</code> method.</li> <li>Move <code>CSS3_COLORMAP</code> constant in utils directory. Link with previous location in <code>odfdo.const</code> is kept for compatibility.</li> <li>Refactor <code>Element.text_content</code> property.</li> </ul>"},{"location":"CHANGES.html#added_2","title":"Added","text":"<ul> <li>Add <code>utils/css3_colormap.py</code> file.</li> </ul>"},{"location":"CHANGES.html#3140-2025-05-26","title":"[3.14.0] - 2025-05-26","text":"<ul> <li> <p>Improve methods for retrieving information from cells spanned in tables.</p> <ul> <li> <p>Add boolean argument <code>covered</code> to the method <code>Cell.is_spanned()</code>. If <code>covered</code> is set to True (the default), all covered cells of the spanned area return True, otherwise, only the top-left cell returns True. The top-left cell in the spanned area contains the <code>\"table:number-columns-spanned\"</code> and <code>\"table:number-rows-spanned \"</code> attributes. The default behavior of <code>Cell.is_spanned()</code> remains unchanged from previous versions.</p> </li> <li> <p>Add <code>Cell.is_covered()</code> method: returns whether the cell is covered (<code>table:covered-table-cell</code> tag), meaning it is part of a spanned area of cells, but not the top-left one.</p> </li> <li> <p>Add <code>Cell.span_area()</code> method:  returns the tuple (number of columns, number of rows) of the area covered by a spanned cell. If the cell is not spanned, returns (0, 0).</p> </li> </ul> </li> <li> <p>Small refactoring in <code>coordinates.py</code>.</p> </li> </ul>"},{"location":"CHANGES.html#changed_4","title":"Changed","text":"<ul> <li>Add boolean argument <code>covered</code> to the method <code>Cell.is_spanned()</code>. The default behavior of <code>Cell.is_spanned()</code> remains unchanged from previous versions.</li> <li>Small refactoring in <code>coordinates.py</code>.</li> <li>Update test suite.</li> </ul>"},{"location":"CHANGES.html#added_3","title":"Added","text":"<ul> <li>Add <code>Cell.is_covered()</code> method.</li> <li>Add <code>Cell.span_area()</code> method.</li> </ul>"},{"location":"CHANGES.html#31312-2025-05-17","title":"[3.13.12] - 2025-05-17","text":"<p>Technical updates: refactor code for isiterable() function, define Unit class in its own file, apply ruff.</p>"},{"location":"CHANGES.html#changed_5","title":"Changed","text":"<ul> <li>Define Unit class in its own file odfdo.unit.py (previous import from odfdo.datatype is still allowed to maintain compatibility).</li> <li>Refactor code of isiterable() function.</li> </ul>"},{"location":"CHANGES.html#31311-2025-05-10","title":"[3.13.11] - 2025-05-10","text":"<p>Added <code>lxml</code> version 5.4.0 to the test suite. Technical updates: refactor code for get_formatted_text() and Element.get_value().</p>"},{"location":"CHANGES.html#changed_6","title":"Changed","text":"<ul> <li>Refactor code for get_formatted_text().</li> <li>Refactor code for Element.get_value().</li> </ul>"},{"location":"CHANGES.html#added_4","title":"Added","text":"<ul> <li>Version 5.4.0 of <code>lxml</code> added to <code>tox.ini</code>.</li> </ul>"},{"location":"CHANGES.html#31310-2025-04-20","title":"[3.13.10] - 2025-04-20","text":"<p>Add a method to set the metadata of the document from a Python dict. Added <code>lxml</code> version 5.3.2 to the test suite. Fix incorrect docstring of DrawImage (issue 56). Technical update: apply more ruff\u2019s style recommendations.</p>"},{"location":"CHANGES.html#changed_7","title":"Changed","text":"<ul> <li>Apply ruff\u2019s style recommendations.</li> </ul>"},{"location":"CHANGES.html#added_5","title":"Added","text":"<ul> <li>Add methods: <code>Meta.from_dict()</code>.</li> <li>Version 5.3.2 of <code>lxml</code> added to <code>tox.ini</code>.</li> </ul>"},{"location":"CHANGES.html#fixed_2","title":"Fixed","text":"<ul> <li>Update incorrect docstring of DrawImage.</li> </ul>"},{"location":"CHANGES.html#3139-2025-03-22","title":"[3.13.9] - 2025-03-22","text":"<p>Technical update: migrate from <code>poetry</code> build environment to <code>uv</code>, and reorganize tests.</p>"},{"location":"CHANGES.html#changed_8","title":"Changed","text":"<ul> <li>Migrate from <code>poetry</code> build environment to <code>uv</code></li> <li>Organize tests with more fixtures and sub directories.</li> </ul>"},{"location":"CHANGES.html#3138-2025-03-15","title":"[3.13.8] - 2025-03-15","text":"<p>Technical update: update <code>poetry</code> to version 2.1, reformat <code>pyproject.toml</code>, move source code in the <code>src</code> directory.</p>"},{"location":"CHANGES.html#changed_9","title":"Changed","text":"<ul> <li>The source code is now in the <code>src</code> sub directory.</li> <li>Build of the library requires <code>poetry</code> version 2.0 or more.</li> </ul>"},{"location":"CHANGES.html#3137-2025-03-08","title":"[3.13.7] - 2025-03-08","text":"<p>Improved filter on allowed characters in a table name (for compatibility with allowed names in LibreOffice). Forbidden characters are now <code>\\n</code> <code>\\</code> <code>/</code> <code>*</code> <code>?</code> <code>:</code> <code>[</code> <code>]</code>, and <code>\"'\"</code> as first or last character. Previously forbidden characters were simply <code>\\n</code> <code>/</code> <code>\\</code> <code>\"'\"</code>.</p> <p>Added <code>lxml</code> version 5.3.1 to the test suite.</p>"},{"location":"CHANGES.html#changed_10","title":"Changed","text":"<ul> <li>The regex for unauthised characters in table names is now: <code>r\"^\\'|[\\n\\\\/\\*\\?:\\][]|\\'$\"</code>.</li> </ul>"},{"location":"CHANGES.html#added_6","title":"Added","text":"<ul> <li>Version 5.3.1 of <code>lxml</code> added to <code>tox.ini</code>.</li> </ul>"},{"location":"CHANGES.html#3136-2025-02-04","title":"[3.13.6] - 2025-02-04","text":"<p>Fix corrupted ODF file due to incoherent manifest files, especially in .odg files (issue 54).</p>"},{"location":"CHANGES.html#fixed_3","title":"Fixed","text":"<ul> <li>Fixed <code>Document.save()</code> check for <code>manifest.rdf</code> listed in <code>manifest.xml</code></li> </ul>"},{"location":"CHANGES.html#3135-2025-01-25","title":"[3.13.5] - 2025-01-25","text":"<p>Add the option <code>formatted</code> to script <code>odfdo-replace</code> and method <code>Element.replace()</code> to interpret the <code>&lt;space&gt;</code>, <code>&lt;tab&gt;</code> and <code>&lt;CR&gt;</code> of the replacement string.</p>"},{"location":"CHANGES.html#added_7","title":"Added","text":"<ul> <li>Add <code>Element.replace()</code> optional argument <code>formatted</code></li> <li>Add <code>odfdo-replace</code> optional option <code>--formatted</code></li> </ul>"},{"location":"CHANGES.html#3134-2025-01-22","title":"[3.13.4] - 2025-01-22","text":"<ul> <li>Fix a bug on <code>Document.insert_style()</code> and related methods that prevented the loading of styles from the family <code>number:*</code>, like <code>number:currency-style</code> (issue #53).</li> </ul>"},{"location":"CHANGES.html#fixed_4","title":"Fixed","text":"<ul> <li>Fixed <code>Document.insert_style()</code> and <code>CONTEXT_MAPPING</code> in <code>styles.py</code> for a better detection of styles pseudo-families.</li> </ul>"},{"location":"CHANGES.html#3133-2025-01-01","title":"[3.13.3] - 2025-01-01","text":"<ul> <li>Refactor cell properties to get easier and more consistent access to cell values. Some new properties added: Cell.decimal, Cell.int, Cell.bool, Cell.duration, Cell.datetime, Cell.date.</li> <li>Add a <code>.rdf</code> manifest file if it is missing (this should only happen in very rare manipulations).</li> </ul>"},{"location":"CHANGES.html#changed_11","title":"Changed","text":"<ul> <li>Refactoring of Cell properties.</li> <li>Refactoring of Container class to ensure creation of manifest file.</li> </ul>"},{"location":"CHANGES.html#added_8","title":"Added","text":"<ul> <li>Add properties: <code>Cell.decimal</code>, <code>Cell.int</code>, <code>Cell.bool</code>, <code>Cell.duration</code>, <code>Cell.datetime</code>, <code>Cell.date</code>.</li> </ul>"},{"location":"CHANGES.html#3132-2024-12-15","title":"[3.13.2] - 2024-12-15","text":"<ul> <li>Refactor Table and Row caching, removing useless <code>_caching</code> attribute from many classes.</li> <li>Remove module scriptutils.</li> </ul>"},{"location":"CHANGES.html#changed_12","title":"Changed","text":"<ul> <li>Refactoring of Table and Row caching.</li> <li>Replace in <code>container.py</code> and scripts <code>show.py</code> and <code>styles.py</code> the previous functions of scriptutils.</li> </ul>"},{"location":"CHANGES.html#removed","title":"Removed","text":"<ul> <li><code>odfdo.scriptutils.py</code> removed.</li> </ul>"},{"location":"CHANGES.html#3131-2024-12-14","title":"[3.13.1] - 2024-12-14","text":"<ul> <li>Allow XML export of base64 encoded images (preparing for flat ODF export).</li> <li>Update XML propertires to ODF 1.2.</li> </ul>"},{"location":"CHANGES.html#changed_13","title":"Changed","text":"<ul> <li>Refactoring of Document.add_file() and export to XML format.</li> </ul>"},{"location":"CHANGES.html#3130-2024-12-07","title":"[3.13.0] - 2024-12-07","text":"<ul> <li>The <code>Meta</code> class which manages the <code>meta.xml</code> part has two new methods <code>as_dict()</code> and <code>as_json()</code> to export its content.</li> <li>Improved \u201cpretty\u201d export of documents.</li> </ul>"},{"location":"CHANGES.html#added_9","title":"Added","text":"<ul> <li>Add methods: <code>Meta.as_dict()</code>, <code>Meta.as_json()</code>, <code>MetaTemplate.as_dict()</code>, <code>MetaAutoReload.as_dict()</code>, <code>MetaHyperlinkBehaviour.as_dict()</code>.</li> </ul>"},{"location":"CHANGES.html#changed_14","title":"Changed","text":"<ul> <li>Small XML file formatting changes when saving with \u201cpretty=True\u201d.</li> </ul>"},{"location":"CHANGES.html#3121-2024-11-30","title":"[3.12.1] - 2024-11-30","text":"<p>Fix some small rendering issues for Markdown export.</p>"},{"location":"CHANGES.html#fixed_5","title":"Fixed","text":"<ul> <li>Better Markdown export for strike style, non break space, successive tags, line breaks, footnotes</li> </ul>"},{"location":"CHANGES.html#3120-2024-11-30","title":"[3.12.0] - 2024-11-30","text":"<ul> <li>Change in <code>str(Paragraph)</code> which now includes a <code>'\\n'</code> at the end of the string.</li> <li>The <code>odfdo-to-md</code> script is renamed to <code>odfdo-markdown</code> and should be functional. Markdown export of .odt files supports all standard formatting features (including tables) except quoted text (no clear semantic equivalent in the ODF standard).</li> <li>Improved <code>__str__</code> methods for many classes: Document.body, Paragraph, Span, Link, Unit, Note, Annotation.</li> <li>Some added methods: <code>Document.get_parent_style()</code>, <code>Document.get_list_style()</code>, <code>Style.get_list_style_properties()</code>, <code>Style.get_text_properties()</code>.</li> <li>The new <code>Element.inner_text</code> property is now the preferred way to access an element\u2019s inner text.</li> </ul>"},{"location":"CHANGES.html#added_10","title":"Added","text":"<ul> <li>Add methods: <code>Document.get_parent_style()</code>, <code>Document.get_list_style()</code>, <code>Style.get_list_style_properties()</code>, <code>Style.get_text_properties()</code>.</li> <li>Add propterty <code>Element.inner_text</code>.</li> </ul>"},{"location":"CHANGES.html#changed_15","title":"Changed","text":"<ul> <li>Script <code>odfdo-to-md</code> renamed to <code>odfdo-markdown</code>.</li> <li><code>str(Paragraph)</code> now includes a <code>'\\n'</code> at the end of the string.</li> <li>Output of the str method modified for many elements.</li> </ul>"},{"location":"CHANGES.html#3110-2024-11-23","title":"[3.11.0] - 2024-11-23","text":"<ul> <li>New script <code>odfdo-to-md</code> to export text document in markdown format to stdout (experimental, do not export images links neither tables).</li> <li>Fix <code>VarTime</code> initialization: class can now be initialized without mandatory time argument.</li> </ul>"},{"location":"CHANGES.html#added_11","title":"Added","text":"<ul> <li>Add script <code>odfdo-to-md</code>.</li> </ul>"},{"location":"CHANGES.html#changed_16","title":"Changed","text":"<ul> <li><code>odfdo-folder</code> script now writes XML files with the \u201cpretty\u201d option by default.</li> </ul>"},{"location":"CHANGES.html#fixed_6","title":"Fixed","text":"<ul> <li>Fix <code>VarTime</code> initialization.</li> </ul>"},{"location":"CHANGES.html#3101-2024-11-23","title":"[3.10.1] - 2024-11-23","text":"<p>The HTML documentation in <code>/doc</code> (mostly auto generated) contains now all recipes, sorted by relevance.</p>"},{"location":"CHANGES.html#changed_17","title":"Changed","text":"<ul> <li>Improvement of documentation.</li> </ul>"},{"location":"CHANGES.html#3100-2024-11-23","title":"[3.10.0] - 2024-11-23","text":"<ul> <li>Fix a bug of <code>Paragraph.set_span()</code> when using an offset argument of zero (the  Span was not created). Added 3 methods related to searching strings in paragraphs: <code>search_first()</code>, <code>search_all()</code> and <code>text_at()</code>. These methods permit to search some string with regex in a paragraph and get their position, <code>text_at()</code> returns the text content at a given position.</li> <li>Fix the \u201cpretty\u201d option of <code>Document.save()</code>. \u201cpretty\u201d is now the default for odfdo-folder.</li> </ul> <p>Added a new recipe showing several methods to change the style of a paragraph or words in a pragraph with the use of <code>Paragraph.style = style.name</code> and <code>Paragraph.set_span()</code>.</p>"},{"location":"CHANGES.html#added_12","title":"Added","text":"<ul> <li>Added <code>Element.search_first()</code>, <code>Element.search_all()</code> , <code>Element.text_at()</code>.</li> <li>Added <code>change_paragraph_styles_or_spans.py</code> recipe (issue #21).</li> </ul>"},{"location":"CHANGES.html#changed_18","title":"Changed","text":"<ul> <li><code>odfdo-folder</code> script now writes XML files with the \u201cpretty\u201d option by default.</li> </ul>"},{"location":"CHANGES.html#fixed_7","title":"Fixed","text":"<ul> <li>Fix <code>Paragraph.set_span()</code> when using an offset argument of zero (issue #21).</li> <li>Fix the \u201cpretty\u201d option of <code>Document.save()</code> (issue #28).</li> </ul>"},{"location":"CHANGES.html#394-2024-11-06","title":"[3.9.4] - 2024-11-06","text":"<p>Fix a performance bug on huge .ods tables when number of rows is a large (several thousand). See issue #46 for a table of about ~83k. Table.traverse() on such a table is expected to be ~2 sec.</p>"},{"location":"CHANGES.html#changed_19","title":"Changed","text":"<ul> <li>Rewrite the method Table.traverse().</li> </ul>"},{"location":"CHANGES.html#fixed_8","title":"Fixed","text":"<ul> <li>Fix the performance bug on huge .ods tables (issue #46).</li> </ul>"},{"location":"CHANGES.html#393-2024-10-14","title":"[3.9.3] - 2024-10-14","text":"<p>Add support for Python 3.13 final in test suite.</p>"},{"location":"CHANGES.html#added_13","title":"Added","text":"<ul> <li>Add support for Python3.13 in tox.ini</li> </ul>"},{"location":"CHANGES.html#392-2024-10-05","title":"[3.9.2] - 2024-10-05","text":"<p>Add support for Python 3.13.0.rc3 in test suite.</p>"},{"location":"CHANGES.html#added_14","title":"Added","text":"<ul> <li>Add support for Python3.13.0.rc3 in tox.ini, add requirement for lxml version 5.3 or higher for Python 3.13.</li> </ul>"},{"location":"CHANGES.html#391-2024-09-29","title":"[3.9.1] - 2024-09-29","text":"<p>When creating a Document() allow alias \u201codt\u201d for \u201cText\u201d, \u201cods\u201d for \u201cspreadsheet\u201d.</p> <p>Add a recipe showing how to remove parts from a text document.</p>"},{"location":"CHANGES.html#added_15","title":"Added","text":"<ul> <li> <p>Aliases \u201codt\u201d, \u201cods\u201d, \u201codp\u201d and \u201codg\u201d for Document creation.</p> </li> <li> <p>Add recipe <code>delete_parts_of_a_text_document.py</code>.</p> </li> </ul>"},{"location":"CHANGES.html#390-2024-09-22","title":"[3.9.0] - 2024-09-22","text":"<p>Two changes in this version:</p> <ul> <li>Fix of the broken <code>Table.displayed</code> property.</li> <li>Fix the way spaces are represented for better compliance with the ODF standard and word processors.</li> </ul> <p>The <code>Table.displayed</code> property was broken and is removed. The functionality is replaced by the <code>Document.get_table_displayed</code> and <code>Document.set_table_displayed</code> methods. This change should not affect anyone since the previous implementation was unusable.</p> <p>In previous version 3 spaces were translated into 1 space followed by <code>'&lt;text:s text:c=\"2\"/&gt;'</code> unconditionally. However, the standard specifies that at the beginning and end of a paragraph spaces must be discarded by word processors, so 3 spaces should be coded <code>'&lt;text:s text:c=\"3\"/&gt;'</code> and a single space as <code>'&lt;text:s/&gt;'</code>. This change should fix the bug of \u201cdisappearing\u201d spaces at the beginning of paragraphs.</p>"},{"location":"CHANGES.html#added_16","title":"Added","text":"<ul> <li> <p>Methods Document.get_table_displayed(), Document.set_table_displayed(), Document.get_table_style().</p> </li> <li> <p>The Spacer() class has 2 new properties: Spacer.length and Spacer.text.</p> </li> </ul>"},{"location":"CHANGES.html#changed_20","title":"Changed","text":"<ul> <li> <p>XML generation of spaces at beginning and end of Paragraph content.</p> </li> <li> <p>Update of dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#removed_1","title":"Removed","text":"<ul> <li>Table.displayed property.</li> </ul>"},{"location":"CHANGES.html#fixed_9","title":"Fixed","text":"<ul> <li>Fix the \u201cdisappearing\u201d spaces at the beginning of paragraphs bug.</li> </ul>"},{"location":"CHANGES.html#380-2024-08-25","title":"[3.8.0] - 2024-08-25","text":"<p>Changed the default behavior for appending text to a <code>Paragraph</code>: the behavior of the <code>Paragraph.append_plain_text()</code> method is now the default. A <code>\"formatted\"</code> argument is added, <code>True</code> by default, which applies the recognition of \u201c\\n\u201d, \u201c\\t\u201d or a sequence of several spaces and converts them to ODF tags (<code>text:line-break</code>, <code>text:tab</code>, <code>text:s</code>)). To ignore this text formatting, set <code>\"formatted=False\"</code>.</p> <p>This change affects you if you create paragraphs from text containing line breaks or tabs and you don\u2019t want them to appear. In this case, add the argument <code>\"formatted=False\"</code></p> <p>Details:</p> <ul> <li> <p><code>Paragraph(\"word1     word2\")</code></p> <ul> <li> <p>previous behavior:</p> <ul> <li>product XML:  <code>'&lt;text:p&gt;word1     word2&lt;/text:p&gt;'</code></li> <li>expected display: <code>word1 word2</code> (single space, the ODF standard does not recognize space sequences)</li> </ul> </li> <li> <p>new behavior:</p> <ul> <li>product XML:  <code>'&lt;text:p&gt;word1 &lt;text:s text:c=\"4\"/&gt;word2&lt;/text:p&gt;'</code></li> <li>expected display: <code>word1     word2</code> (5 spaces)</li> </ul> </li> </ul> </li> <li> <p><code>Paragraph(\"word1     word2\", formatted=False)</code></p> <ul> <li>new behavior:<ul> <li>product XML:  <code>'&lt;text:p&gt;word1 word2&lt;/text:p&gt;'</code></li> <li>expected display: <code>word1 word2</code></li> </ul> </li> </ul> </li> <li> <p><code>Paragraph(\"word1\\nword2\")</code></p> <ul> <li> <p>previous behavior:</p> <ul> <li>product XML:  <code>'&lt;text:p&gt;word1\\nword2&lt;/text:p&gt;'</code></li> <li>expected display: <code>word1 word2</code> (single space, the ODF standard does not recognize \u201c\\n\u201d in XML content)</li> </ul> </li> <li> <p>new behavior:</p> <ul> <li>product XML:  <code>'&lt;text:p&gt;word1&lt;text:line-break/&gt;word2&lt;/text:p&gt;'</code></li> <li>expected display:     <pre><code>word1\nword2\n</code></pre></li> </ul> </li> </ul> </li> <li> <p><code>Paragraph(\"word1\\nword2\", formatted=False)</code></p> <ul> <li>new behavior:<ul> <li>product XML:  <code>'&lt;text:p&gt;word1 word2&lt;/text:p&gt;'</code></li> <li>expected display: <code>word1 word2</code></li> </ul> </li> </ul> </li> </ul> <p>On the same principle the <code>\"formatted\"</code> argument is available for <code>Pararaph.append(text)</code>, <code>Header(text)</code>, <code>Span(text)</code>.</p> <p>The <code>Paragraph.append_plain_text(text)</code> method is retained for compatibility with previous versions and has the same behavior as <code>Paragraph.append(text, formatted=True)</code>, the default.</p>"},{"location":"CHANGES.html#changed_21","title":"Changed","text":"<ul> <li> <p><code>Paragraph()</code>, <code>Paragraph.append()</code> and subclasses <code>Header()</code> and <code>Span()</code> have a new <code>\"formatted\"</code> argument True by default that translates into ODF format \u201c\\n\u201d, \u201c\\t\u201d and multiples spaces.</p> </li> <li> <p>Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#3713-2024-08-17","title":"[3.7.13] - 2024-08-17","text":"<ul> <li>Fix parsing of Date and Datetime for a better compliance with ISO8601.</li> </ul>"},{"location":"CHANGES.html#changed_22","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#fixed_10","title":"Fixed","text":"<ul> <li> <p>Fix datetime encoding/decoding for ISO8601 compliance and different Python versions.</p> </li> <li> <p>Move from strptime() to date.isoformat() for class Date and DateTime.</p> </li> </ul>"},{"location":"CHANGES.html#3712-2024-08-11","title":"[3.7.12] - 2024-08-11","text":"<ul> <li>Update dependencies and test suite, support of <code>lxml</code> version 5.3.0.</li> </ul>"},{"location":"CHANGES.html#changed_23","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#fixed_11","title":"Fixed","text":"<ul> <li> <p>Fix a type hint in element.py</p> </li> <li> <p>Fix missing .venv in gitconfig</p> </li> </ul>"},{"location":"CHANGES.html#3711-2024-05-25","title":"[3.7.11] - 2024-05-25","text":"<ul> <li>New script <code>odfdo-userfield</code> to show or set the user-field content in an ODF file.</li> </ul>"},{"location":"CHANGES.html#added_17","title":"Added","text":"<ul> <li>Add script <code>odfdo-userfield</code>.</li> </ul>"},{"location":"CHANGES.html#changed_24","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#3710-2024-05-4","title":"[3.7.10] - 2024-05-4","text":"<ul> <li> <p>Refactor to add property getter for some common methods. Original get_*     method is still available and permits detailed requests with parameters.</p> <pre><code>-   Body.tables -&gt; Body.get_tables()\n-   Element.tocs -&gt; Element.get_tocs()\n-   Element.toc -&gt; Element.get_toc()\n-   Element.text_changes -&gt; Element.get_text_changes()\n-   Element.tracked_changes -&gt; Element.get_tracked_changes()\n-   Element.user_defined_list -&gt; Element.get_user_defined_list()\n-   Element.images -&gt; Element.get_images()\n-   Element.frames -&gt; Element.get_frames()\n-   Element.lists -&gt; Element.get_lists()\n-   Element.headers -&gt; Element.get_headers()\n-   Element.spans -&gt; Element.get_spans()\n-   Element.paragraphs -&gt; Element.get_paragraphs()\n-   Element.sections -&gt; Element.get_sections()\n-   Table.rows -&gt; Table.get_rows()\n-   Table.cells -&gt; Table.get_cells()\n-   Table.columns -&gt; Table.get_columns()\n-   Row.cells -&gt; Row.get_cells()\n-   Document.parts -&gt; Document.get_parts()\n-   Container.parts -&gt; Container.get_parts()\n</code></pre> </li> <li> <p>Refactor to add property getter/setter for some common methods. Original get_*     and set_* methods are still available and permit detailed requests with parameters.</p> <pre><code>-   Column.default_cell_style -&gt; Column.get/set_default_cell_style()\n</code></pre> </li> </ul>"},{"location":"CHANGES.html#added_18","title":"Added","text":"<ul> <li>Added <code>Body.tables</code></li> <li>Added <code>Element.tocs</code></li> <li>Added <code>Element.toc</code></li> <li>Added <code>Element.text_changes</code></li> <li>Added <code>Element.tracked_changes</code></li> <li>Added <code>Element.images</code></li> <li>Added <code>Element.frames</code></li> <li>Added <code>Element.lists</code></li> <li>Added <code>Element.headers</code></li> <li>Added <code>Element.spans</code></li> <li>Added <code>Element.paragraphs</code></li> <li>Added <code>Element.sections</code></li> <li>Added <code>Column.default_cell_style</code></li> <li>Added <code>Table.rows</code></li> <li>Added <code>Table.cells</code></li> <li>Added <code>Table.columns</code></li> <li>Added <code>Row.cells</code></li> <li>Added <code>Document.parts</code></li> <li>Added <code>Container.parts</code></li> </ul>"},{"location":"CHANGES.html#379-2024-05-3","title":"[3.7.9] - 2024-05-3","text":"<ul> <li> <p>Refactor the Body access methods, creating relevant a Body class and related sub-classes. Moved some access method from the Element class to relevant Body sub-classes.</p> </li> <li> <p>Refactor metadata methods to permit access throuh @property (the legacy get_* and set_* methods are still available).</p> </li> <li> <p>Added a few metadata elements from the ODF standard (hyperlink-behaviour, auto-reload, template, print-dateprinted-by)</p> </li> </ul>"},{"location":"CHANGES.html#added_19","title":"Added","text":"<ul> <li>Added <code>MetaAutoReload</code> class</li> <li>Added <code>MetaHyperlinkBehaviour</code> class</li> <li>Added <code>MetaTemplate</code> class</li> <li>Added <code>DcCreatorMixin</code> class</li> <li>Added <code>DcDateMixin</code> class</li> <li>Added <code>Body</code> class</li> <li>Added <code>Chart</code> class</li> <li>Added <code>Database</code> class</li> <li>Added <code>Drawing</code> class</li> <li>Added <code>Image</code> class</li> <li>Added <code>Presentation</code> class</li> <li>Added <code>Spreadsheet</code> class</li> <li>Added <code>Text</code> class (renaming the previous internal <code>Text</code> class to <code>EText</code>)</li> </ul>"},{"location":"CHANGES.html#378-2024-05-2","title":"[3.7.8] - 2024-05-2","text":"<p>Fix embedded chart analysis in documents, see recipe <code>change_values_of_a_chart_inside_a_document.py</code>.</p>"},{"location":"CHANGES.html#added_20","title":"Added","text":"<ul> <li>Added <code>change_values_of_a_chart_inside_a_document.py</code> recipe</li> </ul>"},{"location":"CHANGES.html#changed_25","title":"Changed","text":"<ul> <li> <p>The \u201cpretty\u201d setting when saving the file always defaults to False. This setting should only be used for debugging purposes</p> </li> <li> <p><code>meta.generator</code> can be used via a @property accessor</p> </li> <li> <p>(Internal change) move body() definition to xmlpart</p> </li> <li> <p>(Internal change) refactoring for future XML feature</p> </li> </ul>"},{"location":"CHANGES.html#fixed_12","title":"Fixed","text":"<ul> <li> <p>Fix parsing of Table when parent uses \u201ctable:table-rows\u201d kind of wrapper</p> </li> <li> <p>Fix a bug when a Cell contains the valid \u2018NaN\u2019 Decimal number</p> </li> </ul>"},{"location":"CHANGES.html#377-2024-04-1","title":"[3.7.7] - 2024-04-1","text":"<p>Improvement of the <code>lxml</code> dependency support.</p>"},{"location":"CHANGES.html#added_21","title":"Added","text":"<ul> <li> <p>Added a <code>CHANGES.md</code> file</p> </li> <li> <p>Automatic tests for ubuntu-latest, macos-latest, windows-latest</p> </li> </ul>"},{"location":"CHANGES.html#changed_26","title":"Changed","text":"<ul> <li> <p>Now supports a wider range of <code>lxml</code> versions:</p> <ul> <li> <p>python 3.9: lxml version 4.8.0 to 4.9.4</p> </li> <li> <p>python 3.10: lxml version 4.8.0 to 5.1.1</p> </li> <li> <p>python 3.11: lxml version 4.9.4 to 5.2.0 and beyond</p> </li> <li> <p>python 3.12: lxml version 4.9.4 to 5.2.0 and beyond</p> </li> </ul> </li> <li> <p>autogenerated documentation now uses <code>mkdocs</code></p> </li> </ul>"},{"location":"CHANGES.html#fixed_13","title":"Fixed","text":"<ul> <li> <p>Use <code>sys.executable</code> to ensure all tests can pass in a github virtualenv on Windows.</p> </li> <li> <p>Remove import of <code>lxml</code> internal <code>\\_ElementUnicodeResult</code> and <code>\\_ElementUnicodeResult</code> classes.</p> </li> </ul>"},{"location":"CHANGES.html#376-2024-03-30","title":"[3.7.6] - 2024-03-30","text":"<p>Quick fix for the crash with new <code>lxml</code> version 5.1.1</p>"},{"location":"CHANGES.html#fixed_14","title":"Fixed","text":"<pre><code>- Fix crash with `lxml` 5.1.1 by restricting version do 5.1.0\n</code></pre>"},{"location":"CHANGES.html#375-2024-03-23","title":"[3.7.5] - 2024-03-23","text":"<p>Add the method <code>get_cell_background_color</code> to retrieve the background color of a cell in a table.</p>"},{"location":"CHANGES.html#added_22","title":"Added","text":"<ul> <li> <p>Tables: some users need to easily access the background color of cells, including cells without \u201cvalue\u201d content. That was requiring a complex parsing of styles. So a new method: <code>Document.get_cell_background_color(sheet_id, cell_coords)</code>.</p> </li> <li> <p>See the corresponding recipe <code>recipes/get_cell_background_color.py</code> for an exemple of usage.</p> </li> <li> <p>Tables: (related to previous). It is often useful to reduce the table size before working on it, especially if styles apply to whole rows. A method called <code>Table.rstrip()</code> already permitted to remove empty bottom rows and empty right columns. However, a <code>Cell</code> mays have no value but a style (color background for example), and <code>rstrip()</code> was removing such cells. So an new clever method is provided: <code>Table.optimize_width()</code> that shrink the table size, still keeping styled empty cells.</p> </li> <li> <p>To test the actual result of this method, you can use the new script <code>odfdo-table-shrink</code> which is basically a wrapper upon this method. (Note: all this stuff aims to facilitate some feature for the related github project <code>odsparsator</code>).</p> </li> <li> <p><code>repr()</code> method for <code>Cell</code>, <code>Row</code> and <code>Column</code>.</p> </li> <li> <p>Ancillary methods related to above features.</p> </li> </ul>"},{"location":"CHANGES.html#fixed_15","title":"Fixed","text":"<ul> <li><code>Document(path)</code> now accepts a <code>str</code> path starting with <code>~</code> as the path relative to the user home.</li> </ul>"},{"location":"CHANGES.html#changed_27","title":"Changed","text":"<ul> <li> <p>Tables: (related to previous), change the <code>Cell.is_empty()</code> test. A cell is now considered as not empty if part of a <code>span</code> (a cell spanned on several rows or columns). This may induce some changes for parsing scripts. Before that, only the first cell of the span (which actually contains the value) was considered as non empty. Now other cells of the span are not empty (but contain a null value).</p> </li> <li> <p>Minor refactor of code, version updates of dependencies.</p> </li> </ul>"},{"location":"CHANGES.html#374-2024-03-17","title":"[3.7.4] - 2024-03-17","text":"<p>Add a recipe as example of programmatically setting text styles for headers and paragraphs, with basic font and color properties.</p>"},{"location":"CHANGES.html#added_23","title":"Added","text":"<ul> <li> <p>Add recipe <code>create_basic_text_styles</code>.</p> </li> <li> <p>All style fields related to color accept a color name from the CSS list of color.</p> </li> </ul>"},{"location":"CHANGES.html#changed_28","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#373-2024-03-10","title":"[3.7.3] - 2024-03-10","text":"<p>Internal maintenance release.</p>"},{"location":"CHANGES.html#fixed_16","title":"Fixed","text":"<ul> <li>Fix logo link on <code>Pypi</code> page.</li> </ul>"},{"location":"CHANGES.html#changed_29","title":"Changed","text":"<ul> <li> <p>Technical updates from <code>optparse</code> to <code>argparse</code>.</p> </li> <li> <p>Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#372-2024-03-9","title":"[3.7.2] - 2024-03-9","text":"<p>Internal maintenance release.</p>"},{"location":"CHANGES.html#changed_30","title":"Changed","text":"<ul> <li> <p>Use <code>pdoc</code> for autogenerated documentation.</p> </li> <li> <p>Refactor some recipes to use them in a test suit.</p> </li> <li> <p>Code refactor, Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#371-2024-03-3","title":"[3.7.1] - 2024-03-3","text":"<p>Minor performance improvement of script <code>odfdo-headers</code>.</p>"},{"location":"CHANGES.html#changed_31","title":"Changed","text":"<ul> <li>Use better algorithm for script <code>odfdo-headers</code>.</li> </ul>"},{"location":"CHANGES.html#370-2024-03-2","title":"[3.7.0] - 2024-03-2","text":"<p>New script <code>odfdo-headers</code> to print the headers of a <code>ODF</code> file.</p>"},{"location":"CHANGES.html#added_24","title":"Added","text":"<ul> <li>Add script <code>odfdo-headers</code>.</li> </ul>"},{"location":"CHANGES.html#changed_32","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#360-2024-02-25","title":"[3.6.0] - 2024-02-25","text":"<p>New script <code>odfdo-highlight</code> to highlight the text matching a pattern (regex) in a <code>ODF</code> file.</p>"},{"location":"CHANGES.html#added_25","title":"Added","text":"<ul> <li>Add script <code>odfdo-highlight</code>.</li> </ul>"},{"location":"CHANGES.html#changed_33","title":"Changed","text":"<ul> <li>Updating dependency versions.</li> </ul>"},{"location":"CHANGES.html#351-2024-02-20","title":"[3.5.1] - 2024-02-20","text":"<p>Fix the update method of <code>Table of Content</code> and add a recipe to show how to update a <code>TOC</code>.</p>"},{"location":"CHANGES.html#added_26","title":"Added","text":"<ul> <li>Add recipe <code>update_a_text_document_with_a_table_of_content</code>.</li> </ul>"},{"location":"CHANGES.html#changed_34","title":"Changed","text":"<ul> <li> <p>Refactor of TOC related code.</p> </li> <li> <p>Updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#350-2024-01-27","title":"[3.5.0] - 2024-01-27","text":"<p>2024 release, updated ODF templates and better test suit.</p>"},{"location":"CHANGES.html#changed_35","title":"Changed","text":"<ul> <li> <p>Update <code>ODF</code> templates.</p> </li> <li> <p>Refactor many Python files for use of type hints.</p> </li> <li> <p>Updates for year 2024, updating dependency versions.</p> </li> </ul>"},{"location":"CHANGES.html#347-2024-01-15","title":"[3.4.7] - 2024-01-15","text":"<p>Updade to <code>lxml</code> version 5.</p>"},{"location":"CHANGES.html#changed_36","title":"Changed","text":"<pre><code>- Update `lxml` from version 4 to 5.\n</code></pre>"},{"location":"CHANGES.html#346-2023-12-25","title":"[3.4.6] - 2023-12-25","text":"<p>Add script <code>odfdo-replace</code> to find a pattern (regex) in an <code>ODF</code> file and replace by some string.</p>"},{"location":"CHANGES.html#fixed_17","title":"Fixed","text":"<ul> <li>Fix reading content from a <code>BytesIO</code>.</li> </ul>"},{"location":"CHANGES.html#changed_37","title":"Changed","text":"<ul> <li>Add script <code>odfdo-replace</code>.</li> </ul>"},{"location":"CHANGES.html#345-2023-12-24","title":"[3.4.5] - 2023-12-24","text":"<p>Add recipes showing how to save/read document from <code>io.BytesIO</code>.</p>"},{"location":"CHANGES.html#added_27","title":"Added","text":"<ul> <li>Add recipes <code>read_document_from_bytesio.py</code> and <code>save_document_as_bytesio.py</code>.</li> </ul>"},{"location":"CHANGES.html#changed_38","title":"Changed","text":"<ul> <li>Refactoring of code.</li> </ul>"},{"location":"recipes.html","title":"Recipes","text":"<p>Recipes source code is in the <code>/recipes</code> directory of <code>odfdo</code> sources. Most recipes are autonomous scripts doing actual modifications of ODF sample files, you can check the results in the <code>recipes/recipes_output</code> directory.</p>"},{"location":"recipes.html#how-to-write-hello-world-in-a-text-document","title":"How to write hello world in a text document","text":"<p>Create a basic spreadsheet with \u201cHello World\u201d in the first cell.</p> recipes/how_to_write_hello_world_in_a_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic spreadsheet with \"Hello World\" in the first cell.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Paragraph\n\n_DOC_SEQUENCE = 3\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_hello\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n    paragraph = Paragraph(\"Hello World\")\n    body.append(paragraph)\n\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    text = str(document.body)\n    print(text)\n    assert text == \"Hello World\\n\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-write-hello-world-in-a-spreadsheet-document","title":"How to write hello world in a spreadsheet document","text":"<p>Create a basic spreadsheet with \u201cHello World\u201d in the first cell.</p> recipes/how_to_write_hello_world_in_a_spreadsheet_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic spreadsheet with \"Hello World\" in the first cell.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Table\n\n_DOC_SEQUENCE = 5\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_ods\"\nTARGET = \"document.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"spreadsheet\")\n    body = document.body\n    body.clear()\n\n    table = Table(\"Empty Table\")\n    table.set_value(\"A1\", \"Hello World\")\n    body.append(table)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    text = document.body.get_table(0).get_cell((0, 0)).value.strip()\n    print(text)\n    assert text == \"Hello World\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#basic-presentation-hello-world","title":"Basic presentation hello world","text":"<p>Write a basic \u201cHello World\u201d in the middle of the first page of a presentation.</p> recipes/basic_presentation_hello_world.py <pre><code>#!/usr/bin/env python\n\"\"\"Write a basic \"Hello World\" in the middle of the first page\nof a presentation.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, DrawPage, Frame\n\n_DOC_SEQUENCE = 7\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_odp\"\nTARGET = \"hello.odp\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef add_text_frame(document: Document, text: str) -&gt; None:\n    \"\"\"Add a text frame to an empty presentation.\"\"\"\n    body = document.body\n    body.clear()\n\n    page = DrawPage(\"page1\", name=\"Page 1\")\n    text_frame = Frame.text_frame(\n        text,\n        size=(\"7cm\", \"5cm\"),\n        position=(\"11cm\", \"8cm\"),\n        style=\"Standard\",\n        text_style=\"Standard\",\n    )\n    page.append(text_frame)\n    body.append(page)\n\n\ndef main() -&gt; None:\n    document = Document(\"presentation\")\n    add_text_frame(document, \"Hello world!\")\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    frames = document.body.get_frames()\n    assert len(frames) == 1\n    assert str(frames[0]).strip() == \"Hello world!\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-text-document","title":"Create a basic text document","text":"<p>Create a basic text document with headers and praragraphs.</p> recipes/create_a_basic_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic text document with headers and praragraphs.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph\n\n_DOC_SEQUENCE = 10\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_text\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef create_basic_document():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n    body.append(Header(1, \"De la Guerre des Gaules - Livre V\"))\n    body.append(Header(2, \"Pr\u00e9paratifs d'exp\u00e9dition en Bretagne\"))\n    body.append(\n        Paragraph(\n            \"Sous le consulat de Lucius Domitius et d'Appius Claudius, \"\n            \"C\u00e9sar, quittant les quartiers d'hiver pour aller en Italie, \"\n            \"comme il avait coutume de le faire chaque ann\u00e9e, ordonne aux \"\n            \"lieutenants qu'il laissait \u00e0 la t\u00eate des l\u00e9gions de construire, \"\n            \"pendant l'hiver, le plus de vaisseaux qu'il serait possible, \"\n            \"et de r\u00e9parer les anciens.\"\n        )\n    )\n    body.append(Header(2, \"La Bretagne\"))\n    body.append(\n        Paragraph(\n            \"Cette \u00eele est de forme triangulaire ; l'un des c\u00f4t\u00e9s regarde \"\n            \"la Gaule. Des deux angles de ce c\u00f4t\u00e9, l'un est au levant, \"\n            \"vers le pays de Cantium, o\u00f9 abordent presque tous les vaisseaux \"\n            \"gaulois ; l'autre, plus bas, est au midi. La longueur de ce c\u00f4t\u00e9 \"\n            \"est d'environ cinq cent mille pas. \"\n        )\n    )\n    return document\n\n\ndef main():\n    document = create_basic_document()\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    text = str(document.body.get_paragraph(position=1))\n    print(text)\n    assert text.startswith(\"Cette \u00eele est de forme triangulaire\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-paragraph-to-a-text-document","title":"How to add a paragraph to a text document","text":"<p>Minimal example of how to add a paragraph.</p> recipes/how_to_add_a_paragraph_to_a_text_document.py <pre><code>\"\"\"Minimal example of how to add a paragraph.\n\"\"\"\n\nfrom odfdo import Document, Paragraph\n\n_DOC_SEQUENCE = 12\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n\n    # create a new paragraph with some content :\n    paragraph = Paragraph(\"Hello World\")\n    body.append(paragraph)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-text-document-with-a-list","title":"Create a basic text document with a list","text":"<p>Create a basic text document with a list.</p> recipes/create_a_basic_text_document_with_a_list.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic text document with a list.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, List, ListItem\n\n_DOC_SEQUENCE = 20\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_list\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = generate_document()\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef generate_document():\n    # Create the document\n    document = Document(\"text\")\n    body = document.body\n\n    # Adding List\n    my_list = List([\"Arthur\", \"Ford\", \"Trillian\"])\n    # The list accepts a Python list of strings and list items.\n\n    # The list can be written even though we will modify it afterwards:\n    body.append(my_list)\n\n    # Adding more List Item to the list\n    item = ListItem(\"Marvin\")\n    my_list.append_item(item)\n\n    # it should contain:\n    print(document.get_formatted_text())\n    # - Arthur\n    # - Ford\n    # - Trillian\n    # - Marvin\n\n    return document\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    assert str(document).strip() == \"- Arthur\\n- Ford\\n- Trillian\\n- Marvin\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-text-document-with-list-and-sublists","title":"Create a basic text document with list and sublists","text":"<p>Create a basic text document with list and sublists.</p> recipes/create_a_basic_text_document_with_list_and_sublists.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic text document with list and sublists.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, List, ListItem\n\n_DOC_SEQUENCE = 25\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_sublist\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = generate_document()\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef generate_document():\n    document = Document(\"text\")\n    body = document.body\n\n    # Adding List\n    name_list = List([\"Arthur\", \"Ford\", \"Trillian\"])\n    item = ListItem(\"Marvin\")\n    name_list.append_item(item)\n    body.append(name_list)\n\n    # Adding Sublist\u00b6\n    # A sublist is simply a list as an item of another list:\n    item.append(List([\"Paranoid Android\", \"older than the universe\"]))\n\n    # See the result:\n    print(document.get_formatted_text())\n    # - Arthur\n    # - Ford\n    # - Trillian\n    # - Marvin\n    #   - Paranoid Android\n    #   - older than the universe\n\n    # Inserting List Item\n    # In case your forgot to insert an item:\n    name_list.insert_item(\"some dolphins\", position=1)\n\n    # Or you can insert it before another item:\n    marvin = name_list.get_item(content=\"Marvin\")\n    name_list.insert_item(\"Zaphod\", before=marvin)\n    # Or after:\n    name_list.insert_item(\"and many others\", after=marvin)\n\n    # See the result:\n    print(document.get_formatted_text())\n    # - Arthur\n    # - some dolphins\n    # - Ford\n    # - Trillian\n    # - Zaphod\n    # - Marvin\n    #   - Paranoid Android\n    #   - older than the universe\n    # - and many others\n    #\n\n    return document\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    assert document.get_formatted_text().strip() == (\n        \"- Arthur\\n\"\n        \"- some dolphins\\n\"\n        \"- Ford\\n\"\n        \"- Trillian\\n\"\n        \"- Zaphod\\n\"\n        \"- Marvin\\n\"\n        \"  \\n\"\n        \"  - Paranoid Android\\n\"\n        \"  - older than the universe\\n\"\n        \"- and many others\"\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-sublist-to-a-list","title":"How to add a sublist to a list","text":"<p>Minimal example of how to add a paragraph.</p> recipes/how_to_add_a_sublist_to_a_list.py <pre><code>\"\"\"Minimal example of how to add a paragraph.\n\"\"\"\n\nfrom odfdo import Document, List, ListItem\n\n_DOC_SEQUENCE = 27\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n\n    my_list = List([\"chocolat\", \"caf\u00e9\"])\n    body.append(my_list)\n\n    item = ListItem(\"th\u00e9\")\n    my_list.append(item)\n\n    # A sublist is simply a list as an item of another list\n    item.append(List([\"th\u00e9 vert\", \"th\u00e9 rouge\"]))\n\n    print(body.serialize(True))\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-insert-a-new-item-within-a-list","title":"How to insert a new item within a list","text":"<p>Minimal example of how to insert a new item within a list.</p> recipes/how_to_insert_a_new_item_within_a_list.py <pre><code>\"\"\"Minimal example of how to insert a new item within a list.\n\"\"\"\n\nfrom odfdo import List\n\n_DOC_SEQUENCE = 28\n\n\ndef main():\n\n    a_list = List([\"chocolat\", \"caf\u00e9\"])\n\n    # In case your forgot to insert an important item:\n    a_list.insert_item(\"Chicor\u00e9e\", position=1)\n\n    # Or you can insert it before another item:\n    cafe = a_list.get_item(content=\"caf\u00e9\")\n    a_list.insert_item(\"Chicor\u00e9e\", before=cafe)\n\n    # Or after:\n    a_list.insert_item(\"Chicor\u00e9e\", after=cafe)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-an-item-to-a-list","title":"How to add an item to a list","text":"<p>Minimal example of how to add an item to a list.</p> recipes/how_to_add_an_item_to_a_list.py <pre><code>\"\"\"Minimal example of how to add an item to a list.\n\"\"\"\n\nfrom odfdo import List, ListItem\n\n_DOC_SEQUENCE = 28\n\n\ndef main():\n    a_list = List([\"chocolat\", \"caf\u00e9\"])\n    item = ListItem(\"th\u00e9\")\n    a_list.append(item)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#get-text-content-from-odt-file","title":"Get text content from odt file","text":"<p>Read the text content from an .odt file.</p> recipes/get_text_content_from_odt_file.py <pre><code>#!/usr/bin/env python\n\"\"\"Read the text content from an .odt file.\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 30\nDATA = Path(__file__).parent / \"data\"\n# ODF export of Wikipedia article Hitchhiker's Guide to the Galaxy (CC-By-SA) :\nSOURCE = \"collection2.odt\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef read_text_content(document: Document) -&gt; str:\n    # just verify what type of document it is:\n    print(\"Type of document:\", document.get_type())\n    # A quick way to get the text content:\n    text = document.get_formatted_text()\n\n    print(\"Size :\", len(text))\n\n    # Let's show the beginning :\n    print(text[:320])\n\n    return text\n\n\ndef main() -&gt; None:\n    document = read_source_document()\n    text = read_text_content(document)\n    test_unit(text)\n\n\ndef test_unit(text: str) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert len(text) == 56828\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-text-document-with-a-table-of-content","title":"Create a basic text document with a table of content","text":"<p>Create a basic text document with a table of content.</p> recipes/create_a_basic_text_document_with_a_table_of_content.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic text document with a table of content.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import TOC, Document, Header, Paragraph\n\n_DOC_SEQUENCE = 35\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_toc\"\nDATA = Path(__file__).parent / \"data\"\nLOREM = (DATA / \"lorem.txt\").read_text(encoding=\"utf8\")\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"text\")\n    make_toc(document)\n    save_new(document, TARGET)\n\n\ndef make_toc(document):\n    # Create the document\n    body = document.body\n\n    # Create the Table Of Content\n    toc = TOC()\n    # Changing the default \"Table Of Content\" Title :\n    toc.title = \"My Table of Content\"\n\n    # Do not forget to add the component to the document:\n    body.append(toc)\n\n    # Add some content with headers\n    title1 = Header(1, LOREM[:70])\n    body.append(title1)\n    for idx in range(3):\n        title = Header(2, LOREM[idx * 5 : 70 + idx * 5])\n        body.append(title)\n        paragraph = Paragraph(LOREM)\n        body.append(paragraph)\n\n    # Beware, update the TOC with the actual content. If not done there,\n    # the reader will need to \"update the table of content\" later.\n    toc.fill()\n\n    # only for test suite:\n    if \"ODFDO_TESTING\" in os.environ:\n        assert str(toc).split(\"\\n\")[2] == (\n            \"1.1. Lorem ipsum dolor sit amet, consectetuer \"\n            \"adipiscing elit. Sed non risu\"\n        )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-table-of-content-to-a-document","title":"How to add a table of content to a document","text":"<p>Adding a table of content to an existing text document.</p> recipes/how_to_add_a_table_of_content_to_a_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Adding a table of content to an existing text document.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import TOC, Document, Paragraph, Style\n\n_DOC_SEQUENCE = 37\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"add_toc\"\nTARGET = \"document.odt\"\nDATA = Path(__file__).parent / \"data\"\nSOURCE = DATA / \"collection.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(SOURCE)\n    body = document.body\n\n    # here is a way to insert a page break:\n    page_break_style = Style(\"paragraph\", name=\"page_break\")\n    page_break_style.set_properties({\"fo:break-before\": \"page\"})\n    document.insert_style(page_break_style)\n    empty_paragraph = Paragraph(\"\", style=\"page_break\")\n    body.insert(empty_paragraph, 0)\n\n    # The TOC element comes from the toc module\n    toc = TOC()\n    # to put the TOC at the end, just do:\n    # body.append(toc)\n    body.insert(toc, 0)\n    # fill the toc with current content of document:\n    toc.fill()\n\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#update-a-text-document-with-a-table-of-content","title":"Update a text document with a table of content","text":"<p>Update the table of contents of a document.</p> recipes/update_a_text_document_with_a_table_of_content.py <pre><code>#!/usr/bin/env python\n\"\"\"Update the table of contents of a document.\n\"\"\"\n\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph\n\n_DOC_SEQUENCE = 38\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"doc_with_toc.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"modified_toc\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main() -&gt; None:\n    document = Document(DATA / SOURCE)\n    update_toc(document)\n    save_new(document, TARGET)\n\n\ndef update_toc(document: Document) -&gt; None:\n    check_toc_v1(document)\n    add_some_header(document)\n    check_toc_v2(document)\n    change_toc_title(document)\n    check_toc_v3(document)\n    change_toc_title_to_empty(document)\n    check_toc_v4(document)\n    remove_second_header_1b(document)\n    check_toc_v5(document)\n    add_toc_title(document)\n    check_toc_v6(document)\n\n\ndef check_toc_v1(document: Document) -&gt; None:\n    toc = document.body.toc\n    content = str(toc).split(\"\\n\")\n    assert len(content) == 5\n    assert content[0].startswith(\"Table of Contents\")\n    assert content[1].startswith(\"1. Lorem 1\")\n    assert content[2].startswith(\"1.1. Lorem 1A\")\n    assert content[3].startswith(\"1.2. Lorem 1B\")\n    assert content[4].startswith(\"1.3. Lorem 1C\")\n\n\ndef add_some_header(document: Document) -&gt; None:\n    header = Header(1, \"New header\")\n    document.body.append(header)\n    document.body.append(Paragraph(\"Some text after the new header.\"))\n    # update the table of contents\n    toc = document.body.toc\n    toc.fill(document)\n\n\ndef check_toc_v2(document: Document) -&gt; None:\n    toc = document.body.toc\n    content = str(toc).split(\"\\n\")\n    assert len(content) == 6\n    assert content[0].startswith(\"Table of Contents\")\n    assert content[1].startswith(\"1. Lorem 1\")\n    assert content[2].startswith(\"1.1. Lorem 1A\")\n    assert content[3].startswith(\"1.2. Lorem 1B\")\n    assert content[4].startswith(\"1.3. Lorem 1C\")\n    assert content[5].startswith(\"2. New header\")\n\n\ndef change_toc_title(document: Document) -&gt; None:\n    toc = document.body.toc\n    toc.set_toc_title(\"Another title\")\n    toc.fill(document)\n\n\ndef check_toc_v3(document: Document) -&gt; None:\n    toc = document.body.toc\n    content = str(toc).split(\"\\n\")\n    assert len(content) == 6\n    assert content[0].startswith(\"Another title\")\n\n\ndef change_toc_title_to_empty(document: Document) -&gt; None:\n    toc = document.body.toc\n    toc.set_toc_title(\"\")  # that will remove the title\n    toc.fill(document)\n\n\ndef check_toc_v4(document: Document) -&gt; None:\n    toc = document.body.toc\n    content = str(toc).split(\"\\n\")\n    assert len(content) == 5\n    assert content[0].startswith(\"1. Lorem 1\")\n    assert content[1].startswith(\"1.1. Lorem 1A\")\n    assert content[2].startswith(\"1.2. Lorem 1B\")\n    assert content[3].startswith(\"1.3. Lorem 1C\")\n    assert content[4].startswith(\"2. New header\")\n\n\ndef remove_second_header_1b(document: Document) -&gt; None:\n    # find second header:\n    header = document.body.get_header(position=2)\n    # this 'header' variable is attached to the document, so\n    # deleting will remove the element from the document\n    header.delete()\n\n    toc = document.body.toc\n    toc.fill(document)\n\n\ndef check_toc_v5(document: Document) -&gt; None:\n    toc = document.body.toc\n    content = str(toc).split(\"\\n\")\n    assert len(content) == 4\n    assert content[0].startswith(\"1. Lorem 1\")\n    assert content[1].startswith(\"1.1. Lorem 1A\")\n    assert content[2].startswith(\"1.2. Lorem 1C\")\n    assert content[3].startswith(\"2. New header\")\n\n\ndef add_toc_title(document: Document) -&gt; None:\n    toc = document.body.toc\n    toc.set_toc_title(\"A new title\")\n    toc.fill(document)\n\n\ndef check_toc_v6(document: Document) -&gt; None:\n    toc = document.body.toc\n    content = str(toc).split(\"\\n\")\n    assert len(content) == 5\n    assert content[0].startswith(\"A new title\")\n    assert content[1].startswith(\"1. Lorem 1\")\n    assert content[2].startswith(\"1.1. Lorem 1A\")\n    assert content[3].startswith(\"1.2. Lorem 1C\")\n    assert content[4].startswith(\"2. New header\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-text-document-with-annotations","title":"Create a basic text document with annotations","text":"<p>Create a basic text document with annotations.</p> recipes/create_a_basic_text_document_with_annotations.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic text document with annotations.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph\n\n_DOC_SEQUENCE = 40\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_annotations\"\nDATA = Path(__file__).parent / \"data\"\nLOREM = (DATA / \"lorem.txt\").read_text(encoding=\"utf8\")\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"text\")\n    make_annotations(document)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef make_annotations(document):\n    body = document.body\n    title1 = Header(1, \"Main title\")\n    body.append(title1)\n    for index in range(3):\n        title = Header(2, f\"title {index}\")\n        body.append(title)\n        paragraph = Paragraph(LOREM[:240])\n\n        # Adding Annotation\n        # Annotations are notes that don't appear in the document but\n        # typically on a side bar in a desktop application. So they are not printed.\n\n        # Now we add some annotation on each paragraph\n        some_word = str(paragraph).split()[3]\n        # choosing the 4th word of the paragraph to insert the note\n\n        paragraph.insert_annotation(\n            after=some_word,  # The word after what the annotation is inserted.\n            body=\"It's so easy!\",  # The annotation itself, at the end of the page.\n            creator=\"Bob\",  # The author of the annotation.\n            # date= xxx              A datetime value, by default datetime.now().\n        )\n\n        body.append(paragraph)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    assert len(document.body.get_annotations(creator=\"Bob\")) == 3\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-text-document-with-footnotes","title":"Create a basic text document with footnotes","text":"<p>Create a basic text document with footnotes.</p> recipes/create_a_basic_text_document_with_footnotes.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a basic text document with footnotes.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph\n\n_DOC_SEQUENCE = 45\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_footnotes\"\nDATA = Path(__file__).parent / \"data\"\nLOREM = (DATA / \"lorem.txt\").read_text(encoding=\"utf8\")\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"text\")\n    make_footnotes(document)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef make_footnotes(document):\n    body = document.body\n\n    # Add content (See Create_a_basic_document.py)\n    title1 = Header(1, \"Main title\")\n    body.append(title1)\n    for index in range(3):\n        title = Header(2, f\"title {index}\")\n        body.append(title)\n        paragraph = Paragraph(LOREM[:240])\n\n        # Adding Footnote\n        # Now we add a footnote on each paragraph\n        # Notes are quite complex so they deserve a dedicated API on paragraphs:\n        some_word = str(paragraph).split()[3]\n        # choosing the 4th word of the paragraph to insert the note\n        paragraph.insert_note(\n            after=some_word,  # The word after what the \u201c\u00b9\u201d citation is inserted.\n            note_id=f\"note{index}\",  # The unique identifier of the note in the document.\n            citation=\"1\",  # The symbol the user sees to follow the footnote.\n            body=(\n                f'Author{index}, A. (2007). \"How to cite references\", Sample Editions.'\n                # The footnote itself, at the end of the page.\n            ),\n        )\n\n        body.append(paragraph)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    assert len(document.body.get_notes()) == 3\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-footnote-to-a-text-document","title":"How to add footnote to a text document","text":"<p>Minimal example of how to add an footnote to a text document.</p> recipes/how_to_add_footnote_to_a_text_document.py <pre><code>\"\"\"Minimal example of how to add an footnote to a text document.\n\"\"\"\n\nfrom odfdo import Document, Paragraph\n\n_DOC_SEQUENCE = 47\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n\n    paragraph = Paragraph(\"A paragraph with a footnote about some references.\")\n    body.append(paragraph)\n\n    # Notes are quite complex so they deserve a dedicated API on paragraphs:\n    paragraph.insert_note(\n        after=\"graph\",\n        note_id=\"note1\",\n        citation=\"1\",\n        body='Author, A. (2007). \"How to cite references\" New York: McGraw-Hill.',\n    )\n\n    # That looks complex so we detail the arguments:\n    #\n    # after    =&gt;   The word after what the \u201c\u00b9\u201d citation is inserted.\n    # note_id  =&gt;   The unique identifier of the note in the document.\n    # citation =&gt;   The symbol the user sees to follow the footnote.\n    # body     =&gt;   The footnote itself, at the end of the page.\n    #\n    # odfdo creates footnotes by default. To create endnotes (notes\n    # that appear at the end of the document), give the\n    # note_class='endnote' parameter.\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-text-document-with-tables-in-it","title":"Create a text document with tables in it","text":"<p>Build a commercial document, with numerical values displayed in both the text and in a table.</p> recipes/create_a_text_document_with_tables_in_it.py <pre><code>#!/usr/bin/env python\n\"\"\"Build a commercial document, with numerical values displayed in\nboth the text and in a table.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nfrom odfdo import (\n    Cell,\n    Document,\n    Header,\n    List,\n    ListItem,\n    Paragraph,\n    Row,\n    Table,\n    create_table_cell_style,\n    make_table_cell_border_string,\n)\n\n_DOC_SEQUENCE = 50\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"commercial\"\nTARGET = \"commercial.odt\"\nTAX_RATE = 0.20\n\n\nclass Product:\n    \"\"\"Minimalistic Product.\"\"\"\n\n    def __init__(self, reference: int, name: str, price: float) -&gt; None:\n        self.reference = reference\n        self.name = f\"Product {name}\"\n        self.price = price\n\n\nclass OrderLine:\n    \"\"\"Line of an Order.\"\"\"\n\n    def __init__(self, reference: int, quantity: int) -&gt; None:\n        self.reference = reference\n        self.quantity = quantity\n\n\ndef make_product_catalog() -&gt; list[Product]:\n    \"\"\"Generate a list of Product.\"\"\"\n    catalog: list[Product] = []\n    price = 10.0\n    for index in range(5):\n        catalog.append(Product(index, chr(65 + index), price))\n        price += 10.5\n    return catalog\n\n\ndef make_order(catalog: list[Product]) -&gt; list[OrderLine]:\n    \"\"\"Generate purchase order list.\"\"\"\n    order: list[OrderLine] = []\n    quantity = 1\n    for product in catalog:\n        quantity = int(quantity * 2.5)\n        order.append(OrderLine(product.reference, quantity))\n    return order\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef create_header_cell_style(doc: Document) -&gt; str:\n    \"\"\"Create a Cell style, insert it in Document, return its name.\"\"\"\n    border = make_table_cell_border_string(thick=\"0.03cm\", color=\"black\")\n    cell_style = create_table_cell_style(\n        color=\"black\",\n        background_color=(210, 210, 210),\n        border_right=border,\n        border_left=border,\n        border_bottom=border,\n        border_top=border,\n    )\n    style_name = doc.insert_style(style=cell_style, automatic=True)\n    return style_name\n\n\ndef add_top_content(doc: Document, catalog: list[Product]) -&gt; None:\n    \"\"\"Add some descriptive content to the document.\"\"\"\n    body = doc.body\n\n    title1 = Header(1, \"Basic commercial document\")\n    body.append(title1)\n    title11 = Header(2, \"Available products\")\n    body.append(title11)\n    paragraph = Paragraph(\"Here the list:\")\n    body.append(paragraph)\n    # List of products in a list :\n    product_list = List()  # odfdo.List\n    body.append(product_list)\n    for product in catalog:\n        item = ListItem(f\"{product.name:&lt;10}, price: {product.price:.2f} \u20ac\")\n        product_list.append(item)\n\n\ndef add_order_table(\n    doc: Document, catalog: list[Product], order: list[OrderLine]\n) -&gt; None:\n    \"\"\"Add a table with order lines.\"\"\"\n    body = doc.body\n    title12 = Header(2, \"Your order\")\n    body.append(title12)\n\n    style_name = create_header_cell_style(doc)\n    table = make_order_table(catalog, order, style_name)\n    body.append(table)\n\n\ndef make_order_table(\n    catalog: list[Product],\n    order: list[OrderLine],\n    style_name: str,\n) -&gt; Table:\n    \"\"\"Build the order table.\"\"\"\n    table = Table(\"Table\")\n\n    # Header of table\n    row = Row()\n    row.set_values([\"Product\", \"Price\", \"Quantity\", \"Amount\"])\n    table.set_row(\"A1\", row)\n    # or: table.set_row(0, row)\n\n    # Add a row for each order line\n    row_number = 0\n    for line in order:\n        row_number += 1\n        product = catalog[line.reference]\n\n        row = Row()\n\n        row.set_value(\"A\", product.name)\n        # or : row.set_value(0, product.name)\n\n        cell = Cell()\n        cell.set_value(\n            product.price,\n            text=f\"{product.price:.2f} \u20ac\",\n            currency=\"EUR\",\n            cell_type=\"float\",\n        )\n        row.set_cell(\"B\", cell)\n        # or : row.set_cell(1, cell)\n\n        row.set_value(\"C\", line.quantity)\n        # row.set_value(2, line.quantity)\n\n        price = product.price * line.quantity\n        cell = Cell()\n        cell.set_value(\n            price,\n            text=f\"{price:.2f} \u20ac\",\n            currency=\"EUR\",\n            cell_type=\"float\",\n        )\n        row.set_cell(\"D\", cell)\n\n        table.set_row(row_number, row)\n\n    # Total lines\n\n    # add a merged empty row\n    row = Row()\n    row_number += 1\n    table.set_row(row_number, row)\n    table.set_span((0, row_number, 3, row_number))\n\n    # compute total line\n    row = Row()\n    row_number += 1\n    row.set_value(0, \"Total:\")\n    total = sum(table.get_column_values(3)[1:-1])\n    # note: total is a Decimal\n    cell = Cell()\n    cell.set_value(\n        total,\n        text=f\"{total:.2f} \u20ac\",\n        currency=\"EUR\",\n        cell_type=\"float\",\n    )\n    row.set_cell(3, cell)\n    table.set_row(row_number, row)\n    # merge the 3 first columns for this row:\n    table.set_span((0, row_number, 2, row_number), merge=True)\n\n    # compute VAT line\n    row = Row()\n    row_number += 1\n    row.set_value(0, \"Total with tax:\")\n    total_vat = float(total) * (1 + TAX_RATE)\n    cell = Cell()\n    cell.set_value(\n        total_vat,\n        text=f\"{total_vat:.2f} \u20ac\",\n        currency=\"EUR\",\n        cell_type=\"float\",\n    )\n    row.set_cell(3, cell)\n    table.set_row(row_number, row)\n    table.set_span((0, row_number, 2, row_number), merge=True)\n\n    # Let's add some style on header row\n    row = table.get_row(0)\n    for cell in row.traverse():\n        cell.style = style_name\n        row.set_cell(x=cell.x, cell=cell)\n    table.set_row(row.y, row)\n\n    return table\n\n\ndef generate_commercial(catalog: list[Product], order: list[OrderLine]) -&gt; Document:\n    \"\"\"Generate a Text Document with table in in.\"\"\"\n    document = Document(\"text\")\n    add_top_content(document, catalog)\n    add_order_table(document, catalog, order)\n\n    return document\n\n\ndef main() -&gt; None:\n    catalog = make_product_catalog()\n    order = make_order(catalog)\n    document = generate_commercial(catalog, order)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    table = document.body.get_table(name=\"Table\")\n    assert isinstance(table, Table)\n    assert table.get_cell(\"A1\").value == \"Product\"\n    assert table.get_cell(\"A2\").value == \"Product A\"\n    assert table.get_cell(\"A8\").value == \"Total:\"\n    assert table.get_cell(\"B1\").value == \"Price\"\n    assert table.get_cell(\"C1\").value == \"Quantity\"\n    assert table.get_cell(\"C2\").value == 2\n    assert table.get_cell(\"D1\").value == \"Amount\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-table-to-a-document","title":"How to add a table to a document","text":"<p>Minimal example of how to add a table to a text document.</p> recipes/how_to_add_a_table_to_a_document.py <pre><code>\"\"\"Minimal example of how to add a table to a text document.\"\"\"\n\nimport os\n\nfrom odfdo import Document, Header, Paragraph, Table\n\n_DOC_SEQUENCE = 55\n\n\ndef generate_document() -&gt; Document:\n    \"\"\"Add a 3x3 table to a new document.\"\"\"\n    document = Document(\"text\")\n    body = document.body\n\n    # Let's add another section to make our document clear:\n    body.append(Header(1, \"Tables\"))\n    body.append(Paragraph(\"A 3x3 table:\"))\n\n    # Creating a table :\n    table = Table(\"Table 1\", width=3, height=3)\n    body.append(table)\n    return document\n\n\ndef main() -&gt; None:\n    document = generate_document()\n    test_unit(document)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    table = document.body.get_table(0)\n    assert table.size == (3, 3)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-text-document-from-plain-text-with-layout","title":"Create a text document from plain text with layout","text":"<p>Create a document with styles.</p> <p>We want to:</p> <ul> <li> <p>remove standard styles from the document</p> </li> <li> <p>set some styles grabed from a styles.xml ODF file (or generated)</p> </li> <li> <p>insert plain \u201cpython\u201d text, containing some          ,  , and spaces</p> </li> </ul> recipes/create_a_text_document_from_plain_text_with_layout.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a document with styles.\n\n We want to:\n\n  - remove standard styles from the document\n\n  - set some styles grabed from a styles.xml ODF file (or generated)\n\n  - insert plain \"python\" text, containing some \\t , \\n, and spaces\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document, Element, Paragraph, Style\n\n_DOC_SEQUENCE = 60\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"styled2\"\nTARGET = \"document.odt\"\n\n\n# Element is the base class of all odfdo classes.\n# Element.from_tag permits the creation of any ODF XML tag\n\n# some font styles :\n_style_font_1 = Element.from_tag(\n    '&lt;style:font-face style:name=\"OpenSymbol\" svg:font-family=\"OpenSymbol\"/&gt;'\n)\n\n_style_font_2 = Element.from_tag(\n    '&lt;style:font-face style:name=\"Liberation Serif\" '\n    'svg:font-family=\"Liberation Serif\" '\n    'style:font-family-generic=\"roman\" '\n    'style:font-pitch=\"variable\"/&gt;'\n)\n\n_style_font_3 = Element.from_tag(\n    '&lt;style:font-face style:name=\"Liberation Sans\" '\n    'svg:font-family=\"Liberation Sans\" '\n    'style:font-family-generic=\"swiss\" '\n    'style:font-pitch=\"variable\"/&gt;'\n)\n\n# page layout style (changing margin)\n_style_page = Element.from_tag(\n    '&lt;style:page-layout style:name=\"MyLayout\"&gt;'\n    '&lt;style:page-layout-properties fo:page-width=\"21.00cm\" '\n    'fo:page-height=\"29.70cm\" style:num-format=\"1\" '\n    'style:print-orientation=\"portrait\" fo:margin-top=\"1.7cm\" '\n    'fo:margin-bottom=\"1.5cm\" fo:margin-left=\"1.6cm\" '\n    'fo:margin-right=\"1.6cm\" style:writing-mode=\"lr-tb\" '\n    'style:footnote-max-height=\"0cm\"&gt;&lt;style:footnote-sep '\n    'style:width=\"0.018cm\" style:distance-before-sep=\"0.10cm\" '\n    'style:distance-after-sep=\"0.10cm\" style:line-style=\"solid\" '\n    'style:adjustment=\"left\" style:rel-width=\"25%\" '\n    'style:color=\"#000000\"/&gt; &lt;/style:page-layout-properties&gt;'\n    \"&lt;style:footer-style&gt; \"\n    '&lt;style:header-footer-properties fo:min-height=\"0.6cm\" '\n    'fo:margin-left=\"0cm\" fo:margin-right=\"0cm\" '\n    'fo:margin-top=\"0.3cm\" style:dynamic-spacing=\"false\"/&gt; '\n    \"&lt;/style:footer-style&gt;&lt;/style:page-layout&gt;\"\n)\n\n# master style, using the precedent layout for the actual document\n_style_master = Element.from_tag(\n    '&lt;style:master-page style:name=\"Standard\" '\n    'style:page-layout-name=\"MyLayout\"&gt;&lt;style:footer&gt;'\n    '&lt;text:p text:style-name=\"Footer\"&gt; '\n    \"&lt;text:tab/&gt;&lt;text:tab/&gt;&lt;text:page-number \"\n    'text:select-page=\"current\"/&gt; / &lt;text:page-count '\n    'style:num-format=\"1\"&gt;15&lt;/text:page-count&gt;'\n    \"&lt;/text:p&gt;&lt;/style:footer&gt; \"\n    \"&lt;/style:master-page&gt;\"\n)\n\n# some footer\n_style_footer = Element.from_tag(\n    '&lt;style:style style:name=\"Footer\" '\n    'style:family=\"paragraph\" style:class=\"extra\" '\n    'style:master-page-name=\"\"&gt;'\n    '&lt;style:paragraph-properties style:page-number=\"auto\" '\n    'text:number-lines=\"false\" text:line-number=\"0\"&gt;'\n    \"&lt;style:tab-stops&gt;\"\n    '&lt;style:tab-stop style:position=\"8.90cm\" '\n    'style:type=\"center\"/&gt;'\n    '&lt;style:tab-stop style:position=\"17.80cm\" style:type=\"right\"/&gt;'\n    \"&lt;/style:tab-stops&gt;\"\n    \"&lt;/style:paragraph-properties&gt;\"\n    \"&lt;style:text-properties \"\n    'style:font-name=\"Liberation Sans\" '\n    'fo:font-size=\"7pt\"/&gt;&lt;/style:style&gt;'\n)\n\n# some text style using Liberation Sans font\n_style_description = Element.from_tag(\n    '&lt;style:style style:name=\"description\" '\n    'style:family=\"paragraph\" '\n    'style:class=\"text\" style:master-page-name=\"\"&gt;'\n    \"&lt;style:paragraph-properties \"\n    'fo:margin=\"100%\" fo:margin-left=\"0cm\" fo:margin-right=\"0cm\" '\n    'fo:margin-top=\"0.35cm\" fo:margin-bottom=\"0.10cm\" '\n    'style:contextual-spacing=\"false\" '\n    'fo:text-indent=\"0cm\" '\n    'style:auto-text-indent=\"false\" '\n    'style:page-number=\"auto\"/&gt;'\n    \"&lt;style:text-properties \"\n    'style:font-name=\"Liberation Sans\" '\n    'fo:font-size=\"11pt\"/&gt;'\n    \"&lt;/style:style&gt;\"\n)\n\n# some text style using Liberation Serif font\n_style_small_serif = Element.from_tag(\n    '&lt;style:style style:name=\"smallserif\" '\n    'style:family=\"paragraph\" style:class=\"text\"&gt;'\n    '&lt;style:paragraph-properties fo:margin=\"100%\" '\n    'fo:margin-left=\"1.20cm\" '\n    'fo:margin-right=\"0cm\" fo:margin-top=\"0cm\" '\n    'fo:margin-bottom=\"0.10cm\" '\n    'style:contextual-spacing=\"false\" '\n    'fo:text-indent=\"0cm\" '\n    'style:auto-text-indent=\"false\"/&gt;'\n    '&lt;style:text-properties style:font-name=\"Liberation Serif\" '\n    'fo:font-size=\"9pt\" '\n    'fo:font-weight=\"normal\"/&gt;'\n    \"&lt;/style:style&gt;\"\n)\n\n# some style to have stylish line in text\n_style_line = Element.from_tag(\n    '&lt;style:style style:name=\"line\" '\n    'style:family=\"paragraph\" style:class=\"text\"&gt;'\n    '&lt;style:paragraph-properties fo:margin=\"100%\" '\n    'fo:margin-left=\"0cm\" '\n    'fo:margin-right=\"0cm\" fo:margin-top=\"0cm\" '\n    'fo:margin-bottom=\"0.15cm\" '\n    'style:contextual-spacing=\"false\" fo:text-indent=\"0cm\" '\n    'style:auto-text-indent=\"false\" fo:padding=\"0cm\" '\n    'fo:border-left=\"none\" '\n    'fo:border-right=\"none\" fo:border-top=\"none\" '\n    'fo:border-bottom=\"0.06pt solid #000000\"/&gt;'\n    '&lt;style:text-properties style:font-name=\"Liberation Sans\" '\n    'fo:font-size=\"9pt\"/&gt;'\n    \"&lt;/style:style&gt;\"\n)\n\n# some odfdo generated style (for bold Span)\n_style_bold = Style(\"text\", name=\"bolder\", bold=True)\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    # Some plain text :\n    text_1 = (\n        \"Lorem ipsum dolor sit amet,\\n\\t\"\n        \"consectetuer adipiscing elit.\\n\\tSed\"\n        \"non risus.\\n\\tSuspendisse lectus tortor,\\n\"\n        \"ndignissim sit amet, \\nadipiscing nec,\"\n        \"\\nultricies sed, dolor.\\n\\n\"\n        \" Cras elementum ultrices diam. Maecenas ligula massa,\"\n        \"varius a,semper congue, euismod non,\"\n        \" mi. Proin porttitor, orci nec nonummy\"\n        \"molestie, enim est eleifend mi,\"\n        \" non fermentum diam nisl sit amet erat.\"\n    )\n\n    text_2 = (\n        \"Vestibulum                 \"\n        \"ante               \"\n        \"ipsum             primis\\n\"\n        \"in faucibus orci luctus et ultrices \"\n        \"posuere cubilia Curae; Aliquam nibh.\"\n    )\n\n    text_3 = (\n        \"Duis semper. \\n\\tDuis arcu massa,\"\n        \" \\n\\t\\tscelerisque vitae, \\n\"\n        \"\\t\\t\\tconsequat in, \\n\"\n        \"\\t\\t\\t\\tpretium a, enim. \\n\"\n        \"\\t\\t\\t\\t\\tPellentesque congue. \\n\"\n        \"Ut in risus volutpat libero pharetra \"\n        \"tempor. Cras vestibulum bibendum augue.\"\n        \"Praesent egestas leo in pede. Praesent \"\n        \"blandit odio eu enim. Pellentesque sed\"\n    )\n\n    document = Document(\"text\")\n    # remove default styles\n    document.delete_styles()\n    # add our styles\n    document.insert_style(_style_font_1, default=True)\n    document.insert_style(_style_font_2, default=True)\n    document.insert_style(_style_font_3, default=True)\n    document.insert_style(_style_page, automatic=True)\n    document.insert_style(_style_master)\n    document.insert_style(_style_footer)\n    document.insert_style(_style_description)\n    document.insert_style(_style_small_serif)\n    document.insert_style(_style_bold)\n\n    body = document.body\n\n    # since version 3.8.14, the append_plain_text() mode is the\n    # default for paragraph creation, so the code is more simple:\n\n    # paragraph = Paragraph(\"\", style=\"description\")\n    # paragraph.append_plain_text(text_1)\n    # body.append(paragraph)\n\n    # paragraph = Paragraph(style=\"line\")\n    # body.append(paragraph)\n\n    # paragraph = Paragraph(style=\"smallserif\")\n    # paragraph.append_plain_text(text_2)\n    # body.append(paragraph)\n\n    # paragraph = Paragraph(style=\"line\")\n    # body.append(paragraph)\n\n    # paragraph = Paragraph(style=\"description\")\n    # paragraph.append_plain_text(text_3)\n\n    paragraph = Paragraph(text_1, style=\"description\")\n    body.append(paragraph)\n\n    paragraph = Paragraph(style=\"line\")\n    body.append(paragraph)\n\n    paragraph = Paragraph(text_2, style=\"smallserif\")\n    body.append(paragraph)\n\n    paragraph = Paragraph(style=\"line\")\n    body.append(paragraph)\n\n    paragraph = Paragraph(\"A: \" + text_3, style=\"description\")\n    # span offset become complex after inserting &lt;CR&gt; and &lt;TAB&gt; in a text\n    paragraph.set_span(\"bolder\", offset=5, length=6)  # find TEXT position 5 : 6\n    paragraph.set_span(\"bolder\", offset=18, length=4)  # find TEXT position 18 : 4\n    paragraph.set_span(\"bolder\", offset=49)  # find TEXT position 18 to the end\n    # of the text bloc\n    paragraph.set_span(\"bolder\", regex=r\"Praes\\w+\\s\\w+\")  # regex: Praes. + next word\n\n    body.append(paragraph)\n\n    paragraph = Paragraph(style=\"line\")\n    body.append(paragraph)\n\n    # it is possible to add the content without the original layout (\\n, tab, spaces)\n    paragraph = Paragraph(\"B: \" + text_3, style=\"description\", formatted=False)\n    body.append(paragraph)\n\n    paragraph = Paragraph(style=\"line\")\n    body.append(paragraph)\n\n    # text can also be append after paragraph creation\n    paragraph = Paragraph(style=\"description\")\n    paragraph.append(\"C: \" + text_3)\n    body.append(paragraph)\n\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#add-a-custom-footer-to-a-text-document","title":"Add a custom footer to a text document","text":"<p>Minimal example of setting a page footer using Style.set_page_footer().</p> <p>Note: the created footer uses the current footer style, to change that footer style, use the method  set_footer_style() on the \u2018page-layout\u2019 style family.</p> recipes/add_a_custom_footer_to_a_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Minimal example of setting a page footer using Style.set_page_footer().\n\nNote: the created footer uses the current footer style, to change that\nfooter style, use the method  set_footer_style() on the 'page-layout'\nstyle family.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph, Tab, VarPageNumber\n\n_DOC_SEQUENCE = 62\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"styled4\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef make_document() -&gt; Document:\n    \"\"\"Generate a short document with a page footer.\"\"\"\n    text_1 = (\n        \"Lorem ipsum dolor sit amet,\\n\\t\"\n        \"consectetuer adipiscing elit.\\n\\tSed\"\n        \"non risus.\\n\\tSuspendisse lectus tortor,\\n\"\n        \"ndignissim sit amet, \\nadipiscing nec,\"\n        \"\\nultricies sed, dolor.\\n\\n\"\n        \" Cras elementum ultrices diam. Maecenas ligula massa,\"\n        \"varius a,semper congue, euismod non,\"\n        \" mi. Proin porttitor, orci nec nonummy\"\n        \"molestie, enim est eleifend mi,\"\n        \" non fermentum diam nisl sit amet erat.\"\n    )\n\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n    body.append(Header(1, \"Some Title\"))\n    body.append(Paragraph(text_1))\n\n    # looking for the current \"master-page\" style, it is probably\n    # named \"Standard\". If not found, search with something like:\n    # print([s for s in document.get_styles() if s.family == \"master-page\"])\n    page_style = document.get_style(\"master-page\", \"Standard\")\n\n    # The footer can be a Paragraph or a list of Paragraphs:\n    first_line = Paragraph(\"\\tA first footer line\")\n    second_line = Paragraph(\"Second line\")\n    second_line.append(Tab())\n    second_line.append(Tab())\n    second_line.append(VarPageNumber())\n    second_line.append(\".\")\n    my_footer = [first_line, second_line]\n\n    page_style.set_page_footer(my_footer)\n\n    # important: insert again the modified style\n    document.insert_style(page_style)\n\n    return document\n\n\ndef main() -&gt; None:\n    document = make_document()\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    from odfdo import Style\n\n    assert len([s for s in document.get_styles() if s.family == \"master-page\"]) &gt;= 1\n    page_style = document.get_style(\"master-page\", \"Standard\")\n    assert isinstance(page_style, Style)\n    footer = page_style.get_page_footer()\n    content = footer.serialize()\n    assert \"A first footer\" in content\n    assert \"Second line\" in content\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-picture-to-a-text-document","title":"How to add a picture to a text document","text":"<p>Create an empty text document and add a picture in a frame.</p> recipes/how_to_add_a_picture_to_a_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Create an empty text document and add a picture in a frame.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document, Frame, Paragraph\n\n_DOC_SEQUENCE = 65\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_picture\"\nTARGET = \"document.odt\"\nDATA = Path(__file__).parent / \"data\"\nIMAGE = DATA / \"newlogo.png\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n    image_path = str(DATA / IMAGE)\n    uri = document.add_file(image_path)\n    image_frame = Frame.image_frame(\n        uri,\n        size=(\"6cm\", \"4cm\"),\n        position=(\"5cm\", \"10cm\"),\n    )\n\n    # put image frame in a paragraph:\n    paragraph = Paragraph(\"\")\n    paragraph.append(image_frame)\n    body.append(paragraph)\n\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-title-to-a-text-document","title":"How to add a title to a text document","text":"<p>Minimal example of how to add a Header of first level to a text document.</p> recipes/how_to_add_a_title_to_a_text_document.py <pre><code>\"\"\"Minimal example of how to add a Header of first level to a text document.\n\"\"\"\n\nfrom odfdo import Document, Header\n\n_DOC_SEQUENCE = 67\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n\n    title1 = Header(1, \"The Title\")\n    body.append(title1)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#accessing-a-single-element","title":"Accessing a single element","text":"<p>Example of methods and properties to analyse a document.</p> <p>These methods return a single element (or None):</p> <pre><code>- `body.get_note(position)`\n- `body.get_paragraph(position)`\n- `body.get_header(position)`\n</code></pre> recipes/accessing_a_single_element.py <pre><code>#!/usr/bin/env python\n\"\"\"Example of methods and properties to analyse a document.\n\nThese methods return a single element (or None):\n\n    - `body.get_note(position)`\n    - `body.get_paragraph(position)`\n    - `body.get_header(position)`\n\"\"\"\n\n# Expected result on stdout:\n# - Content of the first footnote:\n# 1. [Gaiman, Neil](http://en.wikipedia.org/w/index.php?title=Neil_Gaiman)\n# (2003). Don't Panic: Douglas Adams and the \"Hitchhiker's Guide to the\n# Galaxy\". Titan Books. pp 144-145. ISBN 1-84023-742-2.\n#\n# - Content of the paragraph with the word 'Fish'\n# In So Long, and Thanks for All the Fish (published in 1984), Arthur\n# returns home to Earth, rather surprisingly since it was destroyed when\n# he left. He meets and falls in love with a girl named\n# [Fenchurch](http://en.wikipedia.org/w/index.php?title=Minor_characters_from_The_Hitchhiker%27s_Guide_to_the_Galaxy%23Fenchurch), and discovers this Earth is a replacement provided by the [dolphin](http://en.wikipedia.org/w/index.php?title=Dolphin)s in their Save the Humans campaign. Eventually he rejoins Ford, who claims to have saved the Universe in the meantime, to hitch-hike one last time and see God's Final Message to His Creation. Along the way, they are joined by Marvin, the Paranoid Android, who, although 37 times older than the universe itself (what with time\n# travel and all), has just enough power left in his failing body to read\n# the message and feel better about it all before expiring.\n#\n# - Content of the first Title:\n# The Hitchhiker's Guide to the Galaxy\n#\n# - Content of the last Title:\n# Official sites\n\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 70\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef method_demo(document: Document) -&gt; None:\n    \"\"\"Show some methos examples.\"\"\"\n    # The body object is an XML element from which we can access one or several\n    # other elements we are looking for.\n    body = document.body\n\n    # Accessing a single element\n    # To access a single element by name, position or a regular expression on\n    # the content, use get_xxx_by_&lt;criteria&gt;, where criteria can be position,\n    # content, or for some of them name, id title, description.\n    print(\"- Content of the first footnote:\")\n    print(str(body.get_note(position=0)))\n    print()\n    print(\"- Content of the paragraph with the word 'Fish'\")\n    print(str(body.get_paragraph(content=\"Fish\")))\n    print(\"- Content of the first Title:\")\n    print(str(body.get_header(position=0)))\n    print(\"- Content of the last Title:\")\n    print(str(body.get_header(position=-1)))\n\n\ndef main() -&gt; None:\n    document = read_source_document()\n    method_demo(document)\n    test_unit(document)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    body = document.body\n    assert str(body.get_note(position=0)).startswith(\n        \"1. [Gaiman, Neil](http://en.wikipedia.org/w/index.php?title=Neil_Gaiman) (2003)\"\n    )\n    assert str(body.get_paragraph(content=\"Fish\")).endswith(\"all before expiring.\\n\")\n    assert str(body.get_header(position=0)).startswith(\"The Hitchhiker's Guide\")\n    assert str(body.get_header(position=-1)).startswith(\"Official sites\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#accessing-a-list-of-elements","title":"Accessing a list of elements","text":"<p>Example of methods and properties to analyse a document.</p> <p>These methods or properties return a list of elements:</p> <pre><code>- `body.headers`\n- `body.images`\n- `body.paragraphs`\n- `body.get_links()`\n- `body.get_notes()`\n- `body.tables`\n- `body.get_paragraphs(content)`\n</code></pre> recipes/accessing_a_list_of_elements.py <pre><code>#!/usr/bin/env python\n\"\"\"Example of methods and properties to analyse a document.\n\nThese methods or properties return a list of elements:\n\n    - `body.headers`\n    - `body.images`\n    - `body.paragraphs`\n    - `body.get_links()`\n    - `body.get_notes()`\n    - `body.tables`\n    - `body.get_paragraphs(content)`\n\"\"\"\n\n# Expected result on stdout:\n# 96 get methods are available\n# number of headings: 29\n# number of images stored: 0\n# number of paragraphs: 175\n# number of links (URLs): 352\n# number of footnotes: 49\n# number of tables: 0\n# Paragraphs with 'Fish': 4\n# Paragraphs with 'answer' and '42': 1\n\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 75\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef analysis(document: Document) -&gt; dict[str, int]:\n    \"\"\"Returns some statistics about the document.\"\"\"\n    result: dict[str, int] = {\n        \"methods\": 0,\n        \"headings\": 0,\n        \"images\": 0,\n        \"paragraphs\": 0,\n        \"links\": 0,\n        \"footnotes\": 0,\n        \"tables\": 0,\n        \"fish\": 0,\n        \"answer\": 0,\n    }\n\n    # The body object is an XML element from which we can access one or several\n    # other elements we are looking for.\n    body = document.body\n\n    # Accessing a list of elements\n    # Should you need to access all elements of a kind, there are the\n    # get_xxxs methods, where xxx can be paragraph, heading, list, table, ...\n    # Methods without parameters are accessible through properties.\n    result[\"methods\"] = \" \".join(dir(body)).count(\"get_\")\n    # Some examples, that you can check against actual content of the odt file:\n    # See how complex is our wikipedia documents:\n    result[\"headings\"] = len(body.headers)\n    result[\"images\"] = len(body.images)\n    result[\"paragraphs\"] = len(body.paragraphs)\n    result[\"links\"] = len(body.get_links())\n    result[\"footnotes\"] = len(body.get_notes())\n    # Our sample document has no table:\n    # print(\"number of tables:\", len(body.get_tables()))\n    result[\"tables\"] = len(body.tables)\n\n    # Each get_xxx_list method provides parameters for filtering the results.\n    # For example headings can be listed by level, annotations by creator, etc.\n    # Almost all of them accept filtering by style and content using a regular\n    # expressions.\n    result[\"fish\"] = len(body.get_paragraphs(content=r\"Fish\"))\n    result[\"answer\"] = len(body.get_paragraphs(content=r\"answer.*42\"))\n\n    return result\n\n\ndef display_analysis(stats: dict[str, int]) -&gt; None:\n    \"\"\"Print the stats on stdout.\"\"\"\n    print(f\"{stats['methods']} get methods are available\")\n    print(f\"number of headings: {stats['headings']}\")\n    print(f\"number of images stored: {stats['images']}\")\n    print(f\"number of paragraphs: {stats['paragraphs']}\")\n    print(f\"number of links (URLs): {stats['links']}\")\n    print(f\"number of footnotes: {stats['footnotes']}\")\n    print(f\"number of tables: {stats['tables']}\")\n    print(f\"Paragraphs with 'Fish': {stats['fish']}\")\n    print(f\"Paragraphs with 'answer' and '42': {stats['answer']}\")\n\n\ndef main() -&gt; None:\n    document = read_source_document()\n    stats = analysis(document)\n    display_analysis(stats)\n    test_unit(stats)\n\n\ndef test_unit(stats: dict[str, int]) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert stats[\"methods\"] == 96\n    assert stats[\"headings\"] == 29\n    assert stats[\"images\"] == 0\n    assert stats[\"paragraphs\"] == 175\n    assert stats[\"links\"] == 352\n    assert stats[\"footnotes\"] == 49\n    assert stats[\"tables\"] == 0\n    assert stats[\"fish\"] == 4\n    assert stats[\"answer\"] == 1\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#accessing-other-element-from-element-like-list","title":"Accessing other element from element like list","text":"<p>Accessing elements from element-like list.</p> <p>Any fetched element is a XML tree context that can be queried, but only on the subtree it contains. Here are quick examples of iteration on <code>Paragraphs</code> and <code>Lists</code> from the document.</p> recipes/accessing_other_element_from_element_like_list.py <pre><code>#!/usr/bin/env python\n\"\"\"Accessing elements from element-like list.\n\nAny fetched element is a XML tree context that can be queried, but only on the subtree it\ncontains. Here are quick examples of iteration on `Paragraphs` and `Lists` from the document.\n\"\"\"\n\n# Expected result on stdout:\n# Number of available lists in the document: 5\n#\n# The 4th list contains 9 paragraphs\n#\n# 1 : [BBC Cult website](http://www.bbc.co.uk/cult/hitchhikers/),\n# official website for the [TV show version](http://en.wikipedia.org/w/index.php?title=The_Hitchhiker%27s_Guide_to_the_Galaxy_%28TV_series%29)\n# (includes information, links and downloads)\n#\n# 2 : [BBC Radio 4 website for the 2004-2005\n# series](http://www.bbc.co.uk/radio4/hitchhikers/)\n#\n# 3 : [Official Movie Site](http://hitchhikers.movies.go.com/)\n#\n# 4 : [The Hitchhiker's Guide to the Galaxy\n# (2005 movie)](http://www.imdb.com/title/tt0371724/)at the\n# [Internet Movie Database](http://en.wikipedia.org/w/index.php?title=Internet_Movie_Database)\n#\n# 5 : [The Hitch Hikers Guide to the Galaxy\n# (1981 TV series)](http://www.imdb.com/title/tt0081874/)at the\n# [Internet Movie Database](http://en.wikipedia.org/w/index.php?title=Internet_Movie_Database)\n#\n# 6 : [h2g2](http://www.bbc.co.uk/h2g2/guide/)\n#\n# 7 : [Encyclopedia of Television](http://www.museum.tv/archives/etv/H/htmlH/hitch-hickers/hitch-hickers.htm)\n#\n# 8 : [British Film Institute Screen Online](http://www.screenonline.org.uk/tv/id/560180/index.html)\n# page devoted to the TV series\n#\n# 9 : [DC Comics H2G2 site](http://www.dccomics.com/graphic_novels/?gn=1816)\n\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 80\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef analyse_list(document: Document):\n    # The body object is an XML element from which we can access one or several\n    # other elements we are looking for.\n    body = document.body\n\n    # Any element is a context for navigating but only on the subtree it\n    # contains. Just like the body was, but since the body contains all content,\n    # we didn't see the difference.\n    # Let's try the lists:\n    print(\"Number of available lists in the document:\", len(body.lists))\n    print()\n\n    list4 = body.get_list(position=4)\n    print(f\"The 4th list contains {len(list4.paragraphs)} paragraphs\")\n    print()\n\n    # Now print the list content\n    paragraphs = list4.paragraphs\n    for count, paragraph in enumerate(paragraphs):\n        print(count + 1, \":\", paragraph)\n\n\ndef main():\n    document = read_source_document()\n    analyse_list(document)\n    test_unit(document)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    body = document.body\n    list4 = body.get_list(position=4)\n    paragraphs = list4.paragraphs\n    assert len(body.lists) == 5\n    assert len(list4.paragraphs) == 9\n    assert str(paragraphs[0]).startswith(\"[BBC Cult website](http\")\n    assert str(paragraphs[8]).startswith(\"[DC Comics H2G2 site](http\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-list-to-a-text-document","title":"How to add a list to a text document","text":"<p>Create an empty text document and add a list.</p> recipes/how_to_add_a_list_to_a_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Create an empty text document and add a list.\n\"\"\"\nimport os\nfrom pathlib import Path\n\n# Lists are a dedicated object List\nfrom odfdo import Document, List\n\n_DOC_SEQUENCE = 90\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"add_list\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n    some_list = List([\"chocolate\", \"tea\", \"coffee\"])\n    # The list factory accepts a Python list of strings and list items.\n    body.append(some_list)\n\n    test_unit(document)\n\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    assert (document.get_formatted_text()).strip() == \"- chocolate\\n- tea\\n- coffee\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-add-a-manual-page-break","title":"How to add a manual page break","text":"<p>Adding a manual page break to a text document.</p> recipes/how_to_add_a_manual_page_break.py <pre><code>#!/usr/bin/env python\n\"\"\"Adding a manual page break to a text document.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document, PageBreak, Paragraph, Style\n\n_DOC_SEQUENCE = 95\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"page_break\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = Document()\n    body = document.body\n    body.clear()\n\n    # here a simple way to insert a page break with odfdoshortcuts:\n    document.add_page_break_style()\n    body.append(Paragraph(\"First paragraph\"))\n    body.append(PageBreak())\n    body.append(Paragraph(\"Second paragraph\"))\n\n    # here is a different way to insert a page break:\n    page_break_style = Style(\"paragraph\", name=\"page_break_before\")\n    page_break_style.set_properties({\"fo:break-before\": \"page\"})\n    document.insert_style(page_break_style)\n    empty_paragraph = Paragraph(\"\", style=\"page_break_before\")\n    body.append(empty_paragraph)\n    body.append(Paragraph(\"Third paragraph\"))\n\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-a-basic-drawing","title":"Create a basic drawing","text":"<p>Insert a circle and a lot of lines (a fractal) in a text document.</p> recipes/create_a_basic_drawing.py <pre><code>#!/usr/bin/env python\n\"\"\"Insert a circle and a lot of lines (a fractal) in a text document.\n\"\"\"\nimport cmath\nfrom pathlib import Path\nfrom typing import Union\n\nfrom odfdo import Document, EllipseShape, Header, LineShape, Paragraph\n\n_DOC_SEQUENCE = 100\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_drawing\"\nTARGET = \"koch.odt\"\n\nCYCLES = 4  # beware, 5 is big, 6 is too big to display...\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef cm(x: float) -&gt; str:\n    return f\"{x:.2f}cm\" \"\"\n\n\n# some graphic computations\nclass Vector:\n    def __init__(self, a: Union[float, complex], b: Union[float, complex]):\n        self.a = a\n        self.b = b\n\n    def koch_split(self) -&gt; list:\n        c = self.a + 1.0 / 3.0 * (self.b - self.a)\n        d = self.a + 2.0 / 3.0 * (self.b - self.a)\n        m = 0.5 * (self.a + self.b)\n        e = m + (d - c) * complex(0, -1)\n        return [Vector(self.a, c), Vector(c, e), Vector(e, d), Vector(d, self.b)]\n\n    def centimeter(self, val) -&gt; tuple:\n        if val == 0:\n            m = self.a\n        else:\n            m = self.b\n        return (cm(m.real), cm(m.imag))\n\n\ndef koch(vector_list, cycle=2):\n    if cycle &lt;= 0:\n        return vector_list\n    else:\n        new_vector_list = []\n        for vector in vector_list:\n            new_vector_list.extend(vector.koch_split())\n        # del vector_list\n        return koch(new_vector_list, cycle - 1)\n\n\ndef make_fractal_coords(side, vpos):\n    orig = complex((17 - side) / 2.0, vpos)\n    v1 = Vector(orig, orig + complex(side, 0))\n    v2 = Vector(v1.b, orig + cmath.rect(side, cmath.pi / 3))\n    v3 = Vector(v2.b, orig)\n    center = (v1.a + v1.b + v2.b) / 3\n    vector_list = koch([v1, v2, v3], cycle=CYCLES)\n    return center, vector_list\n\n\ndef generate_document():\n    document = Document(\"text\")\n    body = document.body\n\n    print(\"Making some Koch fractal\")\n    title = Header(1, \"Some Koch fractal\")\n    body.append(title)\n\n    style = document.get_style(\"graphic\")\n    style.set_properties({\"svg:stroke_color\": \"#0000ff\"})\n    style.set_properties(fill_color=\"#ffffcc\")\n\n    paragraph = Paragraph(\"\")\n    body.append(paragraph)\n\n    # some computation of oordinates\n    center, vector_list = make_fractal_coords(side=12.0, vpos=8.0)\n\n    # create a circle\n    radius = 8.0\n    pos = center - complex(radius, radius)\n    circle = EllipseShape(\n        size=(cm(radius * 2), cm(radius * 2)),\n        position=(cm(pos.real), cm(pos.imag)),\n    )\n    paragraph.append(circle)\n\n    # create a drawing with a lot of lines\n    paragraph.append(f\"number of lines: {len(vector_list)}\")\n    for vector in vector_list:\n        line = LineShape(p1=vector.centimeter(0), p2=vector.centimeter(1))\n        paragraph.append(line)\n\n    return document\n\n\ndef main():\n    document = generate_document()\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#add-private-annotations-to-a-document","title":"Add private annotations to a document","text":"<p>Add not printable annotations to a document.</p> <p>Annotations are notes that do not appear in the document but typically on a side bar in a desktop application. So they are not printed.</p> recipes/add_private_annotations_to_a_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Add not printable annotations to a document.\n\nAnnotations are notes that do not appear in the document but typically\non a side bar in a desktop application. So they are not printed.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph\n\n_DOC_SEQUENCE = 110\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"annotated\"\nTARGET = \"annotated_document.odt\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef base_document() -&gt; Document:\n    \"\"\"Generate a basic document.\"\"\"\n    document = Document(\"text\")\n    body = document.body\n\n    body.append(Header(1, \"De la Guerre des Gaules - Livre V\"))\n    body.append(Header(2, \"Pr\u00e9paratifs d'exp\u00e9dition en Bretagne\"))\n    body.append(\n        Paragraph(\n            \"Sous le consulat de Lucius Domitius et d'Appius Claudius, \"\n            \"C\u00e9sar, quittant les quartiers d'hiver pour aller en Italie, \"\n            \"comme il avait coutume de le faire chaque ann\u00e9e, ordonne aux \"\n            \"lieutenants qu'il laissait \u00e0 la t\u00eate des l\u00e9gions de construire, \"\n            \"pendant l'hiver, le plus de vaisseaux qu'il serait possible, \"\n            \"et de r\u00e9parer les anciens.\"\n        )\n    )\n    body.append(Header(2, \"La Bretagne\"))\n    body.append(\n        Paragraph(\n            \"Cette \u00eele est de forme triangulaire ; l'un des c\u00f4t\u00e9s regarde \"\n            \"la Gaule. Des deux angles de ce c\u00f4t\u00e9, l'un est au levant, \"\n            \"vers le pays de Cantium, o\u00f9 abordent presque tous les vaisseaux \"\n            \"gaulois ; l'autre, plus bas, est au midi. La longueur de ce c\u00f4t\u00e9 \"\n            \"est d'environ cinq cent mille pas. \"\n        )\n    )\n    return document\n\n\ndef insert_annotation(document: Document) -&gt; None:\n    \"\"\"Insert a not printable annotation in a document.\"\"\"\n    body = document.body\n    paragraph = body.get_paragraph(content=\"consulat\")\n    # Annotations are inserted like notes but they are simpler:\n    # Annotation arguments:\n    # after   =&gt;  The word after what the annotation is inserted.\n    # body    =&gt;  The annotation itself, at the end of the page.\n    # creator =&gt;  The author of the annotation.\n    # date    =&gt;  A datetime value, by default datetime.now().\n    paragraph.insert_annotation(\n        after=\"Domitius\",\n        body=\"Talking about Lucius Domitius\",\n        creator=\"Luis\",\n    )\n\n\ndef main() -&gt; None:\n    document = base_document()\n    insert_annotation(document)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert len(document.body.get_annotations(creator=\"Luis\")) == 1\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#accessibility-check-on-a-document","title":"Accessibility check on a document","text":"<p>Basic Accessibility test: check, for every picture in a document, if there is:</p> <ul> <li>a title (svg_title),</li> <li>a description (svg_description)</li> </ul> <p>or, at least, some caption text.</p> <p>See test file <code>planes.odt</code> file and the result of the script.</p> recipes/accessibility_check_on_a_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Basic Accessibility test: check, for every picture in a document, if\nthere is:\n\n  - a title (svg_title),\n  - a description (svg_description)\n\nor, at least, some caption text.\n\nSee test file `planes.odt` file and the result of the script.\n\"\"\"\n\n# Expected result on stdout:\n# The document displays 3 pictures:\n#  - pictures with a title: 2\n#  - pictures with a description: 1\n#  - pictures with a caption: 0\n\n# Image: 100000000000013B000000D345859F604DCE636A.jpg\n#   Name: graphics2, Title: Spitfire, general view, Description:Green spitfire in a hall, view from left front., Caption:None\n# Image: 100000000000013B000000D3F908DA0A939D2F4B.jpg\n#   Name: graphics3, Title: Spitfire, detail, Description:None, Caption:None\n# Image: 100000000000013B000000D375CEBFD6D7CB7CE9.jpg\n#   Name: graphics1, Title: None, Description:None, Caption:None\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Any\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 200\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"planes.odt\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef accessibility_evaluator(document: Document) -&gt; dict[str, Any]:\n    \"\"\"Count for each images: titles, caption,description.\"\"\"\n    result: dict[str, Any] = {\n        \"images\": [],\n        \"titles\": 0,\n        \"descriptions\": 0,\n        \"captions\": 0,\n    }\n\n    # We want the images of the document.\n    body = document.body\n    images = body.images\n\n    for image in images:\n        uri = image.url\n        filename = uri.rpartition(\"/\")[2]\n        frame = image.parent\n        name = frame.name\n        title = frame.svg_title\n        description = frame.svg_description\n        link = frame.parent\n        # this part requires some ODF know how:\n        caption = None\n        if link.tag == \"draw:a\":\n            caption = link.get_attribute(\"office:name\")\n\n        result[\"images\"].append(\n            f\"Image: {filename}\\n\"\n            f\"  Name: {name}, Title: {title}, \"\n            f\"Description:{description}, Caption:{caption}\"\n        )\n        if title:\n            result[\"titles\"] += 1\n        if description:\n            result[\"descriptions\"] += 1\n        if caption:\n            result[\"captions\"] += 1\n\n    return result\n\n\ndef display_accessibilty(stats: dict[str, Any]) -&gt; None:\n    \"\"\"Print the stats on stdout.\"\"\"\n    print(f\"The document displays {len(stats['images'])} pictures:\")\n    print(f\" - pictures with a title: {stats['titles']}\")\n    print(f\" - pictures with a description: {stats['descriptions']}\")\n    print(f\" - pictures with a caption: {stats['captions']}\")\n    print()\n    for content in stats[\"images\"]:\n        print(content)\n\n\ndef main() -&gt; None:\n    document = read_source_document()\n    stats = accessibility_evaluator(document)\n    display_accessibilty(stats)\n    test_unit(stats)\n\n\ndef test_unit(stats: dict[str, Any]) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert len(stats[\"images\"]) == 3\n    assert stats[\"titles\"] == 2\n    assert stats[\"descriptions\"] == 1\n    assert stats[\"captions\"] == 0\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#add-logo-on-presentation","title":"Add logo on presentation","text":"<p>Insert an image (e.g. the logo of an event, organization or a Creative Commons attribution) with size <code>x,y</code> at position <code>x2,y2</code> on a number of slides in a presentation slide deck.</p> recipes/add_logo_on_presentation.py <pre><code>#!/usr/bin/env python\n\"\"\"Insert an image (e.g. the logo of an event, organization or a Creative Commons\nattribution) with size `x,y` at position `x2,y2` on a number of slides in a\npresentation slide deck.\n\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\n\n# reading image size requires a graphic library\nfrom PIL import Image\n\nfrom odfdo import Document, Frame\n\n_DOC_SEQUENCE = 250\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"add_logo\"\nTARGET = \"presentation.odp\"\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"presentation_wo_logo.odp\"\nLOGO = DATA / \"newlogo.png\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef make_image_size(path: Path, size: float) -&gt; tuple[str, str]:\n    \"\"\"Returns the display size (width, height) from the image path and the\n    largest dimension.\"\"\"\n    width, height = Image.open(path).size\n    ratio = max(width / size, height / size)\n    return (f\"{width / ratio:.2f}cm\", f\"{height / ratio:.2f}cm\")\n\n\ndef add_logo(presentation: Document) -&gt; None:\n    \"\"\"Add an image on a presentation.\"\"\"\n    image_position = (\"1.50cm\", \"1.50cm\")\n    svg_title = \"New Logo\"\n    svg_description = \"The new logo with blue background\"\n\n    image_size = make_image_size(LOGO, 4.0)\n    presentation_body = presentation.body\n    uri = presentation.add_file(LOGO)\n\n    for slide in presentation_body.get_draw_pages():\n        # Create a frame for the image\n        image_frame = Frame.image_frame(\n            image=uri,\n            text=\"\",  # Text over the image object\n            size=image_size,  # Display size of image\n            anchor_type=\"page\",\n            page_number=None,\n            position=image_position,\n            style=None,\n        )\n        image_frame.svg_title = svg_title\n        image_frame.svg_description = svg_description\n        slide.append(image_frame)\n\n\ndef main() -&gt; None:\n    document = read_source_document()\n    add_logo(document)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    slides = document.body.get_draw_pages()\n    assert len(slides) == 11\n    for slide in slides:\n        assert len(slide.get_images()) == 1\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#get-pictures-from-document-odt","title":"Get pictures from document odt","text":"<p>Get all the pictures embeded in an .odt file.</p> recipes/get_pictures_from_document_odt.py <pre><code>#!/usr/bin/env python\n\"\"\"Get all the pictures embeded in an .odt file.\n\"\"\"\nimport sys\nfrom pathlib import Path\nfrom pprint import pformat\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 260\nDATA = Path(__file__).parent / \"data\"\n# ODF export of Wikipedia article Hitchhiker's Guide to the Galaxy (CC-By-SA)\n# Remark: the document is badly made: the pictures are not displayed in the\n# text, but are sill inside the document !\nSOURCE = \"collection.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"found_pics\"\n\n\ndef read_source_document():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef main():\n    doc = read_source_document()\n    # show the list the content of the document parts\n    parts = doc.parts\n    print(\"Parts:\")\n    print(pformat(parts))\n    print()\n\n    # We want the images of the document.\n    body = doc.body\n    found_pics = body.images\n    print(\"Pics :\")\n    print(pformat(found_pics))\n    print()\n\n    # we use the get_part function from odfdo to get the actual content\n    # of the image, to copy the images out of the .odt file:\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    for pic in found_pics:\n        # where is the image actual content in the file:\n        url = pic.url\n        image_content = doc.get_part(url)\n        origin_path = Path(url)\n        destination_path = OUTPUT_DIR / origin_path.name\n        destination_path.write_bytes(image_content)\n\n    print(f\"Files in {OUTPUT_DIR}:\")\n    for file in OUTPUT_DIR.glob(\"*\"):\n        print(file.name)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#change-image-in-many-documents","title":"Change image in many documents","text":"<p>Change an image in many ODF files.</p> <p>This recipe is suitable for the scenario where an organization is moving from one company logo to another and needs to replace the logo in several hundred existing documents.</p> recipes/change_image_in_many_documents.py <pre><code>#!/usr/bin/env python\n\"\"\"Change an image in many ODF files.\n\nThis recipe is suitable for the scenario where an organization\nis moving from one company logo to another and needs to replace\nthe logo in several hundred existing documents.\n\"\"\"\n\nimport os\nfrom hashlib import sha256\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 270\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"new_logo\"\nDATA = Path(__file__).parent / \"data\"\nOLD_PRESENTATIONS = DATA / \"old_presentations\"\nOLD_LOGO = OLD_PRESENTATIONS / \"oldlogo.png\"\nNEW_LOGO = DATA / \"newlogo.png\"\n\n\ndef save_modified(document: Document) -&gt; None:\n    \"\"\"Save a modified Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    name = Path(document.path).name\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path)\n\n\ndef footprint(content: bytes) -&gt; str:\n    \"\"\"Return sha256 digest of a bytes content.\"\"\"\n    return sha256(content).hexdigest()\n\n\ndef update_document_logo(\n    path: Path,\n    old_hash: str,\n    new_content: bytes,\n    stats: dict[str, int],\n) -&gt; None:\n    \"\"\"Update the logo inside a Document.\"\"\"\n    stats[\"files\"] += 1\n    if not path.suffix.lower().startswith(\".od\"):\n        return\n    try:\n        document = Document(path)\n    except Exception:\n        return\n\n    stats[\"odf_files\"] += 1\n    document_changed = False\n    for image in document.body.images:\n        image_url = image.url\n        if not image_url:\n            continue\n        try:\n            image_content = document.get_part(image_url)\n        except KeyError:\n            print(\"- not found inside document:\", path, end=\" \")\n            print(\"  image URL:\", image_url)\n            continue\n        if footprint(image_content) == old_hash:\n            document.set_part(image_url, new_content)\n            document_changed = True\n    if document_changed:\n        save_modified(document)\n        stats[\"updated_files\"] += 1\n\n\ndef update_logos() -&gt; dict[str, int]:\n    \"\"\"Update logo image in all documents.\"\"\"\n    result: dict[str, int] = {\n        \"files\": 0,\n        \"odf_files\": 0,\n        \"updated_files\": 0,\n    }\n    old_hash = footprint(OLD_LOGO.read_bytes())\n\n    # making the new image content :\n    buffer = Document(\"text\")\n    url = buffer.add_file(str(NEW_LOGO))\n    new_content = buffer.get_part(url)\n\n    for path in OLD_PRESENTATIONS.glob(\"**/*\"):\n        update_document_logo(path, old_hash, new_content, result)\n    return result\n\n\ndef main() -&gt; None:\n    stats = update_logos()\n    print(f\"Files: {stats['files']}\")\n    print(f\"ODF files: {stats['odf_files']}\")\n    print(f\"Updated files: {stats['updated_files']}\")\n    test_unit(stats)\n\n\ndef test_unit(stats: dict[str, int]) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert (stats[\"files\"]) == 3\n    assert (stats[\"odf_files\"]) == 2\n    assert (stats[\"updated_files\"]) == 2\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#concatenate-presentations","title":"Concatenate presentations","text":"<p>Concatenate several presentations (including presentations found in sub directories), possibly merge styles and images. Result for style may vary.</p> recipes/concatenate_presentations.py <pre><code>#!/usr/bin/env python\n\"\"\"Concatenate several presentations (including presentations found in sub\ndirectories), possibly merge styles and images. Result for style may vary.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 280\nDATA = Path(__file__).parent / \"data\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"concatenate\"\nTARGET = \"presentation.odp\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = concatenate_presentations()\n    save_new(document, TARGET)\n\n\ndef concatenate_presentations():\n    concat_presentation = Document(\"presentation\")\n    concat_presentation.body.clear()\n    concat_presentation.delete_styles()\n\n    count = 0\n    for presentation_path in DATA.glob(\"**/*.odp\"):\n        count += 1\n        add_presentation(concat_presentation, presentation_path)\n\n    nb_slides = len(concat_presentation.body.get_draw_pages())\n    print(f\"{count} presentations concatenated, {nb_slides} slides.\")\n\n    return concat_presentation\n\n\ndef add_presentation(concat_presentation, path):\n    \"\"\"Using odfdo for:\n    - open .odp document\n    - copy content and merge styles\n    \"\"\"\n    try:\n        document = Document(path)\n    except Exception:\n        return\n    concat_presentation.merge_styles_from(document)\n    # add all slides\n    dest_body = concat_presentation.body\n    dest_manifest = concat_presentation.manifest\n    manifest = document.manifest\n    slides = document.body.get_draw_pages()\n    print(f\"- {path.name} has {len(slides)} slides\")\n    for slide in slides:\n        slide = slide.clone\n        # dont forget images:\n        for image in slide.images:\n            uri = image.url\n            media_type = manifest.get_media_type(uri)\n            dest_manifest.add_full_path(uri, media_type)\n            concat_presentation.set_part(uri, document.get_part(uri))\n        # append slide, expecting nothing good about its final style\n        dest_body.append(slide)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#make-a-presentation-from-pictures-of-a-text-document","title":"Make a presentation from pictures of a text document","text":"<p>Open a .odt file with pictures in it, find and analyse all the images, create a new .odp presentation, display all the pictures in the presentation, one image per frame.</p> recipes/make_a_presentation_from_pictures_of_a_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Open a .odt file with pictures in it, find and analyse all the images,\ncreate a new .odp presentation, display all the pictures in the presentation,\none image per frame.\n\"\"\"\nimport os\nfrom pathlib import Path\nfrom tempfile import mkstemp\n\n# analyzing embedded image need Pillow library\nfrom PIL import Image\n\nfrom odfdo import Document, DrawPage, Frame\n\n_DOC_SEQUENCE = 285\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"presentation_images_in_odt\"\nTARGET = \"presentation.odp\"\nDATA = Path(__file__).parent / \"data\"\nSOURCE = DATA / \"collection.odt\"\n\n\ndef embedded_image_ratio(href, part):\n    image_suffix = \".\" + href.split(\".\")[-1]\n    fd, tmp_file = mkstemp(suffix=image_suffix)\n    tmp_file_handler = os.fdopen(fd, \"wb\")\n    tmp_file_handler.write(part)\n    tmp_file_handler.close()\n    width, height = Image.open(tmp_file).size\n    os.unlink(tmp_file)\n    print(f\"image {href} , size : {width}x{height}\")\n    ratio = 1.0 * width / height\n    return ratio\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = generate_document()\n    save_new(document, TARGET)\n\n    _expected_result = \"\"\"\n    image Pictures/12918371211855030272.jpe , size : 333x386\n    image Pictures/12918371212102410240.jpe , size : 200x350\n    image Pictures/12918371212184750080.jpe , size : 384x552\n    image Pictures/12918371212196450304.jpe , size : 373x576\n    image Pictures/12918371212450449408.jpe , size : 400x596\n    image Pictures/12918371212536940544.jpe , size : 800x1195\n    image Pictures/12918371212580190208.jpe , size : 561x282\n    image Pictures/12918371212597118976.jpe , size : 660x515\n    image Pictures/12918371212741570560.jpe , size : 328x504\n    \"\"\"\n\n\ndef generate_document():\n    # Open the input document\n    # doc_source = Document_extend(filename)\n    doc_source = Document(SOURCE)\n\n    # Making of the output Presentation document :\n    presentation = Document(\"presentation\")\n\n    # Presentation got a body in which elements are stored\n    presentation_body = presentation.body\n    presentation_body.clear()\n    presentation_manifest = presentation.manifest\n\n    # For each image, we create a page in the presentation and display the image\n    # and some text on this frame\n    # First, get all image elements available in document:\n    images_source = doc_source.body.images\n    manifest_source = doc_source.manifest\n\n    for image in images_source:\n        # we use the get_part function from odfdo to get the actual content\n        # of the images, with the URI link to the image as argument\n        uri = image.url\n        # weight = len(doc_source.get_part(uri))  # only for info\n        # print \"image %s , size in bytes: %s\" % (uri, weight)\n        part = doc_source.get_part(uri)  # actual image content\n        name = uri.split(\"/\")[-1]  # lets make a file name for image\n\n        # Compute the display size of the image on the final page\n        ratio = embedded_image_ratio(uri, part)\n        max_border = 16.0  # max size of the greatest border, in cm\n        a = max_border * ratio\n        b = max_border\n        if ratio &gt; 1.0:\n            a /= ratio\n            b /= ratio\n\n        # Create an underlying page for the image and the text\n        page = DrawPage(\"page \" + name)\n\n        # Create a frame for the image\n        image_frame = Frame.image_frame(\n            image=uri,\n            text=\"\",  # Text over the image object\n            size=(f\"{a}cm\", f\"{b}cm\"),  # Display size of image\n            anchor_type=\"page\",\n            page_number=None,\n            position=(\"3.5cm\", \"3.5 cm\"),\n            style=None,\n        )\n\n        # Add some text object somehere on the frame, with a text frame\n        legend = f\"Image {name} from Wikipedia document / {SOURCE.name}\"\n        text_frame = Frame.text_frame(\n            legend,\n            size=(\"26cm\", \"2cm\"),\n            position=(\"0.5cm\", \"0.5cm\"),\n            style=\"Standard\",\n            text_style=\"Standard\",\n        )\n\n        # Append all the component, do not forget to add the actuel image file\n        # into the Picture global directory of the presentation file with set_part\n        page.append(text_frame)\n        page.append(image_frame)\n        presentation_body.append(page)\n        # for the same operation from a local filesystem image, just use:\n        # presentation_output.add_file(uri)\n        media_type = manifest_source.get_media_type(uri)\n        presentation_manifest.add_full_path(uri, media_type)\n        presentation.set_part(uri, doc_source.get_part(uri))\n\n    return presentation\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#make-presentation-from-images","title":"Make presentation from images","text":"<p>Create a presentation from a some images in a given directory, where each image is put on the center of its own page scaled to either the maximum available size, prefered maximum size, or cover the full page and lose some info.</p> recipes/make_presentation_from_images.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a presentation from a some images in a given directory,\nwhere each image is put on the center of its own page scaled to either\nthe maximum available size, prefered maximum size, or cover the full\npage and lose some info.\n\"\"\"\nfrom pathlib import Path\n\n# analyzing embedded image need Pillow library\nfrom PIL import Image\n\nfrom odfdo import Document, DrawPage, Frame\n\n_DOC_SEQUENCE = 286\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"presentation_from_images\"\nTARGET = \"presentation.odp\"\nIMAGES = Path(__file__).parent / \"data\" / \"images\"\nMAX_SIZE = 15.0  # feel free to customize\nCROP_SIZE = False  # feel free to customize\n\n# Size (in cm) of a slide : (default page-layout)\nSLIDE_W, SLIDE_H = 28.0, 21.0  # 4/3 screen\n# FIXME: this is the default page-layout.\n# - Changing the style of the page-layout by program is not done in this script\n# - an other way, merging with external page-layout/master-page requires\n#   extra files, out of the scope for this script.\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path)\n\n\ndef main():\n    presentation = make_presentation()\n    if presentation is None:\n        print(\"Something went wrong.\")\n        exit(0)\n    save_new(presentation, TARGET)\n\n\ndef make_presentation():\n    # Collecting images\n    images_pool = collect_images()\n    if not images_pool:  # unable to find images\n        print(\"No image found !\")\n        return None\n\n    # Creation of the output Presentation document :\n    # presentation = Document_from_type('presentation')  # 092\n    presentation = Document(\"presentation\")\n\n    # Presentation got a body in which content is stored\n    presentation_body = presentation.body\n    presentation_body.clear()\n\n    # For each image, we create a page in the presentation and display the image\n    # and some text on this frame\n    for image in images_pool:\n        # add the file to the document\n        uri = presentation.add_file(str(image.path))\n\n        # Create an underlying page for the image and the text\n        page = DrawPage(\"Page \" + image.path.name)\n\n        # Create a frame for the image\n        image_frame = Frame.image_frame(\n            image=uri,\n            name=image.path.name,\n            text=\"\",  # Text over the image object\n            size=(image.disp_w, image.disp_h),  # Display size of image\n            anchor_type=\"page\",\n            page_number=None,\n            position=(image.pos_x, image.pos_y),\n            style=None,\n        )\n\n        # Append all the component\n        page.append(image_frame)\n        presentation_body.append(page)\n\n    return presentation\n\n\n# Principle :\n# - original image are left unmodified by the script\n# - only the size they should appear is computed\n# - later, the display engine (say LibreOffice) will merge this display\n#   information with other informations, like the size of the page\n#   (page-layout) and should act like a mask against the \"big\" croped image.\nclass ImageInfo:\n    def __init__(self, path: Path):\n        self.path = path\n        self.size = None\n        self.disp_w = self.disp_h = None\n        self.pos_x = self.pos_y = None\n\n    def adjust(self):\n        try:\n            self.size = Image.open(self.path).size\n        except OSError:\n            # Not an image ?\n            self.size = None\n            return\n        width, height = self.size\n        if MAX_SIZE:\n            ratio = max(width / MAX_SIZE, height / MAX_SIZE)\n            display_w = width / ratio\n            display_h = height / ratio\n        elif CROP_SIZE:\n            ratio = min(width / SLIDE_W, height / SLIDE_H)\n            display_w = width / ratio\n            display_h = height / ratio\n        else:\n            ratio = max(width / SLIDE_W, height / SLIDE_H)\n            display_w = width / ratio\n            display_h = height / ratio\n        self.disp_w = f\"{display_w:2f}cm\"\n        self.disp_h = f\"{display_h:2f}cm\"\n        self.pos_x = f\"{(SLIDE_W - display_w) / 2:2f}cm\"\n        self.pos_y = f\"{(SLIDE_H - display_h) / 2:2f}cm\"\n        print(self.path.name, self.disp_w, self.disp_h)\n\n\ndef collect_images():\n    pool = []\n    for path in IMAGES.glob(\"**/*\"):\n        if not path.is_file():\n            continue\n        image_info = ImageInfo(path)\n        image_info.adjust()\n        if image_info.size:\n            pool.append(image_info)\n    return pool\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#make-a-presentation-from-text-with-different-styles","title":"Make a presentation from text with different styles","text":"<p>Each line of the text becomes a slide of the presentation, we change of style depending on the length of text line.</p> recipes/make_a_presentation_from_text_with_different_styles.py <pre><code>#!/usr/bin/env python\n\"\"\"Each line of the text becomes a slide of the presentation, we change of style\ndepending on the length of text line.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, DrawPage, Frame, Style\n\n_DOC_SEQUENCE = 287\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"styled_prez\"\nTARGET = \"presentation.odp\"\n\nCONTENT = \"\"\"123\nazertyuiop\nazertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop azertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop\nazertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop azertyuiop\nend.\n\"\"\".splitlines()\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef create_style() -&gt; Style:\n    \"\"\"Creating a smooth style for the graphic item.\"\"\"\n    base_style = Style(\n        \"graphic\",\n        name=\"Gloup48\",\n        parent=\"standard\",\n        stroke=\"none\",\n        fill_color=\"#b3b3b3\",\n        textarea_vertical_align=\"middle\",\n        padding_top=\"1cm\",\n        padding_bottom=\"1cm\",\n        padding_left=\"1cm\",\n        padding_right=\"1cm\",\n        line_distance=\"0cm\",\n        guide_overhang=\"0cm\",\n        guide_distance=\"0cm\",\n    )\n    base_style.set_properties(area=\"paragraph\", align=\"center\")\n    base_style.set_properties(\n        area=\"text\",\n        color=\"#dd0000\",\n        text_outline=\"false\",\n        font=\"Liberation Sans\",\n        font_family=\"Liberation Sans\",  # compatibility\n        font_style_name=\"Bold\",\n        family_generic=\"swiss\",\n        size=\"48pt\",\n        weight=\"bold\",\n    )\n    return base_style\n\n\ndef generate_document() -&gt; Document:\n    \"\"\"Generate a Presentation Document with different styles.\"\"\"\n    presentation = Document(\"presentation\")\n    body = presentation.body\n    body.clear()\n\n    base_style = create_style()\n    presentation.insert_style(base_style)\n\n    # Making o lot of variations\n    variants = [10, 11, 14, 16, 20, 24, 32, 40, 44]\n    text_size = [95, 80, 65, 50, 40, 30, 20, 10, 5]\n    for size in variants:\n        variant_style = base_style.clone\n        variant_style.set_attribute(\"style:name\", f\"Gloup{size}\")\n        variant_style.set_properties(area=\"text\", size=f\"{size}pt\")\n        presentation.insert_style(variant_style)\n\n    for count, blurb in enumerate(CONTENT):\n        text = blurb\n        name = f\"{count + 1} - {text[:10]}\"\n        page = DrawPage(name)\n        # choosing some style:\n        size = 48\n        for index, max_size in enumerate(text_size):\n            if len(text) &gt; max_size:\n                size = variants[index]\n                break\n\n        text_frame = Frame.text_frame(\n            text,\n            size=(\"24cm\", \"2cm\"),\n            position=(\"2cm\", \"8cm\"),\n            style=f\"Gloup{size}\",\n            text_style=f\"Gloup{size}\",\n        )\n\n        page.append(text_frame)\n        body.append(page)\n\n    return presentation\n\n\ndef main() -&gt; None:\n    document = generate_document()\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    body = document.body\n    count = len([item for item in body.children if isinstance(item, DrawPage)])\n    assert count == len(CONTENT)\n    first_page = body.children[0]\n    assert str(first_page).strip() == CONTENT[0].strip()\n    last_page = body.children[-1]\n    assert str(last_page).strip() == CONTENT[-1].strip()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#extract-and-reorder-slides","title":"Extract and reorder slides","text":"<p>Create a new presentation from a previous one by extracting some slides, in a different order.</p> recipes/extract_and_reorder_slides.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a new presentation from a previous one by extracting some slides,\nin a different order.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 290\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"presentation_extracted\"\nTARGET = \"presentation.odp\"\nDATA = Path(__file__).parent / \"data\"\nSOURCE = DATA / \"presentation_base.odp\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    new_order = (3, 5, 2, 2)\n    presentation_base = Document(SOURCE)\n    extracted = Document(\"presentation\")\n\n    # Important, copy styles too:\n    extracted.delete_styles()\n    extracted.merge_styles_from(presentation_base)\n    extracted.body.clear()\n\n    for index in new_order:\n        try:\n            slide_position = index - 1\n            slide = presentation_base.body.get_draw_page(position=slide_position)\n        except Exception:  # noqa: S112\n            continue\n        if slide is None:\n            continue\n\n        slide = slide.clone\n        extracted.body.append(slide)\n\n    save_new(extracted, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#change-values-of-a-chart-inside-a-document","title":"Change values of a chart inside a document","text":"<p>Open a text document with an embedded chart and change some values.</p> recipes/change_values_of_a_chart_inside_a_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Open a text document with an embedded chart and change some values.\n\"\"\"\n\nfrom pathlib import Path\n\n# for cell style\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 295\nDATA = Path(__file__).parent / \"data\"\nSOURCE = DATA / \"chart.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"modified_chart\"\nTARGET = \"modified_chart.odt\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main() -&gt; None:\n    document = Document(SOURCE)\n    change(document)\n    save_new(document, TARGET)\n\n\ndef change(document: Document) -&gt; None:\n    # list the parts if needed\n    print(document.parts)\n    # -&gt; ['mimetype', 'ObjectReplacements/Object 1', 'Object 1/meta.xml', 'Object 1/styles.xml', 'Object 1/content.xml', ...\n\n    part = document.get_part(\"Object 1/content.xml\")\n    body = part.body\n    table = body.get_table(0)\n\n    # if needed, get the values:\n    values = table.get_values()\n    print(values)\n    # -&gt; [\n    #     [None, \"\", \"Column 2\", \"Column 3\"],\n    #     [\"Row 1\", Decimal(\"NaN\"), 10, 20],\n    #     [\"Row 2\", Decimal(\"NaN\"), 30, 40],\n    #     [\"Row 3\", Decimal(\"NaN\"), 50, 360],\n    #     [\"Row 4\", Decimal(\"NaN\"), Decimal(\"9.02\"), Decimal(\"6.2\")],\n    # ]\n\n    # change some values\n    table.set_value(\"A2\", \"label changed\")\n    table.set_value(\"D3\", 4000)\n    table.set_value(\"D4\", 4321)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#add-text-span-styles","title":"Add text span styles","text":"<p>Transform a not styled document into a multi styled document, by changing size and color of each parts of words.</p> recipes/add_text_span_styles.py <pre><code>#!/usr/bin/env python\n\"\"\"Transform a not styled document into a multi styled document,\nby changing size and color of each parts of words.\n\"\"\"\n\nimport os\nimport sys\nfrom itertools import chain\nfrom pathlib import Path\n\nfrom odfdo import Document, Style\n\n_DOC_SEQUENCE = 300\nDATA = Path(__file__).parent / \"data\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"styled3\"\nSOURCE = \"dormeur_notstyled.odt\"\nTARGET = \"dormeur_styled.odt\"\nRANDOM_SEED = 1234\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\nclass SimpleRandom:\n    \"\"\"Q&amp;D reproductible random generator for tests.\"\"\"\n\n    MODULUS = 2**31 - 1\n    MAXI = 2**31 - 2\n\n    def __init__(self) -&gt; None:\n        self.current = 16807\n\n    def _next_number(self) -&gt; None:\n        self.current = (16807 * self.current) % self.MODULUS\n\n    def set_seed(self, seed: int = 16807) -&gt; None:\n        self.current = seed\n\n    def randint(self, max_value: int) -&gt; int:\n        self._next_number()\n        return int(self.current * max_value / self.MAXI + 1)\n\n\ndef color_hex(r: int, g: int, b: int) -&gt; str:\n    \"\"\"Convert red, green, blue values to #rgb string.\"\"\"\n    return f\"#{r:02X}{g:02X}{b:02X}\"\n\n\ndef style_name_index(index: int) -&gt; str:\n    \"\"\"Generate a style_name.\"\"\"\n    return f\"rnd_{index}\"\n\n\ndef generate_random_styles(document: Document, rnd: SimpleRandom) -&gt; None:\n    \"\"\"Generate 64 random styles.\"\"\"\n    for index in range(1, 64):\n        style = Style(\n            \"text\",\n            name=style_name_index(index),\n            color=color_hex(rnd.randint(256), rnd.randint(256), rnd.randint(256)),\n            size=f\"{8 + index / 5}\",\n        )\n        document.insert_style(style)\n\n\ndef add_styles(document: Document) -&gt; None:\n    \"\"\"Change randomly size and color of words.\"\"\"\n    rnd = SimpleRandom()\n    body = document.body\n\n    generate_random_styles(document, rnd)\n\n    words = sorted(set(str(body).split()))\n    for word in words:\n        style_name = style_name_index(rnd.randint(64))\n        for paragraph in chain(body.paragraphs, body.headers):\n            # apply style to each text matching with the regex of some word\n            paragraph.set_span(style_name, regex=word)\n\n\ndef main():\n    document = read_source_document()\n    add_styles(document)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert len(document.body.spans) == 157\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-copy-some-style-from-another-document","title":"How to copy some style from another document","text":"<p>Minimal example of copy of a style from another document.</p> recipes/how_to_copy_some_style_from_another_document.py <pre><code>\"\"\"Minimal example of copy of a style from another document.\n\"\"\"\n\nfrom odfdo import Document, Style\n\n_DOC_SEQUENCE = 310\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n\n    # Let's imagine the sample_styles.odt document contains an interesting style.\n    #\n    # So let's first fetch the style:\n    try:\n        odfdo_styles = Document(\"sample_styles.odt\")\n        highlight = odfdo_styles.get_style(\"text\", display_name=\"Yellow Highlight\")\n    except Exception:\n        # let's create some *very simple* text style.\n        highlight = Style(\n            \"text\", display_name=\"Yellow Highlight\", color=\"blue\", italic=True\n        )\n\n    # We made some assumptions here:\n    #\n    # 'text'              : The family of the style, text styles apply on\n    #                       individual characters.\n    # \u201dYellow Highlight\u201d  : The name of the style as we see it in a desktop\n    #                       application.\n    # display_name        : Styles have an internal name (\u201cYellow_20_Highlight\u201d\n    #                       in this example) but we gave the display_name\n    #                       instead.\n    #\n    # We hopefully have a style object that we add to our own collection:\n    document.insert_style(highlight, automatic=True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#copy-style-from-another-document","title":"Copy style from another document","text":"<p>Copy the styles from an existing document.</p> <p>For more advanced version, see the odfdo-style script.</p> recipes/copy_style_from_another_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Copy the styles from an existing document.\n\nFor more advanced version, see the odfdo-style script.\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 320\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\n# copied here from the odfdo package:\nSTYLE_SOURCE = DATA / \"lpod_styles.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"styled1\"\nTARGET = \"document.odt\"\n\n\ndef read_source_document():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    # We want to change the styles of collection2.odt,\n    # we know the odfdo_styles.odt document contains an interesting style,\n    # So let's first fetch the style:\n    style_document = Document(STYLE_SOURCE)\n\n    # Open our document:\n    document = read_source_document()\n\n    # We could change only some styles, but here we want a clean basis:\n    document.delete_styles()\n\n    # And now the actual style change:\n    document.merge_styles_from(style_document)\n\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-basic-text-styles","title":"Create basic text styles","text":"<p>Create basic text styles.</p> recipes/create_basic_text_styles.py <pre><code>#!/usr/bin/env python\n\"\"\"Create basic text styles.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Header, Paragraph, Style\n\n_DOC_SEQUENCE = 330\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_styles\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef _create_style_header_blue(document: Document) -&gt; None:\n    style = Style(\n        family=\"paragraph\",\n        name=\"header_blue\",\n        display_name=\"header_blue\",\n        parent_style=\"Heading\",\n        area=\"text\",\n        bold=True,\n        color=\"blue\",\n        size=\"160%\",\n    )\n    style.set_attribute(\"style:default-outline-level\", \"1\")\n    document.insert_style(style)\n\n\ndef _create_style_header_navy(document: Document) -&gt; None:\n    style = Style(\n        family=\"paragraph\",\n        name=\"header_navy\",\n        display_name=\"header_navy\",\n        parent_style=\"Heading\",\n        area=\"text\",\n        bold=True,\n        color=\"navy\",\n        size=\"120%\",\n    )\n    style.set_attribute(\"style:default-outline-level\", \"2\")\n    document.insert_style(style)\n\n\ndef _create_style_steel(document: Document) -&gt; None:\n    style = Style(\n        family=\"paragraph\",\n        area=\"text\",\n        name=\"steel\",\n        display_name=\"steel\",\n        color=\"yellow\",\n        background_color=\"darkblue\",\n    )\n    style.set_properties(\n        area=\"graphic\",\n        properties={\n            \"draw:fill\": \"solid\",\n            \"draw:fill-color\": \"darkblue\",\n        },\n    )\n    document.insert_style(style)\n\n\ndef _create_style_special(document: Document) -&gt; None:\n    style = Style(\n        family=\"paragraph\",\n        area=\"text\",\n        name=\"special\",\n        display_name=\"special\",\n        font=\"Courier New\",\n        font_family=\"Courier New\",\n        font_style_name=\"Regular\",\n        font_pitch=\"fixed\",\n        background_color=\"AntiqueWhite\",\n    )\n    style.set_properties(\n        area=\"paragraph\",\n        properties={\n            \"fo:margin-left\": \"2cm\",\n            \"fo:margin-right\": \"2cm\",\n            \"fo:line-height\": \"150%\",\n            \"fo:text-align\": \"center\",\n        },\n    )\n    document.insert_style(style)\n\n\ndef _create_style_bold_gold(document: Document) -&gt; None:\n    style = Style(\n        family=\"text\",\n        name=\"bold_gold\",\n        display_name=\"bold_gold\",\n        bold=True,\n        color=\"darkgoldenrod\",\n    )\n    document.insert_style(style)\n\n\ndef _create_style_italic_lime(document: Document) -&gt; None:\n    style = Style(\n        family=\"text\",\n        name=\"italic_lime\",\n        display_name=\"italic_lime\",\n        italic=True,\n        size=\"120%\",\n        color=\"lime\",\n    )\n    document.insert_style(style)\n\n\ndef add_styles(document: Document) -&gt; None:\n    _create_style_header_blue(document)\n    _create_style_header_navy(document)\n    _create_style_steel(document)\n    _create_style_special(document)\n    _create_style_bold_gold(document)\n    _create_style_italic_lime(document)\n\n\ndef add_content(document: Document) -&gt; None:\n    body = document.body\n    body.append(Header(1, \"First level header\", style=\"header_blue\"))\n\n    body.append(Header(2, \"First sub header\", style=\"header_navy\"))\n    para = Paragraph(\n        \"Lorem ipsum dolor sit amet, consectetuer \"\n        \"adipiscing elit. Sed non risus. \"\n        \"Suspendisse lectus tortor, dignissim sit amet, \"\n        \"adipiscing nec, ultricies sed, dolor.\"\n    )\n    para.set_span(\"bold_gold\", regex=\"dolor\")\n    para.set_span(\"italic_lime\", regex=r\"\\w+ing\")\n    body.append(para)\n\n    body.append(Header(2, \"Second sub header\", style=\"header_navy\"))\n    para = Paragraph(\n        \"Cras elementum ultrices diam. Maecenas ligula massa, \"\n        \"varius a, semper congue, euismod non, mi. Proin porttitor, \"\n        \"orci nec nonummy molestie, enim est eleifend mi, non \"\n        \"fermentum diam nisl sit amet erat. Duis semper.\",\n        style=\"steel\",\n    )\n    para.set_span(\"italic_lime\", regex=\"semper\")\n    body.append(para)\n\n    body.append(Header(2, \"Third sub header\", style=\"header_navy\"))\n    para = Paragraph(\n        \"Duis arcu massa, scelerisque vitae, consequat in, pretium a, \"\n        \"enim. Pellentesque congue. Ut in risus volutpat libero \"\n        \"pharetra tempor. Cras vestibulum bibendum augue. Praesent \"\n        \"egestas leo in pede. Praesent blandit odio eu enim. \"\n        \"Pellentesque sed dui ut augue blandit sodales.\",\n        style=\"special\",\n    )\n    body.append(para)\n\n\ndef create_document() -&gt; Document:\n    document = Document()\n    body = document.body\n    body.clear()\n    add_styles(document)\n    add_content(document)\n    return document\n\n\ndef main() -&gt; None:\n    document = create_document()\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    style1 = document.get_style(\"paragraph\", \"header_blue\").serialize()\n    assert 'name=\"header_blue\"' in style1\n    assert 'color=\"#0000FF\"' in style1\n    assert 'font-weight=\"bold\"' in style1\n    assert 'font-size=\"160%\"' in style1\n\n    style2 = document.get_style(\"paragraph\", \"header_navy\").serialize()\n    assert 'name=\"header_navy\"' in style2\n    assert 'color=\"#000080\"' in style2\n    assert 'font-weight=\"bold\"' in style2\n    assert 'font-size=\"120%\"' in style2\n\n    style3 = document.get_style(\"paragraph\", \"steel\").serialize()\n    assert 'name=\"steel\"' in style3\n    assert 'color=\"#FFFF00\"' in style3\n    assert \"graphic-properties\" in style3\n    assert 'draw:fill-color=\"#00008B\"' in style3\n\n    style4 = document.get_style(\"paragraph\", \"special\").serialize()\n    assert 'name=\"special\"' in style4\n    assert 'background-color=\"#FAEBD7\"' in style4\n    assert \"Courier\" in style4\n    assert 'line-height=\"150%\"' in style4\n    assert 'margin-left=\"2cm\"' in style4\n    assert 'margin-right=\"2cm\"' in style4\n    assert 'text-align=\"center\"' in style4\n\n    style5 = document.get_style(\"text\", \"bold_gold\").serialize()\n    assert 'name=\"bold_gold\"' in style5\n    assert 'color=\"#B8860B\"' in style5\n    assert 'font-weight=\"bold\"' in style5\n\n    style6 = document.get_style(\"text\", \"italic_lime\").serialize()\n    assert 'name=\"italic_lime\"' in style6\n    assert 'color=\"#00FF00\"' in style6\n    assert 'font-style=\"italic\"' in style6\n    assert 'font-size=\"120%\"' in style6\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#how-to-apply-a-style-to-a-paragraph","title":"How to apply a style to a paragraph","text":"<p>Minimal example of how to add a styled paragraph to a document.</p> recipes/how_to_apply_a_style_to_a_paragraph.py <pre><code>\"\"\"Minimal example of how to add a styled paragraph to a document.\n\"\"\"\n\nfrom odfdo import Document, Paragraph\n\n_DOC_SEQUENCE = 335\n\n\ndef main():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n\n    # we knwo we have a style of name \"highlight\" :\n    body.append(Paragraph(\"Highlighting the word\", style=\"highlight\"))\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#change-paragraph-styles-methods","title":"Change paragraph styles methods","text":"<p>Many examples of how to change paragraph (and in-paragraph) styles, either by changing the paragraph style itself or by using Span to select parts of the paragraph. Includes several ways to create or import styles.</p> recipes/change_paragraph_styles_methods.py <pre><code>#!/usr/bin/env python\n\"\"\"Many examples of how to change paragraph (and in-paragraph) styles, either\nby changing the paragraph style itself or by using Span to select parts\nof the paragraph. Includes several ways to create or import styles.\n\"\"\"\nimport os\nfrom collections.abc import Iterator\nfrom itertools import cycle\nfrom pathlib import Path\n\nfrom odfdo import Document, Element, Header, Paragraph, Style\n\n_DOC_SEQUENCE = 340\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"change_styles\"\nDATA = Path(__file__).parent / \"data\"\nLOREM = (DATA / \"lorem.txt\").read_text(encoding=\"utf8\")\nSTYLED_SOURCE = \"lpod_styles.odt\"\nTARGET_BEFORE = \"document_before.odt\"\nTARGET_AFTER = \"document_after.odt\"\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path)\n\n\ndef main() -&gt; None:\n    document = Document(\"odt\")\n    make_base_document(document)\n    save_new(document, TARGET_BEFORE)\n    add_some_styles(document)\n    add_style_from_xml(document)\n    import_style_from_other_doc(document)\n    apply_styles(document)\n    test_unit(document)\n    save_new(document, TARGET_AFTER)\n\n\ndef iter_lorem() -&gt; Iterator[str]:\n    return cycle(lr.strip() for lr in LOREM.replace(\"\\n\", \" \").split(\".\"))\n\n\ndef make_base_document(document: Document) -&gt; None:\n    \"\"\"Fill document from parts or lorem ipsum content.\"\"\"\n    # Create the document\n    body = document.body\n    body.clear()\n    # Add some content with headers\n    lorem = iter_lorem()\n    title1 = Header(1, next(lorem))\n    body.append(title1)\n    for _i in range(3):\n        title = Header(2, next(lorem))\n        body.append(title)\n        for _j in range(5):\n            body.append(Paragraph(next(lorem) + \". \" + next(lorem) + \".\"))\n\n\ndef add_some_styles(document) -&gt; None:\n    # Always simpler to copy styles from an actual .odt existing file, but:\n    document.insert_style(\n        Style(\n            family=\"paragraph\",\n            area=\"text\",\n            display_name=\"bold-blue\",\n            color=\"blue\",\n            bold=True,\n        ),\n        automatic=True,\n    )\n    document.insert_style(\n        Style(\n            family=\"paragraph\",\n            area=\"text\",\n            display_name=\"italic-red\",\n            color=\"red\",\n            bold=True,\n            italic=True,\n        ),\n        automatic=True,\n    )\n    document.insert_style(\n        Style(\n            family=\"text\",\n            area=\"text\",\n            display_name=\"green\",\n            background_color=\"green\",\n        ),\n        automatic=True,\n    )\n    document.insert_style(\n        Style(\n            family=\"text\",\n            area=\"text\",\n            display_name=\"bold-yellow-blue\",\n            color=\"yellow\",\n            background_color=\"blue\",\n            bold=True,\n        ),\n        automatic=True,\n    )\n    document.insert_style(\n        Style(\n            family=\"text\",\n            area=\"text\",\n            display_name=\"bold-white-black\",\n            color=\"white\",\n            background_color=\"black\",\n            bold=True,\n        ),\n        automatic=True,\n    )\n    document.insert_style(\n        Style(\n            family=\"text\",\n            area=\"text\",\n            display_name=\"italic-red-yellow\",\n            color=\"red\",\n            background_color=\"yellow\",\n            bold=True,\n            italic=True,\n        ),\n        automatic=True,\n    )\n\n\ndef add_style_from_xml(document: Document) -&gt; None:\n    # Styles can be defined by WML definition\n    document.insert_style(\n        Element.from_tag(\n            '&lt;style:style style:name=\"custom\" '\n            'style:display-name=\"custom\" '\n            'style:family=\"paragraph\" '\n            'style:parent-style-name=\"Text\"&gt;'\n            '&lt;style:paragraph-properties fo:margin-left=\"2cm\"/&gt;'\n            '&lt;style:text-properties fo:color=\"#808080\" loext:opacity=\"100%\" '\n            'fo:font-size=\"16pt\" fo:font-style=\"normal\" '\n            'style:text-underline-style=\"solid\" '\n            'style:text-underline-width=\"auto\" '\n            'style:text-underline-color=\"font-color\" '\n            'fo:font-weight=\"bold\"/&gt;'\n            \"&lt;/style:style&gt;\"\n        )\n    )\n\n\ndef import_style_from_other_doc(document: Document) -&gt; None:\n    styled_doc = Document(DATA / STYLED_SOURCE)\n    highlight = styled_doc.get_style(\"text\", display_name=\"Yellow Highlight\")\n    document.insert_style(highlight, automatic=True)\n\n\ndef apply_styles(document: Document) -&gt; None:\n    \"\"\"Apply some style changes to document.\"\"\"\n\n    def change_all_headers():\n        style = document.get_style(family=\"text\", display_name=\"green\")\n        # header styles should include some hints about he numeration level\n        # So, here we just prefer to apply style with a span\n        for header in document.body.headers:\n            header.set_span(style.name, offset=0)\n\n    def change_all_paragraphs():\n        style = document.get_style(family=\"paragraph\", display_name=\"bold-blue\")\n        for para in document.body.paragraphs:\n            para.style = style.name\n\n    def change_some_paragraph():\n        style = document.get_style(family=\"paragraph\", display_name=\"italic-red\")\n        document.body.get_paragraph(3).style = style.name\n        document.body.get_paragraph(5).style = style.name\n        document.body.get_paragraph(7).style = style.name\n\n    def apply_span_regex():\n        yellow = document.get_style(family=\"text\", display_name=\"bold-yellow-blue\")\n        white = document.get_style(family=\"text\", display_name=\"bold-white-black\")\n        for para in document.body.paragraphs:\n            para.set_span(yellow.name, regex=r\"tortor|ipsum\")\n            para.set_span(white.name, regex=r\"A\\w+\")\n\n    def apply_span_offset():\n        red = document.get_style(family=\"text\", display_name=\"italic-red-yellow\")\n        para = document.body.get_paragraph(2)\n        para.set_span(red.name, offset=9, length=22)\n\n    def apply_custom_style():\n        para = document.body.get_paragraph(13)\n        para.style = \"custom\"\n\n    def apply_imported_style():\n        para = document.body.get_paragraph(14)\n        style = document.get_style(family=\"text\", display_name=\"Yellow Highlight\")\n        # feature: to not highlight spaces, make as many Spans as required:\n        for start, end in para.search_all(r\"\\w+\"):\n            length = end - start\n            para.set_span(style.name, offset=start, length=length)\n\n    change_all_headers()\n    change_all_paragraphs()\n    change_some_paragraph()\n    apply_span_regex()\n    apply_span_offset()\n    apply_custom_style()\n    apply_imported_style()\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" in os.environ:\n        assert len(list(document.body.paragraphs)) == 15\n        for display_name in (\n            \"bold-blue\",\n            \"italic-red\",\n            \"custom\",\n        ):\n            style = document.get_style(family=\"paragraph\", display_name=display_name)\n            assert document.get_styled_elements(style.name)\n        for display_name in (\n            \"green\",\n            \"bold-yellow-blue\",\n            \"bold-white-black\",\n            \"Yellow Highlight\",\n        ):\n            style = document.get_style(family=\"text\", display_name=display_name)\n            assert document.get_styled_elements(style.name)\n        style = document.get_style(family=\"text\", display_name=\"Yellow Highlight\")\n        assert len(document.get_styled_elements(style.name)) == 21\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#delete-parts-of-a-text-document","title":"Delete parts of a text document","text":"<p>Idea comming from issue #49: Deleting content from one point to another in a .odt document.</p> recipes/delete_parts_of_a_text_document.py <pre><code>#!/usr/bin/env python\n\"\"\"Idea comming from issue #49:\nDeleting content from one point to another in a .odt document.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Element, Header, Paragraph\n\n_DOC_SEQUENCE = 400\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"delete_content\"\nTARGET_INITIAL = \"document_initial.odt\"\nTARGET_FINAL = \"document_final.odt\"\n\n\nclass KeepingState:\n    def __init__(self, initial: str):\n        self.step = initial\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef create_base_document():\n    document = Document(\"text\")\n    body = document.body\n    body.clear()\n    body.append(Header(1, \"Some title\"))\n    body.append(Header(2, \"part A\"))\n    body.append(\n        Paragraph(\n            \"Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Sed non risus.\"\n        )\n    )\n    body.append(\n        Paragraph(\n            \"Suspendisse lectus tortor, dignissim sit amet, adipiscing \"\n            \"nec, ultricies sed, dolor. Cras elementum ultrices diam. \"\n            \"Maecenas ligula massa, varius a, semper congue, euismod non, mi.\"\n        )\n    )\n    body.append(Header(2, \"part B\"))\n    body.append(\n        Paragraph(\n            \"Proin porttitor, orci nec nonummy molestie, enim est eleifend \"\n            \"mi, non fermentum diam nisl sit amet erat. Duis semper. \"\n            \"Duis arcu massa, scelerisque vitae, consequat in, pretium a, \"\n            \"enim. Pellentesque congue. Ut in risus volutpat libero pharetra tempor.\"\n        )\n    )\n    body.append(\n        Paragraph(\n            \"Cras vestibulum bibendum augue. Praesent egestas leo in pede. \"\n            \"Praesent blandit odio eu enim. Pellentesque sed dui ut augue \"\n            \"blandit sodales. Vestibulum ante ipsum primis in faucibus orci \"\n            \"luctus et ultrices posuere cubilia Curae; Aliquam nibh.\"\n        )\n    )\n\n    body.append(Header(2, \"part C\"))\n    body.append(\n        Paragraph(\n            \"Mauris ac mauris sed pede pellentesque fermentum. \"\n            \"Maecenas adipiscing ante non diam sodales hendrerit. Ut \"\n            \"velit mauris, egestas sed, gravida nec, ornare ut, mi.\"\n        )\n    )\n    body.append(\n        Paragraph(\n            \"Aenean ut orci vel massa suscipit pulvinar. Nulla sollicitudin. \"\n            \"Fusce varius, ligula non tempus aliquam, nunc turpis \"\n            \"ullamcorper nibh, in tempus sapien eros vitae ligula. \"\n            \"Pellentesque rhoncus nunc et augue. Integer id felis. Curabitur \"\n            \"aliquet pellentesque diam. Integer quis metus vitae elit \"\n            \"lobortis egestas.\"\n        )\n    )\n    body.append(Header(2, \"part D\"))\n    body.append(\n        Paragraph(\n            \"Morbi vel erat non mauris convallis vehicula. Nulla et sapien. \"\n            \"Integer tortor tellus, aliquam faucibus, convallis id, congue \"\n            \"eu, quam. Mauris ullamcorper felis vitae erat.\"\n            \"Proin feugiat, augue non elementum posuere, metus purus \"\n            \"iaculis lectus, et tristique ligula justo vitae magna. Aliquam \"\n            \"convallis sollicitudin purus.\"\n        )\n    )\n    body.append(\n        Paragraph(\n            \"Praesent aliquam, enim at fermentum mollis, ligula massa \"\n            \"adipiscing nisl, ac euismod nibh nisl eu lectus. Fusce \"\n            \"vulputate sem at sapien. Vivamus leo. Aliquam euismod \"\n            \"libero eu enim. Nulla nec felis sed leo placerat imperdiet.\"\n        )\n    )\n    body.append(\n        Paragraph(\n            \"Aenean suscipit nulla in justo. Suspendisse cursus rutrum augue. \"\n            \"Nulla tincidunt tincidunt mi. Curabitur iaculis, lorem vel \"\n            \"rhoncus faucibus, felis magna fermentum augue, et ultricies \"\n            \"lacus lorem varius purus. Curabitur eu amet.\"\n        )\n    )\n    return document\n\n\ndef keep_element(state: KeepingState, elem: Element) -&gt; bool:\n    # keep everythin until \"part B\"\n    if state.step == \"before\":\n        if isinstance(elem, Header) and \"part B\" in str(elem):\n            state.step = \"deleting\"\n    # delete everythin until paragraph strating with \"Aenean\"\n    if state.step == \"deleting\":\n        if isinstance(elem, Paragraph) and str(elem).startswith(\"Aenean\"):\n            state.step = \"after\"\n    return state.step != \"deleting\"\n\n\ndef main():\n    document = create_base_document()\n    save_new(document, TARGET_INITIAL)\n    # Removing part B and half the part C\n    state = KeepingState(\"before\")\n    keep_list = []\n    for elem in document.body.children:\n        if keep_element(state, elem):\n            keep_list.append(elem)\n    document.body.clear()\n    document.body.extend(keep_list)\n    save_new(document, TARGET_FINAL)\n    test_unit(document)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    text0 = str(document.body.get_paragraph(position=0))\n    print(text0)\n    assert text0.startswith(\"Lorem\")\n    text1 = str(document.body.get_paragraph(position=3))\n    print(text1)\n    assert text1.startswith(\"Morbi\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#create-color-chart-in-spreadsheet","title":"Create color chart in spreadsheet","text":"<p>Create some color chart in a spreadsheet using cells styles. (adapted from the odfdo library test cases)</p> recipes/create_color_chart_in_spreadsheet.py <pre><code>#!/usr/bin/env python\n\"\"\"Create some color chart in a spreadsheet using cells styles.\n(adapted from the odfdo library test cases)\n\"\"\"\n\nfrom pathlib import Path\n\nfrom odfdo import (\n    Cell,\n    Document,\n    Row,\n    Style,\n    Table,\n    __version__,\n    create_table_cell_style,\n    make_table_cell_border_string,\n    rgb2hex,\n)\n\n_DOC_SEQUENCE = 420\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"chart\"\nTARGET = \"color_chart.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path)\n\n\ndef hello_messages():\n    print(\"odfdo installation test\")\n    print(f\" Version           : {__version__}\")\n    print()\n    print(f\"Generating color chart in {TARGET}\")\n    print(\"...\")\n\n\ndef generate_chart():\n    document = Document(\"spreadsheet\")\n    body = document.body\n    body.clear()\n    table = Table(\"chart\")\n\n    for y in range(0, 256, 8):\n        row = Row()\n        for x in range(0, 256, 32):\n            cell_value = (x, y, (x + y) % 256)\n            border_rl = make_table_cell_border_string(thick=\"0.20cm\", color=\"white\")\n            border_bt = make_table_cell_border_string(\n                thick=\"0.80cm\",\n                color=\"white\",\n            )\n            style = create_table_cell_style(\n                color=\"grey\",\n                background_color=cell_value,\n                border_right=border_rl,\n                border_left=border_rl,\n                border_bottom=border_bt,\n                border_top=border_bt,\n            )\n            name = document.insert_style(style=style, automatic=True)\n            cell = Cell(value=rgb2hex(cell_value), style=name)\n            row.append_cell(cell)\n        table.append_row(row)\n\n        row_style = Style(\"table-row\", height=\"1.80cm\")\n        name_style_row = document.insert_style(style=row_style, automatic=True)\n        for row in table.rows:\n            row.style = name_style_row\n            table.set_row(row.y, row)\n\n        col_style = Style(\"table-column\", width=\"3.6cm\")\n        name = document.insert_style(style=col_style, automatic=True)\n        for column in table.columns:\n            column.style = col_style\n            table.set_column(column.x, column)\n\n    body.append(table)\n\n    return document\n\n\ndef main():\n    hello_messages()\n    document = generate_chart()\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#get-cell-background-color","title":"Get cell background color","text":"<p>Read the background color of a table cell.</p> recipes/get_cell_background_color.py <pre><code>#!/usr/bin/env python\n\"\"\"Read the background color of a table cell.\n\"\"\"\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 440\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"cell_color.ods\"\n\n\ndef read_source_document():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef main():\n    doc = read_source_document()\n\n    # reading color from the table 0 (first sheet)\n    color_b2 = doc.get_cell_background_color(0, \"b2\")\n    print(\"Color for B2\", color_b2)\n\n    color_b3 = doc.get_cell_background_color(0, \"b3\")\n    print(\"Color for B3\", color_b3)\n\n    color_c3 = doc.get_cell_background_color(0, \"c3\")\n    print(\"Color for C3\", color_c3)\n\n    # default is \"#ffffff\"\n    color_d3 = doc.get_cell_background_color(0, \"d3\")\n    print(\"Color for D3\", color_d3)\n\n    # set another default\n    color_e3 = doc.get_cell_background_color(0, \"e3\", \"#123456\")\n    print(\"Color for e3\", color_e3)\n\n    # read very far cell\n    color_far = doc.get_cell_background_color(0, (1000, 10000))\n    print(\"Color for far\", color_far)\n\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    assert color_b2 == \"#2a6099\"\n    assert color_b3 == \"#ff4000\"\n    assert color_c3 == \"#ffff00\"\n    assert color_d3 == \"#ffffff\"\n    assert color_e3 == \"#123456\"\n    assert color_far == \"#ffffff\"\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#extract-a-sub-table-from-some-big-table","title":"Extract a sub table from some big table","text":"<p>Create a table of 1000 lines and 100 columns, extract a sub table of 100 lines 26 columns, save the result in a spreadsheet document.</p> recipes/extract_a_sub_table_from_some_big_table.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a table of 1000 lines and 100 columns, extract a sub table\nof 100 lines 26 columns, save the result in a spreadsheet document.\n\"\"\"\nimport os\nfrom pathlib import Path\n\nfrom odfdo import Document, Row, Table\n\n_DOC_SEQUENCE = 450\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"extract_table\"\nTARGET = \"document.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef syracuse(n: int) -&gt; int:\n    if n % 2 == 0:\n        return n // 2\n    return 3 * n + 1\n\n\ndef generate_big_table(table_name) -&gt; Document:\n    spreadsheet = Document(\"spreadsheet\")\n    body = spreadsheet.body\n    body.clear()\n    table = Table(table_name)\n    body.append(table)\n\n    lines = 1000\n    cols = 100\n\n    for line in range(lines):\n        row = Row()\n        values = []\n        n = line\n        for _i in range(cols):\n            values.append(n)\n            n = syracuse(n)\n        row.set_values(values)\n        table.append(row)\n\n    return spreadsheet\n\n\ndef main():\n    table_name = \"Big Table\"\n    spreadsheet = generate_big_table(table_name)\n    body = spreadsheet.body\n    big_table = body.get_table(name=table_name)\n    print(\"Size of Big Table :\", big_table.size)\n\n    # now extract 100 rows of 26 columns :\n    table1 = Table(\"Extract 1\")\n    for r in range(800, 900):\n        row = big_table.get_row(r)\n        extracted_values = [row.get_value(x) for x in range(50, 76)]\n        new_row = Row()\n        new_row.set_values(extracted_values)\n        table1.append(new_row)\n    body.append(table1)\n    print(\"Size of extracted table 1 :\", table1.size)\n\n    # other method\n    table2 = Table(\"Extract 2\")\n    cells = big_table.get_cells(coord=(50, 800, 75, 899))\n    table2.set_cells(coord=(0, 0), cells=cells)\n    body.append(table2)\n    print(\"Size of extracted table 2 :\", table2.size)\n\n    test_unit(spreadsheet)\n\n    save_new(spreadsheet, TARGET)\n\n    _expected_result = \"\"\"\nSize of Big Table : (100, 1000)\nSize of extracted table 1 : (26, 100)\nSize of extracted table 2 : (26, 100)\n\"\"\"\n\n\ndef test_unit(spreadsheet: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n    body = spreadsheet.body\n    table1 = body.get_table(position=0)\n    assert table1.size == (100, 1000)\n    table2 = body.get_table(position=1)\n    assert table2.size == (26, 100)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#make-a-basic-spreadsheet","title":"Make a basic spreadsheet","text":"<p>Create a spreadsheet with one table and a few data, strip the table and compute the table size.</p> recipes/make_a_basic_spreadsheet.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a spreadsheet with one table and a few data, strip the table\nand compute the table size.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document, Table\n\n_DOC_SEQUENCE = 460\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"basic_ods\"\nTARGET = \"spreadsheet.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = generate_document()\n    save_new(document, TARGET)\n\n\ndef generate_document():\n    # creating an empty spreadsheet document:\n    document = Document(\"spreadsheet\")\n\n    # Each sheet of a spreadsheet is a table:\n    # setting drom the beginning width (columns) and height (rows)\n    # is not mandatory, but a good practice, since odfdo don't check\n    # actual existence of cells\n    body = document.body\n    body.clear()\n    table = Table(\"First Table\", width=20, height=3)\n    body.append(table)\n\n    # A table contains rows, we can append some more.\n    for _ in range(2):\n        table.append_row()\n    print(\"rows in the table (3+2):\", len(table.rows))\n\n    #  A row contains cells\n    for row in table.rows:\n        print(\"row, nb of cells \", row.y, len(row.cells))\n\n    last_row = table.get_row(-1)\n    print(\"nb of cells of the last row:\", len(last_row.cells))\n\n    # cell can have different kind of values\n    for row_nb in range(3):\n        for col_nb in range(10):\n            table.set_value((col_nb, row_nb), f\"cell {col_nb} {row_nb}\")\n    for row_nb in range(3, 5):\n        for col_nb in range(10):\n            table.set_value((col_nb, row_nb), col_nb * 100 + row_nb)\n\n    # Before saving the document,  we can strip the unused colums:\n    print(\"table size:\", table.size)\n    table.rstrip()\n    print(\"table size after strip:\", table.size)\n    print(\"nb of cells of the last row:\", len(table.get_row(-1).cells))\n    print(\"Content of the table:\")\n    print(table.to_csv())\n\n    return document\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#make-spreadsheet-with-named-ranges","title":"Make spreadsheet with named ranges","text":"<p>Create a spreadsheet with two tables, using some named ranges.</p> recipes/make_spreadsheet_with_named_ranges.py <pre><code>#!/usr/bin/env python\n\"\"\"Create a spreadsheet with two tables, using some named ranges.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document, Table\n\n_DOC_SEQUENCE = 470\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"named_range\"\nTARGET = \"spreadsheet.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = generate_document()\n    save_new(document, TARGET)\n\n\ndef generate_document():\n    document = Document(\"spreadsheet\")\n    body = document.body\n    body.clear()\n    table = Table(\"First Table\")\n    body.append(table)\n    # populate the table :\n    for index in range(10):\n        table.set_value((1, index), (index + 1) ** 2)\n    table.set_value(\"A11\", \"Total:\")\n\n    # lets define a named range for the 10 values :\n    range_squares = \"B1:B10\"\n    name = \"squares_values\"\n    table_name = table.name\n    table.set_named_range(name, range_squares, table_name)\n\n    # we can define a single cell range, using notation \"B11\" or (1, 10) :\n    table.set_named_range(\"total\", (1, 10), table_name)\n\n    # get named range values :\n    values = table.get_named_range(\"squares_values\").get_values(flat=True)\n\n    # set named range value :\n    result = sum(values)\n    table.get_named_range(\"total\").set_value(result)\n\n    # lets use the named ranges from a second table :\n    table2 = Table(\"Second Table\")\n    body.append(table2)\n\n    named_range1 = table2.get_named_range(\"total\")\n    table2.set_value(\"A1\", \"name:\")\n    table2.set_value(\"B1\", named_range1.name)\n    table2.set_value(\"A2\", \"range:\")\n    table2.set_value(\"B2\", str(named_range1.crange))\n    table2.set_value(\"A3\", \"from table:\")\n    table2.set_value(\"B3\", named_range1.table_name)\n    table2.set_value(\"A4\", \"content:\")\n    table2.set_value(\"B4\", named_range1.get_value())\n\n    named_range2 = table2.get_named_range(\"squares_values\")\n    table2.set_value(\"D1\", \"name:\")\n    table2.set_value(\"E1\", named_range2.name)\n    table2.set_value(\"D2\", \"range:\")\n    table2.set_value(\"E2\", str(named_range2.crange))\n    table2.set_value(\"D3\", \"from table:\")\n    table2.set_value(\"E3\", named_range2.table_name)\n    table2.set_value(\"D4\", \"content:\")\n    # using \"E4:4\" notaion is a little hack for the area starting at E4 on row 4\n    table2.set_values(values=[named_range2.get_values(flat=True)], coord=\"E4:4\")\n\n    print(\"Content of the table1:\")\n    print(table.name)\n    print(table.to_csv())\n    print(table2.name)\n    print(table2.to_csv())\n\n    # of course named ranges are stored in the document :\n    return document\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#introspecting-elements","title":"Introspecting elements","text":"<p>Demo of quick introspecting of a document\u2019s elements.</p> recipes/introspecting_elements.py <pre><code>#!/usr/bin/env python\n\"\"\"Demo of quick introspecting of a document's elements.\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 480\nDATA = Path(__file__).parent / \"data\"\n# ODF export of Wikipedia article Hitchhiker's Guide to the Galaxy (CC-By-SA) :\nSOURCE = \"collection2.odt\"\n\n\ndef read_source_document():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef main():\n    document = read_source_document()\n\n    # The body object is an XML element from which we can access one or several\n    # other elements we are looking for.\n    body = document.body\n\n    # Should you be lost, remember elements are part of an XML tree:\n    para = body.get_paragraph(position=42)\n    print(\"Children of the praragraph:\\n   \", para.children)\n    print(\"\\nParent of the paragraph:\\n   \", para.parent)\n\n    # And you can introspect any element as serialized XML:\n    link0 = body.get_link(position=0)\n    print(\"\\nContent of the serialization link:\")\n    print(\"   \", link0.serialize())\n    print(\"\\nWhich is different from the text content of the link:\")\n    print(\"   \", str(link0))\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#show-meta-data","title":"Show meta data","text":"<p>Print the metadata informations of a ODF file.</p> recipes/show_meta_data.py <pre><code>#!/usr/bin/env python\n\"\"\"Print the metadata informations of a ODF file.\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 490\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\n\n\ndef read_source_document():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef main():\n    document = read_source_document()\n\n    # Metadata are accessible through the meta part:\n    # meta = document.get_part(\"meta.xml\")\n    # or the shortcut:\n    meta = document.meta\n\n    # You then get access to various getters and setters. The getters return\n    # Python types and the respective setters take the same Python type as\n    # a parameter.\n    #\n    # Here are the output of the get_xxx methods for metadata.\n    # (Notice that odfdo doesn't increment editing cycles nor statistics\n    # when saving the document.\n    # For the metadata using dates or durations, lpOD provides datatypes that\n    # decode from and serialize back to strings.\n    # Strings are always decoded as unicode, numeric values are always decoded\n    # as Decimal (as they offer the best precision).\n\n    print(f\"Meta data of {document.container.path}\")\n    # print(\"Title                :\", meta.get_title())\n    print(\"Title                :\", meta.title)\n    # print(\"creator              :\", meta.get_creator())\n    print(\"creator              :\", meta.creator)\n    # print(\"creation date        :\", meta.get_creation_date())\n    print(\"creation date        :\", meta.creation_date)\n    # print(\"modification date    :\", meta.get_modification_date())\n    print(\"modification date    :\", meta.date)\n    # print(\"initial creator      :\", meta.get_initial_creator())\n    print(\"initial creator      :\", meta.initial_creator)\n    # print(\"subject              :\", meta.get_subject())\n    print(\"subject              :\", meta.subject)\n    # print(\"description          :\", meta.get_description())\n    print(\"description          :\", meta.description)\n    # print(\"editing cycles       :\", meta.get_editing_cycles())\n    print(\"editing cycles       :\", meta.editing_cycles)\n    # print(\"editing duration     :\", meta.get_editing_duration())\n    print(\"editing duration     :\", meta.editing_duration)\n    # print(\"generator            :\", meta.get_generator())\n    print(\"generator            :\", meta.generator)\n    # print(\"language             :\", meta.get_language())\n    print(\"language             :\", meta.language)\n    print(\"keywords             :\", meta.keyword)\n    print(\"statistics    \")\n    if meta.statistic is not None:\n        for key, value in meta.statistic.items():\n            print(f\"   {key[5:]:&lt;18}: {value}\")\n    user_defined = meta.user_defined_metadata\n    if user_defined:\n        print(\"user defined metadata\")\n        for key, value in user_defined.items():\n            print(f\"   {key[5:]:&lt;18}: {value}\")\n\n    # A quick way to have all of those informations:\n    print(\"-\" * 70)\n    print(document.get_formated_meta())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#move-link-to-footnote","title":"Move link to footnote","text":"<p>Remove all links from a document, transforming each link information (URL, text) into a footnote. Of course, removing links already inside notes, just keeping plain text URL. (Side note: most office suite dislike notes in notes)</p> recipes/move_link_to_footnote.py <pre><code>#!/usr/bin/env python\n\"\"\"Remove all links from a document, transforming each link information (URL,\ntext) into a footnote. Of course, removing links already inside notes, just\nkeeping plain text URL. (Side note: most office suite dislike notes in notes)\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 500\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"footnote1\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef remove_links(element):\n    tag = \"text:a\"\n    keep_inside_tag = \"None\"\n    context = (tag, keep_inside_tag, False)\n    element, _is_modified = _tree_remove_tag(element, context)\n\n\ndef main():\n    try:\n        source = Path(sys.argv[1])\n    except IndexError:\n        source = DATA / SOURCE\n\n    document = Document(str(source))\n    body = document.body\n\n    print(\"Moving links to footnotes from\", source)\n    print(\"links occurrences:\", len(body.get_links()))\n    print(\"footnotes occurences:\", len(body.get_notes()))\n\n    counter_links_in_notes = 0\n    for note in body.get_notes():\n        for link in note.get_links():\n            counter_links_in_notes += 1\n            url = link.get_attribute(\"xlink:href\")\n            tail = link.tail\n            new_tail = f\" (link: {url}) {tail}\"\n            link.tail = new_tail\n            remove_links(note)\n\n    print(\"links in notes:\", counter_links_in_notes)\n\n    counter_added_note = 0  # added notes counter\n    for paragraph in body.paragraphs:\n        for link in paragraph.get_links():\n            url = link.get_attribute(\"xlink:href\")\n            text = link.inner_text\n            counter_added_note += 1\n            paragraph.insert_note(\n                after=link,  # citation is inserted after current link\n                note_id=f\"my_note_{counter_added_note}\",\n                citation=\"1\",  # The symbol the user sees to follow the footnote.\n                # The footnote itself, at the end of the page:\n                body=(f\". {text}, link: {url}\"),\n            )\n        remove_links(paragraph)\n\n    print(\"links occurrences:\", len(body.get_links()))\n    print(\"footnotes occurences:\", len(body.get_notes()))\n\n    save_new(document, TARGET)\n\n\ndef _tree_remove_tag(element, context):\n    \"\"\"Remove tag in the element, recursive.\n    - context: tuple (tag to remove, protection tag, protection flag)\n    where protection tag protect from change sub elements one sub\n    level depth\"\"\"\n    buffer = element.clone\n    modified = False\n    sub_elements = []\n    tag, keep_inside_tag, protected = context\n    if keep_inside_tag and element.tag == keep_inside_tag:\n        protect_below = True\n    else:\n        protect_below = False\n    for child in buffer.children:\n        striped, is_modified = _tree_remove_tag(\n            child, (tag, keep_inside_tag, protect_below)\n        )\n        if is_modified:\n            modified = True\n        if isinstance(striped, list):\n            for item in striped:\n                sub_elements.append(item)\n        else:\n            sub_elements.append(striped)\n    if not protected and element.tag == tag:\n        element = []\n        modified = True\n    else:\n        if not modified:\n            # no change in element sub tree, no change on element\n            return (element, False)\n        element.clear()\n        try:\n            for key, value in buffer.attributes.items():\n                element.set_attribute(key, value)\n        except ValueError:\n            print(\"Incorrect attribute in\", buffer)\n    text = buffer.text\n    tail = buffer.tail\n    if text is not None:\n        element.append(text)\n    for child in sub_elements:\n        element.append(child)\n    if tail is not None:\n        if isinstance(element, list):\n            element.append(tail)\n        else:\n            element.tail = tail\n    return (element, True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#remove-http-links","title":"Remove http links","text":"<p>Remove the links (the text:a tag), keeping the inner text.</p> recipes/remove_http_links.py <pre><code>#!/usr/bin/env python\n\"\"\"Remove the links (the text:a tag), keeping the inner text.\"\"\"\n\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 510\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"collection2.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"nolink\"\nTARGET = \"document.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    try:\n        source = Path(sys.argv[1])\n    except IndexError:\n        source = DATA / SOURCE\n\n    document = Document(str(source))\n    body = document.body\n\n    print(\"Removing links from\", source)\n    print(\"'text:a' occurrences:\", len(body.get_links()))\n\n    remove_links(body)\n    print(\"'text:a' occurrences after removal:\", len(body.get_links()))\n\n    save_new(document, TARGET)\n\n\ndef remove_links(element):\n    tag = \"text:a\"\n    keep_inside_tag = \"None\"\n    context = (tag, keep_inside_tag, False)\n    element, _is_modified = _tree_remove_tag(element, context)\n\n\ndef _tree_remove_tag(element, context):\n    \"\"\"Remove tag in the element, recursive.\n\n    - context: a tuple (tag to remove, protection tag, protection flag)\n    where protection tag protect from change sub elements one sub level depth\n    \"\"\"\n    buffer = element.clone\n    modified = False\n    sub_elements = []\n    tag, keep_inside_tag, protected = context\n    if keep_inside_tag and element.tag == keep_inside_tag:\n        protect_below = True\n    else:\n        protect_below = False\n    for child in buffer.children:\n        striped, is_modified = _tree_remove_tag(\n            child, (tag, keep_inside_tag, protect_below)\n        )\n        if is_modified:\n            modified = True\n        if isinstance(striped, list):\n            for item in striped:\n                sub_elements.append(item)\n        else:\n            sub_elements.append(striped)\n    if not protected and element.tag == tag:\n        element = []\n        modified = True\n    else:\n        if not modified:\n            # no change in element sub tree, no change on element\n            return (element, False)\n        element.clear()\n        try:\n            for key, value in buffer.attributes.items():\n                element.set_attribute(key, value)\n        except ValueError:\n            print(\"Bad attribute in\", buffer)\n    text = buffer.text\n    tail = buffer.tail\n    if text is not None:\n        element.append(text)\n    for child in sub_elements:\n        element.append(child)\n    if tail is not None:\n        if isinstance(element, list):\n            element.append(tail)\n        else:\n            element.tail = tail\n    return (element, True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#remove-span-styles","title":"Remove span styles","text":"<p>Remove span styles (like some words in bold in a paragraph), except in titles.</p> recipes/remove_span_styles.py <pre><code>#!/usr/bin/env python\n\"\"\"Remove span styles (like some words in bold in a paragraph),\nexcept in titles.\n\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Body, Document, Element\n\n_DOC_SEQUENCE = 520\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"dormeur.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"nostyle\"\nTARGET = \"document.odt\"\n\n\ndef read_source_document() -&gt; Document:\n    \"\"\"Return the source Document.\"\"\"\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef save_new(document: Document, name: str) -&gt; None:\n    \"\"\"Save a recipe result Document.\"\"\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef remove_text_span(body: Body) -&gt; None:\n    \"\"\"Remove span styles from an Element, except in titles.\"\"\"\n    tag = \"text:span\"\n    keep_inside_tag = \"text:h\"\n    context = (tag, keep_inside_tag, False)\n    body, _is_modified = _tree_remove_tag(body, context)\n\n\ndef _tree_remove_tag(element: Element, context: tuple) -&gt; Element:\n    \"\"\"Send back a copy of the element, without span styles. Element should be\n    either paragraph or heading.\n\n    - context: a tuple (tag to remove, protection tag, protection flag)\n    where protection tag protects from change any sub elements one level depth\n    \"\"\"\n    buffer = element.clone\n    modified = False\n    sub_elements = []\n    tag, keep_inside_tag, protected = context\n    if keep_inside_tag and element.tag == keep_inside_tag:\n        protect_below = True\n    else:\n        protect_below = False\n    for child in buffer.children:\n        striped, is_modified = _tree_remove_tag(\n            child, (tag, keep_inside_tag, protect_below)\n        )\n        if is_modified:\n            modified = True\n        if isinstance(striped, list):\n            for item in striped:\n                sub_elements.append(item)\n        else:\n            sub_elements.append(striped)\n    if not protected and element.tag == tag:\n        element = []\n        modified = True\n    else:\n        if not modified:\n            # no change in element sub tree, no change on element\n            return (element, False)\n        element.clear()\n        try:\n            for key, value in buffer.attributes.items():\n                element.set_attribute(key, value)\n        except ValueError:\n            print(\"Bad attribute in\", buffer)\n    text = buffer.text\n    tail = buffer.tail\n    if text is not None:\n        element.append(text)\n    for child in sub_elements:\n        element.append(child)\n    if tail is not None:\n        if isinstance(element, list):\n            element.append(tail)\n        else:\n            element.tail = tail\n    return (element, True)\n\n\ndef clean_document(document: Document) -&gt; None:\n    \"\"\"Remove span styles from a Document.\"\"\"\n    body = document.body\n\n    print(\"'text:span' occurrences:\", len(body.spans))\n    remove_text_span(body)\n    print(\"'text:span' occurrences after removal:\", len(body.spans))\n\n\ndef main() -&gt; None:\n    document = read_source_document()\n    clean_document(document)\n    test_unit(document)\n    save_new(document, TARGET)\n\n\ndef test_unit(document: Document) -&gt; None:\n    # only for test suite:\n    if \"ODFDO_TESTING\" not in os.environ:\n        return\n\n    assert len(document.body.spans) == 1\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#retrieve-all-pictures-from-odf-files","title":"Retrieve all pictures from odf files","text":"<p>Analyse a list of files and directory (recurse), open all ODF documents and copy pictures from documents in a directory.</p> recipes/retrieve_all_pictures_from_ODF_files.py <pre><code>#!/usr/bin/env python\n\"\"\"Analyse a list of files and directory (recurse), open all ODF documents\nand copy pictures from documents in a directory.\n\"\"\"\nimport sys\nimport time\nfrom hashlib import sha256\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 530\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"collected_pics\"\nDATA = Path(__file__).parent / \"data\"\n\n# encoding = \"UTF8\"\nknown_images = set()\ncounter_image = 0\ncounter_odf = 0\ncounter_outside = 0\n\n\ndef store_image(path, name, content):\n    \"\"\"Image new name is \"odffile_imagename\".\"\"\"\n    global counter_image\n\n    base = path.name.replace(\".\", \"_\")\n    cpt = 1\n    if not OUTPUT_DIR.is_dir():\n        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    target = OUTPUT_DIR / f\"{base}_{cpt}_{name}\"\n    while target.exists():\n        cpt += 1\n        target = OUTPUT_DIR / f\"{base}_{cpt}_{name}\"\n    target.write_bytes(content)\n    counter_image += 1\n\n\ndef parse_odf_pics(path: Path):\n    \"\"\"Using odfdo for:\n    - open possible ODF document: Document (including URI)\n    - find images inside the document: get_image_list, get_attribute\n    \"\"\"\n    if not path.suffix.lower().startswith(\".od\"):\n        return\n    try:\n        document = Document(path)\n    except Exception:\n        return\n\n    global counter_odf\n    global counter_outside\n\n    counter_odf += 1\n    for image in document.body.images:\n        image_url = image.url\n        if not image_url:\n            continue\n        try:\n            image_content = document.get_part(image_url)\n        except KeyError:\n            print(\"- not found inside document:\", path)\n            print(\"  image URL:\", image_url)\n            counter_outside += 1\n            continue\n        image_name = image_url.split(\"/\")[-1]\n        if not known_pic(image_content):\n            store_image(path, image_name, image_content)\n\n\ndef known_pic(content) -&gt; bool:\n    \"\"\"Remember already seen images by sha256 footprint.\"\"\"\n    footprint = sha256(content).digest()\n    if footprint in known_images:\n        return True\n    known_images.add(footprint)\n    return False\n\n\ndef analyse_document(source):\n    for path in source.glob(\"**/*\"):\n        if path.is_file():\n            parse_odf_pics(path)\n\n\ndef main():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA\n\n    t0 = time.time()\n    analyse_document(Path(source))\n    elapsed = time.time() - t0\n    print(\n        f\"{counter_image} images copied ({counter_outside} not found) from \"\n        f\"{counter_odf} ODF files to {OUTPUT_DIR} in {elapsed:.2f}sec.\"\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#read-document-from-bytesio","title":"Read document from bytesio","text":"<p>Read a document from BytesIO.</p> recipes/read_document_from_bytesio.py <pre><code>#!/usr/bin/env python\n\"\"\"Read a document from BytesIO.\n\"\"\"\nimport io\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 600\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"lorem.odt\"\n\n\ndef main():\n    file_path = DATA / SOURCE\n    with io.BytesIO() as bytes_content:\n        # read the file in the BytesIO (or read from some network)\n        bytes_content.write(file_path.read_bytes())\n        # Create the odfdo.Document from the BytesIO\n        bytes_content.seek(0)\n        document = Document(bytes_content)\n        # check :\n        if document.body.search(\"Lorem ipsum dolor sit amet\") is None:\n            raise ValueError(\"string not found\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#save-document-as-bytesio","title":"Save document as bytesio","text":"<p>Save a document as BytesIO.</p> recipes/save_document_as_bytesio.py <pre><code>#!/usr/bin/env python\n\"\"\"Save a document as BytesIO.\n\"\"\"\nimport io\nfrom pathlib import Path\n\nfrom odfdo import Document, Paragraph\n\n_DOC_SEQUENCE = 605\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"bytes\"\nTARGET = \"document.odt\"\n\n\ndef make_document():\n    document = Document(\"text\")\n    body = document.body\n    paragraph = Paragraph(\"Hello World\")\n    body.append(paragraph)\n    return document\n\n\ndef main():\n    document = make_document()\n    with io.BytesIO() as bytes_content:\n        document.save(bytes_content)\n        # Now use the BytesIO in some way:\n        # In a netwotk context, typically:\n        #    response.write(bytes_content.getvalue())\n        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n        with open(OUTPUT_DIR / TARGET, \"wb\") as file:\n            file.write(bytes_content.getvalue())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#search-and-replace-words","title":"Search and replace words","text":"<p>Search and replace words in a text document.</p> recipes/search_and_replace_words.py <pre><code>#!/usr/bin/env python\n\"\"\"Search and replace words in a text document.\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document\n\n_DOC_SEQUENCE = 700\nDATA = Path(__file__).parent / \"data\"\nSOURCE = \"lorem.odt\"\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"replaced_text\"\nTARGET = \"lorem_replaced.odt\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef search_replace(document):\n    body = document.body\n\n    # replace a string in the full document\n    body.replace(\"Lorem\", \"(Lorem replaced)\")\n\n    # replace in paragraphs only\n    for paragraph in body.paragraphs:\n        paragraph.replace(\"ipsum\", \"(ipsum in paragraph)\")\n\n    # replace in headers\n    for header in body.headers:\n        header.replace(\"ipsum\", \"(ipsum in header)\")\n\n    # pattern is a regular expression\n    body.replace(r\"\\S+lit \", \"(...lit) \")\n    body.replace(r\"pul[a-z]+\", \"(pulvinar)\")\n\n\ndef main():\n    document = Document(DATA / SOURCE)\n    search_replace(document)\n    save_new(document, TARGET)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#spreadsheet-with-words-frequency-from-a-text","title":"Spreadsheet with words frequency from a text","text":"<p>Load an ODF text, store the frequency of words in a spreadsheet, make requests on the table, by regex or value.</p> recipes/spreadsheet_with_words_frequency_from_a_text.py <pre><code>#!/usr/bin/env python\n\"\"\"Load an ODF text, store the frequency of words in a spreadsheet,\nmake requests on the table, by regex or value.\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nfrom odfdo import Document, Table\n\n_DOC_SEQUENCE = 710\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"freq\"\nSOURCE = \"collection2.odt\"\nDATA = Path(__file__).parent / \"data\"\nTARGET = \"frequency.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef read_source_document():\n    try:\n        source = sys.argv[1]\n    except IndexError:\n        source = DATA / SOURCE\n    return Document(source)\n\n\ndef main():\n    document = generate_document()\n    save_new(document, TARGET)\n    _expected_result = \"\"\"\n    Word frequency analysis of collection2.odt\n    Nb of words: 9128\n    Unique words found: 2337\n    Rows in the table : 2337\n    Words corresponding to the regex: ^the\n      word: the                   occurences: 644\n      word: they                  occurences: 15\n      word: their                 occurences: 11\n      word: then                  occurences: 10\n      word: there                 occurences: 7\n      word: these                 occurences: 4\n      word: them                  occurences: 4\n      word: themselves            occurences: 2\n      word: theme                 occurences: 2\n      word: themed                occurences: 1\n      word: theatrical            occurences: 1\n    List of words of frequency 15: two, they, release, one, its, his, film,\n    episodes, but, adaptation, UK, Radio, J, 0\n\"\"\"\n\n\ndef frequence_count(document):\n    print(\"Word frequency analysis of\", Path(document.container.path).name)\n    text = str(document.body)\n    for char in \"():;!.,[]{}#@/\\\\=-_+*#@`\\\"'\":\n        text = text.replace(char, \" \")  # slow algorithm\n    words = text.split()\n    print(\"Nb of words:\", len(words))\n\n    frequences = {}\n\n    for word in words:\n        frequences[word] = frequences.get(word, 0) + 1\n\n    print(\"Unique words found:\", len(frequences))\n    return frequences\n\n\ndef generate_document():\n    document_source = read_source_document()\n    spreadsheet = Document(\"spreadsheet\")\n\n    frequences = frequence_count(document_source)\n\n    # Populate the table in the spreadsheet\n    body = spreadsheet.body\n    body.clear()\n    table = Table(\"Frequency Table\")\n    body.append(table)\n\n    sorted_keys = reversed([(value, key) for key, value in frequences.items()])\n\n    # one solution :\n\n    # for value, key in sorted:\n    #    row = Row()\n    #    row.set_value(0, key)\n    #    row.set_value(1, value) # Cell type is guessed.\n    #    table.append_row(row)\n\n    # another solution :\n    sorted_keys = [(k, v) for (v, k) in sorted_keys]\n    table.set_values(sorted_keys)\n\n    print(\"Rows in the table :\", len(table.rows))\n\n    # frequency of word:\n    regex_query = \"^the\"\n    print(\"Words corresponding to the regex:\", regex_query)\n    result = table.get_rows(content=regex_query)\n    for row in result:\n        print(f\"  word: {row.get_value(0):&lt;20}  occurences: {row.get_value(1)}\")\n\n    # list of words of frequecy = 15\n    found = []\n    for word, freq in table.iter_values():\n        if freq == 15:\n            found.append(word)\n    print(\"List of words of frequency 15:\", \", \".join(found))\n    return spreadsheet\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"recipes.html#transpose-table","title":"Transpose table","text":"<p>Transpose a table. Create a spreadsheet table (example: 50 rows and 20 columns), and subsequently create a new table in a separate sheet where the columns and rows are now swapped (e.g. 20 rows and 50 columns).</p> recipes/transpose_table.py <pre><code>#!/usr/bin/env python\n\"\"\"Transpose a table. Create a spreadsheet table (example: 50 rows and 20\ncolumns), and subsequently create a new table in a separate sheet where the\ncolumns and rows are now swapped (e.g. 20 rows and 50 columns).\n\"\"\"\nfrom pathlib import Path\n\nfrom odfdo import Document, Row, Table\n\n_DOC_SEQUENCE = 800\nOUTPUT_DIR = Path(__file__).parent / \"recipes_output\" / \"transpose\"\nTARGET = \"transposed.ods\"\n\n\ndef save_new(document: Document, name: str):\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    new_path = OUTPUT_DIR / name\n    print(\"Saving:\", new_path)\n    document.save(new_path, pretty=True)\n\n\ndef main():\n    document = generate_document()\n    save_new(document, TARGET)\n\n\ndef generate_document():\n    spreadsheet = Document(\"spreadsheet\")\n\n    # Populate the table in the spreadsheet\n    body = spreadsheet.body\n    body.clear()\n    table = Table(\"Table\")\n    body.append(table)\n\n    lines = 50\n    cols = 20\n\n    for line in range(lines):\n        row = Row()\n        for column in range(cols):\n            row.set_value(column, f\"{chr(65 + column)}{line + 1}\")\n        table.append(row)\n\n    print(\"Size of Table :\", table.size)\n\n    table2 = Table(\"Symetry\")\n\n    # building the symetric table using classical method :\n    for x in range(cols):\n        values = table.get_column_values(x)\n        table2.set_row_values(x, values)\n    body.append(table2)\n\n    print(\"Size of symetric table 2 :\", table2.size)\n\n    # a more simple solution with the table.transpose() method :\n    table3 = table.clone\n    table3.transpose()\n    table3.name = \"Transpose\"\n    body.append(table3)\n\n    print(\"Size of symetric table 3 :\", table3.size)\n    return spreadsheet\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"reference.html","title":"Reference","text":""},{"location":"reference.html#odfdo.AnimPar","title":"<code>AnimPar</code>","text":"<p>               Bases: <code>Element</code></p> <p>A container for SMIL Presentation Animations.</p> <p>Arguments:</p> <pre><code>presentation_node_type -- default, on-click, with-previous,\n                          after-previous, timing-root, main-sequence\n                          and interactive-sequence\n\nsmil_begin -- indefinite, 10s, [id].click, [id].begin\n</code></pre> Source code in <code>odfdo/smil.py</code> <pre><code>class AnimPar(Element):\n    \"\"\"A container for SMIL Presentation Animations.\n\n    Arguments:\n\n        presentation_node_type -- default, on-click, with-previous,\n                                  after-previous, timing-root, main-sequence\n                                  and interactive-sequence\n\n        smil_begin -- indefinite, 10s, [id].click, [id].begin\n    \"\"\"\n\n    _tag = \"anim:par\"\n    _properties = (\n        PropDef(\"presentation_node_type\", \"presentation:node-type\"),\n        PropDef(\"smil_begin\", \"smil:begin\"),\n    )\n\n    def __init__(\n        self,\n        presentation_node_type: str | None = None,\n        smil_begin: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if presentation_node_type:\n                self.presentation_node_type = presentation_node_type\n            if smil_begin:\n                self.smil_begin = smil_begin\n</code></pre>"},{"location":"reference.html#odfdo.AnimSeq","title":"<code>AnimSeq</code>","text":"<p>               Bases: <code>Element</code></p> <p>TA container for SMIL Presentation Animations. Animations inside this block are executed after the slide has executed its initial transition.</p> <p>Arguments:</p> <pre><code>presentation_node_type -- default, on-click, with-previous,\n                          after-previous, timing-root, main-sequence\n                          and interactive-sequence\n</code></pre> Source code in <code>odfdo/smil.py</code> <pre><code>class AnimSeq(Element):\n    \"\"\"TA container for SMIL Presentation Animations. Animations\n    inside this block are executed after the slide has executed its initial\n    transition.\n\n    Arguments:\n\n        presentation_node_type -- default, on-click, with-previous,\n                                  after-previous, timing-root, main-sequence\n                                  and interactive-sequence\n    \"\"\"\n\n    _tag = \"anim:seq\"\n    _properties = (PropDef(\"presentation_node_type\", \"presentation:node-type\"),)\n\n    def __init__(\n        self,\n        presentation_node_type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init and presentation_node_type:\n            self.presentation_node_type = presentation_node_type\n</code></pre>"},{"location":"reference.html#odfdo.AnimTransFilter","title":"<code>AnimTransFilter</code>","text":"<p>               Bases: <code>Element</code></p> <p>Class to make a beautiful transition between two frames.</p> <p>Arguments:</p> <p>smil_dur \u2013 str, duration</p> <p>smil_type and smil_subtype \u2013 see http://www.w3.org/TR/SMIL20/                 smil-transitions.html#TransitionEffects-Appendix                                 to get a list of all types/subtypes</p> <p>smil_direction \u2013 forward, reverse</p> <p>smil_fadeColor \u2013 forward, reverse</p> <p>smil_mode \u2013 in, out</p> Source code in <code>odfdo/smil.py</code> <pre><code>class AnimTransFilter(Element):\n    \"\"\"\n    Class to make a beautiful transition between two frames.\n\n    Arguments:\n\n      smil_dur -- str, duration\n\n      smil_type and smil_subtype -- see http://www.w3.org/TR/SMIL20/\n                    smil-transitions.html#TransitionEffects-Appendix\n                                    to get a list of all types/subtypes\n\n      smil_direction -- forward, reverse\n\n      smil_fadeColor -- forward, reverse\n\n      smil_mode -- in, out\n    \"\"\"\n\n    _tag = \"anim:transitionFilter\"\n    _properties = (\n        PropDef(\"smil_dur\", \"smil:dur\"),\n        PropDef(\"smil_type\", \"smil:type\"),\n        PropDef(\"smil_subtype\", \"smil:subtype\"),\n        PropDef(\"smil_direction\", \"smil:direction\"),\n        PropDef(\"smil_fadeColor\", \"smil:fadeColor\"),\n        PropDef(\"smil_mode\", \"smil:mode\"),\n    )\n\n    def __init__(\n        self,\n        smil_dur: str | None = None,\n        smil_type: str | None = None,\n        smil_subtype: str | None = None,\n        smil_direction: str | None = None,\n        smil_fadeColor: str | None = None,\n        smil_mode: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if smil_dur:\n                self.smil_dur = smil_dur\n            if smil_type:\n                self.smil_type = smil_type\n            if smil_subtype:\n                self.smil_subtype = smil_subtype\n            if smil_direction:\n                self.smil_direction = smil_direction\n            if smil_fadeColor:\n                self.smil_fadeColor = smil_fadeColor\n            if smil_mode:\n                self.smil_mode = smil_mode\n</code></pre>"},{"location":"reference.html#odfdo.Annotation","title":"<code>Annotation</code>","text":"<p>               Bases: <code>MDTail</code>, <code>Element</code>, <code>DcCreatorMixin</code>, <code>DcDateMixin</code></p> <p>Annotation element credited to the given creator with the given text, optionally dated (current date by default). If name not provided and some parent is provided, the name is autogenerated.</p> <p>Arguments:</p> <pre><code>text -- str or odf_element\n\ncreator -- str\n\ndate -- datetime\n\nname -- str\n\nparent -- Element\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>class Annotation(MDTail, Element, DcCreatorMixin, DcDateMixin):\n    \"\"\"Annotation element credited to the given creator with the\n    given text, optionally dated (current date by default).\n    If name not provided and some parent is provided, the name is\n    autogenerated.\n\n    Arguments:\n\n        text -- str or odf_element\n\n        creator -- str\n\n        date -- datetime\n\n        name -- str\n\n        parent -- Element\n    \"\"\"\n\n    _tag = \"office:annotation\"\n    _properties = (\n        PropDef(\"name\", \"office:name\"),\n        PropDef(\"note_id\", \"text:id\"),\n    )\n\n    def __init__(\n        self,\n        text_or_element: Element | str | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        name: str | None = None,\n        parent: Element | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        # fixme : use offset\n        # TODO allow paragraph and text styles\n        super().__init__(**kwargs)\n\n        if self._do_init:\n            self.note_body = text_or_element  # type:ignore\n            if creator:\n                self.creator = creator\n            if date is None:\n                date = datetime.now()\n            self.date = date\n            if not name:\n                name = get_unique_office_name(parent)\n                self.name = name\n\n    @property\n    def dc_creator(self) -&gt; str | None:\n        \"\"\"Alias for self.creator property.\"\"\"\n        return self.creator\n\n    @dc_creator.setter\n    def dc_creator(self, creator: str) -&gt; None:\n        self.creator = creator\n\n    @property\n    def dc_date(self) -&gt; datetime | None:\n        \"\"\"Alias for self.date property.\"\"\"\n        return self.date\n\n    @dc_date.setter\n    def dc_date(self, dtdate: datetime) -&gt; None:\n        self.date = dtdate\n\n    @property\n    def note_body(self) -&gt; str:\n        return self.text_content\n\n    @note_body.setter\n    def note_body(self, text_or_element: Element | str | None) -&gt; None:\n        if text_or_element is None:\n            self.text_content = \"\"\n        elif isinstance(text_or_element, str):\n            self.text_content = text_or_element\n        elif isinstance(text_or_element, Element):\n            self.clear()\n            self.append(text_or_element)\n        else:\n            raise TypeError(f'Unexpected type for body: \"{type(text_or_element)}\"')\n\n    @property\n    def start(self) -&gt; Element:\n        \"\"\"Return self.\"\"\"\n        return self\n\n    @property\n    def end(self) -&gt; Element | None:\n        \"\"\"Return the corresponding annotation-end tag or None.\"\"\"\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can't find end tag: no parent available\")\n        body = self.document_body\n        if not body:\n            body = parent\n        return body.get_annotation_end(name=name)\n\n    def get_annotated(\n        self,\n        as_text: bool = False,\n        no_header: bool = True,\n        clean: bool = True,\n    ) -&gt; Element | list | str | None:\n        \"\"\"Returns the annotated content from an annotation.\n\n        If no content exists (single position annotation or annotation-end not\n        found), returns [] (or \"\" if text flag is True).\n        If as_text is True: returns the text content.\n        If clean is True: suppress unwanted tags (deletions marks, ...)\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of odf_element, cleaned and without headers.\n\n        Arguments:\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list or Element or text or None\n        \"\"\"\n        end = self.end\n        if end is None:\n            if as_text:\n                return \"\"\n            return None\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_between(\n            self, end, as_text=as_text, no_header=no_header, clean=clean\n        )\n\n    def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        For Annotation : delete the annotation-end tag if exists.\n\n        Arguments:\n\n            child -- Element or None\n        \"\"\"\n        if child is not None:  # act like normal delete\n            super().delete(child)\n            return\n        end = self.end\n        if end:\n            end.delete()\n        # act like normal delete\n        super().delete()\n\n    def check_validity(self) -&gt; None:\n        if not self.note_body:\n            raise ValueError(\"Annotation must have a body\")\n        if not self.dc_creator:\n            raise ValueError(\"Annotation must have a creator\")\n        if not self.dc_date:\n            self.dc_date = datetime.now()\n\n    def __str__(self) -&gt; str:\n        return f\"{self.note_body}\\n{self.dc_creator} {self.dc_date}\"\n</code></pre>"},{"location":"reference.html#odfdo.Annotation.dc_creator","title":"<code>dc_creator</code>  <code>property</code> <code>writable</code>","text":"<p>Alias for self.creator property.</p>"},{"location":"reference.html#odfdo.Annotation.dc_date","title":"<code>dc_date</code>  <code>property</code> <code>writable</code>","text":"<p>Alias for self.date property.</p>"},{"location":"reference.html#odfdo.Annotation.end","title":"<code>end</code>  <code>property</code>","text":"<p>Return the corresponding annotation-end tag or None.</p>"},{"location":"reference.html#odfdo.Annotation.start","title":"<code>start</code>  <code>property</code>","text":"<p>Return self.</p>"},{"location":"reference.html#odfdo.Annotation.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>For Annotation : delete the annotation-end tag if exists.</p> <p>Arguments:</p> <pre><code>child -- Element or None\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    For Annotation : delete the annotation-end tag if exists.\n\n    Arguments:\n\n        child -- Element or None\n    \"\"\"\n    if child is not None:  # act like normal delete\n        super().delete(child)\n        return\n    end = self.end\n    if end:\n        end.delete()\n    # act like normal delete\n    super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.Annotation.get_annotated","title":"<code>get_annotated(as_text=False, no_header=True, clean=True)</code>","text":"<p>Returns the annotated content from an annotation.</p> <p>If no content exists (single position annotation or annotation-end not found), returns [] (or \u201c\u201d if text flag is True). If as_text is True: returns the text content. If clean is True: suppress unwanted tags (deletions marks, \u2026) If no_header is True: existing text:h are changed in text:p By default: returns a list of odf_element, cleaned and without headers.</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list or Element or text or None</p> Source code in <code>odfdo/note.py</code> <pre><code>def get_annotated(\n    self,\n    as_text: bool = False,\n    no_header: bool = True,\n    clean: bool = True,\n) -&gt; Element | list | str | None:\n    \"\"\"Returns the annotated content from an annotation.\n\n    If no content exists (single position annotation or annotation-end not\n    found), returns [] (or \"\" if text flag is True).\n    If as_text is True: returns the text content.\n    If clean is True: suppress unwanted tags (deletions marks, ...)\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of odf_element, cleaned and without headers.\n\n    Arguments:\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list or Element or text or None\n    \"\"\"\n    end = self.end\n    if end is None:\n        if as_text:\n            return \"\"\n        return None\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_between(\n        self, end, as_text=as_text, no_header=no_header, clean=clean\n    )\n</code></pre>"},{"location":"reference.html#odfdo.AnnotationEnd","title":"<code>AnnotationEnd</code>","text":"<p>               Bases: <code>MDTail</code>, <code>Element</code></p> <p>AnnotationEnd: the \u201coffice:annotation-end\u201d element may be used to define the end of a text range of document content that spans element boundaries. In that case, an \u201coffice:annotation\u201d element shall precede the \u201coffice:annotation-end\u201d element. Both elements shall have the same value for their office:name attribute. The \u201coffice:annotation-end\u201d element shall be preceded by an \u201coffice:annotation\u201d element that has the same value for its office:name attribute as the \u201coffice:annotation-end\u201d element. An \u201coffice:annotation-end\u201d element without a preceding \u201coffice:annotation\u201d element that has the same name assigned is ignored.</p> Source code in <code>odfdo/note.py</code> <pre><code>class AnnotationEnd(MDTail, Element):\n    \"\"\"AnnotationEnd: the \"office:annotation-end\" element may be used to\n    define the end of a text range of document content that spans element\n    boundaries. In that case, an \"office:annotation\" element shall precede\n    the \"office:annotation-end\" element. Both elements shall have the same\n    value for their office:name attribute. The \"office:annotation-end\" element\n    shall be preceded by an \"office:annotation\" element that has the same\n    value for its office:name attribute as the \"office:annotation-end\"\n    element. An \"office:annotation-end\" element without a preceding\n    \"office:annotation\" element that has the same name assigned is ignored.\n    \"\"\"\n\n    _tag = \"office:annotation-end\"\n    _properties = (PropDef(\"name\", \"office:name\"),)\n\n    def __init__(\n        self,\n        annotation: Element | None = None,\n        name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize an AnnotationEnd element. Either annotation or name must be\n        provided to have proper reference for the annotation-end.\n\n        Arguments:\n\n            annotation -- odf_annotation element\n\n            name -- str\n        \"\"\"\n        # fixme : use offset\n        # TODO allow paragraph and text styles\n        super().__init__(**kwargs)\n        if self._do_init:\n            if annotation:\n                name = annotation.name  # type: ignore\n            if not name:\n                raise ValueError(\"Annotation-end must have a name\")\n            self.name = name\n\n    @property\n    def start(self) -&gt; Element | None:\n        \"\"\"Return the corresponding annotation starting tag or None.\"\"\"\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can't find start tag: no parent available\")\n        body = self.document_body\n        if not body:\n            body = parent\n        return body.get_annotation(name=name)\n\n    @property\n    def end(self) -&gt; Element:\n        \"\"\"Return self.\"\"\"\n        return self\n</code></pre>"},{"location":"reference.html#odfdo.AnnotationEnd.end","title":"<code>end</code>  <code>property</code>","text":"<p>Return self.</p>"},{"location":"reference.html#odfdo.AnnotationEnd.start","title":"<code>start</code>  <code>property</code>","text":"<p>Return the corresponding annotation starting tag or None.</p>"},{"location":"reference.html#odfdo.AnnotationEnd.__init__","title":"<code>__init__(annotation=None, name=None, **kwargs)</code>","text":"<p>Initialize an AnnotationEnd element. Either annotation or name must be provided to have proper reference for the annotation-end.</p> <p>Arguments:</p> <pre><code>annotation -- odf_annotation element\n\nname -- str\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>def __init__(\n    self,\n    annotation: Element | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize an AnnotationEnd element. Either annotation or name must be\n    provided to have proper reference for the annotation-end.\n\n    Arguments:\n\n        annotation -- odf_annotation element\n\n        name -- str\n    \"\"\"\n    # fixme : use offset\n    # TODO allow paragraph and text styles\n    super().__init__(**kwargs)\n    if self._do_init:\n        if annotation:\n            name = annotation.name  # type: ignore\n        if not name:\n            raise ValueError(\"Annotation-end must have a name\")\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>Element</code></p> <p>Body, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Body(Element):\n    \"\"\"Body, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:body\"\n    _properties: tuple[PropDef, ...] = ()\n\n    def get_tables(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the tables that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Table\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::table:table\", table_style=style, content=content\n        )\n\n    @property\n    def tables(self) -&gt; list[Element]:\n        \"\"\"Return all the tables.\n\n        Return: list of Table\n        \"\"\"\n        return self.get_elements(\"descendant::table:table\")\n\n    def get_table(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the table that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            content -- str regex\n\n        Return: Table or None if not found\n        \"\"\"\n        if name is None and content is None:\n            result = self._filtered_element(\"descendant::table:table\", position)\n        else:\n            result = self._filtered_element(\n                \"descendant::table:table\",\n                position,\n                table_name=name,\n                content=content,\n            )\n        return result\n</code></pre>"},{"location":"reference.html#odfdo.Body.tables","title":"<code>tables</code>  <code>property</code>","text":"<p>Return all the tables.</p> <p>Return: list of Table</p>"},{"location":"reference.html#odfdo.Body.get_table","title":"<code>get_table(position=0, name=None, content=None)</code>","text":"<p>Return the table that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\ncontent -- str regex\n</code></pre> <p>Return: Table or None if not found</p> Source code in <code>odfdo/body.py</code> <pre><code>def get_table(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the table that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        content -- str regex\n\n    Return: Table or None if not found\n    \"\"\"\n    if name is None and content is None:\n        result = self._filtered_element(\"descendant::table:table\", position)\n    else:\n        result = self._filtered_element(\n            \"descendant::table:table\",\n            position,\n            table_name=name,\n            content=content,\n        )\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Body.get_tables","title":"<code>get_tables(style=None, content=None)</code>","text":"<p>Return all the tables that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Table</p> Source code in <code>odfdo/body.py</code> <pre><code>def get_tables(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the tables that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Table\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::table:table\", table_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Bookmark","title":"<code>Bookmark</code>","text":"<p>               Bases: <code>Element</code></p> <p>Bookmark class for ODF \u201ctext:bookmark\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/bookmark.py</code> <pre><code>class Bookmark(Element):\n    \"\"\"\n    Bookmark class for ODF \"text:bookmark\"\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:bookmark\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.BookmarkEnd","title":"<code>BookmarkEnd</code>","text":"<p>               Bases: <code>Element</code></p> <p>BookmarkEnd class for ODF \u201ctext:bookmark-end\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/bookmark.py</code> <pre><code>class BookmarkEnd(Element):\n    \"\"\"\n    BookmarkEnd class for ODF \"text:bookmark-end\"\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:bookmark-end\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.BookmarkStart","title":"<code>BookmarkStart</code>","text":"<p>               Bases: <code>Element</code></p> <p>BookmarkStart class for ODF \u201ctext:bookmark-start\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/bookmark.py</code> <pre><code>class BookmarkStart(Element):\n    \"\"\"\n    BookmarkStart class for ODF \"text:bookmark-start\"\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:bookmark-start\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.Cell","title":"<code>Cell</code>","text":"<p>               Bases: <code>ElementTyped</code></p> <p>\u201ctable:table-cell\u201d table cell element.</p> Source code in <code>odfdo/cell.py</code> <pre><code>class Cell(ElementTyped):\n    \"\"\" \"table:table-cell\" table cell element.\"\"\"\n\n    _tag = \"table:table-cell\"\n\n    def __init__(\n        self,\n        value: Any = None,\n        text: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        formula: str | None = None,\n        repeated: int | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a cell element containing the given value. The textual\n        representation is automatically formatted but can be provided. Cell\n        type can be deduced as well, unless the number is a percentage or\n        currency. If cell type is \"currency\", the currency must be given.\n        The cell can be repeated on the given number of columns.\n\n        Arguments:\n\n            value -- bool, int, float, Decimal, date, datetime, str,\n                     timedelta\n\n            text -- str\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            repeated -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self.x = None\n        self.y = None\n        if self._do_init:\n            self.set_value(\n                value,\n                text=text,\n                cell_type=cell_type,\n                currency=currency,\n                formula=formula,\n            )\n            if repeated and repeated &gt; 1:\n                self.repeated = repeated\n            if style is not None:\n                self.style = style\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} x={self.x} y={self.y}&gt;\"\n\n    @property\n    def clone(self) -&gt; Cell:\n        clone = Element.clone.fget(self)  # type: ignore\n        clone.y = self.y\n        clone.x = self.x\n        return clone\n\n    @property\n    def value(\n        self,\n    ) -&gt; str | bool | int | Float | Decimal | date | datetime | timedelta | None:\n        \"\"\"Set / get the value of the cell. The type is read from the\n        'office:value-type' attribute of the cell. When setting the value,\n        the type of the value will determine the new value_type of the cell.\n\n        Warning:\n            - for date, datetime and timedelta, a default text value is generated.\n            - for boolean type, the text value is either 'True' or 'False'.\n            - for numeric types, the return value is either Decimal or in, use\n              the float, decimal or int properties to force the type.\n            - Use the method Cell.set_value() to customize the text value.\n        \"\"\"\n        value_type = self.get_attribute_string(\"office:value-type\")\n        if value_type == \"boolean\":\n            return self.bool\n        if value_type in {\"float\", \"percentage\", \"currency\"}:\n            value_decimal = Decimal(str(self.get_attribute_string(\"office:value\")))\n            # Return 3 instead of 3.0 if possible\n            if int(value_decimal) == value_decimal:\n                return int(value_decimal)\n            return value_decimal\n        if value_type == \"date\":\n            value_str = str(self.get_attribute_string(\"office:date-value\"))\n            if \"T\" in value_str:\n                return DateTime.decode(value_str)\n            return Date.decode(value_str)\n        if value_type == \"time\":\n            return Duration.decode(str(self.get_attribute_string(\"office:time-value\")))\n        if value_type == \"string\":\n            value = self.get_attribute_string(\"office:string-value\")\n            if value is not None:\n                return value\n            value_list = []\n            for para in self.get_elements(\"text:p\"):\n                value_list.append(para.inner_text)\n            return \"\\n\".join(value_list)\n        return None\n\n    @value.setter\n    def value(\n        self,\n        value: (\n            str\n            | bytes\n            | bool\n            | int\n            | Float\n            | Decimal\n            | timedelta\n            | datetime\n            | date\n            | None\n        ),\n    ) -&gt; None:\n        if value is None:\n            self.clear()\n        elif isinstance(value, (str, bytes)):\n            self.string = value\n        elif isinstance(value, bool):\n            self.bool = value\n        elif isinstance(value, Float):\n            self.float = value\n        elif isinstance(value, Decimal):\n            self.decimal = value\n        elif isinstance(value, int):\n            self.int = value\n        elif isinstance(value, timedelta):\n            self.duration = value\n        elif isinstance(value, datetime):\n            self.datetime = value\n        elif isinstance(value, date):\n            self.date = value\n        else:\n            raise TypeError(f\"Unknown value type, try with set_value() : {value!r}\")\n\n    @property\n    def _bool_string(self) -&gt; str:\n        value = self.get_attribute_string(\"office:boolean-value\")\n        if not isinstance(value, str):\n            return \"0\"\n        return \"1\" if value == \"true\" else \"0\"\n\n    @property\n    def float(self) -&gt; Float:\n        \"\"\"Set / get the value of the cell as a float (or 0.0).\"\"\"\n        for tag in (\"office:value\", \"office:string-value\"):\n            read_attr = self.get_attribute(tag)\n            if isinstance(read_attr, str):\n                with contextlib.suppress(ValueError, TypeError):\n                    return Float(read_attr)\n        return Float(self._bool_string)\n\n    @float.setter\n    def float(self, value: str | Float | int | Decimal | None) -&gt; None:\n        try:\n            value_float = Float(value)\n        except (ValueError, TypeError, ConversionSyntax):\n            value_float = 0.0\n        value_str = str(value_float)\n        self.clear()\n        self.set_attribute(\"office:value\", value_str)\n        self.set_attribute(\"office:value-type\", \"float\")\n        self.text = value_str\n\n    @property\n    def decimal(self) -&gt; Decimal:\n        \"\"\"Set / get the value of the cell as a Decimal (or 0.0).\"\"\"\n        for tag in (\"office:value\", \"office:string-value\"):\n            read_attr = self.get_attribute(tag)\n            if isinstance(read_attr, str):\n                with contextlib.suppress(ValueError, TypeError, ConversionSyntax):\n                    return Decimal(read_attr)\n        return Decimal(self._bool_string)\n\n    @decimal.setter\n    def decimal(self, value: str | Float | int | Decimal | None) -&gt; None:\n        try:\n            value_decimal = Decimal(value)\n        except (ValueError, TypeError, ConversionSyntax, InvalidOperation):\n            value_decimal = Decimal(\"0.0\")\n        value_str = str(value_decimal)\n        self.clear()\n        self.set_attribute(\"office:value\", value_str)\n        self.set_attribute(\"office:value-type\", \"float\")\n        self.text = value_str\n\n    @property\n    def int(self) -&gt; int:\n        \"\"\"Set / get the value of the cell as a integer (or 0).\"\"\"\n        for tag in (\"office:value\", \"office:string-value\"):\n            read_attr = self.get_attribute(tag)\n            if isinstance(read_attr, str):\n                with contextlib.suppress(ValueError, TypeError):\n                    return int(float(read_attr))\n        return int(self._bool_string)\n\n    @int.setter\n    def int(self, value: str | Float | int | Decimal | None) -&gt; None:\n        try:\n            value_int = int(value)  # type:ignore\n        except (ValueError, TypeError, ConversionSyntax):\n            value_int = 0\n        value_str = str(value_int)\n        self.clear()\n        self.set_attribute(\"office:value\", value_str)\n        self.set_attribute(\"office:value-type\", \"float\")\n        self.text = value_str\n\n    @property\n    def string(self) -&gt; str:\n        \"\"\"Set / get the value of the cell as a string (or '').\"\"\"\n        value = self.get_attribute_string(\"office:string-value\")\n        if isinstance(value, str):\n            return value\n        return \"\"\n\n    @string.setter\n    def string(\n        self,\n        value: str | bytes | int | Float | Decimal | bool | None,\n    ) -&gt; None:\n        self.clear()\n        if value is None:\n            value_str = \"\"\n        elif isinstance(value, bytes):\n            value_str = value.decode()\n        else:\n            value_str = str(value)\n        self.set_attribute(\"office:value-type\", \"string\")\n        self.set_attribute(\"office:string-value\", value_str)\n        self.text = value_str\n\n    @property\n    def bool(self) -&gt; bool:\n        \"\"\"Set / get the value of the cell as a boolean.\"\"\"\n        value = self.get_attribute_string(\"office:boolean-value\")\n        if isinstance(value, str):\n            return value == \"true\"\n        return bool(self.int)\n\n    @bool.setter\n    def bool(\n        self,\n        value: str | bytes | int | Float | Decimal | bool | None,\n    ) -&gt; None:\n        self.clear()\n        self.set_attribute(\"office:value-type\", \"boolean\")\n        if isinstance(value, (bool, str, bytes)):\n            bvalue = Boolean.encode(value)\n        else:\n            bvalue = Boolean.encode(bool(value))\n        self.set_attribute(\"office:boolean-value\", bvalue)\n        self.text = bvalue\n\n    @property\n    def duration(self) -&gt; timedelta:\n        \"\"\"Set / get the value of the cell as a duration (Python timedelta).\"\"\"\n        value = self.get_attribute(\"office:time-value\")\n        if isinstance(value, str):\n            return Duration.decode(value)\n        return timedelta(0)\n\n    @duration.setter\n    def duration(self, value: timedelta) -&gt; None:\n        self.clear()\n        self.set_attribute(\"office:value-type\", \"time\")\n        dvalue = Duration.encode(value)\n        self.set_attribute(\"office:time-value\", dvalue)\n        self.text = dvalue\n\n    @property\n    def datetime(self) -&gt; datetime:\n        \"\"\"Set / get the value of the cell as a datetime.\"\"\"\n        value = self.get_attribute(\"office:date-value\")\n        if isinstance(value, str):\n            return DateTime.decode(value)\n        return datetime.fromtimestamp(0)\n\n    @datetime.setter\n    def datetime(self, value: datetime) -&gt; None:\n        self.clear()\n        self.set_attribute(\"office:value-type\", \"date\")\n        dvalue = DateTime.encode(value)\n        self.set_attribute(\"office:date-value\", dvalue)\n        self.text = dvalue\n\n    @property\n    def date(self) -&gt; date:\n        \"\"\"Set / get the value of the cell as a date.\"\"\"\n        value = self.get_attribute(\"office:date-value\")\n        if isinstance(value, str):\n            return Date.decode(value).date()\n        return date.fromtimestamp(0)\n\n    @date.setter\n    def date(self, value: date) -&gt; None:\n        self.clear()\n        self.set_attribute(\"office:value-type\", \"date\")\n        dvalue = Date.encode(value)\n        self.set_attribute(\"office:date-value\", dvalue)\n        self.text = dvalue\n\n    def set_value(\n        self,\n        value: (\n            str\n            | bytes\n            | Float\n            | int\n            | Decimal\n            | bool\n            | datetime\n            | date\n            | timedelta\n            | None\n        ),\n        text: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        formula: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set the cell state from the Python value type.\n\n        Text is how the cell is displayed. Cell type is guessed,\n        unless provided.\n\n        For monetary values, provide the name of the currency.\n\n        Arguments:\n\n            value -- Python type\n\n            text -- str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                        'currency' or 'percentage'\n\n            currency -- str\n        \"\"\"\n        self.clear()\n        text = self.set_value_and_type(\n            value=value,\n            text=text,\n            value_type=cell_type,\n            currency=currency,\n        )\n        if text is not None:\n            self.text_content = text\n        if formula is not None:\n            self.formula = formula\n\n    @property\n    def type(self) -&gt; str | None:\n        \"\"\"Get / set the type of the cell: boolean, float, date, string\n        or time.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"office:value-type\")\n\n    @type.setter\n    def type(self, cell_type: str) -&gt; None:\n        self.set_attribute(\"office:value-type\", cell_type)\n\n    @property\n    def currency(self) -&gt; str | None:\n        \"\"\"Get / set the currency used for monetary values.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"office:currency\")\n\n    @currency.setter\n    def currency(self, currency: str) -&gt; None:\n        self.set_attribute(\"office:currency\", currency)\n\n    def _set_repeated(self, repeated: int | None) -&gt; None:\n        \"\"\"Internal only. Set the numnber of times the cell is repeated, or\n        None to delete. Without changing cache.\n        \"\"\"\n        if repeated is None or repeated &lt; 2:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:number-columns-repeated\")\n            return\n        self.set_attribute(\"table:number-columns-repeated\", str(repeated))\n\n    @property\n    def repeated(self) -&gt; int | None:\n        \"\"\"Get / set the number of times the cell is repeated.\n\n        Always None when using the table API.\n\n        Return: int or None\n        \"\"\"\n        repeated = self.get_attribute(\"table:number-columns-repeated\")\n        if repeated is None:\n            return None\n        return int(repeated)\n\n    @repeated.setter\n    def repeated(self, repeated: int | None) -&gt; None:\n        self._set_repeated(repeated)\n        # update cache\n        child: Element = self\n        while True:\n            # look for Row, parent may be group of rows\n            upper = child.parent\n            if not upper:\n                # lonely cell\n                return\n            # parent may be group of rows, not table\n            if isinstance(upper, Element) and upper._tag == \"table:table-row\":\n                upper._compute_row_cache()\n                return\n            child = upper\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get / set the style of the cell itself.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"table:style-name\")\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n\n    @property\n    def formula(self) -&gt; str | None:\n        \"\"\"Get / set the formula of the cell, or None if undefined.\n\n        The formula is not interpreted in any way.\n\n        Return: str | None\n        \"\"\"\n        return self.get_attribute_string(\"table:formula\")\n\n    @formula.setter\n    def formula(self, formula: str | None) -&gt; None:\n        self.set_attribute(\"table:formula\", formula)\n\n    def is_empty(self, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return whether the cell has no value or the value evaluates\n        to False (empty string), and no style.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            aggressive -- bool\n\n        Return: bool\n        \"\"\"\n        if (\n            self.value is not None\n            or self.children\n            or self.is_covered()\n            or self.is_spanned()\n        ):\n            return False\n        if not aggressive and self.style is not None:  # noqa: SIM103\n            return False\n        return True\n\n    def is_covered(self) -&gt; bool:\n        \"\"\"Return whether the cell is covered (tag table:covered-table-cell).\n\n        Returns: True | False\n        \"\"\"\n        return self.tag == \"table:covered-table-cell\"\n\n    def is_spanned(self, covered: bool = True) -&gt; bool:\n        \"\"\"Return whether the cell is spanned over several cells.\n\n        If covered is True (the default), covered cells are considered as\n        spanned, else only the top left cell. The top left contains the\n        attributes \"table:number-columns-spanned\" and\n        \"table:number-rows-spanned\".\n\n        Arguments:\n\n            covered -- bool\n\n        Return: True | False\n        \"\"\"\n        if self.is_covered():\n            return covered\n        if self.get_attribute(\"table:number-columns-spanned\") is not None:\n            return True\n        if self.get_attribute(\"table:number-rows-spanned\") is not None:  # noqa: SIM103\n            return True\n        return False\n\n    _is_spanned = is_spanned  # compatibility\n\n    def span_area(self) -&gt; tuple[int, int]:\n        \"\"\"Return the tuple (nb_columns, nb_rows) of the zone covered\n        by a spanned cell.\n\n        If the cell is not spanned, return (0,0).\n\n        Return: tuple[int, int]\n        \"\"\"\n        columns = self.get_attribute_integer(\"table:number-columns-spanned\") or 0\n        rows = self.get_attribute_integer(\"table:number-rows-spanned\") or 0\n        return (columns, rows)\n</code></pre>"},{"location":"reference.html#odfdo.Cell.bool","title":"<code>bool</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a boolean.</p>"},{"location":"reference.html#odfdo.Cell.currency","title":"<code>currency</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the currency used for monetary values.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.date","title":"<code>date</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a date.</p>"},{"location":"reference.html#odfdo.Cell.datetime","title":"<code>datetime</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a datetime.</p>"},{"location":"reference.html#odfdo.Cell.decimal","title":"<code>decimal</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a Decimal (or 0.0).</p>"},{"location":"reference.html#odfdo.Cell.duration","title":"<code>duration</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a duration (Python timedelta).</p>"},{"location":"reference.html#odfdo.Cell.float","title":"<code>float</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a float (or 0.0).</p>"},{"location":"reference.html#odfdo.Cell.formula","title":"<code>formula</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the formula of the cell, or None if undefined.</p> <p>The formula is not interpreted in any way.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.int","title":"<code>int</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a integer (or 0).</p>"},{"location":"reference.html#odfdo.Cell.repeated","title":"<code>repeated</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the number of times the cell is repeated.</p> <p>Always None when using the table API.</p> <p>Return: int or None</p>"},{"location":"reference.html#odfdo.Cell.string","title":"<code>string</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell as a string (or \u2018\u2019).</p>"},{"location":"reference.html#odfdo.Cell.style","title":"<code>style</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the style of the cell itself.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.type","title":"<code>type</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the type of the cell: boolean, float, date, string or time.</p> <p>Return: str | None</p>"},{"location":"reference.html#odfdo.Cell.value","title":"<code>value</code>  <code>property</code> <code>writable</code>","text":"<p>Set / get the value of the cell. The type is read from the \u2018office:value-type\u2019 attribute of the cell. When setting the value, the type of the value will determine the new value_type of the cell.</p> Warning <ul> <li>for date, datetime and timedelta, a default text value is generated.</li> <li>for boolean type, the text value is either \u2018True\u2019 or \u2018False\u2019.</li> <li>for numeric types, the return value is either Decimal or in, use   the float, decimal or int properties to force the type.</li> <li>Use the method Cell.set_value() to customize the text value.</li> </ul>"},{"location":"reference.html#odfdo.Cell.__init__","title":"<code>__init__(value=None, text=None, cell_type=None, currency=None, formula=None, repeated=None, style=None, **kwargs)</code>","text":"<p>Create a cell element containing the given value. The textual representation is automatically formatted but can be provided. Cell type can be deduced as well, unless the number is a percentage or currency. If cell type is \u201ccurrency\u201d, the currency must be given. The cell can be repeated on the given number of columns.</p> <p>Arguments:</p> <pre><code>value -- bool, int, float, Decimal, date, datetime, str,\n         timedelta\n\ntext -- str\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nrepeated -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/cell.py</code> <pre><code>def __init__(\n    self,\n    value: Any = None,\n    text: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    formula: str | None = None,\n    repeated: int | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a cell element containing the given value. The textual\n    representation is automatically formatted but can be provided. Cell\n    type can be deduced as well, unless the number is a percentage or\n    currency. If cell type is \"currency\", the currency must be given.\n    The cell can be repeated on the given number of columns.\n\n    Arguments:\n\n        value -- bool, int, float, Decimal, date, datetime, str,\n                 timedelta\n\n        text -- str\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        repeated -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self.x = None\n    self.y = None\n    if self._do_init:\n        self.set_value(\n            value,\n            text=text,\n            cell_type=cell_type,\n            currency=currency,\n            formula=formula,\n        )\n        if repeated and repeated &gt; 1:\n            self.repeated = repeated\n        if style is not None:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Cell.is_covered","title":"<code>is_covered()</code>","text":"<p>Return whether the cell is covered (tag table:covered-table-cell).</p> <p>Returns: True | False</p> Source code in <code>odfdo/cell.py</code> <pre><code>def is_covered(self) -&gt; bool:\n    \"\"\"Return whether the cell is covered (tag table:covered-table-cell).\n\n    Returns: True | False\n    \"\"\"\n    return self.tag == \"table:covered-table-cell\"\n</code></pre>"},{"location":"reference.html#odfdo.Cell.is_empty","title":"<code>is_empty(aggressive=False)</code>","text":"<p>Return whether the cell has no value or the value evaluates to False (empty string), and no style.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> <p>Return: bool</p> Source code in <code>odfdo/cell.py</code> <pre><code>def is_empty(self, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return whether the cell has no value or the value evaluates\n    to False (empty string), and no style.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        aggressive -- bool\n\n    Return: bool\n    \"\"\"\n    if (\n        self.value is not None\n        or self.children\n        or self.is_covered()\n        or self.is_spanned()\n    ):\n        return False\n    if not aggressive and self.style is not None:  # noqa: SIM103\n        return False\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Cell.is_spanned","title":"<code>is_spanned(covered=True)</code>","text":"<p>Return whether the cell is spanned over several cells.</p> <p>If covered is True (the default), covered cells are considered as spanned, else only the top left cell. The top left contains the attributes \u201ctable:number-columns-spanned\u201d and \u201ctable:number-rows-spanned\u201d.</p> <p>Arguments:</p> <pre><code>covered -- bool\n</code></pre> <p>Return: True | False</p> Source code in <code>odfdo/cell.py</code> <pre><code>def is_spanned(self, covered: bool = True) -&gt; bool:\n    \"\"\"Return whether the cell is spanned over several cells.\n\n    If covered is True (the default), covered cells are considered as\n    spanned, else only the top left cell. The top left contains the\n    attributes \"table:number-columns-spanned\" and\n    \"table:number-rows-spanned\".\n\n    Arguments:\n\n        covered -- bool\n\n    Return: True | False\n    \"\"\"\n    if self.is_covered():\n        return covered\n    if self.get_attribute(\"table:number-columns-spanned\") is not None:\n        return True\n    if self.get_attribute(\"table:number-rows-spanned\") is not None:  # noqa: SIM103\n        return True\n    return False\n</code></pre>"},{"location":"reference.html#odfdo.Cell.set_value","title":"<code>set_value(value, text=None, cell_type=None, currency=None, formula=None)</code>","text":"<p>Set the cell state from the Python value type.</p> <p>Text is how the cell is displayed. Cell type is guessed, unless provided.</p> <p>For monetary values, provide the name of the currency.</p> <p>Arguments:</p> <pre><code>value -- Python type\n\ntext -- str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n            'currency' or 'percentage'\n\ncurrency -- str\n</code></pre> Source code in <code>odfdo/cell.py</code> <pre><code>def set_value(\n    self,\n    value: (\n        str\n        | bytes\n        | Float\n        | int\n        | Decimal\n        | bool\n        | datetime\n        | date\n        | timedelta\n        | None\n    ),\n    text: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    formula: str | None = None,\n) -&gt; None:\n    \"\"\"Set the cell state from the Python value type.\n\n    Text is how the cell is displayed. Cell type is guessed,\n    unless provided.\n\n    For monetary values, provide the name of the currency.\n\n    Arguments:\n\n        value -- Python type\n\n        text -- str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                    'currency' or 'percentage'\n\n        currency -- str\n    \"\"\"\n    self.clear()\n    text = self.set_value_and_type(\n        value=value,\n        text=text,\n        value_type=cell_type,\n        currency=currency,\n    )\n    if text is not None:\n        self.text_content = text\n    if formula is not None:\n        self.formula = formula\n</code></pre>"},{"location":"reference.html#odfdo.Cell.span_area","title":"<code>span_area()</code>","text":"<p>Return the tuple (nb_columns, nb_rows) of the zone covered by a spanned cell.</p> <p>If the cell is not spanned, return (0,0).</p> <p>Return: tuple[int, int]</p> Source code in <code>odfdo/cell.py</code> <pre><code>def span_area(self) -&gt; tuple[int, int]:\n    \"\"\"Return the tuple (nb_columns, nb_rows) of the zone covered\n    by a spanned cell.\n\n    If the cell is not spanned, return (0,0).\n\n    Return: tuple[int, int]\n    \"\"\"\n    columns = self.get_attribute_integer(\"table:number-columns-spanned\") or 0\n    rows = self.get_attribute_integer(\"table:number-rows-spanned\") or 0\n    return (columns, rows)\n</code></pre>"},{"location":"reference.html#odfdo.ChangeInfo","title":"<code>ChangeInfo</code>","text":"<p>               Bases: <code>Element</code>, <code>DcCreatorMixin</code>, <code>DcDateMixin</code></p> <p>The \u201coffice:change-info\u201d element represents who made a change and when. It may also contain a comment (one or more Paragrah \u201ctext:p\u201d elements) on the change.</p> The comments available in the ChangeInfo are available through <ul> <li>paragraphs property, get_paragraphs and get_paragraph methods for actual Paragraph.</li> <li>get_comments for a plain text version</li> </ul> <p>Arguments:</p> <p>creator \u2013 str (or None)</p> <p>date \u2013 datetime (or None)</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class ChangeInfo(Element, DcCreatorMixin, DcDateMixin):\n    \"\"\"The \"office:change-info\" element represents who made a change and when.\n    It may also contain a comment (one or more Paragrah \"text:p\" elements)\n    on the change.\n\n    The comments available in the ChangeInfo are available through:\n      - paragraphs property, get_paragraphs and get_paragraph methods for actual Paragraph.\n      - get_comments for a plain text version\n\n      Arguments:\n\n         creator -- str (or None)\n\n         date -- datetime (or None)\n    \"\"\"\n\n    _tag = \"office:change-info\"\n\n    def __init__(\n        self,\n        creator: str | None = None,\n        date: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.creator = creator or \"Unknown\"\n            self.date = date\n\n    def get_comments(self, joined: bool = True) -&gt; str | list[str]:\n        \"\"\"Get text content of the comments. If joined is True (default), the\n        text of different paragraphs is concatenated, else a list of strings,\n        one per paragraph, is returned.\n\n        Arguments:\n\n            joined -- boolean (default is True)\n\n        Return: str or list of str.\n        \"\"\"\n        content = self.paragraphs\n        if content is None:\n            content = []\n        text = [para.get_formatted_text(simple=True) for para in content]  # type: ignore\n        if joined:\n            return \"\\n\".join(text)\n        return text\n\n    def set_comments(self, text: str = \"\", replace: bool = True) -&gt; None:\n        \"\"\"Set the text content of the comments. If replace is True (default),\n        the new text replace old comments, else it is added at the end.\n\n        Arguments:\n\n            text -- str\n\n            replace -- boolean\n        \"\"\"\n        if replace:\n            for para in self.paragraphs:\n                self.delete(para)\n        para = Paragraph()\n        para.append_plain_text(text)\n        self.insert(para, xmlposition=LAST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.ChangeInfo.get_comments","title":"<code>get_comments(joined=True)</code>","text":"<p>Get text content of the comments. If joined is True (default), the text of different paragraphs is concatenated, else a list of strings, one per paragraph, is returned.</p> <p>Arguments:</p> <pre><code>joined -- boolean (default is True)\n</code></pre> <p>Return: str or list of str.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_comments(self, joined: bool = True) -&gt; str | list[str]:\n    \"\"\"Get text content of the comments. If joined is True (default), the\n    text of different paragraphs is concatenated, else a list of strings,\n    one per paragraph, is returned.\n\n    Arguments:\n\n        joined -- boolean (default is True)\n\n    Return: str or list of str.\n    \"\"\"\n    content = self.paragraphs\n    if content is None:\n        content = []\n    text = [para.get_formatted_text(simple=True) for para in content]  # type: ignore\n    if joined:\n        return \"\\n\".join(text)\n    return text\n</code></pre>"},{"location":"reference.html#odfdo.ChangeInfo.set_comments","title":"<code>set_comments(text='', replace=True)</code>","text":"<p>Set the text content of the comments. If replace is True (default), the new text replace old comments, else it is added at the end.</p> <p>Arguments:</p> <pre><code>text -- str\n\nreplace -- boolean\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_comments(self, text: str = \"\", replace: bool = True) -&gt; None:\n    \"\"\"Set the text content of the comments. If replace is True (default),\n    the new text replace old comments, else it is added at the end.\n\n    Arguments:\n\n        text -- str\n\n        replace -- boolean\n    \"\"\"\n    if replace:\n        for para in self.paragraphs:\n            self.delete(para)\n    para = Paragraph()\n    para.append_plain_text(text)\n    self.insert(para, xmlposition=LAST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.Chart","title":"<code>Chart</code>","text":"<p>               Bases: <code>Body</code></p> <p>Chart, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Chart(Body):\n    \"\"\"Chart, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:chart\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.Column","title":"<code>Column</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF table column \u201ctable:table-column\u201d</p> Source code in <code>odfdo/table.py</code> <pre><code>class Column(Element):\n    \"\"\"ODF table column \"table:table-column\" \"\"\"\n\n    _tag = \"table:table-column\"\n\n    def __init__(\n        self,\n        default_cell_style: str | None = None,\n        repeated: int | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a column group element of the optionally given style. Cell\n        style can be set for the whole column. If the properties apply to\n        several columns, give the number of repeated columns.\n\n        Columns don't contain cells, just style information.\n\n        You don't generally have to create columns by hand, use the Table API.\n\n        Arguments:\n\n            default_cell_style -- str\n\n            repeated -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self.x = None\n        if self._do_init:\n            if default_cell_style:\n                self.default_cell_style = default_cell_style\n            if repeated and repeated &gt; 1:\n                self.repeated = repeated\n            if style:\n                self.style = style\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} x={self.x}&gt;\"\n\n    @property\n    def clone(self) -&gt; Column:\n        clone = Element.clone.fget(self)  # type: ignore\n        clone.x = self.x\n        return clone\n\n    def get_default_cell_style(self) -&gt; str | None:\n        \"\"\"Get or set the default cell style for column.\n\n        (See also self.default_cell_style property.)\n        \"\"\"\n        return self.get_attribute_string(\"table:default-cell-style-name\")\n\n    def set_default_cell_style(self, style: Element | str | None) -&gt; None:\n        \"\"\"Get or set the default cell style for column.\n\n        (See also self.default_cell_style property.)\n        \"\"\"\n        self.set_style_attribute(\"table:default-cell-style-name\", style)\n\n    @property\n    def default_cell_style(self) -&gt; str | None:\n        \"\"\"Get or set the default cell style for column.\"\"\"\n        return self.get_attribute_string(\"table:default-cell-style-name\")\n\n    @default_cell_style.setter\n    def default_cell_style(self, style: Element | str | None) -&gt; None:\n        self.set_style_attribute(\"table:default-cell-style-name\", style)\n\n    def _set_repeated(self, repeated: int | None) -&gt; None:\n        \"\"\"Internal only. Set the number of times the column is repeated, or\n        None to delete it. Without changing cache.\n\n        Arguments:\n\n            repeated -- int or None\n        \"\"\"\n        if repeated is None or repeated &lt; 2:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:number-columns-repeated\")\n            return\n        self.set_attribute(\"table:number-columns-repeated\", str(repeated))\n\n    @property\n    def repeated(self) -&gt; int | None:\n        \"\"\"Get /set the number of times the column is repeated.\n\n        Always None when using the table API.\n\n        Return: int or None\n        \"\"\"\n        repeated = self.get_attribute(\"table:number-columns-repeated\")\n        if repeated is None:\n            return None\n        return int(repeated)\n\n    @repeated.setter\n    def repeated(self, repeated: int | None) -&gt; None:\n        self._set_repeated(repeated)\n        # update cache\n        current: Element = self\n        while True:\n            # look for Table, parent may be group of rows\n            upper = current.parent\n            if not upper:\n                # lonely column\n                return\n            # parent may be group of rows, not table\n            if isinstance(upper, Table):\n                break\n            current = upper\n        # fixme : need to optimize this\n        if isinstance(upper, Table):\n            upper._compute_table_cache()\n            if hasattr(self, \"_cmap\"):\n                del self._cmap[:]\n                self._cmap.extend(upper._cmap)\n            else:\n                self._cmap = upper._cmap\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get /set the style of the column itself.\n\n        Return: str\n        \"\"\"\n        return self.get_attribute_string(\"table:style-name\")\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n</code></pre>"},{"location":"reference.html#odfdo.Column.default_cell_style","title":"<code>default_cell_style</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the default cell style for column.</p>"},{"location":"reference.html#odfdo.Column.repeated","title":"<code>repeated</code>  <code>property</code> <code>writable</code>","text":"<p>Get /set the number of times the column is repeated.</p> <p>Always None when using the table API.</p> <p>Return: int or None</p>"},{"location":"reference.html#odfdo.Column.style","title":"<code>style</code>  <code>property</code> <code>writable</code>","text":"<p>Get /set the style of the column itself.</p> <p>Return: str</p>"},{"location":"reference.html#odfdo.Column.__init__","title":"<code>__init__(default_cell_style=None, repeated=None, style=None, **kwargs)</code>","text":"<p>Create a column group element of the optionally given style. Cell style can be set for the whole column. If the properties apply to several columns, give the number of repeated columns.</p> <p>Columns don\u2019t contain cells, just style information.</p> <p>You don\u2019t generally have to create columns by hand, use the Table API.</p> <p>Arguments:</p> <pre><code>default_cell_style -- str\n\nrepeated -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    default_cell_style: str | None = None,\n    repeated: int | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a column group element of the optionally given style. Cell\n    style can be set for the whole column. If the properties apply to\n    several columns, give the number of repeated columns.\n\n    Columns don't contain cells, just style information.\n\n    You don't generally have to create columns by hand, use the Table API.\n\n    Arguments:\n\n        default_cell_style -- str\n\n        repeated -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self.x = None\n    if self._do_init:\n        if default_cell_style:\n            self.default_cell_style = default_cell_style\n        if repeated and repeated &gt; 1:\n            self.repeated = repeated\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Column.get_default_cell_style","title":"<code>get_default_cell_style()</code>","text":"<p>Get or set the default cell style for column.</p> <p>(See also self.default_cell_style property.)</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_default_cell_style(self) -&gt; str | None:\n    \"\"\"Get or set the default cell style for column.\n\n    (See also self.default_cell_style property.)\n    \"\"\"\n    return self.get_attribute_string(\"table:default-cell-style-name\")\n</code></pre>"},{"location":"reference.html#odfdo.Column.set_default_cell_style","title":"<code>set_default_cell_style(style)</code>","text":"<p>Get or set the default cell style for column.</p> <p>(See also self.default_cell_style property.)</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_default_cell_style(self, style: Element | str | None) -&gt; None:\n    \"\"\"Get or set the default cell style for column.\n\n    (See also self.default_cell_style property.)\n    \"\"\"\n    self.set_style_attribute(\"table:default-cell-style-name\", style)\n</code></pre>"},{"location":"reference.html#odfdo.ConnectorShape","title":"<code>ConnectorShape</code>","text":"<p>               Bases: <code>ShapeBase</code></p> <p>Create a Connector shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\nconnected_shapes -- (shape, shape)\n\nglue_points -- (point, point)\n\np1 -- (str, str)\n\np2 -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class ConnectorShape(ShapeBase):\n    \"\"\"Create a Connector shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        connected_shapes -- (shape, shape)\n\n        glue_points -- (point, point)\n\n        p1 -- (str, str)\n\n        p2 -- (str, str)\n    \"\"\"\n\n    _tag = \"draw:connector\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"start_shape\", \"draw:start-shape\"),\n        PropDef(\"end_shape\", \"draw:end-shape\"),\n        PropDef(\"start_glue_point\", \"draw:start-glue-point\"),\n        PropDef(\"end_glue_point\", \"draw:end-glue-point\"),\n        PropDef(\"x1\", \"svg:x1\"),\n        PropDef(\"y1\", \"svg:y1\"),\n        PropDef(\"x2\", \"svg:x2\"),\n        PropDef(\"y2\", \"svg:y2\"),\n    )\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        connected_shapes: tuple | None = None,\n        glue_points: tuple | None = None,\n        p1: tuple | None = None,\n        p2: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n            }\n        )\n        super().__init__(**kwargs)\n        if self._do_init:\n            if connected_shapes:\n                self.start_shape = connected_shapes[0].draw_id\n                self.end_shape = connected_shapes[1].draw_id\n            if glue_points:\n                self.start_glue_point = glue_points[0]\n                self.end_glue_point = glue_points[1]\n            if p1:\n                self.x1 = p1[0]\n                self.y1 = p1[1]\n            if p2:\n                self.x2 = p2[0]\n                self.y2 = p2[1]\n</code></pre>"},{"location":"reference.html#odfdo.Container","title":"<code>Container</code>","text":"<p>Representation of the ODF file.</p> Source code in <code>odfdo/container.py</code> <pre><code>class Container:\n    \"\"\"Representation of the ODF file.\"\"\"\n\n    def __init__(self, path: Path | str | io.BytesIO | None = None) -&gt; None:\n        self.__parts: dict[str, bytes | None] = {}\n        self.__parts_ts: dict[str, int] = {}\n        self.__path_like: Path | str | io.BytesIO | None = None\n        self.__packaging: str = ZIP\n        self.path: Path | None = None  # or Path\n        if path:\n            self.open(path)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} type={self.mimetype} path={self.path}&gt;\"\n\n    def open(self, path_or_file: Path | str | io.BytesIO) -&gt; None:\n        \"\"\"Load the content of an ODF file.\"\"\"\n        self.__path_like = path_or_file\n        if isinstance(path_or_file, (str, Path)):\n            self.path = Path(path_or_file).expanduser()\n            if not self.path.exists():\n                raise FileNotFoundError(str(self.path))\n            self.__path_like = self.path\n        if (self.path or isinstance(self.__path_like, io.BytesIO)) and is_zipfile(\n            self.__path_like  # type: ignore\n        ):\n            self.__packaging = ZIP\n            return self._read_zip()\n        if self.path:\n            is_folder = False\n            with contextlib.suppress(OSError):\n                is_folder = self.path.is_dir()\n            if is_folder:\n                self.__packaging = FOLDER\n                return self._read_folder()\n        raise TypeError(f\"Document format not managed by odfdo: {type(path_or_file)}.\")\n\n    def _read_zip(self) -&gt; None:\n        if isinstance(self.__path_like, io.BytesIO):\n            self.__path_like.seek(0)\n        with ZipFile(self.__path_like) as zf:  # type: ignore\n            mimetype = bytes_to_str(zf.read(\"mimetype\"))\n            if mimetype not in ODF_MIMETYPES:\n                raise ValueError(f\"Document of unknown type {mimetype}\")\n            self.__parts[\"mimetype\"] = str_to_bytes(mimetype)\n        if self.path is None:\n            if isinstance(self.__path_like, io.BytesIO):\n                self.__path_like.seek(0)\n            # read the full file at once and forget file\n            with ZipFile(self.__path_like) as zf:  # type: ignore\n                for name in zf.namelist():\n                    upath = normalize_path(name)\n                    self.__parts[upath] = zf.read(name)\n            self.__path_like = None\n\n    def _read_folder(self) -&gt; None:\n        try:\n            mimetype, timestamp = self._get_folder_part(\"mimetype\")\n        except OSError:\n            printwarn(\"Corrupted or not an OpenDocument folder (missing mimetype)\")\n            mimetype = b\"\"\n            timestamp = int(time.time())\n        if bytes_to_str(mimetype) not in ODF_MIMETYPES:\n            message = f\"Document of unknown type {mimetype!r}, try with ODF Text.\"\n            printwarn(message)\n            self.__parts[\"mimetype\"] = str_to_bytes(ODF_EXTENSIONS[\"odt\"])\n            self.__parts_ts[\"mimetype\"] = timestamp\n\n    def _parse_folder(self, folder: str) -&gt; list[str]:\n        parts = []\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        root = self.path / folder\n        for path in root.iterdir():\n            if path.name.startswith(\".\"):  # no hidden files\n                continue\n            relative_path = path.relative_to(self.path)\n            if path.is_file():\n                parts.append(relative_path.as_posix())\n            if path.is_dir():\n                sub_parts = self._parse_folder(str(relative_path))\n                if sub_parts:\n                    parts.extend(sub_parts)\n                else:\n                    # store leaf directories\n                    parts.append(relative_path.as_posix() + \"/\")\n        return parts\n\n    def _get_folder_parts(self) -&gt; list[str]:\n        \"\"\"Get the list of members in the ODF folder.\"\"\"\n        return self._parse_folder(\"\")\n\n    def _get_folder_part(self, name: str) -&gt; tuple[bytes, int]:\n        \"\"\"Get bytes of a part from the ODF folder, with timestamp.\"\"\"\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        path = self.path / name\n        timestamp = int(path.stat().st_mtime)\n        if path.is_dir():\n            return (b\"\", timestamp)\n        return (path.read_bytes(), timestamp)\n\n    def _get_folder_part_timestamp(self, name: str) -&gt; int:\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        path = self.path / name\n        try:\n            timestamp = int(path.stat().st_mtime)\n        except OSError:\n            timestamp = -1\n        return timestamp\n\n    def _get_zip_part(self, name: str) -&gt; bytes | None:\n        \"\"\"Get bytes of a part from the Zip ODF file. No cache.\"\"\"\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        try:\n            with ZipFile(self.path) as zf:\n                upath = normalize_path(name)\n                self.__parts[upath] = zf.read(name)\n                return self.__parts[upath]\n        except BadZipfile:\n            return None\n\n    def _get_all_zip_part(self) -&gt; None:\n        \"\"\"Read all parts. No cache.\"\"\"\n        if self.path is None:\n            raise ValueError(\"Document path is not defined\")\n        try:\n            with ZipFile(self.path) as zf:\n                for name in zf.namelist():\n                    upath = normalize_path(name)\n                    self.__parts[upath] = zf.read(name)\n        except BadZipfile:\n            pass\n\n    def _save_zip(self, target: str | Path | io.BytesIO) -&gt; None:\n        \"\"\"Save a Zip ODF from the available parts.\"\"\"\n        parts = self.__parts\n        with ZipFile(target, \"w\", compression=ZIP_DEFLATED) as filezip:\n            # Parts to save, except manifest at the end\n            part_names = list(parts.keys())\n            try:\n                part_names.remove(ODF_MANIFEST)\n            except ValueError:\n                printwarn(f\"Missing '{ODF_MANIFEST}'\")\n            # \"Pretty-save\" parts in some order\n            # mimetype requires to be first and uncompressed\n            mimetype = parts.get(\"mimetype\")\n            if mimetype is None:\n                raise ValueError(\"Mimetype is not defined\")\n            try:\n                filezip.writestr(\"mimetype\", mimetype, ZIP_STORED)\n                part_names.remove(\"mimetype\")\n            except (ValueError, KeyError):\n                printwarn(\"Missing 'mimetype'\")\n            # XML parts\n            for path in ODF_CONTENT, ODF_META, ODF_SETTINGS, ODF_STYLES:\n                if path not in parts:\n                    printwarn(f\"Missing '{path}'\")\n                    continue\n                part = parts[path]\n                if part is None:\n                    continue\n                filezip.writestr(path, part)\n                part_names.remove(path)\n            # Everything else\n            for path in part_names:\n                data = parts[path]\n                if data is None:\n                    # Deleted\n                    continue\n                filezip.writestr(path, data)\n            with contextlib.suppress(KeyError):\n                part = parts[ODF_MANIFEST]\n                if part is not None:\n                    filezip.writestr(ODF_MANIFEST, part)\n\n    def _save_folder(self, folder: Path | str) -&gt; None:\n        \"\"\"Save a folder ODF from the available parts.\"\"\"\n\n        def dump(part_path: str, content: bytes) -&gt; None:\n            if part_path.endswith(\"/\"):  # folder\n                is_folder = True\n                pure_path = PurePath(folder, part_path[:-1])\n            else:\n                is_folder = False\n                pure_path = PurePath(folder, part_path)\n            path = Path(pure_path)\n            if is_folder:\n                path.mkdir(parents=True, exist_ok=True)\n            else:\n                path.parent.mkdir(parents=True, exist_ok=True)\n                path.write_bytes(content)\n                path.chmod(0o666)\n\n        for part_path, data in self.__parts.items():\n            if data is None:\n                # Deleted\n                continue\n            dump(part_path, data)\n\n    def _encoded_image(self, elem: _Element) -&gt; _Element | None:\n        mime_type = elem.get(\n            \"{urn:oasis:names:tc:opendocument:xmlns:drawing:1.0}mime-type\"\n        )\n        path = elem.get(\"{http://www.w3.org/1999/xlink}href\")\n        if not path:\n            return None\n        content = self.__parts[path]\n        if not content:\n            return None\n        text = base64.standard_b64encode(content).decode()\n        ebytes = (\n            f'&lt;draw:image draw:mime-type=\"{mime_type}\"&gt;'\n            f\"&lt;office:binary-data&gt;{text}\\n&lt;/office:binary-data&gt;&lt;/draw:image&gt;\"\n        ).encode()\n        root = fromstring(NAMESPACES_XML % ebytes)\n        return root[0]\n\n    def _xml_content(self, pretty: bool = True) -&gt; bytes:\n\n        mimetype = self.__parts[\"mimetype\"].decode(\"utf8\")\n        doc_xml = (\n            OFFICE_PREFIX.decode(\"utf8\")\n            + f'office:version=\"{OFFICE_VERSION}\"\\n'\n            + f'office:mimetype=\"{mimetype}\"&gt;'\n            + \"&lt;/office:document&gt;\"\n        )\n        root = fromstring(doc_xml.encode(\"utf8\"))\n        for path in ODF_META, ODF_SETTINGS, ODF_STYLES, ODF_CONTENT:\n            if path not in self.__parts:\n                printwarn(f\"Missing '{path}'\")\n                continue\n            part = self.__parts[path]\n            if part is None:\n                continue\n            if isinstance(part, bytes):\n                xpart = fromstring(part)\n            else:\n                xpart = part\n            if path == ODF_CONTENT:\n                xpath = xpath_compile(\"descendant::draw:image\")\n                images = xpath(xpart)\n                if images:\n                    for elem in images:\n                        encoded = self._encoded_image(elem)\n                        elem.getparent().replace(elem, encoded)\n            for child in xpart:\n                root.append(child)\n        if pretty:\n            xml_header = b'&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n'\n            bytes_tree = tostring(\n                pretty_indent(root),\n                encoding=\"unicode\",\n            ).encode(\"utf8\")\n            return xml_header + bytes_tree\n        else:\n            return tostring(root, encoding=\"UTF-8\", xml_declaration=True)\n\n    def _save_xml(self, target: Path | str | io.BytesIO, pretty: bool = True) -&gt; None:\n        \"\"\"Save a XML flat ODF format from the available parts.\"\"\"\n        if isinstance(target, (Path, str)):\n            target = Path(target).with_suffix(\".xml\")\n            target.write_bytes(self._xml_content(pretty))\n        else:\n            target.write(self._xml_content(pretty))\n\n    # Public API\n\n    def get_parts(self) -&gt; list[str]:\n        \"\"\"Get the list of members.\"\"\"\n        if not self.path:\n            # maybe a file like zip archive\n            return list(self.__parts.keys())\n        if self.__packaging == ZIP:\n            parts = []\n            with ZipFile(self.path) as zf:\n                for name in zf.namelist():\n                    upath = normalize_path(name)\n                    parts.append(upath)\n            return parts\n        elif self.__packaging == FOLDER:\n            return self._get_folder_parts()\n        else:\n            raise ValueError(\"Unable to provide parts of the document\")\n\n    @property\n    def parts(self) -&gt; list[str]:\n        \"\"\"Get the list of members.\"\"\"\n        return self.get_parts()\n\n    def get_part(self, path: str) -&gt; str | bytes | None:\n        \"\"\"Get the bytes of a part of the ODF.\"\"\"\n        path = str(path)\n        if path in self.__parts:\n            part = self.__parts[path]\n            if part is None:\n                raise ValueError(f'Part \"{path}\" is deleted')\n            if self.__packaging == FOLDER:\n                cache_ts = self.__parts_ts.get(path, -1)\n                current_ts = self._get_folder_part_timestamp(path)\n                if current_ts != cache_ts:\n                    part, timestamp = self._get_folder_part(path)\n                    self.__parts[path] = part\n                    self.__parts_ts[path] = timestamp\n            return part\n        if self.__packaging == ZIP:\n            return self._get_zip_part(path)\n        if self.__packaging == FOLDER:\n            part, timestamp = self._get_folder_part(path)\n            self.__parts[path] = part\n            self.__parts_ts[path] = timestamp\n            return part\n        return None\n\n    @property\n    def default_manifest_rdf(self) -&gt; str:\n        return (\n            '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n            '&lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"&gt;\\n'\n            '  &lt;rdf:Description rdf:about=\"styles.xml\"&gt;\\n'\n            f'    &lt;rdf:type rdf:resource=\"http://docs.oasis-open.org/ns/office/{OFFICE_VERSION}/meta/odf#StylesFile\"/&gt;\\n'\n            \"  &lt;/rdf:Description&gt;\\n\"\n            '  &lt;rdf:Description rdf:about=\"\"&gt;\\n'\n            f'    &lt;ns0:hasPart xmlns:ns0=\"http://docs.oasis-open.org/ns/office/{OFFICE_VERSION}/meta/pkg#\" rdf:resource=\"styles.xml\"/&gt;\\n'\n            \"  &lt;/rdf:Description&gt;\\n\"\n            '  &lt;rdf:Description rdf:about=\"content.xml\"&gt;\\n'\n            f'    &lt;rdf:type rdf:resource=\"http://docs.oasis-open.org/ns/office/{OFFICE_VERSION}/meta/odf#ContentFile\"/&gt;\\n'\n            \"  &lt;/rdf:Description&gt;\\n\"\n            '  &lt;rdf:Description rdf:about=\"\"&gt;\\n'\n            f'    &lt;ns0:hasPart xmlns:ns0=\"http://docs.oasis-open.org/ns/office/{OFFICE_VERSION}/meta/pkg#\" rdf:resource=\"content.xml\"/&gt;\\n'\n            \"  &lt;/rdf:Description&gt;\\n\"\n            '  &lt;rdf:Description rdf:about=\"\"&gt;\\n'\n            f'    &lt;rdf:type rdf:resource=\"http://docs.oasis-open.org/ns/office/{OFFICE_VERSION}/meta/pkg#Document\"/&gt;\\n'\n            \"  &lt;/rdf:Description&gt;\\n\"\n            \"&lt;/rdf:RDF&gt;\\n\"\n        )\n\n    @property\n    def mimetype(self) -&gt; str:\n        \"\"\"Return str value of mimetype of the document.\"\"\"\n        with contextlib.suppress(Exception):\n            b_mimetype = self.get_part(\"mimetype\")\n            if isinstance(b_mimetype, bytes):\n                return bytes_to_str(b_mimetype)\n        return \"\"\n\n    @mimetype.setter\n    def mimetype(self, mimetype: str | bytes) -&gt; None:\n        \"\"\"Set mimetype value of the document.\"\"\"\n        if isinstance(mimetype, str):\n            self.__parts[\"mimetype\"] = str_to_bytes(mimetype)\n        elif isinstance(mimetype, bytes):\n            self.__parts[\"mimetype\"] = mimetype\n        else:\n            raise TypeError(f'Wrong mimetype \"{mimetype!r}\"')\n\n    def set_part(self, path: str, data: bytes) -&gt; None:\n        \"\"\"Replace or add a new part.\"\"\"\n        self.__parts[path] = data\n\n    def del_part(self, path: str) -&gt; None:\n        \"\"\"Mark a part for deletion.\"\"\"\n        self.__parts[path] = None\n\n    @property\n    def clone(self) -&gt; Container:\n        \"\"\"Make a copy of this container with no path.\"\"\"\n        if self.path and self.__packaging == ZIP:\n            self._get_all_zip_part()\n        clone = deepcopy(self)\n        clone.path = None\n        return clone\n\n    def _backup_or_unlink(self, backup: bool, target: str | Path) -&gt; None:\n        if backup:\n            self._do_backup(target)\n        else:\n            self._do_unlink(target)\n\n    @staticmethod\n    def _do_backup(target: str | Path) -&gt; None:\n        path = Path(target)\n        if not path.exists():\n            return\n        back_file = Path(path.stem + \".backup\" + path.suffix)\n        if back_file.is_dir():\n            try:\n                shutil.rmtree(back_file)\n            except OSError as e:\n                printwarn(str(e))\n        try:\n            shutil.move(target, back_file)\n        except OSError as e:\n            printwarn(str(e))\n\n    @staticmethod\n    def _do_unlink(target: str | Path) -&gt; None:\n        path = Path(target)\n        if path.exists():\n            try:\n                shutil.rmtree(path)\n            except OSError as e:\n                printwarn(str(e))\n\n    def _clean_save_packaging(self, packaging: str | None) -&gt; str:\n        if not packaging:\n            packaging = self.__packaging if self.__packaging else ZIP\n        packaging = packaging.strip().lower()\n        if packaging not in PACKAGING:\n            raise ValueError(f'Packaging of type \"{packaging}\" is not supported')\n        return packaging\n\n    def _clean_save_target(\n        self,\n        target: str | Path | io.BytesIO | None,\n    ) -&gt; str | io.BytesIO:\n        if target is None:\n            target = self.path\n        if isinstance(target, Path):\n            target = str(target)\n        if isinstance(target, str):\n            while target.endswith(os.sep):\n                target = target[:-1]\n            while target.endswith(\".folder\"):\n                target = target.split(\".folder\", 1)[0]\n        return target  # type: ignore\n\n    def _save_as_zip(self, target: str | Path | io.BytesIO, backup: bool) -&gt; None:\n        if isinstance(target, (str, Path)) and backup:\n            self._do_backup(target)\n        self._save_zip(target)\n\n    def _save_as_folder(self, target: str | Path, backup: bool) -&gt; None:\n        if not isinstance(target, (str, Path)):\n            raise TypeError(\n                f\"Saving in folder format requires a folder name, not '{target!r}'\"\n            )\n        if not str(target).endswith(\".folder\"):\n            target = str(target) + \".folder\"\n        self._backup_or_unlink(backup, target)\n        self._save_folder(target)\n\n    def _save_as_xml(\n        self,\n        target: str | Path | io.BytesIO,\n        backup: bool,\n        pretty: bool = True,\n    ) -&gt; None:\n        if not isinstance(target, (str, Path, io.BytesIO)):\n            raise TypeError(\n                f\"Saving in XML format requires a path name, not '{target!r}'\"\n            )\n        if isinstance(target, (str, Path)):\n            if not str(target).endswith(\".xml\"):\n                target = str(target) + \".xml\"\n            if backup:\n                self._do_backup(target)\n        self._save_xml(target, pretty)\n\n    def save(\n        self,\n        target: str | Path | io.BytesIO | None,\n        packaging: str | None = None,\n        backup: bool = False,\n        pretty: bool = False,\n    ) -&gt; None:\n        \"\"\"Save the container to the given target, a path or a file-like\n        object.\n\n        Package the output document in the same format than current document,\n        unless \"packaging\" is different.\n\n        Arguments:\n\n            target -- str or file-like or Path\n\n            packaging -- 'zip', or for debugging purpose 'xml' or 'folder'\n\n            backup -- boolean\n        \"\"\"\n        parts = self.__parts\n        packaging = self._clean_save_packaging(packaging)\n        # Load parts else they will be considered deleted\n        for path in self.parts:\n            if path not in parts:\n                self.get_part(path)\n        target = self._clean_save_target(target)\n        if packaging == FOLDER:\n            if isinstance(target, io.BytesIO):\n                raise TypeError(\n                    \"Impossible to save on io.BytesIO with 'folder' packaging\"\n                )\n            self._save_as_folder(target, backup)\n        elif packaging == XML:\n            self._save_as_xml(target, backup, pretty)\n        else:\n            # default:\n            self._save_as_zip(target, backup)\n</code></pre>"},{"location":"reference.html#odfdo.Container.clone","title":"<code>clone</code>  <code>property</code>","text":"<p>Make a copy of this container with no path.</p>"},{"location":"reference.html#odfdo.Container.mimetype","title":"<code>mimetype</code>  <code>property</code> <code>writable</code>","text":"<p>Return str value of mimetype of the document.</p>"},{"location":"reference.html#odfdo.Container.parts","title":"<code>parts</code>  <code>property</code>","text":"<p>Get the list of members.</p>"},{"location":"reference.html#odfdo.Container.del_part","title":"<code>del_part(path)</code>","text":"<p>Mark a part for deletion.</p> Source code in <code>odfdo/container.py</code> <pre><code>def del_part(self, path: str) -&gt; None:\n    \"\"\"Mark a part for deletion.\"\"\"\n    self.__parts[path] = None\n</code></pre>"},{"location":"reference.html#odfdo.Container.get_part","title":"<code>get_part(path)</code>","text":"<p>Get the bytes of a part of the ODF.</p> Source code in <code>odfdo/container.py</code> <pre><code>def get_part(self, path: str) -&gt; str | bytes | None:\n    \"\"\"Get the bytes of a part of the ODF.\"\"\"\n    path = str(path)\n    if path in self.__parts:\n        part = self.__parts[path]\n        if part is None:\n            raise ValueError(f'Part \"{path}\" is deleted')\n        if self.__packaging == FOLDER:\n            cache_ts = self.__parts_ts.get(path, -1)\n            current_ts = self._get_folder_part_timestamp(path)\n            if current_ts != cache_ts:\n                part, timestamp = self._get_folder_part(path)\n                self.__parts[path] = part\n                self.__parts_ts[path] = timestamp\n        return part\n    if self.__packaging == ZIP:\n        return self._get_zip_part(path)\n    if self.__packaging == FOLDER:\n        part, timestamp = self._get_folder_part(path)\n        self.__parts[path] = part\n        self.__parts_ts[path] = timestamp\n        return part\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Container.get_parts","title":"<code>get_parts()</code>","text":"<p>Get the list of members.</p> Source code in <code>odfdo/container.py</code> <pre><code>def get_parts(self) -&gt; list[str]:\n    \"\"\"Get the list of members.\"\"\"\n    if not self.path:\n        # maybe a file like zip archive\n        return list(self.__parts.keys())\n    if self.__packaging == ZIP:\n        parts = []\n        with ZipFile(self.path) as zf:\n            for name in zf.namelist():\n                upath = normalize_path(name)\n                parts.append(upath)\n        return parts\n    elif self.__packaging == FOLDER:\n        return self._get_folder_parts()\n    else:\n        raise ValueError(\"Unable to provide parts of the document\")\n</code></pre>"},{"location":"reference.html#odfdo.Container.open","title":"<code>open(path_or_file)</code>","text":"<p>Load the content of an ODF file.</p> Source code in <code>odfdo/container.py</code> <pre><code>def open(self, path_or_file: Path | str | io.BytesIO) -&gt; None:\n    \"\"\"Load the content of an ODF file.\"\"\"\n    self.__path_like = path_or_file\n    if isinstance(path_or_file, (str, Path)):\n        self.path = Path(path_or_file).expanduser()\n        if not self.path.exists():\n            raise FileNotFoundError(str(self.path))\n        self.__path_like = self.path\n    if (self.path or isinstance(self.__path_like, io.BytesIO)) and is_zipfile(\n        self.__path_like  # type: ignore\n    ):\n        self.__packaging = ZIP\n        return self._read_zip()\n    if self.path:\n        is_folder = False\n        with contextlib.suppress(OSError):\n            is_folder = self.path.is_dir()\n        if is_folder:\n            self.__packaging = FOLDER\n            return self._read_folder()\n    raise TypeError(f\"Document format not managed by odfdo: {type(path_or_file)}.\")\n</code></pre>"},{"location":"reference.html#odfdo.Container.save","title":"<code>save(target, packaging=None, backup=False, pretty=False)</code>","text":"<p>Save the container to the given target, a path or a file-like object.</p> <p>Package the output document in the same format than current document, unless \u201cpackaging\u201d is different.</p> <p>Arguments:</p> <pre><code>target -- str or file-like or Path\n\npackaging -- 'zip', or for debugging purpose 'xml' or 'folder'\n\nbackup -- boolean\n</code></pre> Source code in <code>odfdo/container.py</code> <pre><code>def save(\n    self,\n    target: str | Path | io.BytesIO | None,\n    packaging: str | None = None,\n    backup: bool = False,\n    pretty: bool = False,\n) -&gt; None:\n    \"\"\"Save the container to the given target, a path or a file-like\n    object.\n\n    Package the output document in the same format than current document,\n    unless \"packaging\" is different.\n\n    Arguments:\n\n        target -- str or file-like or Path\n\n        packaging -- 'zip', or for debugging purpose 'xml' or 'folder'\n\n        backup -- boolean\n    \"\"\"\n    parts = self.__parts\n    packaging = self._clean_save_packaging(packaging)\n    # Load parts else they will be considered deleted\n    for path in self.parts:\n        if path not in parts:\n            self.get_part(path)\n    target = self._clean_save_target(target)\n    if packaging == FOLDER:\n        if isinstance(target, io.BytesIO):\n            raise TypeError(\n                \"Impossible to save on io.BytesIO with 'folder' packaging\"\n            )\n        self._save_as_folder(target, backup)\n    elif packaging == XML:\n        self._save_as_xml(target, backup, pretty)\n    else:\n        # default:\n        self._save_as_zip(target, backup)\n</code></pre>"},{"location":"reference.html#odfdo.Container.set_part","title":"<code>set_part(path, data)</code>","text":"<p>Replace or add a new part.</p> Source code in <code>odfdo/container.py</code> <pre><code>def set_part(self, path: str, data: bytes) -&gt; None:\n    \"\"\"Replace or add a new part.\"\"\"\n    self.__parts[path] = data\n</code></pre>"},{"location":"reference.html#odfdo.Content","title":"<code>Content</code>","text":"<p>               Bases: <code>XmlPart</code></p> Source code in <code>odfdo/content.py</code> <pre><code>class Content(XmlPart):\n    # The following two seem useless but they match styles API\n\n    def _get_style_contexts(self, family: str | None) -&gt; tuple:\n        if family == \"font-face\":\n            return (self.get_element(\"//office:font-face-decls\"),)\n        return (\n            self.get_element(\"//office:font-face-decls\"),\n            self.get_element(\"//office:automatic-styles\"),\n        )\n\n    def __str__(self) -&gt; str:\n        return str(self.body)\n\n    # Public API\n\n    def get_styles(self, family: str | None = None) -&gt; list[Style]:\n        \"\"\"Return the list of styles in the Content part, optionally limited\n        to the given family.\n\n        Arguments:\n\n            family -- str or None\n\n        Return: list of Style\n        \"\"\"\n        result: list[Style] = []\n        for context in self._get_style_contexts(family):\n            if context is None:\n                continue\n            result.extend(context.get_styles(family=family))\n        return result\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Element | None = None,\n        display_name: str | None = None,\n    ) -&gt; Style | None:\n        \"\"\"Return the style uniquely identified by the name/family pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is None, the default style is fetched.\n\n        If the name is not the internal name but the name you gave in the\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                      'number', ...\n            name_or_element -- str or Style\n\n            display_name -- str\n\n        Return: Style or None if not found\n        \"\"\"\n        for context in self._get_style_contexts(family):\n            if context is None:\n                continue\n            style = context.get_style(\n                family,\n                name_or_element=name_or_element,\n                display_name=display_name,\n            )\n            if style is not None:\n                return style\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Content.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the name/family pair. If the argument is already a style object, it will return it.</p> <p>If the name is None, the default style is fetched.</p> <p>If the name is not the internal name but the name you gave in the desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n          'number', ...\nname_or_element -- str or Style\n\ndisplay_name -- str\n</code></pre> <p>Return: Style or None if not found</p> Source code in <code>odfdo/content.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Element | None = None,\n    display_name: str | None = None,\n) -&gt; Style | None:\n    \"\"\"Return the style uniquely identified by the name/family pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is None, the default style is fetched.\n\n    If the name is not the internal name but the name you gave in the\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                  'number', ...\n        name_or_element -- str or Style\n\n        display_name -- str\n\n    Return: Style or None if not found\n    \"\"\"\n    for context in self._get_style_contexts(family):\n        if context is None:\n            continue\n        style = context.get_style(\n            family,\n            name_or_element=name_or_element,\n            display_name=display_name,\n        )\n        if style is not None:\n            return style\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Content.get_styles","title":"<code>get_styles(family=None)</code>","text":"<p>Return the list of styles in the Content part, optionally limited to the given family.</p> <p>Arguments:</p> <pre><code>family -- str or None\n</code></pre> <p>Return: list of Style</p> Source code in <code>odfdo/content.py</code> <pre><code>def get_styles(self, family: str | None = None) -&gt; list[Style]:\n    \"\"\"Return the list of styles in the Content part, optionally limited\n    to the given family.\n\n    Arguments:\n\n        family -- str or None\n\n    Return: list of Style\n    \"\"\"\n    result: list[Style] = []\n    for context in self._get_style_contexts(family):\n        if context is None:\n            continue\n        result.extend(context.get_styles(family=family))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Database","title":"<code>Database</code>","text":"<p>               Bases: <code>Body</code></p> <p>Database, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Database(Body):\n    \"\"\"Database, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:database\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>MDDocument</code></p> <p>Abstraction of the ODF document.</p> <p>To create a new Document, several possibilities:</p> <pre><code>- Document() or Document(\"text\") or Document(\"odt\")\n    -&gt; an \"empty\" document of type text\n- Document(\"spreadsheet\") or Document(\"ods\")\n    -&gt; an \"empty\" document of type spreadsheet\n- Document(\"presentation\") or Document(\"odp\")\n    -&gt; an \"empty\" document of type presentation\n- Document(\"drawing\") or Document(\"odg\")\n    -&gt; an \"empty\" document of type drawing\n\nMeaning of \u201cempty\u201d: these documents are copies of the default\ntemplates documents provided with this library, which, as templates,\nare not really empty. It may be useful to clear the newly created\ndocument: document.body.clear(), or adjust meta informations like\ndescription or default language: document.meta.language = 'fr-FR'\n</code></pre> <p>If the argument is not a known template type, or is a Path, Document(file) will load the content of the ODF file.</p> <p>To explicitly create a document from a custom template, use the Document.new(path) method whose argument is the path to the template file.</p> Source code in <code>odfdo/document.py</code> <pre><code>class Document(MDDocument):\n    \"\"\"Abstraction of the ODF document.\n\n    To create a new Document, several possibilities:\n\n        - Document() or Document(\"text\") or Document(\"odt\")\n            -&gt; an \"empty\" document of type text\n        - Document(\"spreadsheet\") or Document(\"ods\")\n            -&gt; an \"empty\" document of type spreadsheet\n        - Document(\"presentation\") or Document(\"odp\")\n            -&gt; an \"empty\" document of type presentation\n        - Document(\"drawing\") or Document(\"odg\")\n            -&gt; an \"empty\" document of type drawing\n\n        Meaning of \u201cempty\u201d: these documents are copies of the default\n        templates documents provided with this library, which, as templates,\n        are not really empty. It may be useful to clear the newly created\n        document: document.body.clear(), or adjust meta informations like\n        description or default language: document.meta.language = 'fr-FR'\n\n    If the argument is not a known template type, or is a Path,\n    Document(file) will load the content of the ODF file.\n\n    To explicitly create a document from a custom template, use the\n    Document.new(path) method whose argument is the path to the template file.\n    \"\"\"\n\n    def __init__(\n        self,\n        target: str | bytes | Path | Container | io.BytesIO | None = \"text\",\n    ) -&gt; None:\n        # Cache of XML parts\n        self.__xmlparts: dict[str, XmlPart] = {}\n        # Cache of the body\n        self.__body: Element | None = None\n        self.container: Container | None = None\n        if isinstance(target, bytes):\n            # eager conversion\n            target = bytes_to_str(target)\n        if target is None:\n            # empty document, you probably don't wnat this.\n            self.container = Container()\n            return\n        if isinstance(target, Path):\n            # let's assume we open a container on existing file\n            self.container = Container(target)\n            return\n        if isinstance(target, Container):\n            # special internal case, use an existing container\n            self.container = target\n            return\n        if isinstance(target, str):\n            if target in ODF_TEMPLATES:\n                # assuming a new document from templates\n                self.container = container_from_template(target)\n                return\n            # let's assume we open a container on existing file\n            self.container = Container(target)\n            return\n        if isinstance(target, io.BytesIO):\n            self.container = Container(target)\n            return\n        raise TypeError(f\"Unknown Document source type: '{target!r}'\")\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} type={self.get_type()} path={self.path}&gt;\"\n\n    def __str__(self) -&gt; str:\n        try:\n            return str(self.get_formatted_text())\n        except NotImplementedError:\n            return str(self.body)\n\n    @classmethod\n    def new(cls, template: str | Path | io.BytesIO = \"text\") -&gt; Document:\n        \"\"\"Create a Document from a template.\n\n        The template argument is expected to be the path to a ODF template.\n\n        Arguments:\n\n            template -- str or Path or file-like (io.BytesIO)\n\n        Return : ODF document -- Document\n        \"\"\"\n        container = container_from_template(template)\n        return cls(container)\n\n    # Public API\n\n    @property\n    def path(self) -&gt; Path | None:\n        \"\"\"Shortcut to Document.Container.path.\"\"\"\n        if not self.container:\n            return None\n        return self.container.path\n\n    @path.setter\n    def path(self, path_or_str: str | Path) -&gt; None:\n        \"\"\"Shortcut to Document.Container.path\n\n        Only accepting str or Path.\"\"\"\n        if not self.container:\n            return\n        self.container.path = Path(path_or_str)\n\n    def get_parts(self) -&gt; list[str]:\n        \"\"\"Return available part names with path inside the archive, e.g.\n        ['content.xml', ..., 'Pictures/100000000000032000000258912EB1C3.jpg']\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        return self.container.parts\n\n    @property\n    def parts(self) -&gt; list[str]:\n        \"\"\"Return available part names with path inside the archive, e.g.\n        ['content.xml', ..., 'Pictures/100000000000032000000258912EB1C3.jpg']\n        \"\"\"\n        return self.get_parts()\n\n    def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:\n        \"\"\"Return the bytes of the given part. The path is relative to the\n        archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n        'content', 'meta', 'settings', 'styles' and 'manifest' are shortcuts\n        to the real path, e.g. content.xml, and return a dedicated object with\n        its own API.\n\n        path formated as URI, so always use '/' separator\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        # \"./ObjectReplacements/Object 1\"\n        path = path.lstrip(\"./\")\n        path = _get_part_path(path)\n        cls = _get_part_class(path)\n        # Raw bytes\n        if cls is None:\n            return self.container.get_part(path)\n        # XML part\n        part = self.__xmlparts.get(path)\n        if part is None:\n            self.__xmlparts[path] = part = cls(path, self.container)\n        return part\n\n    def set_part(self, path: str, data: bytes) -&gt; None:\n        \"\"\"Set the bytes of the given part. The path is relative to the\n        archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n        path formated as URI, so always use '/' separator\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        # \"./ObjectReplacements/Object 1\"\n        path = path.lstrip(\"./\")\n        path = _get_part_path(path)\n        cls = _get_part_class(path)\n        # XML part overwritten\n        if cls is not None:\n            with suppress(KeyError):\n                self.__xmlparts[path]\n        self.container.set_part(path, data)\n\n    def del_part(self, path: str) -&gt; None:\n        \"\"\"Mark a part for deletion. The path is relative to the archive,\n        e.g. \"Pictures/1003200258912EB1C3.jpg\"\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        path = _get_part_path(path)\n        cls = _get_part_class(path)\n        if path == ODF_MANIFEST or cls is not None:\n            raise ValueError(f\"part '{path}' is mandatory\")\n        self.container.del_part(path)\n\n    @property\n    def mimetype(self) -&gt; str:\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        return self.container.mimetype\n\n    @mimetype.setter\n    def mimetype(self, mimetype: str) -&gt; None:\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        self.container.mimetype = mimetype\n\n    def get_type(self) -&gt; str:\n        \"\"\"Get the ODF type (also called class) of this document.\n\n        Return: 'chart', 'database', 'formula', 'graphics',\n            'graphics-template', 'image', 'presentation',\n            'presentation-template', 'spreadsheet', 'spreadsheet-template',\n            'text', 'text-master', 'text-template' or 'text-web'\n        \"\"\"\n        # The mimetype must be with the form:\n        # application/vnd.oasis.opendocument.text\n\n        # Isolate and return the last part\n        return self.mimetype.rsplit(\".\", 1)[-1]\n\n    @property\n    def body(self) -&gt; Element:\n        \"\"\"Return the body element of the content part, where actual content\n        is stored.\n        \"\"\"\n        if self.__body is None:\n            self.__body = self.content.body\n        return self.__body\n\n    @property\n    def meta(self) -&gt; Meta:\n        \"\"\"Return the meta part (meta.xml) of the document, where meta data\n        are stored.\"\"\"\n        metadata = self.get_part(ODF_META)\n        if metadata is None or not isinstance(metadata, Meta):\n            raise ValueError(\"Empty Meta\")\n        return metadata\n\n    @property\n    def manifest(self) -&gt; Manifest:\n        \"\"\"Return the manifest part (manifest.xml) of the document.\"\"\"\n        manifest = self.get_part(ODF_MANIFEST)\n        if manifest is None or not isinstance(manifest, Manifest):\n            raise ValueError(\"Empty Manifest\")\n        return manifest\n\n    def _get_formatted_text_footnotes(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Separate text from notes\n        if rst_mode:\n            result.append(\"\\n\")\n        else:\n            result.append(\"----\\n\")\n        for citation, body in context[\"footnotes\"]:\n            if rst_mode:\n                result.append(f\".. [#] {body}\\n\")\n            else:\n                result.append(f\"[{citation}] {body}\\n\")\n        # Append a \\n after the notes\n        result.append(\"\\n\")\n        # Reset for the next paragraph\n        context[\"footnotes\"] = []\n\n    def _get_formatted_text_annotations(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Insert the annotations\n        # With a separation\n        if rst_mode:\n            result.append(\"\\n\")\n        else:\n            result.append(\"----\\n\")\n        for annotation in context[\"annotations\"]:\n            if rst_mode:\n                result.append(f\".. [#] {annotation}\\n\")\n            else:\n                result.append(f\"[*] {annotation}\\n\")\n        context[\"annotations\"] = []\n\n    def _get_formatted_text_images(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Insert the images ref, only in rst mode\n        result.append(\"\\n\")\n        for ref, filename, (width, height) in context[\"images\"]:\n            result.append(f\".. {ref} image:: {filename}\\n\")\n            if width is not None:\n                result.append(f\"   :width: {width}\\n\")\n            if height is not None:\n                result.append(f\"   :height: {height}\\n\")\n        context[\"images\"] = []\n\n    def _get_formatted_text_endnotes(\n        self,\n        result: list[str],\n        context: dict,\n        rst_mode: bool,\n    ) -&gt; None:\n        # Append the end notes\n        if rst_mode:\n            result.append(\"\\n\\n\")\n        else:\n            result.append(\"\\n========\\n\")\n        for citation, body in context[\"endnotes\"]:\n            if rst_mode:\n                result.append(f\".. [*] {body}\\n\")\n            else:\n                result.append(f\"({citation}) {body}\\n\")\n\n    def get_formatted_text(self, rst_mode: bool = False) -&gt; str:\n        \"\"\"Return content as text, with some formatting.\"\"\"\n        # For the moment, only \"type='text'\"\n        doc_type = self.get_type()\n        if doc_type == \"spreadsheet\":\n            return self._tables_csv()\n        if doc_type in {\n            \"text\",\n            \"text-template\",\n            \"presentation\",\n            \"presentation-template\",\n        }:\n            return self._formatted_text(rst_mode)\n        raise NotImplementedError(f\"Type of document '{doc_type}' not supported yet\")\n\n    def _tables_csv(self) -&gt; str:\n        return \"\\n\\n\".join(str(table) for table in self.body.tables)\n\n    def _formatted_text(self, rst_mode: bool) -&gt; str:\n        # Initialize an empty context\n        context = {\n            \"document\": self,\n            \"footnotes\": [],\n            \"endnotes\": [],\n            \"annotations\": [],\n            \"rst_mode\": rst_mode,\n            \"img_counter\": 0,\n            \"images\": [],\n            \"no_img_level\": 0,\n        }\n        body = self.body\n        # Get the text\n        result = []\n        for child in body.children:\n            # self._get_formatted_text_child(result, element, context, rst_mode)\n            # if child.tag == \"table:table\":\n            #     result.append(child.get_formatted_text(context))\n            #     return\n            result.append(child.get_formatted_text(context))\n            if context[\"footnotes\"]:\n                self._get_formatted_text_footnotes(result, context, rst_mode)\n            if context[\"annotations\"]:\n                self._get_formatted_text_annotations(result, context, rst_mode)\n            # Insert the images ref, only in rst mode\n            if context[\"images\"]:\n                self._get_formatted_text_images(result, context, rst_mode)\n        if context[\"endnotes\"]:\n            self._get_formatted_text_endnotes(result, context, rst_mode)\n        return \"\".join(result)\n\n    def get_formated_meta(self) -&gt; str:\n        \"\"\"Return meta informations as text, with some formatting.\n\n        (Redirection to new implementation for compatibility.)\"\"\"\n        return self.meta.as_text()\n\n    def to_markdown(self) -&gt; str:\n        doc_type = self.get_type()\n        if doc_type not in {\n            \"text\",\n        }:\n            raise NotImplementedError(\n                f\"Type of document '{doc_type}' not supported yet\"\n            )\n        return self._markdown_export()\n\n    def _add_binary_part(self, blob: Blob) -&gt; str:\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        manifest = self.manifest\n        if manifest.get_media_type(\"Pictures/\") is None:\n            manifest.add_full_path(\"Pictures/\")\n        path = posixpath.join(\"Pictures\", blob.name)\n        self.container.set_part(path, blob.content)\n        manifest.add_full_path(path, blob.mime_type)\n        return path\n\n    def add_file(self, path_or_file: str | Path | BinaryIO) -&gt; str:\n        \"\"\"Insert a file from a path or a file-like object in the container.\n\n        Return the full path to reference in the content. The internal name\n        of the file in the Picture/ folder is gnerated by a hash function.\n\n        Arguments:\n\n            path_or_file -- str or Path or file-like\n\n        Return: str (URI)\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        if isinstance(path_or_file, (str, Path)):\n            blob = Blob.from_path(path_or_file)\n        else:\n            blob = Blob.from_io(path_or_file)\n        return self._add_binary_part(blob)\n\n    @property\n    def clone(self) -&gt; Document:\n        \"\"\"Return an exact copy of the document.\n\n        Return: Document\n        \"\"\"\n        clone = object.__new__(self.__class__)\n        for name in self.__dict__:\n            if name == \"_Document__body\":\n                setattr(clone, name, None)\n            elif name == \"_Document__xmlparts\":\n                setattr(clone, name, {})\n            elif name == \"container\":\n                if not self.container:\n                    raise ValueError(\"Empty Container\")\n                setattr(clone, name, self.container.clone)\n            else:\n                value = deepcopy(getattr(self, name))\n                setattr(clone, name, value)\n        return clone\n\n    def _check_manifest_rdf(self) -&gt; None:\n        manifest = self.manifest\n        parts = self.container.parts\n        if manifest.get_media_type(ODF_MANIFEST_RDF):\n            if ODF_MANIFEST_RDF not in parts:\n                self.container.set_part(\n                    ODF_MANIFEST_RDF, self.container.default_manifest_rdf.encode(\"utf8\")\n                )\n        else:\n            if ODF_MANIFEST_RDF in parts:\n                self.container.del_part(ODF_MANIFEST_RDF)\n\n    def save(\n        self,\n        target: str | Path | io.BytesIO | None = None,\n        packaging: str = ZIP,\n        pretty: bool | None = None,\n        backup: bool = False,\n    ) -&gt; None:\n        \"\"\"Save the document, at the same place it was opened or at the given\n        target path. Target can also be a file-like object. It can be saved\n        as a Zip file (default), flat XML format or as files in a folder\n        (for debugging purpose). XML parts can be pretty printed (the default\n        for 'folder' and 'xml' packaging).\n\n        Note: 'xml' packaging is an experimental work in progress.\n\n        Arguments:\n\n            target -- str or file-like object\n\n            packaging -- 'zip', 'folder', 'xml'\n\n            pretty -- bool | None\n\n            backup -- bool\n        \"\"\"\n        if not self.container:\n            raise ValueError(\"Empty Container\")\n        if packaging not in PACKAGING:\n            raise ValueError(f'Packaging of type \"{packaging}\" is not supported')\n        # Some advertising\n        self.meta.set_generator_default()\n        # Synchronize data with container\n        container = self.container\n        if pretty is None:\n            pretty = packaging in {\"folder\", \"xml\"}\n        pretty = bool(pretty)\n        backup = bool(backup)\n        self._check_manifest_rdf()\n        if pretty and packaging != XML:\n            for path, part in self.__xmlparts.items():\n                if part is not None:\n                    container.set_part(path, part.pretty_serialize())\n            for path in (ODF_CONTENT, ODF_META, ODF_SETTINGS, ODF_STYLES):\n                if path in self.__xmlparts:\n                    continue\n                cls = _get_part_class(path)\n                # XML part\n                self.__xmlparts[path] = part = cls(path, container)\n                container.set_part(path, part.pretty_serialize())\n        else:\n            for path, part in self.__xmlparts.items():\n                if part is not None:\n                    container.set_part(path, part.serialize())\n        container.save(target, packaging=packaging, backup=backup, pretty=pretty)\n\n    @property\n    def content(self) -&gt; Content:\n        content: Content | None = self.get_part(ODF_CONTENT)  # type:ignore\n        if content is None:\n            raise ValueError(\"Empty Content\")\n        return content\n\n    @property\n    def styles(self) -&gt; Styles:\n        styles: Styles | None = self.get_part(ODF_STYLES)  # type:ignore\n        if styles is None:\n            raise ValueError(\"Empty Styles\")\n        return styles\n\n    # Styles over several parts\n\n    def get_styles(\n        self,\n        family: str | bytes = \"\",\n        automatic: bool = False,\n    ) -&gt; list[Style | Element]:\n        # compatibility with old versions:\n\n        if isinstance(family, bytes):\n            family = bytes_to_str(family)\n        return self.content.get_styles(family=family) + self.styles.get_styles(\n            family=family, automatic=automatic\n        )\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Style | None = None,\n        display_name: str | None = None,\n    ) -&gt; Style | None:\n        \"\"\"Return the style uniquely identified by the name/family pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is None, the default style is fetched.\n\n        If the name is not the internal name but the name you gave in a\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                      'number', 'page-layout', 'master-page', ...\n\n            name -- str or Element or None\n\n            display_name -- str\n\n        Return: Style or None if not found.\n        \"\"\"\n        # 1. content.xml\n        element = self.content.get_style(\n            family, name_or_element=name_or_element, display_name=display_name\n        )\n        if element is not None:\n            return element\n        # 2. styles.xml\n        return self.styles.get_style(\n            family,\n            name_or_element=name_or_element,\n            display_name=display_name,\n        )\n\n    def get_parent_style(self, style: Style) -&gt; Style | None:\n        family = style.family\n        parent_style_name = style.parent_style\n        if not parent_style_name:\n            return None\n        return self.get_style(family, parent_style_name)\n\n    def get_list_style(self, style: Style) -&gt; Style | None:\n        list_style_name = style.list_style_name\n        if not list_style_name:\n            return None\n        return self.get_style(\"list\", list_style_name)\n\n    @staticmethod\n    def _pseudo_style_attribute(style_element: Style | Element, attribute: str) -&gt; Any:\n        if hasattr(style_element, attribute):\n            return getattr(style_element, attribute)\n        return \"\"\n\n    def _set_automatic_name(self, style: Style, family: str) -&gt; None:\n        \"\"\"Generate a name for the new automatic style.\"\"\"\n        if not hasattr(style, \"name\"):\n            # do nothing\n            return\n        styles = self.get_styles(family=family, automatic=True)\n        max_index = 0\n        for existing_style in styles:\n            if not hasattr(existing_style, \"name\"):\n                continue\n            if not existing_style.name.startswith(AUTOMATIC_PREFIX):\n                continue\n            try:\n                index = int(existing_style.name[len(AUTOMATIC_PREFIX) :])  # type: ignore\n            except ValueError:\n                continue\n            max_index = max(max_index, index)\n\n        style.name = f\"{AUTOMATIC_PREFIX}{max_index + 1}\"\n\n    def _insert_style_get_common_styles(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:styles\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_automatic_styles(\n        self,\n        style: Style,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.content.get_element(\"office:automatic-styles\")\n        # A name ?\n        if name:\n            if hasattr(style, \"name\"):\n                style.name = name\n            existing = self.content.get_style(family, name)\n        else:\n            self._set_automatic_name(style, family)\n            existing = None\n        return existing, style_container\n\n    def _insert_style_get_default_styles(\n        self,\n        style: Style,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:styles\")\n        style.tag = \"style:default-style\"\n        if name:\n            style.del_attribute(\"style:name\")\n        existing = self.styles.get_style(family)\n        return existing, style_container\n\n    def _insert_style_get_master_page(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:master-styles\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_font_face_default(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.styles.get_element(\"office:font-face-decls\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_font_face(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        style_container = self.content.get_element(\"office:font-face-decls\")\n        existing = self.content.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_page_layout(\n        self,\n        family: str,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        # force to automatic\n        style_container = self.styles.get_element(\"office:automatic-styles\")\n        existing = self.styles.get_style(family, name)\n        return existing, style_container\n\n    def _insert_style_get_draw_fill_image(\n        self,\n        name: str,\n    ) -&gt; tuple[Any, Any]:\n        # special case for 'draw:fill-image' pseudo style\n        # not family and style_element.__class__.__name__ == \"DrawFillImage\"\n        style_container = self.styles.get_element(\"office:styles\")\n        existing = self.styles.get_style(\"\", name)\n        return existing, style_container\n\n    def _insert_style_standard(\n        self,\n        style: Style,\n        name: str,\n        family: str,\n        automatic: bool,\n        default: bool,\n    ) -&gt; tuple[Any, Any]:\n        # Common style\n        if name and automatic is False and default is False:\n            return self._insert_style_get_common_styles(family, name)\n        # Automatic style\n        elif automatic is True and default is False:\n            return self._insert_style_get_automatic_styles(style, family, name)\n        # Default style\n        elif automatic is False and default is True:\n            return self._insert_style_get_default_styles(style, family, name)\n        else:\n            raise AttributeError(\"Invalid combination of arguments\")\n\n    def insert_style(\n        self,\n        style: Style | str,\n        name: str = \"\",\n        automatic: bool = False,\n        default: bool = False,\n    ) -&gt; Any:\n        \"\"\"Insert the given style object in the document, as required by the\n        style family and type.\n\n        The style is expected to be a common style with a name. In case it\n        was created with no name, the given can be set on the fly.\n\n        If automatic is True, the style will be inserted as an automatic\n        style.\n\n        If default is True, the style will be inserted as a default style and\n        would replace any existing default style of the same family. Any name\n        or display name would be ignored.\n\n        Automatic and default arguments are mutually exclusive.\n\n        All styles can't be used as default styles. Default styles are\n        allowed for the following families: paragraph, text, section, table,\n        table-column, table-row, table-cell, table-page, chart, drawing-page,\n        graphic, presentation, control and ruby.\n\n        Arguments:\n\n            style -- Style or str\n\n            name -- str\n\n            automatic -- bool\n\n            default -- bool\n\n        Return : style name -- str\n        \"\"\"\n\n        # if style is a str, assume it is the Style definition\n        if isinstance(style, str):\n            style_element: Style = Element.from_tag(style)  # type: ignore\n        else:\n            style_element = style\n        if not isinstance(style_element, Element):\n            raise TypeError(f\"Unknown Style type: '{style!r}'\")\n\n        # Get family and name\n        family = style_element.family\n        if not name:\n            name = self._pseudo_style_attribute(style_element, \"name\")\n\n        # Master page style\n        if family == \"master-page\":\n            existing, style_container = self._insert_style_get_master_page(family, name)\n        # Font face declarations\n        elif family == \"font-face\":\n            if default:\n                existing, style_container = self._insert_style_get_font_face_default(\n                    family, name\n                )\n            else:\n                existing, style_container = self._insert_style_get_font_face(\n                    family, name\n                )\n        # page layout style\n        elif family == \"page-layout\":\n            existing, style_container = self._insert_style_get_page_layout(family, name)\n        # Common style\n        elif family in FAMILY_MAPPING:\n            existing, style_container = self._insert_style_standard(\n                style_element, name, family, automatic, default\n            )\n        elif not family and style_element.__class__.__name__ == \"DrawFillImage\":\n            # special case for 'draw:fill-image' pseudo style\n            existing, style_container = self._insert_style_get_draw_fill_image(name)\n        # Invalid style\n        else:\n            raise ValueError(\n                \"Invalid style: \"\n                f\"{style_element}, tag:{style_element.tag}, family:{family}\"\n            )\n\n        # Insert it!\n        if existing is not None:\n            style_container.delete(existing)\n        style_container.append(style_element)\n        return self._pseudo_style_attribute(style_element, \"name\")\n\n    def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n        \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n        name (or all by default).\n\n        Arguments:\n\n            name -- str\n\n        Return: list\n        \"\"\"\n        # Header, footer, etc. have styles too\n        return self.content.root.get_styled_elements(\n            name\n        ) + self.styles.root.get_styled_elements(name)\n\n    def show_styles(\n        self,\n        automatic: bool = True,\n        common: bool = True,\n        properties: bool = False,\n    ) -&gt; str:\n        infos = []\n        for style in self.get_styles():\n            try:\n                name = style.name  # type: ignore\n            except AttributeError:\n                print(\"--------------\")\n                print(style.__class__)\n                print(style.serialize())\n                raise\n            if style.__class__.__name__ == \"DrawFillImage\":\n                family = \"\"\n            else:\n                family = str(style.family)  # type: ignore\n            parent = style.parent\n            is_auto = parent and parent.tag == \"office:automatic-styles\"\n            if (is_auto and automatic is False) or (not is_auto and common is False):\n                continue\n            is_used = bool(self.get_styled_elements(name))\n            infos.append(\n                {\n                    \"type\": \"auto  \" if is_auto else \"common\",\n                    \"used\": \"y\" if is_used else \"n\",\n                    \"family\": family,\n                    \"parent\": self._pseudo_style_attribute(style, \"parent_style\") or \"\",\n                    \"name\": name or \"\",\n                    \"display_name\": self._pseudo_style_attribute(style, \"display_name\")\n                    or \"\",\n                    \"properties\": style.get_properties() if properties else None,  # type: ignore\n                }\n            )\n        if not infos:\n            return \"\"\n        # Sort by family and name\n        infos.sort(key=itemgetter(\"family\", \"name\"))\n        # Show common and used first\n        infos.sort(key=itemgetter(\"type\", \"used\"), reverse=True)\n        max_family = str(max(len(x[\"family\"]) for x in infos))  # type: ignore\n        max_parent = str(max(len(x[\"parent\"]) for x in infos))  # type: ignore\n        formater = (\n            \"%(type)s used:%(used)s family:%(family)-0\"\n            + max_family\n            + \"s parent:%(parent)-0\"\n            + max_parent\n            + \"s name:%(name)s\"\n        )\n        output = []\n        for info in infos:\n            line = formater % info\n            if info[\"display_name\"]:\n                line += \" display_name:\" + info[\"display_name\"]  # type: ignore\n            output.append(line)\n            if info[\"properties\"]:\n                for name, value in info[\"properties\"].items():  # type: ignore\n                    output.append(f\"   - {name}: {value}\")\n        output.append(\"\")\n        return \"\\n\".join(output)\n\n    def delete_styles(self) -&gt; int:\n        \"\"\"Remove all style information from content and all styles.\n\n        Return: number of deleted styles\n        \"\"\"\n        # First remove references to styles\n        for element in self.get_styled_elements():\n            for attribute in (\n                \"text:style-name\",\n                \"draw:style-name\",\n                \"draw:text-style-name\",\n                \"table:style-name\",\n                \"style:page-layout-name\",\n            ):\n                try:\n                    element.del_attribute(attribute)\n                except KeyError:\n                    continue\n        # Then remove supposedly orphaned styles\n        deleted = 0\n        for style in self.get_styles():\n            if style.name is None:  # type: ignore\n                # Don't delete default styles\n                continue\n            # elif type(style) is odf_master_page:\n            #    # Don't suppress header and footer, just styling was removed\n            #    continue\n            style.delete()\n            deleted += 1\n        return deleted\n\n    def merge_styles_from(self, document: Document) -&gt; None:\n        \"\"\"Copy all the styles of a document into ourself.\n\n        Styles with the same type and name will be replaced, so only unique\n        styles will be preserved.\n        \"\"\"\n        manifest = self.manifest\n        document_manifest = document.manifest\n        for style in document.get_styles():\n            tagname = style.tag\n            family = style.family\n            stylename = style.name  # type: ignore\n            container = style.parent\n            container_name = container.tag  # type: ignore\n            partname = container.parent.tag  # type: ignore\n            # The destination part\n            if partname == \"office:document-styles\":\n                part: Content | Styles = self.styles\n            elif partname == \"office:document-content\":\n                part = self.content\n            else:\n                raise NotImplementedError(partname)\n            # Implemented containers\n            if container_name not in {\n                \"office:styles\",\n                \"office:automatic-styles\",\n                \"office:master-styles\",\n                \"office:font-face-decls\",\n            }:\n                raise NotImplementedError(container_name)\n            dest = part.get_element(f\"//{container_name}\")\n            # Implemented style types\n            # if tagname not in registered_styles:\n            #    raise NotImplementedError(tagname)\n            duplicate = part.get_style(family, stylename)\n            if duplicate is not None:\n                duplicate.delete()\n            dest.append(style)\n            # Copy images from the header/footer\n            if tagname == \"style:master-page\":\n                query = \"descendant::draw:image\"\n                for image in style.get_elements(query):\n                    url = image.url  # type: ignore\n                    part_url = document.get_part(url)\n                    # Manually add the part to keep the name\n                    self.set_part(url, part_url)  # type: ignore\n                    media_type = document_manifest.get_media_type(url)\n                    manifest.add_full_path(url, media_type)  # type: ignore\n            # Copy images from the fill-image\n            elif tagname == \"draw:fill-image\":\n                url = style.url  # type: ignore\n                part_url = document.get_part(url)\n                self.set_part(url, part_url)  # type: ignore\n                media_type = document_manifest.get_media_type(url)\n                manifest.add_full_path(url, media_type)  # type: ignore\n\n    def add_page_break_style(self) -&gt; None:\n        \"\"\"Ensure that the document contains the style required for a manual page break.\n\n        Then a manual page break can be added to the document with:\n            from paragraph import PageBreak\n            ...\n            document.body.append(PageBreak())\n\n        Note: this style uses the property 'fo:break-after', another\n        possibility could be the property 'fo:break-before'\n        \"\"\"\n        if existing := self.get_style(  # noqa: SIM102\n            family=\"paragraph\",\n            name_or_element=\"odfdopagebreak\",\n        ):\n            if properties := existing.get_properties():  # noqa: SIM102\n                if properties[\"fo:break-after\"] == \"page\":\n                    return\n        style = (\n            '&lt;style:style style:family=\"paragraph\" style:parent-style-name=\"Standard\" '\n            'style:name=\"odfdopagebreak\"&gt;'\n            '&lt;style:paragraph-properties fo:break-after=\"page\"/&gt;&lt;/style:style&gt;'\n        )\n        self.insert_style(style, automatic=False)\n\n    def get_style_properties(\n        self, family: str, name: str, area: str | None = None\n    ) -&gt; dict[str, str] | None:\n        \"\"\"Return the properties of the required style as a dict.\"\"\"\n        style = self.get_style(family, name)\n        if style is None:\n            return None\n        return style.get_properties(area=area)  # type: ignore\n\n    def _get_table(self, table: int | str) -&gt; Table | None:\n        if not isinstance(table, (int, str)):\n            raise TypeError(f\"Table parameter must be int or str: {table!r}\")\n        if isinstance(table, int):\n            return self.body.get_table(position=table)  # type: ignore\n        return self.body.get_table(name=table)  # type: ignore\n\n    def get_cell_style_properties(\n        self, table: str | int, coord: tuple | list | str\n    ) -&gt; dict[str, str]:  # type: ignore\n        \"\"\"Return the style properties of a table cell of a .ods document,\n        from the cell style or from the row style.\"\"\"\n\n        if not (sheet := self._get_table(table)):\n            return {}\n        cell = sheet.get_cell(coord, clone=False)\n        if cell.style:\n            return (\n                self.get_style_properties(\"table-cell\", cell.style, \"table-cell\") or {}\n            )\n        try:\n            row = sheet.get_row(cell.y, clone=False, create=False)  # type: ignore\n            if row.style:  # noqa: SIM102\n                if props := self.get_style_properties(\n                    \"table-row\", row.style, \"table-cell\"\n                ):\n                    return props\n            column = sheet.get_column(cell.x)  # type: ignore\n            style = column.default_cell_style\n            if style:  # noqa: SIM102\n                if props := self.get_style_properties(\n                    \"table-cell\", style, \"table-cell\"\n                ):\n                    return props\n        except ValueError:\n            pass\n        return {}\n\n    def get_cell_background_color(\n        self,\n        table: str | int,\n        coord: tuple | list | str,\n        default: str = \"#ffffff\",\n    ) -&gt; str:\n        \"\"\"Return the background color of a table cell of a .ods document,\n        from the cell style, or from the row or column.\n\n        If color is not defined, return default value..\"\"\"\n        found = self.get_cell_style_properties(table, coord).get(\"fo:background-color\")\n        return found or default\n\n    def get_table_style(\n        self,\n        table: str | int,\n    ) -&gt; Style | None:  # type: ignore\n        \"\"\"Return the Style instance the table.\n\n        Arguments:\n\n            table -- name or index of the table\n        \"\"\"\n        if not (sheet := self._get_table(table)):\n            return None\n        return self.get_style(\"table\", sheet.style)\n\n    def get_table_displayed(self, table: str | int) -&gt; bool:\n        \"\"\"Return the table:display property of the style of the table, ie if\n        the table should be displayed in a graphical interface.\n\n        Note: that method replaces the broken Table.displayd() method from previous\n        odfdo versions.\n\n        Arguments:\n\n            table -- name or index of the table\n        \"\"\"\n        style = self.get_table_style(table)\n        if not style:\n            # should not happen, but assume that a table without style is\n            # displayed by default\n            return True\n        properties = style.get_properties() or {}\n        property_str = str(properties.get(\"table:display\", \"true\"))\n        return Boolean.decode(property_str)\n\n    def _unique_style_name(self, base: str) -&gt; str:\n        current = {style.name for style in self.get_styles()}\n        idx = 0\n        while True:\n            name = f\"{base}_{idx}\"\n            if name in current:\n                idx += 1\n                continue\n            return name\n\n    def set_table_displayed(self, table: str | int, displayed: bool) -&gt; None:\n        \"\"\"Set the table:display property of the style of the table, ie if\n        the table should be displayed in a graphical interface.\n\n        Note: that method replaces the broken Table.displayd() method from previous\n        odfdo versions.\n\n        Arguments:\n\n            table -- name or index of the table\n\n            displayed -- boolean flag\n        \"\"\"\n        orig_style = self.get_table_style(table)\n        if not orig_style:\n            name = self._unique_style_name(\"ta\")\n            orig_style = Element.from_tag(\n                f'&lt;style:style style:name=\"{name}\" style:family=\"table\" '\n                'style:master-page-name=\"Default\"&gt;'\n                '&lt;style:table-properties table:display=\"true\" '\n                'style:writing-mode=\"lr-tb\"/&gt;&lt;/style:style&gt;'\n            )\n            self.insert_style(orig_style, automatic=True)  # type:ignore\n        new_style = orig_style.clone\n        new_name = self._unique_style_name(\"ta\")\n        new_style.name = new_name  # type:ignore\n        self.insert_style(new_style, automatic=True)  # type:ignore\n        sheet = self._get_table(table)\n        sheet.style = new_name  # type: ignore\n        properties = {\"table:display\": Boolean.encode(displayed)}\n        new_style.set_properties(properties)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Document.body","title":"<code>body</code>  <code>property</code>","text":"<p>Return the body element of the content part, where actual content is stored.</p>"},{"location":"reference.html#odfdo.Document.clone","title":"<code>clone</code>  <code>property</code>","text":"<p>Return an exact copy of the document.</p> <p>Return: Document</p>"},{"location":"reference.html#odfdo.Document.manifest","title":"<code>manifest</code>  <code>property</code>","text":"<p>Return the manifest part (manifest.xml) of the document.</p>"},{"location":"reference.html#odfdo.Document.meta","title":"<code>meta</code>  <code>property</code>","text":"<p>Return the meta part (meta.xml) of the document, where meta data are stored.</p>"},{"location":"reference.html#odfdo.Document.parts","title":"<code>parts</code>  <code>property</code>","text":"<p>Return available part names with path inside the archive, e.g. [\u2018content.xml\u2019, \u2026, \u2018Pictures/100000000000032000000258912EB1C3.jpg\u2019]</p>"},{"location":"reference.html#odfdo.Document.path","title":"<code>path</code>  <code>property</code> <code>writable</code>","text":"<p>Shortcut to Document.Container.path.</p>"},{"location":"reference.html#odfdo.Document.add_file","title":"<code>add_file(path_or_file)</code>","text":"<p>Insert a file from a path or a file-like object in the container.</p> <p>Return the full path to reference in the content. The internal name of the file in the Picture/ folder is gnerated by a hash function.</p> <p>Arguments:</p> <pre><code>path_or_file -- str or Path or file-like\n</code></pre> <p>Return: str (URI)</p> Source code in <code>odfdo/document.py</code> <pre><code>def add_file(self, path_or_file: str | Path | BinaryIO) -&gt; str:\n    \"\"\"Insert a file from a path or a file-like object in the container.\n\n    Return the full path to reference in the content. The internal name\n    of the file in the Picture/ folder is gnerated by a hash function.\n\n    Arguments:\n\n        path_or_file -- str or Path or file-like\n\n    Return: str (URI)\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    if isinstance(path_or_file, (str, Path)):\n        blob = Blob.from_path(path_or_file)\n    else:\n        blob = Blob.from_io(path_or_file)\n    return self._add_binary_part(blob)\n</code></pre>"},{"location":"reference.html#odfdo.Document.add_page_break_style","title":"<code>add_page_break_style()</code>","text":"<p>Ensure that the document contains the style required for a manual page break.</p> Then a manual page break can be added to the document with <p>from paragraph import PageBreak \u2026 document.body.append(PageBreak())</p> <p>Note: this style uses the property \u2018fo:break-after\u2019, another possibility could be the property \u2018fo:break-before\u2019</p> Source code in <code>odfdo/document.py</code> <pre><code>def add_page_break_style(self) -&gt; None:\n    \"\"\"Ensure that the document contains the style required for a manual page break.\n\n    Then a manual page break can be added to the document with:\n        from paragraph import PageBreak\n        ...\n        document.body.append(PageBreak())\n\n    Note: this style uses the property 'fo:break-after', another\n    possibility could be the property 'fo:break-before'\n    \"\"\"\n    if existing := self.get_style(  # noqa: SIM102\n        family=\"paragraph\",\n        name_or_element=\"odfdopagebreak\",\n    ):\n        if properties := existing.get_properties():  # noqa: SIM102\n            if properties[\"fo:break-after\"] == \"page\":\n                return\n    style = (\n        '&lt;style:style style:family=\"paragraph\" style:parent-style-name=\"Standard\" '\n        'style:name=\"odfdopagebreak\"&gt;'\n        '&lt;style:paragraph-properties fo:break-after=\"page\"/&gt;&lt;/style:style&gt;'\n    )\n    self.insert_style(style, automatic=False)\n</code></pre>"},{"location":"reference.html#odfdo.Document.del_part","title":"<code>del_part(path)</code>","text":"<p>Mark a part for deletion. The path is relative to the archive, e.g. \u201cPictures/1003200258912EB1C3.jpg\u201d</p> Source code in <code>odfdo/document.py</code> <pre><code>def del_part(self, path: str) -&gt; None:\n    \"\"\"Mark a part for deletion. The path is relative to the archive,\n    e.g. \"Pictures/1003200258912EB1C3.jpg\"\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    path = _get_part_path(path)\n    cls = _get_part_class(path)\n    if path == ODF_MANIFEST or cls is not None:\n        raise ValueError(f\"part '{path}' is mandatory\")\n    self.container.del_part(path)\n</code></pre>"},{"location":"reference.html#odfdo.Document.delete_styles","title":"<code>delete_styles()</code>","text":"<p>Remove all style information from content and all styles.</p> <p>Return: number of deleted styles</p> Source code in <code>odfdo/document.py</code> <pre><code>def delete_styles(self) -&gt; int:\n    \"\"\"Remove all style information from content and all styles.\n\n    Return: number of deleted styles\n    \"\"\"\n    # First remove references to styles\n    for element in self.get_styled_elements():\n        for attribute in (\n            \"text:style-name\",\n            \"draw:style-name\",\n            \"draw:text-style-name\",\n            \"table:style-name\",\n            \"style:page-layout-name\",\n        ):\n            try:\n                element.del_attribute(attribute)\n            except KeyError:\n                continue\n    # Then remove supposedly orphaned styles\n    deleted = 0\n    for style in self.get_styles():\n        if style.name is None:  # type: ignore\n            # Don't delete default styles\n            continue\n        # elif type(style) is odf_master_page:\n        #    # Don't suppress header and footer, just styling was removed\n        #    continue\n        style.delete()\n        deleted += 1\n    return deleted\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_cell_background_color","title":"<code>get_cell_background_color(table, coord, default='#ffffff')</code>","text":"<p>Return the background color of a table cell of a .ods document, from the cell style, or from the row or column.</p> <p>If color is not defined, return default value..</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_cell_background_color(\n    self,\n    table: str | int,\n    coord: tuple | list | str,\n    default: str = \"#ffffff\",\n) -&gt; str:\n    \"\"\"Return the background color of a table cell of a .ods document,\n    from the cell style, or from the row or column.\n\n    If color is not defined, return default value..\"\"\"\n    found = self.get_cell_style_properties(table, coord).get(\"fo:background-color\")\n    return found or default\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_cell_style_properties","title":"<code>get_cell_style_properties(table, coord)</code>","text":"<p>Return the style properties of a table cell of a .ods document, from the cell style or from the row style.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_cell_style_properties(\n    self, table: str | int, coord: tuple | list | str\n) -&gt; dict[str, str]:  # type: ignore\n    \"\"\"Return the style properties of a table cell of a .ods document,\n    from the cell style or from the row style.\"\"\"\n\n    if not (sheet := self._get_table(table)):\n        return {}\n    cell = sheet.get_cell(coord, clone=False)\n    if cell.style:\n        return (\n            self.get_style_properties(\"table-cell\", cell.style, \"table-cell\") or {}\n        )\n    try:\n        row = sheet.get_row(cell.y, clone=False, create=False)  # type: ignore\n        if row.style:  # noqa: SIM102\n            if props := self.get_style_properties(\n                \"table-row\", row.style, \"table-cell\"\n            ):\n                return props\n        column = sheet.get_column(cell.x)  # type: ignore\n        style = column.default_cell_style\n        if style:  # noqa: SIM102\n            if props := self.get_style_properties(\n                \"table-cell\", style, \"table-cell\"\n            ):\n                return props\n    except ValueError:\n        pass\n    return {}\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_formated_meta","title":"<code>get_formated_meta()</code>","text":"<p>Return meta informations as text, with some formatting.</p> <p>(Redirection to new implementation for compatibility.)</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_formated_meta(self) -&gt; str:\n    \"\"\"Return meta informations as text, with some formatting.\n\n    (Redirection to new implementation for compatibility.)\"\"\"\n    return self.meta.as_text()\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_formatted_text","title":"<code>get_formatted_text(rst_mode=False)</code>","text":"<p>Return content as text, with some formatting.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_formatted_text(self, rst_mode: bool = False) -&gt; str:\n    \"\"\"Return content as text, with some formatting.\"\"\"\n    # For the moment, only \"type='text'\"\n    doc_type = self.get_type()\n    if doc_type == \"spreadsheet\":\n        return self._tables_csv()\n    if doc_type in {\n        \"text\",\n        \"text-template\",\n        \"presentation\",\n        \"presentation-template\",\n    }:\n        return self._formatted_text(rst_mode)\n    raise NotImplementedError(f\"Type of document '{doc_type}' not supported yet\")\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_part","title":"<code>get_part(path)</code>","text":"<p>Return the bytes of the given part. The path is relative to the archive, e.g. \u201cPictures/1003200258912EB1C3.jpg\u201d.</p> <p>\u2018content\u2019, \u2018meta\u2019, \u2018settings\u2019, \u2018styles\u2019 and \u2018manifest\u2019 are shortcuts to the real path, e.g. content.xml, and return a dedicated object with its own API.</p> <p>path formated as URI, so always use \u2018/\u2019 separator</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_part(self, path: str) -&gt; XmlPart | str | bytes | None:\n    \"\"\"Return the bytes of the given part. The path is relative to the\n    archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n    'content', 'meta', 'settings', 'styles' and 'manifest' are shortcuts\n    to the real path, e.g. content.xml, and return a dedicated object with\n    its own API.\n\n    path formated as URI, so always use '/' separator\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    # \"./ObjectReplacements/Object 1\"\n    path = path.lstrip(\"./\")\n    path = _get_part_path(path)\n    cls = _get_part_class(path)\n    # Raw bytes\n    if cls is None:\n        return self.container.get_part(path)\n    # XML part\n    part = self.__xmlparts.get(path)\n    if part is None:\n        self.__xmlparts[path] = part = cls(path, self.container)\n    return part\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_parts","title":"<code>get_parts()</code>","text":"<p>Return available part names with path inside the archive, e.g. [\u2018content.xml\u2019, \u2026, \u2018Pictures/100000000000032000000258912EB1C3.jpg\u2019]</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_parts(self) -&gt; list[str]:\n    \"\"\"Return available part names with path inside the archive, e.g.\n    ['content.xml', ..., 'Pictures/100000000000032000000258912EB1C3.jpg']\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    return self.container.parts\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the name/family pair. If the argument is already a style object, it will return it.</p> <p>If the name is None, the default style is fetched.</p> <p>If the name is not the internal name but the name you gave in a desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n          'number', 'page-layout', 'master-page', ...\n\nname -- str or Element or None\n\ndisplay_name -- str\n</code></pre> <p>Return: Style or None if not found.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Style | None = None,\n    display_name: str | None = None,\n) -&gt; Style | None:\n    \"\"\"Return the style uniquely identified by the name/family pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is None, the default style is fetched.\n\n    If the name is not the internal name but the name you gave in a\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                  'number', 'page-layout', 'master-page', ...\n\n        name -- str or Element or None\n\n        display_name -- str\n\n    Return: Style or None if not found.\n    \"\"\"\n    # 1. content.xml\n    element = self.content.get_style(\n        family, name_or_element=name_or_element, display_name=display_name\n    )\n    if element is not None:\n        return element\n    # 2. styles.xml\n    return self.styles.get_style(\n        family,\n        name_or_element=name_or_element,\n        display_name=display_name,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_style_properties","title":"<code>get_style_properties(family, name, area=None)</code>","text":"<p>Return the properties of the required style as a dict.</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_style_properties(\n    self, family: str, name: str, area: str | None = None\n) -&gt; dict[str, str] | None:\n    \"\"\"Return the properties of the required style as a dict.\"\"\"\n    style = self.get_style(family, name)\n    if style is None:\n        return None\n    return style.get_properties(area=area)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_styled_elements","title":"<code>get_styled_elements(name='')</code>","text":"<p>Brute-force to find paragraphs, tables, etc. using the given style name (or all by default).</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: list</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n    \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n    name (or all by default).\n\n    Arguments:\n\n        name -- str\n\n    Return: list\n    \"\"\"\n    # Header, footer, etc. have styles too\n    return self.content.root.get_styled_elements(\n        name\n    ) + self.styles.root.get_styled_elements(name)\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_table_displayed","title":"<code>get_table_displayed(table)</code>","text":"<p>Return the table:display property of the style of the table, ie if the table should be displayed in a graphical interface.</p> <p>Note: that method replaces the broken Table.displayd() method from previous odfdo versions.</p> <p>Arguments:</p> <pre><code>table -- name or index of the table\n</code></pre> Source code in <code>odfdo/document.py</code> <pre><code>def get_table_displayed(self, table: str | int) -&gt; bool:\n    \"\"\"Return the table:display property of the style of the table, ie if\n    the table should be displayed in a graphical interface.\n\n    Note: that method replaces the broken Table.displayd() method from previous\n    odfdo versions.\n\n    Arguments:\n\n        table -- name or index of the table\n    \"\"\"\n    style = self.get_table_style(table)\n    if not style:\n        # should not happen, but assume that a table without style is\n        # displayed by default\n        return True\n    properties = style.get_properties() or {}\n    property_str = str(properties.get(\"table:display\", \"true\"))\n    return Boolean.decode(property_str)\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_table_style","title":"<code>get_table_style(table)</code>","text":"<p>Return the Style instance the table.</p> <p>Arguments:</p> <pre><code>table -- name or index of the table\n</code></pre> Source code in <code>odfdo/document.py</code> <pre><code>def get_table_style(\n    self,\n    table: str | int,\n) -&gt; Style | None:  # type: ignore\n    \"\"\"Return the Style instance the table.\n\n    Arguments:\n\n        table -- name or index of the table\n    \"\"\"\n    if not (sheet := self._get_table(table)):\n        return None\n    return self.get_style(\"table\", sheet.style)\n</code></pre>"},{"location":"reference.html#odfdo.Document.get_type","title":"<code>get_type()</code>","text":"<p>Get the ODF type (also called class) of this document.</p> \u2018chart\u2019, \u2018database\u2019, \u2018formula\u2019, \u2018graphics\u2019, <p>\u2018graphics-template\u2019, \u2018image\u2019, \u2018presentation\u2019, \u2018presentation-template\u2019, \u2018spreadsheet\u2019, \u2018spreadsheet-template\u2019, \u2018text\u2019, \u2018text-master\u2019, \u2018text-template\u2019 or \u2018text-web\u2019</p> Source code in <code>odfdo/document.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"Get the ODF type (also called class) of this document.\n\n    Return: 'chart', 'database', 'formula', 'graphics',\n        'graphics-template', 'image', 'presentation',\n        'presentation-template', 'spreadsheet', 'spreadsheet-template',\n        'text', 'text-master', 'text-template' or 'text-web'\n    \"\"\"\n    # The mimetype must be with the form:\n    # application/vnd.oasis.opendocument.text\n\n    # Isolate and return the last part\n    return self.mimetype.rsplit(\".\", 1)[-1]\n</code></pre>"},{"location":"reference.html#odfdo.Document.insert_style","title":"<code>insert_style(style, name='', automatic=False, default=False)</code>","text":"<p>Insert the given style object in the document, as required by the style family and type.</p> <p>The style is expected to be a common style with a name. In case it was created with no name, the given can be set on the fly.</p> <p>If automatic is True, the style will be inserted as an automatic style.</p> <p>If default is True, the style will be inserted as a default style and would replace any existing default style of the same family. Any name or display name would be ignored.</p> <p>Automatic and default arguments are mutually exclusive.</p> <p>All styles can\u2019t be used as default styles. Default styles are allowed for the following families: paragraph, text, section, table, table-column, table-row, table-cell, table-page, chart, drawing-page, graphic, presentation, control and ruby.</p> <p>Arguments:</p> <pre><code>style -- Style or str\n\nname -- str\n\nautomatic -- bool\n\ndefault -- bool\n</code></pre> <p>Return : style name \u2013 str</p> Source code in <code>odfdo/document.py</code> <pre><code>def insert_style(\n    self,\n    style: Style | str,\n    name: str = \"\",\n    automatic: bool = False,\n    default: bool = False,\n) -&gt; Any:\n    \"\"\"Insert the given style object in the document, as required by the\n    style family and type.\n\n    The style is expected to be a common style with a name. In case it\n    was created with no name, the given can be set on the fly.\n\n    If automatic is True, the style will be inserted as an automatic\n    style.\n\n    If default is True, the style will be inserted as a default style and\n    would replace any existing default style of the same family. Any name\n    or display name would be ignored.\n\n    Automatic and default arguments are mutually exclusive.\n\n    All styles can't be used as default styles. Default styles are\n    allowed for the following families: paragraph, text, section, table,\n    table-column, table-row, table-cell, table-page, chart, drawing-page,\n    graphic, presentation, control and ruby.\n\n    Arguments:\n\n        style -- Style or str\n\n        name -- str\n\n        automatic -- bool\n\n        default -- bool\n\n    Return : style name -- str\n    \"\"\"\n\n    # if style is a str, assume it is the Style definition\n    if isinstance(style, str):\n        style_element: Style = Element.from_tag(style)  # type: ignore\n    else:\n        style_element = style\n    if not isinstance(style_element, Element):\n        raise TypeError(f\"Unknown Style type: '{style!r}'\")\n\n    # Get family and name\n    family = style_element.family\n    if not name:\n        name = self._pseudo_style_attribute(style_element, \"name\")\n\n    # Master page style\n    if family == \"master-page\":\n        existing, style_container = self._insert_style_get_master_page(family, name)\n    # Font face declarations\n    elif family == \"font-face\":\n        if default:\n            existing, style_container = self._insert_style_get_font_face_default(\n                family, name\n            )\n        else:\n            existing, style_container = self._insert_style_get_font_face(\n                family, name\n            )\n    # page layout style\n    elif family == \"page-layout\":\n        existing, style_container = self._insert_style_get_page_layout(family, name)\n    # Common style\n    elif family in FAMILY_MAPPING:\n        existing, style_container = self._insert_style_standard(\n            style_element, name, family, automatic, default\n        )\n    elif not family and style_element.__class__.__name__ == \"DrawFillImage\":\n        # special case for 'draw:fill-image' pseudo style\n        existing, style_container = self._insert_style_get_draw_fill_image(name)\n    # Invalid style\n    else:\n        raise ValueError(\n            \"Invalid style: \"\n            f\"{style_element}, tag:{style_element.tag}, family:{family}\"\n        )\n\n    # Insert it!\n    if existing is not None:\n        style_container.delete(existing)\n    style_container.append(style_element)\n    return self._pseudo_style_attribute(style_element, \"name\")\n</code></pre>"},{"location":"reference.html#odfdo.Document.merge_styles_from","title":"<code>merge_styles_from(document)</code>","text":"<p>Copy all the styles of a document into ourself.</p> <p>Styles with the same type and name will be replaced, so only unique styles will be preserved.</p> Source code in <code>odfdo/document.py</code> <pre><code>def merge_styles_from(self, document: Document) -&gt; None:\n    \"\"\"Copy all the styles of a document into ourself.\n\n    Styles with the same type and name will be replaced, so only unique\n    styles will be preserved.\n    \"\"\"\n    manifest = self.manifest\n    document_manifest = document.manifest\n    for style in document.get_styles():\n        tagname = style.tag\n        family = style.family\n        stylename = style.name  # type: ignore\n        container = style.parent\n        container_name = container.tag  # type: ignore\n        partname = container.parent.tag  # type: ignore\n        # The destination part\n        if partname == \"office:document-styles\":\n            part: Content | Styles = self.styles\n        elif partname == \"office:document-content\":\n            part = self.content\n        else:\n            raise NotImplementedError(partname)\n        # Implemented containers\n        if container_name not in {\n            \"office:styles\",\n            \"office:automatic-styles\",\n            \"office:master-styles\",\n            \"office:font-face-decls\",\n        }:\n            raise NotImplementedError(container_name)\n        dest = part.get_element(f\"//{container_name}\")\n        # Implemented style types\n        # if tagname not in registered_styles:\n        #    raise NotImplementedError(tagname)\n        duplicate = part.get_style(family, stylename)\n        if duplicate is not None:\n            duplicate.delete()\n        dest.append(style)\n        # Copy images from the header/footer\n        if tagname == \"style:master-page\":\n            query = \"descendant::draw:image\"\n            for image in style.get_elements(query):\n                url = image.url  # type: ignore\n                part_url = document.get_part(url)\n                # Manually add the part to keep the name\n                self.set_part(url, part_url)  # type: ignore\n                media_type = document_manifest.get_media_type(url)\n                manifest.add_full_path(url, media_type)  # type: ignore\n        # Copy images from the fill-image\n        elif tagname == \"draw:fill-image\":\n            url = style.url  # type: ignore\n            part_url = document.get_part(url)\n            self.set_part(url, part_url)  # type: ignore\n            media_type = document_manifest.get_media_type(url)\n            manifest.add_full_path(url, media_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Document.new","title":"<code>new(template='text')</code>  <code>classmethod</code>","text":"<p>Create a Document from a template.</p> <p>The template argument is expected to be the path to a ODF template.</p> <p>Arguments:</p> <pre><code>template -- str or Path or file-like (io.BytesIO)\n</code></pre> <p>Return : ODF document \u2013 Document</p> Source code in <code>odfdo/document.py</code> <pre><code>@classmethod\ndef new(cls, template: str | Path | io.BytesIO = \"text\") -&gt; Document:\n    \"\"\"Create a Document from a template.\n\n    The template argument is expected to be the path to a ODF template.\n\n    Arguments:\n\n        template -- str or Path or file-like (io.BytesIO)\n\n    Return : ODF document -- Document\n    \"\"\"\n    container = container_from_template(template)\n    return cls(container)\n</code></pre>"},{"location":"reference.html#odfdo.Document.save","title":"<code>save(target=None, packaging=ZIP, pretty=None, backup=False)</code>","text":"<p>Save the document, at the same place it was opened or at the given target path. Target can also be a file-like object. It can be saved as a Zip file (default), flat XML format or as files in a folder (for debugging purpose). XML parts can be pretty printed (the default for \u2018folder\u2019 and \u2018xml\u2019 packaging).</p> <p>Note: \u2018xml\u2019 packaging is an experimental work in progress.</p> <p>Arguments:</p> <pre><code>target -- str or file-like object\n\npackaging -- 'zip', 'folder', 'xml'\n\npretty -- bool | None\n\nbackup -- bool\n</code></pre> Source code in <code>odfdo/document.py</code> <pre><code>def save(\n    self,\n    target: str | Path | io.BytesIO | None = None,\n    packaging: str = ZIP,\n    pretty: bool | None = None,\n    backup: bool = False,\n) -&gt; None:\n    \"\"\"Save the document, at the same place it was opened or at the given\n    target path. Target can also be a file-like object. It can be saved\n    as a Zip file (default), flat XML format or as files in a folder\n    (for debugging purpose). XML parts can be pretty printed (the default\n    for 'folder' and 'xml' packaging).\n\n    Note: 'xml' packaging is an experimental work in progress.\n\n    Arguments:\n\n        target -- str or file-like object\n\n        packaging -- 'zip', 'folder', 'xml'\n\n        pretty -- bool | None\n\n        backup -- bool\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    if packaging not in PACKAGING:\n        raise ValueError(f'Packaging of type \"{packaging}\" is not supported')\n    # Some advertising\n    self.meta.set_generator_default()\n    # Synchronize data with container\n    container = self.container\n    if pretty is None:\n        pretty = packaging in {\"folder\", \"xml\"}\n    pretty = bool(pretty)\n    backup = bool(backup)\n    self._check_manifest_rdf()\n    if pretty and packaging != XML:\n        for path, part in self.__xmlparts.items():\n            if part is not None:\n                container.set_part(path, part.pretty_serialize())\n        for path in (ODF_CONTENT, ODF_META, ODF_SETTINGS, ODF_STYLES):\n            if path in self.__xmlparts:\n                continue\n            cls = _get_part_class(path)\n            # XML part\n            self.__xmlparts[path] = part = cls(path, container)\n            container.set_part(path, part.pretty_serialize())\n    else:\n        for path, part in self.__xmlparts.items():\n            if part is not None:\n                container.set_part(path, part.serialize())\n    container.save(target, packaging=packaging, backup=backup, pretty=pretty)\n</code></pre>"},{"location":"reference.html#odfdo.Document.set_part","title":"<code>set_part(path, data)</code>","text":"<p>Set the bytes of the given part. The path is relative to the archive, e.g. \u201cPictures/1003200258912EB1C3.jpg\u201d.</p> <p>path formated as URI, so always use \u2018/\u2019 separator</p> Source code in <code>odfdo/document.py</code> <pre><code>def set_part(self, path: str, data: bytes) -&gt; None:\n    \"\"\"Set the bytes of the given part. The path is relative to the\n    archive, e.g. \"Pictures/1003200258912EB1C3.jpg\".\n\n    path formated as URI, so always use '/' separator\n    \"\"\"\n    if not self.container:\n        raise ValueError(\"Empty Container\")\n    # \"./ObjectReplacements/Object 1\"\n    path = path.lstrip(\"./\")\n    path = _get_part_path(path)\n    cls = _get_part_class(path)\n    # XML part overwritten\n    if cls is not None:\n        with suppress(KeyError):\n            self.__xmlparts[path]\n    self.container.set_part(path, data)\n</code></pre>"},{"location":"reference.html#odfdo.Document.set_table_displayed","title":"<code>set_table_displayed(table, displayed)</code>","text":"<p>Set the table:display property of the style of the table, ie if the table should be displayed in a graphical interface.</p> <p>Note: that method replaces the broken Table.displayd() method from previous odfdo versions.</p> <p>Arguments:</p> <pre><code>table -- name or index of the table\n\ndisplayed -- boolean flag\n</code></pre> Source code in <code>odfdo/document.py</code> <pre><code>def set_table_displayed(self, table: str | int, displayed: bool) -&gt; None:\n    \"\"\"Set the table:display property of the style of the table, ie if\n    the table should be displayed in a graphical interface.\n\n    Note: that method replaces the broken Table.displayd() method from previous\n    odfdo versions.\n\n    Arguments:\n\n        table -- name or index of the table\n\n        displayed -- boolean flag\n    \"\"\"\n    orig_style = self.get_table_style(table)\n    if not orig_style:\n        name = self._unique_style_name(\"ta\")\n        orig_style = Element.from_tag(\n            f'&lt;style:style style:name=\"{name}\" style:family=\"table\" '\n            'style:master-page-name=\"Default\"&gt;'\n            '&lt;style:table-properties table:display=\"true\" '\n            'style:writing-mode=\"lr-tb\"/&gt;&lt;/style:style&gt;'\n        )\n        self.insert_style(orig_style, automatic=True)  # type:ignore\n    new_style = orig_style.clone\n    new_name = self._unique_style_name(\"ta\")\n    new_style.name = new_name  # type:ignore\n    self.insert_style(new_style, automatic=True)  # type:ignore\n    sheet = self._get_table(table)\n    sheet.style = new_name  # type: ignore\n    properties = {\"table:display\": Boolean.encode(displayed)}\n    new_style.set_properties(properties)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.DrawFillImage","title":"<code>DrawFillImage</code>","text":"<p>               Bases: <code>DrawImage</code></p> Source code in <code>odfdo/image.py</code> <pre><code>class DrawFillImage(DrawImage):\n    _tag = \"draw:fill-image\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"display_name\", \"draw:display-name\"),\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"height\", \"svg:height\"),\n        PropDef(\"width\", \"svg:width\"),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        display_name: str | None = None,\n        height: str | None = None,\n        width: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"The \"draw:fill-image\" element specifies a link to a bitmap\n        resource. Fill image are not available as automatic styles.\n        The \"draw:fill-image\" element is usable within the following element:\n        \"office:styles\"\n\n        Arguments:\n\n            name -- str\n\n            display_name -- str\n\n            height -- str\n\n            width -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n            self.display_name = display_name\n            self.height = height\n            self.width = width\n        self.family = \"\"\n</code></pre>"},{"location":"reference.html#odfdo.DrawFillImage.__init__","title":"<code>__init__(name=None, display_name=None, height=None, width=None, **kwargs)</code>","text":"<p>The \u201cdraw:fill-image\u201d element specifies a link to a bitmap resource. Fill image are not available as automatic styles. The \u201cdraw:fill-image\u201d element is usable within the following element: \u201coffice:styles\u201d</p> <p>Arguments:</p> <pre><code>name -- str\n\ndisplay_name -- str\n\nheight -- str\n\nwidth -- str\n</code></pre> Source code in <code>odfdo/image.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    display_name: str | None = None,\n    height: str | None = None,\n    width: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"The \"draw:fill-image\" element specifies a link to a bitmap\n    resource. Fill image are not available as automatic styles.\n    The \"draw:fill-image\" element is usable within the following element:\n    \"office:styles\"\n\n    Arguments:\n\n        name -- str\n\n        display_name -- str\n\n        height -- str\n\n        width -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n        self.display_name = display_name\n        self.height = height\n        self.width = width\n    self.family = \"\"\n</code></pre>"},{"location":"reference.html#odfdo.DrawGroup","title":"<code>DrawGroup</code>","text":"<p>               Bases: <code>Element</code>, <code>AnchorMix</code>, <code>ZMix</code>, <code>PosMix</code></p> <p>The DrawGroup \u201cdraw:g\u201d element represents a group of drawing shapes.</p> <p>Warning: implementation is currently minimal.</p> <p>Drawing shapes contained by a \u201cdraw:g\u201d element that is itself contained by a \u201cdraw:a\u201d element, act as hyperlinks using the xlink:href attribute of the containing \u201cdraw:a\u201d element. If the included drawing shapes are themselves contained within \u201cdraw:a\u201d elements, then the xlink:href attributes of those \u201cdraw:a\u201d elements act as the hyperlink information for the shapes they contain.</p> <p>The \u201cdraw:g\u201d element has the following attributes: draw:caption-id, draw:class-names, draw:id, draw:name, draw:style-name, draw:z-index, presentation:class-names, presentation:style-name, svg:y, table:end-cell-address, table:end-x, table:end-y, table:table-background, text:anchor-page-number, text:anchor-type, and xml:id.</p> <p>The \u201cdraw:g\u201d element has the following child elements: \u201cdr3d:scene\u201d, \u201cdraw:a\u201d, \u201cdraw:caption\u201d, \u201cdraw:circle\u201d, \u201cdraw:connector\u201d, \u201cdraw:control\u201d, \u201cdraw:custom-shape\u201d, \u201cdraw:ellipse\u201d, \u201cdraw:frame\u201d, \u201cdraw:g\u201d, \u201cdraw:glue-point\u201d, \u201cdraw:line\u201d, \u201cdraw:measure\u201d, \u201cdraw:page-thumbnail\u201d, \u201cdraw:path\u201d, \u201cdraw:polygon\u201d, \u201cdraw:polyline\u201d, \u201cdraw:rect\u201d, \u201cdraw:regular-polygon\u201d, \u201coffice:event-listeners\u201d, \u201csvg:desc\u201d and \u201csvg:title\u201d.</p> Source code in <code>odfdo/shapes.py</code> <pre><code>class DrawGroup(Element, AnchorMix, ZMix, PosMix):\n    \"\"\"The DrawGroup \"draw:g\" element represents a group of drawing shapes.\n\n    Warning: implementation is currently minimal.\n\n    Drawing shapes contained by a \"draw:g\" element that is itself\n    contained by a \"draw:a\" element, act as hyperlinks using the\n    xlink:href attribute of the containing \"draw:a\" element. If the\n    included drawing shapes are themselves contained within \"draw:a\"\n    elements, then the xlink:href attributes of those \"draw:a\" elements\n    act as the hyperlink information for the shapes they contain.\n\n    The \"draw:g\" element has the following attributes: draw:caption-id,\n    draw:class-names, draw:id, draw:name, draw:style-name, draw:z-index,\n    presentation:class-names, presentation:style-name, svg:y,\n    table:end-cell-address, table:end-x, table:end-y,\n    table:table-background, text:anchor-page-number, text:anchor-type,\n    and xml:id.\n\n    The \"draw:g\" element has the following child elements: \"dr3d:scene\",\n    \"draw:a\", \"draw:caption\", \"draw:circle\", \"draw:connector\",\n    \"draw:control\", \"draw:custom-shape\", \"draw:ellipse\", \"draw:frame\",\n    \"draw:g\", \"draw:glue-point\", \"draw:line\", \"draw:measure\",\n    \"draw:page-thumbnail\", \"draw:path\", \"draw:polygon\", \"draw:polyline\",\n    \"draw:rect\", \"draw:regular-polygon\", \"office:event-listeners\",\n    \"svg:desc\" and \"svg:title\".\n    \"\"\"\n\n    _tag = \"draw:g\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"draw_id\", \"draw:id\"),\n        PropDef(\"caption_id\", \"draw:caption-id\"),\n        PropDef(\"draw_class_names\", \"draw:class-names\"),\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"style\", \"draw:style-name\"),\n        # ('z_index', 'draw:z-index'),\n        PropDef(\"presentation_class_names\", \"presentation:class-names\"),\n        PropDef(\"presentation_style\", \"presentation:style-name\"),\n        PropDef(\"table_end_cell\", \"table:end-cell-address\"),\n        PropDef(\"table_end_x\", \"table:end-x\"),\n        PropDef(\"table_end_y\", \"table:end-y\"),\n        PropDef(\"table_background\", \"table:table-background\"),\n        # ('anchor_page', 'text:anchor-page-number'),\n        # ('anchor_type', 'text:anchor-type'),\n        PropDef(\"xml_id\", \"xml:id\"),\n        PropDef(\"pos_x\", \"svg:x\"),\n        PropDef(\"pos_y\", \"svg:y\"),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        z_index: int = 0,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if z_index is not None:\n                self.z_index = z_index\n            if name:\n                self.name = name\n            if draw_id is not None:\n                self.draw_id = draw_id\n            if style is not None:\n                self.style = style\n            if position is not None:\n                self.position = position\n            if anchor_type:\n                self.anchor_type = anchor_type\n            if anchor_page is not None:\n                self.anchor_page = anchor_page\n            if presentation_style is not None:\n                self.presentation_style = presentation_style\n</code></pre>"},{"location":"reference.html#odfdo.DrawImage","title":"<code>DrawImage</code>","text":"<p>               Bases: <code>Element</code></p> <p>The \u201cdraw:image\u201d element represents an image. An image can be either a link to an external resource or most often embedded into the document. When image is embedded in the document, the url parameter is a reference to the local document obtained by copying the source image into the document, ie: url = document.add_file(image_path)</p> <p>Warning: image elements must be stored in a frame \u201cdraw:frame\u201d, see Frame().</p> Source code in <code>odfdo/image.py</code> <pre><code>class DrawImage(Element):\n    \"\"\"The \"draw:image\" element represents an image. An image can be\n    either a link to an external resource or most often embedded into\n    the document.\n    When image is embedded in the document, the url parameter is a\n    reference to the local document obtained by copying the source\n    image into the document, ie: url = document.add_file(image_path)\n\n    Warning: image elements must be stored in a frame \"draw:frame\",\n    see Frame().\n    \"\"\"\n\n    _tag = \"draw:image\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"url\", \"xlink:href\"),\n        PropDef(\"type\", \"xlink:type\"),\n        PropDef(\"show\", \"xlink:show\"),\n        PropDef(\"actuate\", \"xlink:actuate\"),\n        PropDef(\"filter_name\", \"draw:filter-name\"),\n    )\n\n    def __init__(\n        self,\n        url: str = \"\",\n        xlink_type: str = \"simple\",\n        show: str = \"embed\",\n        actuate: str = \"onLoad\",\n        filter_name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialisation of an DrawImage.\n\n        Arguments:\n\n            url -- str\n\n            type -- str\n\n            show -- str\n\n            actuate -- str\n\n            filter_name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.url = url\n            self.type = xlink_type\n            self.show = show\n            self.actuate = actuate\n            self.filter_name = filter_name\n</code></pre>"},{"location":"reference.html#odfdo.DrawImage.__init__","title":"<code>__init__(url='', xlink_type='simple', show='embed', actuate='onLoad', filter_name=None, **kwargs)</code>","text":"<p>Initialisation of an DrawImage.</p> <p>Arguments:</p> <pre><code>url -- str\n\ntype -- str\n\nshow -- str\n\nactuate -- str\n\nfilter_name -- str\n</code></pre> Source code in <code>odfdo/image.py</code> <pre><code>def __init__(\n    self,\n    url: str = \"\",\n    xlink_type: str = \"simple\",\n    show: str = \"embed\",\n    actuate: str = \"onLoad\",\n    filter_name: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialisation of an DrawImage.\n\n    Arguments:\n\n        url -- str\n\n        type -- str\n\n        show -- str\n\n        actuate -- str\n\n        filter_name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.url = url\n        self.type = xlink_type\n        self.show = show\n        self.actuate = actuate\n        self.filter_name = filter_name\n</code></pre>"},{"location":"reference.html#odfdo.DrawPage","title":"<code>DrawPage</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF draw page \u201cdraw:page\u201d, for pages of presentation and drawings.</p> Source code in <code>odfdo/draw_page.py</code> <pre><code>class DrawPage(Element):\n    \"\"\"ODF draw page \"draw:page\", for pages of presentation and drawings.\"\"\"\n\n    _tag = \"draw:page\"\n    _properties = (\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"draw_id\", \"draw:id\"),\n        PropDef(\"master_page\", \"draw:master-page-name\"),\n        PropDef(\n            \"presentation_page_layout\", \"presentation:presentation-page-layout-name\"\n        ),\n        PropDef(\"style\", \"draw:style-name\"),\n    )\n\n    def __init__(\n        self,\n        draw_id: str | None = None,\n        name: str | None = None,\n        master_page: str | None = None,\n        presentation_page_layout: str | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            draw_id -- str\n\n            name -- str\n\n            master_page -- str\n\n            presentation_page_layout -- str\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if draw_id:\n                self.draw_id = draw_id\n            if name:\n                self.name = name\n            if master_page:\n                self.master_page = master_page\n            if presentation_page_layout:\n                self.presentation_page_layout = presentation_page_layout\n            if style:\n                self.style = style\n\n    def set_transition(\n        self,\n        smil_type: str,\n        subtype: str | None = None,\n        dur: str = \"2s\",\n    ) -&gt; None:\n        # Create the new animation\n        anim_page = AnimPar(presentation_node_type=\"timing-root\")\n        anim_begin = AnimPar(smil_begin=f\"{self.draw_id}.begin\")\n        transition = AnimTransFilter(\n            smil_dur=dur, smil_type=smil_type, smil_subtype=subtype\n        )\n        anim_page.append(anim_begin)\n        anim_begin.append(transition)\n\n        # Replace when already a transition:\n        #   anim:seq =&gt; After the frame's transition\n        #   cf page 349 of OpenDocument-v1.0-os.pdf\n        #   Conclusion: We must delete the first child 'anim:par'\n        existing = self.get_element(\"anim:par\")\n        if existing:\n            self.delete(existing)\n        self.append(anim_page)\n\n    def get_shapes(self) -&gt; list[Element]:\n        query = \"(descendant::\" + \"|descendant::\".join(registered_shapes) + \")\"\n        return self.get_elements(query)\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        result: list[str] = []\n        for child in self.children:\n            if child.tag == \"presentation:notes\":\n                # No need for an advanced odf_notes.get_formatted_text()\n                # because the text seems to be only contained in paragraphs\n                # and frames, that we already handle\n                for sub_child in child.children:\n                    result.append(sub_child.get_formatted_text(context))\n                result.append(\"\\n\")\n            result.append(child.get_formatted_text(context))\n        result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.DrawPage.__init__","title":"<code>__init__(draw_id=None, name=None, master_page=None, presentation_page_layout=None, style=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>draw_id -- str\n\nname -- str\n\nmaster_page -- str\n\npresentation_page_layout -- str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/draw_page.py</code> <pre><code>def __init__(\n    self,\n    draw_id: str | None = None,\n    name: str | None = None,\n    master_page: str | None = None,\n    presentation_page_layout: str | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        draw_id -- str\n\n        name -- str\n\n        master_page -- str\n\n        presentation_page_layout -- str\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if draw_id:\n            self.draw_id = draw_id\n        if name:\n            self.name = name\n        if master_page:\n            self.master_page = master_page\n        if presentation_page_layout:\n            self.presentation_page_layout = presentation_page_layout\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Drawing","title":"<code>Drawing</code>","text":"<p>               Bases: <code>Body</code></p> <p>Drawing, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Drawing(Body):\n    \"\"\"Drawing, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:drawing\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.EText","title":"<code>EText</code>","text":"<p>               Bases: <code>str</code></p> <p>Representation of an XML text node. Created to hide the specifics of lxml in searching text nodes using XPath.</p> <p>Constructed like any str object but only accepts lxml text objects.</p> Source code in <code>odfdo/element.py</code> <pre><code>class EText(str):\n    \"\"\"Representation of an XML text node. Created to hide the specifics of\n    lxml in searching text nodes using XPath.\n\n    Constructed like any str object but only accepts lxml text objects.\n    \"\"\"\n\n    # There's some black magic in inheriting from str\n    def __init__(\n        self,\n        text_result: str | bytes,\n    ) -&gt; None:\n        self.__parent = text_result.getparent()  # type: ignore\n        self.__is_text = text_result.is_text\n        self.__is_tail = text_result.is_tail\n\n    @property\n    def parent(self) -&gt; Element | None:\n        parent = self.__parent\n        # XXX happens just because of the unit test\n        if parent is None:\n            return None\n        return Element.from_tag(tag_or_elem=parent)\n\n    def is_text(self) -&gt; bool:\n        return self.__is_text\n\n    def is_tail(self) -&gt; bool:\n        return self.__is_tail\n</code></pre>"},{"location":"reference.html#odfdo.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>MDBase</code></p> <p>Super class of all ODF classes.</p> <p>Representation of an XML element. Abstraction of the XML library behind.</p> Source code in <code>odfdo/element.py</code> <pre><code>class Element(MDBase):\n    \"\"\"Super class of all ODF classes.\n\n    Representation of an XML element. Abstraction of the XML library behind.\n    \"\"\"\n\n    _tag: str = \"\"\n    _properties: tuple[PropDef, ...] = ()\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        tag_or_elem = kwargs.pop(\"tag_or_elem\", None)\n        if tag_or_elem is None:\n            # Instance for newly created object: create new lxml element and\n            # continue by subclass __init__\n            # If the tag key word exists, make a custom element\n            self._do_init = True\n            tag = kwargs.pop(\"tag\", self._tag)\n            self.__element = self.make_etree_element(tag)\n        else:\n            # called with an existing lxml element, sould be a result of\n            # from_tag() casting, do not execute the subclass __init__\n            if not isinstance(tag_or_elem, _Element):\n                raise TypeError(f'\"{type(tag_or_elem)}\" is not an element node')\n            self._do_init = False\n            self.__element = tag_or_elem\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag}&gt;\"\n\n    @classmethod\n    def from_tag(cls, tag_or_elem: str | _Element) -&gt; Element:\n        \"\"\"Element class and subclass factory.\n\n        Turn an lxml Element or ODF string tag into an ODF XML Element\n        of the relevant class.\n\n        Arguments:\n\n            tag_or_elem -- ODF str tag or lxml.Element\n\n        Return: Element (or subclass) instance\n        \"\"\"\n        if isinstance(tag_or_elem, str):\n            # assume the argument is a prefix:name tag\n            elem = cls.make_etree_element(tag_or_elem)\n        else:\n            elem = tag_or_elem\n        klass = _class_registry.get(elem.tag, cls)\n        return klass(tag_or_elem=elem)\n\n    @classmethod\n    def from_tag_for_clone(\n        cls: Any,  # ABCMeta, type, ...\n        tree_element: _Element,\n        cache: tuple | None,\n    ) -&gt; Element:\n        tag = to_str(tree_element.tag)\n        klass = _class_registry.get(tag, cls)\n        element = klass(tag_or_elem=tree_element)\n        element._copy_cache(cache)\n        return element\n\n    def _copy_cache(self, cache: tuple | None) -&gt; None:\n        \"\"\"Method eredefined for cahched elements.\"\"\"\n        pass\n\n    @staticmethod\n    def make_etree_element(tag: str) -&gt; _Element:\n        if not isinstance(tag, str):\n            raise TypeError(f\"Tag is not str: {tag!r}\")\n        tag = tag.strip()\n        if not tag:\n            raise ValueError(\"Tag is empty\")\n        if \"&lt;\" not in tag:\n            # Qualified name\n            # XXX don't build the element from scratch or lxml will pollute with\n            # repeated namespace declarations\n            tag = f\"&lt;{tag}/&gt;\"\n        # XML fragment\n        root = fromstring(NAMESPACES_XML % str_to_bytes(tag))\n        return root[0]\n\n    @staticmethod\n    def _generic_attrib_getter(attr_name: str, family: str | None = None) -&gt; Callable:\n        name = _get_lxml_tag(attr_name)\n\n        def getter(self: Element) -&gt; str | bool | None:\n            try:\n                if family and self.family != family:  # type: ignore\n                    return None\n            except AttributeError:\n                return None\n            value = self.__element.get(name)\n            if value is None:\n                return None\n            elif value in (\"true\", \"false\"):\n                return Boolean.decode(value)\n            return str(value)\n\n        return getter\n\n    @staticmethod\n    def _generic_attrib_setter(attr_name: str, family: str | None = None) -&gt; Callable:\n        name = _get_lxml_tag(attr_name)\n\n        def setter(self: Element, value: Any) -&gt; None:\n            try:\n                if family and self.family != family:  # type: ignore\n                    return None\n            except AttributeError:\n                return None\n            if value is None:\n                with contextlib.suppress(KeyError):\n                    del self.__element.attrib[name]\n                return\n            if isinstance(value, bool):\n                value = Boolean.encode(value)\n            self.__element.set(name, str(value))\n\n        return setter\n\n    @classmethod\n    def _define_attribut_property(cls: type[Element]) -&gt; None:\n        for prop in cls._properties:\n            setattr(\n                cls,\n                prop.name,\n                property(\n                    cls._generic_attrib_getter(prop.attr, prop.family or None),\n                    cls._generic_attrib_setter(prop.attr, prop.family or None),\n                    None,\n                    f\"Get/set the attribute {prop.attr}\",\n                ),\n            )\n\n    @staticmethod\n    def _make_before_regex(\n        before: str | None,\n        after: str | None,\n    ) -&gt; re.Pattern:\n        # 1) before xor after is not None\n        if before is not None:\n            return re.compile(before)\n        else:\n            if after is None:\n                raise ValueError(\"Both 'before' and 'after' are None\")\n            return re.compile(after)\n\n    @staticmethod\n    def _search_negative_position(\n        xpath_result: list,\n        regex: re.Pattern,\n    ) -&gt; tuple[str, re.Match]:\n        # Found the last text that matches the regex\n        text = None\n        for a_text in xpath_result:\n            if regex.search(str(a_text)) is not None:\n                text = a_text\n        if text is None:\n            raise ValueError(f\"Text not found: '{xpath_result}'\")\n        if not isinstance(text, str):\n            raise TypeError(f\"Text not found or text not of type str: '{text}'\")\n        return text, list(regex.finditer(text))[-1]\n\n    @staticmethod\n    def _search_positive_position(\n        xpath_result: list,\n        regex: re.Pattern,\n        position: int,\n    ) -&gt; tuple[str, re.Match]:\n        # Found the last text that matches the regex\n        count = 0\n        for text in xpath_result:\n            found_nb = len(regex.findall(str(text)))\n            if found_nb + count &gt;= position + 1:\n                break\n            count += found_nb\n        else:\n            raise ValueError(f\"Text not found: '{xpath_result}'\")\n        if not isinstance(text, str):\n            raise TypeError(f\"Text not found or text not of type str: '{text}'\")\n        return text, list(regex.finditer(text))[position - count]\n\n    def _insert_before_after(\n        self,\n        current: _Element,\n        element: _Element,\n        before: str | None,\n        after: str | None,\n        position: int,\n        xpath_text: XPath,\n    ) -&gt; tuple[int, str]:\n        regex = self._make_before_regex(before, after)\n        xpath_result = xpath_text(current)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n        # position = -1\n        if position &lt; 0:\n            text, sre = self._search_negative_position(xpath_result, regex)\n        # position &gt;= 0\n        else:\n            text, sre = self._search_positive_position(xpath_result, regex, position)\n        # Compute pos\n        if before is None:\n            pos = sre.end()\n        else:\n            pos = sre.start()\n        return pos, text\n\n    def _insert_find_text(\n        self,\n        current: _Element,\n        element: _Element,\n        before: str | None,\n        after: str | None,\n        position: int,\n        xpath_text: XPath,\n    ) -&gt; tuple[int, str]:\n        # Find the text\n        xpath_result = xpath_text(current)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n        count = 0\n        for text in xpath_result:\n            if not isinstance(text, str):\n                continue\n            found_nb = len(text)\n            if found_nb + count &gt;= position:\n                break\n            count += found_nb\n        else:\n            raise ValueError(\"Text not found\")\n        # We insert before the character\n        pos = position - count\n        return pos, text\n\n    def _insert(\n        self,\n        element: Element,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n        main_text: bool = False,\n    ) -&gt; None:\n        \"\"\"Insert an element before or after the characters in the text which\n        match the regex before/after.\n\n        When the regex matches more of one part of the text, position can be\n        set to choice which part must be used. If before and after are None,\n        we use only position that is the number of characters. If position is\n        positive and before=after=None, we insert before the position\n        character. But if position=-1, we insert after the last character.\n\n\n        Arguments:\n\n        element -- Element\n\n        before -- str regex\n\n        after -- str regex\n\n        position -- int\n        \"\"\"\n        # not implemented: if main_text is True, filter out the annotations texts in computation.\n        current = self.__element\n        xelement = element.__element\n\n        if main_text:\n            xpath_text = _xpath_text_main_descendant\n        else:\n            xpath_text = _xpath_text_descendant\n\n        # 1) before xor after is not None\n        if (before is not None) ^ (after is not None):\n            pos, text = self._insert_before_after(\n                current,\n                xelement,\n                before,\n                after,\n                position,\n                xpath_text,\n            )\n        # 2) before=after=None =&gt; only with position\n        elif before is None and after is None:\n            # Hack if position is negative =&gt; quickly\n            if position &lt; 0:\n                current.append(xelement)\n                return\n            pos, text = self._insert_find_text(\n                current,\n                xelement,\n                before,\n                after,\n                position,\n                xpath_text,\n            )\n        else:\n            raise ValueError(\"bad combination of arguments\")\n\n        # Compute new texts\n        text_before = text[:pos] if text[:pos] else None\n        text_after = text[pos:] if text[pos:] else None\n\n        # Insert!\n        parent = text.getparent()  # type: ignore\n        if text.is_text:  # type: ignore\n            parent.text = text_before\n            element.tail = text_after\n            parent.insert(0, xelement)\n        else:\n            parent.addnext(xelement)\n            parent.tail = text_before\n            element.tail = text_after\n\n    def _insert_between(\n        self,\n        element: Element,\n        from_: str,\n        to: str,\n    ) -&gt; None:\n        \"\"\"Insert the given empty element to wrap the text beginning with\n        \"from_\" and ending with \"to\".\n\n        Example 1: '&lt;p&gt;toto tata titi&lt;/p&gt;\n\n        We want to insert a link around \"tata\".\n\n        Result 1: '&lt;p&gt;toto &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;\n\n        Example 2: '&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; tata titi&lt;/p&gt;\n\n        We want to insert a link around \"tata\".\n\n        Result 2: '&lt;p&gt;&lt;span&gt;toto&lt;/span&gt; &lt;a&gt;tata&lt;/a&gt; titi&lt;/p&gt;\n\n        Example 3: '&lt;p&gt;toto &lt;span&gt; tata &lt;/span&gt; titi&lt;/p&gt;'\n\n        We want to insert a link from \"tata\" to \"titi\" included.\n\n        Result 3: '&lt;p&gt;toto &lt;span&gt; &lt;/span&gt;'\n                  '&lt;a&gt;&lt;span&gt;tata &lt;/span&gt; titi&lt;/a&gt;&lt;/p&gt;'\n\n        Example 4: '&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; tutu&lt;/p&gt;'\n\n        We want to insert a link from \"titi\" to \"tutu\"\n\n        Result 4: '&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;/a&gt;'\n                  '&lt;a&gt; tutu&lt;/a&gt;&lt;/p&gt;'\n\n        Example 5: '&lt;p&gt;toto &lt;span&gt;tata titi&lt;/span&gt; '\n                   '&lt;span&gt;tutu tyty&lt;/span&gt;&lt;/p&gt;'\n\n        We want to insert a link from \"titi\" to \"tutu\"\n\n        Result 5: '&lt;p&gt;toto &lt;span&gt;tata &lt;/span&gt;&lt;a&gt;&lt;span&gt;titi&lt;/span&gt;&lt;a&gt; '\n                  '&lt;a&gt; &lt;span&gt;tutu&lt;/span&gt;&lt;/a&gt;&lt;span&gt; tyty&lt;/span&gt;&lt;/p&gt;'\n        \"\"\"\n        current = self.__element\n        wrapper = element.__element\n\n        xpath_result = _xpath_text_descendant(current)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n\n        for text in xpath_result:\n            if not isinstance(text, str):\n                raise TypeError(\"Text not found or text not of type str\")\n            if from_ not in text:\n                continue\n            from_index = text.index(from_)\n            text_before = text[:from_index]\n            text_after = text[from_index:]\n            from_container = text.getparent()  # type: ignore\n            if not isinstance(from_container, _Element):\n                raise TypeError(\"Bad XPath result\")\n            # Include from_index to match a single word\n            to_index = text.find(to, from_index)\n            if to_index &gt;= 0:\n                # Simple case: \"from\" and \"to\" in the same element\n                to_end = to_index + len(to)\n                if text.is_text:  # type: ignore\n                    from_container.text = text_before\n                    wrapper.text = text[to_index:to_end]\n                    wrapper.tail = text[to_end:]\n                    from_container.insert(0, wrapper)\n                else:\n                    from_container.tail = text_before\n                    wrapper.text = text[to_index:to_end]\n                    wrapper.tail = text[to_end:]\n                    parent = from_container.getparent()\n                    index = parent.index(from_container)  # type: ignore\n                    parent.insert(index + 1, wrapper)  # type: ignore\n                return\n            else:\n                # Exit to the second part where we search for the end text\n                break\n        else:\n            raise ValueError(\"Start text not found\")\n\n        # The container is split in two\n        container2 = deepcopy(from_container)\n        if text.is_text:  # type: ignore\n            from_container.text = text_before\n            from_container.tail = None\n            container2.text = text_after\n            from_container.tail = None\n        else:\n            from_container.tail = text_before\n            container2.tail = text_after\n        # Stack the copy into the surrounding element\n        wrapper.append(container2)\n        parent = from_container.getparent()\n        index = parent.index(from_container)  # type: ignore\n        parent.insert(index + 1, wrapper)  # type: ignore\n\n        xpath_result = _xpath_text_descendant(wrapper)\n        if not isinstance(xpath_result, list):\n            raise TypeError(\"Bad XPath result\")\n\n        for text in xpath_result:\n            if not isinstance(text, str):\n                raise TypeError(\"Text not found or text not of type str\")\n            if to not in text:\n                continue\n            to_end = text.index(to) + len(to)\n            text_before = text[:to_end]\n            text_after = text[to_end:]\n            container_to = text.getparent()  # type: ignore\n            if not isinstance(container_to, _Element):\n                raise TypeError(\"Bad XPath result\")\n            if text.is_text:  # type: ignore\n                container_to.text = text_before\n                container_to.tail = text_after\n            else:\n                container_to.tail = text_before\n                next_one = container_to.getnext()\n                if next_one is None:\n                    next_one = container_to.getparent()\n                next_one.tail = text_after  # type: ignore\n            return\n        raise ValueError(\"End text not found\")\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"Get/set the underlying xml tag with the given qualified name.\n\n        Warning: direct change of tag does not change the element class.\n\n        Arguments:\n\n            qname -- str (e.g. \"text:span\")\n        \"\"\"\n        return _get_prefixed_name(self.__element.tag)\n\n    @tag.setter\n    def tag(self, qname: str) -&gt; None:\n        self.__element.tag = _get_lxml_tag(qname)\n\n    def elements_repeated_sequence(\n        self,\n        xpath_instance: XPath,\n        name: str,\n    ) -&gt; list[tuple[int, int]]:\n        \"\"\"Utility method for table module.\"\"\"\n        lxml_tag = _get_lxml_tag_or_name(name)\n        element = self.__element\n        sub_elements = xpath_instance(element)\n        if not isinstance(sub_elements, list):\n            raise TypeError(\"Bad XPath result.\")\n        result: list[tuple[int, int]] = []\n        idx = -1\n        for sub_element in sub_elements:\n            if not isinstance(sub_element, _Element):\n                continue\n            idx += 1\n            value = sub_element.get(lxml_tag)\n            if value is None:\n                result.append((idx, 1))\n                continue\n            try:\n                int_value = int(value)\n            except ValueError:\n                int_value = 1\n            result.append((idx, max(int_value, 1)))\n        return result\n\n    def get_elements(self, xpath_query: XPath | str) -&gt; list[Element]:\n        cache: tuple | None = None\n        element = self.__element\n        if isinstance(xpath_query, str):\n            new_xpath_query = xpath_compile(xpath_query)\n            result = new_xpath_query(element)\n        else:\n            result = xpath_query(element)\n        if not isinstance(result, list):\n            raise TypeError(\"Bad XPath result\")\n        return [\n            Element.from_tag_for_clone(e, cache)\n            for e in result\n            if isinstance(e, _Element)\n        ]\n\n    # fixme : need original get_element as wrapper of get_elements\n\n    def get_element(self, xpath_query: XPath | str) -&gt; Element | None:\n        element = self.__element\n        result = element.xpath(f\"({xpath_query})[1]\", namespaces=ODF_NAMESPACES)\n        if result:\n            return Element.from_tag(result[0])  # type:ignore\n        return None\n\n    def _get_element_idx(self, xpath_query: XPath | str, idx: int) -&gt; Element | None:\n        element = self.__element\n        result = element.xpath(f\"({xpath_query})[{idx + 1}]\", namespaces=ODF_NAMESPACES)\n        if result:\n            return Element.from_tag(result[0])  # type:ignore\n        return None\n\n    def _get_element_idx2(self, xpath_instance: XPath, idx: int) -&gt; Element | None:\n        element = self.__element\n        result = xpath_instance(element, idx=idx + 1)\n        if result:\n            return Element.from_tag(result[0])  # type:ignore\n        return None\n\n    @property\n    def attributes(self) -&gt; dict[str, str]:\n        return {\n            _get_prefixed_name(str(key)): str(value)\n            for key, value in self.__element.attrib.items()\n        }\n\n    def get_attribute(self, name: str) -&gt; str | bool | None:\n        \"\"\"Return the attribute value as type str | bool | None.\"\"\"\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        value = element.get(lxml_tag)\n        if value is None:\n            return None\n        elif value in (\"true\", \"false\"):\n            return Boolean.decode(value)\n        return str(value)\n\n    def get_attribute_integer(self, name: str) -&gt; int | None:\n        \"\"\"Return either the attribute as type int, or None.\"\"\"\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        value = element.get(lxml_tag)\n        if value is None:\n            return None\n        try:\n            return int(value)\n        except ValueError:\n            return None\n\n    def get_attribute_string(self, name: str) -&gt; str | None:\n        \"\"\"Return either the attribute as type str, or None.\"\"\"\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        value = element.get(lxml_tag)\n        if value is None:\n            return None\n        return str(value)\n\n    def set_attribute(\n        self, name: str, value: bool | str | tuple[int, int, int] | None\n    ) -&gt; None:\n        if name in ODF_COLOR_PROPERTY:\n            if isinstance(value, bool):\n                raise TypeError(f\"Wrong color type {value!r}\")\n            if value != \"transparent\":\n                value = hexa_color(value)\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        if isinstance(value, bool):\n            value = Boolean.encode(value)\n        elif value is None:\n            with contextlib.suppress(KeyError):\n                del element.attrib[lxml_tag]\n            return\n        element.set(lxml_tag, str(value))\n\n    def set_style_attribute(self, name: str, value: Element | str) -&gt; None:\n        \"\"\"Shortcut to accept a style object as a value.\"\"\"\n        if isinstance(value, Element):\n            value = str(value.name)  # type:ignore\n        return self.set_attribute(name, value)\n\n    def del_attribute(self, name: str) -&gt; None:\n        element = self.__element\n        lxml_tag = _get_lxml_tag_or_name(name)\n        del element.attrib[lxml_tag]\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"Get / set the text content of the element.\"\"\"\n        return self.__element.text or \"\"\n\n    @text.setter\n    def text(self, text: str | None) -&gt; None:\n        if text is None:\n            text = \"\"\n        try:\n            self.__element.text = text\n        except TypeError as e:\n            raise TypeError(f'Str type expected: \"{type(text)}\"') from e\n\n    def __str__(self) -&gt; str:\n        return self.inner_text\n\n    @property\n    def _text_tail(self) -&gt; str:\n        return str(self) + (self.tail or \"\")\n\n    # def _elements_descendants(self) -&gt; Iterator[Element]:\n    #     for elem in self.__element.iterdescendants():\n    #         if isinstance(elem, _Element):\n    #             yield Element.from_tag(elem)\n\n    @property\n    def inner_text(self) -&gt; str:\n        return self.text + \"\".join(e._text_tail for e in self.children)\n\n    @property\n    def text_recursive(self) -&gt; str:\n        return self.inner_text + (self.tail or \"\")\n\n    @property\n    def tail(self) -&gt; str | None:\n        \"\"\"Get / set the text immediately following the element.\"\"\"\n        return self.__element.tail\n\n    @tail.setter\n    def tail(self, text: str | None) -&gt; None:\n        self.__element.tail = text or \"\"\n\n    def search(self, pattern: str) -&gt; int | None:\n        \"\"\"Return the first position of the pattern in the text content of\n        the element, or None if not found.\n\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n        Return: int or None\n        \"\"\"\n        match = re.search(pattern, self.text_recursive)\n        if match is None:\n            return None\n        return match.start()\n\n    def search_first(self, pattern: str) -&gt; tuple[int, int] | None:\n        \"\"\"Return the start and end position of the first occurence\n        of the regex pattern in the text content of the element.\n\n        Result is tuples of start and end position, or None.\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n        Return: tuple[int,int] or None\n        \"\"\"\n        match = re.search(pattern, self.text_recursive)\n        if match is None:\n            return None\n        return match.start(), match.end()\n\n    def search_all(self, pattern: str) -&gt; list[tuple[int, int]]:\n        \"\"\"Return all start and end positions of the regex pattern in\n        the text content of the element.\n\n        Result is a list of tuples of start and end position of\n        the matches.\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n        Return: list[tuple[int,int]]\n        \"\"\"\n        results: list[tuple[int, int]] = []\n        for match in re.finditer(pattern, self.text_recursive):\n            results.append((match.start(), match.end()))\n        return results\n\n    def text_at(self, start: int, end: int | None = None) -&gt; str:\n        \"\"\"Return the text (recursive) content of the element between\n        start and end position.\n\n        If the end parameter is not set, return from start to the end\n        of the recursive text.\n\n        Arguments:\n\n            start -- int\n            end -- int or None\n\n        Return: str\n        \"\"\"\n        if start &lt; 0:\n            start = 0\n        if end is None:\n            return self.text_recursive[start:]\n        else:\n            if end &lt; start:\n                end = start\n            return self.text_recursive[start:end]\n\n    def match(self, pattern: str) -&gt; bool:\n        \"\"\"return True if the pattern is found one or more times anywhere in\n        the text content of the element.\n\n        Python regular expression syntax applies.\n\n        Arguments:\n\n            pattern -- str\n\n        Return: bool\n        \"\"\"\n        return self.search(pattern) is not None\n\n    def replace(\n        self,\n        pattern: str,\n        new: str | None = None,\n        formatted: bool = False,\n    ) -&gt; int:\n        \"\"\"Replace the pattern with the given text, or delete if text is an\n        empty string, and return the number of replacements. By default, only\n        return the number of occurences that would be replaced.\n\n        It cannot replace patterns found across several element, like a word\n        split into two consecutive spans.\n\n        Python regular expression syntax applies.\n\n        If formatted is True, and the target is a Paragraph, Span or Header,\n        and the replacement text contains spaces, tabs or newlines, try to\n        convert them into actual ODF elements to obtain a formatted result.\n        On very complex contents, result may differ of expectations.\n\n        Arguments:\n\n            pattern -- str\n\n            new -- str\n\n            formatted -- bool\n\n        Return: int\n        \"\"\"\n        if not isinstance(pattern, str):\n            # Fail properly if the pattern is an non-ascii bytestring\n            pattern = str(pattern)\n        cpattern = re.compile(pattern)\n        count = 0\n        for text in self.xpath(\"descendant::text()\"):\n            if new is None:\n                count += len(cpattern.findall(str(text)))\n            else:\n                new_text, number = cpattern.subn(new, str(text))\n                container = text.parent\n                if not container:\n                    continue\n                if text.is_text():  # type: ignore\n                    container.text = new_text  # type: ignore\n                else:\n                    container.tail = new_text  # type: ignore\n                if formatted and container.tag in {  # type; ignore\n                    \"text:h\",\n                    \"text:p\",\n                    \"text:span\",\n                }:\n                    container.append_plain_text(\"\")  # type; ignore\n                count += number\n        return count\n\n    @property\n    def root(self) -&gt; Element:\n        element = self.__element\n        tree = element.getroottree()\n        root = tree.getroot()\n        return Element.from_tag(root)\n\n    @property\n    def parent(self) -&gt; Element | None:\n        element = self.__element\n        parent = element.getparent()\n        if parent is None:\n            # Already at root\n            return None\n        return Element.from_tag(parent)\n\n    @property\n    def is_bound(self) -&gt; bool:\n        return self.parent is not None\n\n    # def get_next_sibling(self):\n    #     element = self.__element\n    #     next_one = element.getnext()\n    #     if next_one is None:\n    #         return None\n    #     return Element.from_tag(next_one)\n    #\n    # def get_prev_sibling(self):\n    #     element = self.__element\n    #     prev = element.getprevious()\n    #     if prev is None:\n    #         return None\n    #     return Element.from_tag(prev)\n\n    @property\n    def children(self) -&gt; list[Element]:\n        element = self.__element\n        return [\n            Element.from_tag(e)\n            for e in element.iterchildren()\n            if isinstance(e, _Element)\n        ]\n\n    def index(self, child: Element) -&gt; int:\n        \"\"\"Return the position of the child in this element.\n\n        Inspired by lxml\n        \"\"\"\n        return self.__element.index(child.__element)\n\n    @property\n    def text_content(self) -&gt; str:\n        \"\"\"Get / set the text of the embedded paragraphs, including embeded\n        annotations, cells...\n\n        Set does create a paragraph if missing.\n        \"\"\"\n        content = \"\".join(\n            str(child) for child in self.get_elements(\"descendant::text:p\")\n        )\n        if content.endswith(\"\\n\"):\n            return content[:-1]\n        return content\n\n    @text_content.setter\n    def text_content(self, text: str | Element | None) -&gt; None:\n        paragraphs = self.get_elements(\"text:p\")\n        if not paragraphs:\n            # E.g., text:p in draw:text-box in draw:frame\n            paragraphs = self.get_elements(\"*/text:p\")\n        if paragraphs:\n            paragraph = paragraphs.pop(0)\n            for obsolete in paragraphs:\n                obsolete.delete()\n        else:\n            paragraph = Element.from_tag(\"text:p\")\n            self.insert(paragraph, FIRST_CHILD)\n        # As \"text_content\" returned all text nodes, \"text_content\"\n        # will overwrite all text nodes and children that may contain them\n        element = paragraph.__element\n        # Clear but the attributes\n        del element[:]\n        if text is None:\n            text = \"\"\n        element.text = str(text)\n\n    def _erase_text_content(self) -&gt; None:\n        paragraphs = self.get_elements(\"text:p\")\n        if not paragraphs:\n            # E.g., text:p in draw:text-box in draw:frame\n            paragraphs = self.get_elements(\"*/text:p\")\n        if paragraphs:\n            paragraphs.pop(0)\n            for obsolete in paragraphs:\n                obsolete.delete()\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the element is empty : no text, no children, no tail.\n\n        Return: Boolean\n        \"\"\"\n        element = self.__element\n        if element.tail is not None:\n            return False\n        if element.text is not None:\n            return False\n        if list(element.iterchildren()):  # noqa: SIM103\n            return False\n        return True\n\n    def _get_successor(self, target: Element) -&gt; tuple[Element | None, Element | None]:\n        element = self.__element\n        next_one = element.getnext()\n        if next_one is not None:\n            return Element.from_tag(next_one), target\n        parent = self.parent\n        if parent is None:\n            return None, None\n        return parent._get_successor(target.parent)  # type:ignore\n\n    def _get_between_base(\n        self,\n        tag1: Element,\n        tag2: Element,\n    ) -&gt; list[Element]:\n        def find_any_id(elem: Element) -&gt; tuple[str, str, str]:\n            elem_tag = elem.tag\n            for attribute in (\n                \"text:id\",\n                \"text:change-id\",\n                \"text:name\",\n                \"office:name\",\n                \"text:ref-name\",\n                \"xml:id\",\n            ):\n                idx = elem.get_attribute(attribute)\n                if idx is not None:\n                    return elem_tag, attribute, str(idx)\n            raise ValueError(f\"No Id found in {elem.serialize()}\")\n\n        def common_ancestor(\n            tag1: str,\n            attr1: str,\n            val1: str,\n            tag2: str,\n            attr2: str,\n            val2: str,\n        ) -&gt; Element | None:\n            root = self.root\n            request1 = f'descendant::{tag1}[@{attr1}=\"{val1}\"]'\n            request2 = f'descendant::{tag2}[@{attr2}=\"{val2}\"]'\n            ancestor = root.xpath(request1)[0]\n            if ancestor is None:\n                return None\n            while True:\n                # print \"up\",\n                new_ancestor = ancestor.parent\n                if new_ancestor is None:\n                    return None\n                has_tag2 = new_ancestor.xpath(request2)\n                ancestor = new_ancestor\n                if not has_tag2:\n                    continue\n                # print 'found'\n                break\n            # print up.serialize()\n            return ancestor\n\n        elem1_tag, elem1_attr, elem1_val = find_any_id(tag1)\n        elem2_tag, elem2_attr, elem2_val = find_any_id(tag2)\n        ancestor_result = common_ancestor(\n            elem1_tag,\n            elem1_attr,\n            elem1_val,\n            elem2_tag,\n            elem2_attr,\n            elem2_val,\n        )\n        if ancestor_result is None:\n            raise RuntimeError(f\"No common ancestor for {elem1_tag} {elem2_tag}\")\n        ancestor = ancestor_result.clone\n        path1 = f'{elem1_tag}[@{elem1_attr}=\"{elem1_val}\"]'\n        path2 = f'{elem2_tag}[@{elem2_attr}=\"{elem2_val}\"]'\n        result = ancestor.clone\n        for child in result.children:\n            result.delete(child)\n        result.text = \"\"\n        result.tail = \"\"\n        target = result\n        current = ancestor.children[0]\n\n        state = 0\n        while True:\n            if current is None:\n                raise RuntimeError(f\"No current ancestor for {elem1_tag} {elem2_tag}\")\n            # print 'current', state, current.serialize()\n            if state == 0:  # before tag 1\n                if current.xpath(f\"descendant-or-self::{path1}\"):\n                    if current.xpath(f\"self::{path1}\"):\n                        tail = current.tail\n                        if tail:\n                            # got a tail =&gt; the parent should be either t:p or t:h\n                            target.text = tail  # type: ignore\n                        current, target = current._get_successor(target)  # type: ignore\n                        state = 1\n                        continue\n                    # got T1 in chidren, need further analysis\n                    new_target = current.clone\n                    for child in new_target.children:\n                        new_target.delete(child)\n                    new_target.text = \"\"\n                    new_target.tail = \"\"\n                    target.__append(new_target)  # type: ignore\n                    target = new_target\n                    current = current.children[0]\n                    continue\n                else:\n                    # before tag1 : forget element, go to next one\n                    current, target = current._get_successor(target)  # type: ignore\n                    continue\n            elif state == 1:  # collect elements\n                further = False\n                if current.xpath(f\"descendant-or-self::{path2}\"):\n                    if current.xpath(f\"self::{path2}\"):\n                        # end of trip\n                        break\n                    # got T2 in chidren, need further analysis\n                    further = True\n                # further analysis needed :\n                if further:\n                    new_target = current.clone\n                    for child in new_target.children:\n                        new_target.delete(child)\n                    new_target.text = \"\"\n                    new_target.tail = \"\"\n                    target.__append(new_target)  # type: ignore\n                    target = new_target\n                    current = current.children[0]\n                    continue\n                # collect\n                target.__append(current.clone)  # type: ignore\n                current, target = current._get_successor(target)  # type: ignore\n                continue\n        # Now resu should be the \"parent\" of inserted parts\n        # - a text:h or text:p sigle item (simple case)\n        # - a upper element, with some text:p, text:h in it =&gt; need to be\n        #   stripped to have a list of text:p, text:h\n        if result.tag in {\"text:p\", \"text:h\"}:\n            inner = [result]\n        else:\n            inner = result.children\n        return inner\n\n    def get_between(\n        self,\n        tag1: Element,\n        tag2: Element,\n        as_text: bool = False,\n        clean: bool = True,\n        no_header: bool = True,\n    ) -&gt; list | Element | str:\n        \"\"\"Returns elements between tag1 and tag2, tag1 and tag2 shall\n        be unique and having an id attribute.\n        (WARN: buggy if tag1/tag2 defines a malformed odf xml.)\n        If as_text is True: returns the text content.\n        If clean is True: suppress unwanted tags (deletions marks, ...)\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of Element, cleaned and without headers.\n\n        Implementation and standard retrictions:\n        Only text:h and text:p sould be 'cut' by an insert tag, so inner parts\n        of insert tags are:\n\n            - any text:h, text:p or sub tag of these\n\n            - some text, part of a parent text:h or text:p\n\n        Arguments:\n\n            tag1 -- Element\n\n            tag2 -- Element\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list of odf_paragraph or odf_header\n        \"\"\"\n        inner = self._get_between_base(tag1, tag2)\n\n        if clean:\n            clean_tags = (\n                \"text:change\",\n                \"text:change-start\",\n                \"text:change-end\",\n                \"text:reference-mark\",\n                \"text:reference-mark-start\",\n                \"text:reference-mark-end\",\n            )\n            request_self = \" | \".join([f\"self::{tag}\" for tag in clean_tags])\n            inner = [e for e in inner if not e.xpath(request_self)]\n            request = \" | \".join([f\"descendant::{tag}\" for tag in clean_tags])\n            for element in inner:\n                to_del = element.xpath(request)\n                for elem in to_del:\n                    if isinstance(elem, Element):\n                        element.delete(elem)\n        if no_header:  # crude replace t:h by t:p\n            new_inner = []\n            for element in inner:\n                if element.tag == \"text:h\":\n                    children = element.children\n                    text = element.__element.text\n                    para = Element.from_tag(\"text:p\")\n                    para.text = text or \"\"\n                    for child in children:\n                        para.__append(child)\n                    new_inner.append(para)\n                else:\n                    new_inner.append(element)\n            inner = new_inner\n        if as_text:\n            return \"\\n\".join([e.get_formatted_text() for e in inner])\n        else:\n            return inner\n\n    def insert(\n        self,\n        element: Element,\n        xmlposition: int | None = None,\n        position: int | None = None,\n        start: bool = False,\n    ) -&gt; None:\n        \"\"\"Insert an element relatively to ourself.\n\n        Insert either using DOM vocabulary or by numeric position.\n        If text start is True, insert the element before any existing text.\n\n        Position start at 0.\n\n        Arguments:\n\n            element -- Element\n\n            xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING\n                           or PREV_SIBLING\n\n            start -- Boolean\n\n            position -- int\n        \"\"\"\n        # child_tag = element.tag\n        current = self.__element\n        lx_element = element.__element\n        if start:\n            text = current.text\n            if text is not None:\n                current.text = None\n                tail = lx_element.tail\n                if tail is None:\n                    tail = text\n                else:\n                    tail = tail + text\n                lx_element.tail = tail\n            position = 0\n        if position is not None:\n            current.insert(position, lx_element)\n        elif xmlposition is FIRST_CHILD:\n            current.insert(0, lx_element)\n        elif xmlposition is LAST_CHILD:\n            current.append(lx_element)\n        elif xmlposition is NEXT_SIBLING:\n            parent = current.getparent()\n            index = parent.index(current)  # type: ignore\n            parent.insert(index + 1, lx_element)  # type: ignore\n        elif xmlposition is PREV_SIBLING:\n            parent = current.getparent()\n            index = parent.index(current)  # type: ignore\n            parent.insert(index, lx_element)  # type: ignore\n        else:\n            raise ValueError(\"(xml)position must be defined\")\n\n    def extend(self, odf_elements: Iterable[Element]) -&gt; None:\n        \"\"\"Fast append elements at the end of ourself using extend.\"\"\"\n        if odf_elements:\n            current = self.__element\n            elements = [element.__element for element in odf_elements]\n            current.extend(elements)\n\n    @staticmethod\n    def _add_text(text1: str | None, text2: str | None) -&gt; str:\n        if text1 is None:\n            text1 = \"\"\n        if text2 is None:\n            text2 = \"\"\n        return _re_anyspace.sub(\" \", text1 + text2)\n\n    def _cut_text_tail(self) -&gt; str:\n        removed = \"\"\n        current = self.__element\n        children = list(current.iterchildren())\n        if children:\n            # Append to tail of the last child\n            last_child = children[-1]\n            if last_child.tail:\n                removed = last_child.tail\n                last_child.tail = \"\"\n        else:\n            removed = current.text or \"\"\n            current.text = \"\"\n        return removed\n\n    def __append(self, str_or_element: str | Element) -&gt; None:\n        \"\"\"Insert element or text in the last position.\"\"\"\n        current = self.__element\n        if isinstance(str_or_element, str):\n            # Has children ?\n            children = list(current.iterchildren())\n            if children:\n                # Append to tail of the last child\n                last_child = children[-1]\n                last_child.tail = self._add_text(last_child.tail, str_or_element)\n            else:\n                # Append to text of the element\n                current.text = self._add_text(current.text, str_or_element)\n        elif isinstance(str_or_element, Element):\n            current.append(str_or_element.__element)\n        else:\n            raise TypeError(f'Element or string expected, not \"{type(str_or_element)}\"')\n\n    append = __append\n\n    def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        if keep_tail is True (default), the tail text is not erased.\n\n        Arguments:\n\n            child -- Element\n\n            keep_tail -- boolean (default to True), True for most usages.\n        \"\"\"\n        if child is None:\n            parent = self.parent\n            if parent is None:\n                raise ValueError(f\"Can't delete the root element\\n{self.serialize()}\")\n            child = self\n        else:\n            parent = self\n        if keep_tail and child.__element.tail is not None:\n            current = child.__element\n            tail = str(current.tail)\n            current.tail = None\n            prev = current.getprevious()\n            if prev is not None:\n                if prev.tail is None:\n                    prev.tail = tail\n                else:\n                    prev.tail += tail\n            else:\n                if parent.__element.text is None:\n                    parent.__element.text = tail\n                else:\n                    parent.__element.text += tail\n        parent.__element.remove(child.__element)\n\n    def replace_element(self, old_element: Element, new_element: Element) -&gt; None:\n        \"\"\"Replaces in place a sub element with the element passed as second\n        argument.\n\n        Warning : no clone for old element.\n        \"\"\"\n        current = self.__element\n        current.replace(old_element.__element, new_element.__element)\n\n    def strip_elements(\n        self,\n        sub_elements: Element | Iterable[Element],\n    ) -&gt; Element | list:\n        \"\"\"Remove the tags of provided elements, keeping inner childs and text.\n\n        Return : the striped element.\n\n        Warning : no clone in sub_elements list.\n\n        Arguments:\n\n            sub_elements -- Element or list of Element\n        \"\"\"\n        if not sub_elements:\n            return self\n        if isinstance(sub_elements, Element):\n            sub_elements = (sub_elements,)\n        replacer = _get_lxml_tag(\"text:this-will-be-removed\")\n        for element in sub_elements:\n            element.__element.tag = replacer\n        strip = (\"text:this-will-be-removed\",)\n        return self.strip_tags(strip=strip, default=None)\n\n    def strip_tags(\n        self,\n        strip: Iterable[str] | None = None,\n        protect: Iterable[str] | None = None,\n        default: str | None = \"text:p\",\n    ) -&gt; Element | list:\n        \"\"\"Remove the tags listed in strip, recursively, keeping inner childs\n        and text. Tags listed in protect stop the removal one level depth. If\n        the first level element is stripped, default is used to embed the\n        content in the default element. If default is None and first level is\n        striped, a list of text and children is returned. Return : the striped\n        element.\n\n        strip_tags should be used by on purpose methods (strip_span ...)\n        (Method name taken from lxml).\n\n        Arguments:\n\n            strip -- iterable list of str odf tags, or None\n\n            protect -- iterable list of str odf tags, or None\n\n            default -- str odf tag, or None\n\n        Return:\n\n            Element.\n        \"\"\"\n        if not strip:\n            return self\n        if not protect:\n            protect = ()\n        protected = False\n        element, modified = Element._strip_tags(self, strip, protect, protected)\n        if modified and isinstance(element, list) and default:\n            new = Element.from_tag(default)\n            for content in element:\n                if isinstance(content, Element):\n                    new.__append(content)\n                else:\n                    new.text = content\n            element = new\n        return element\n\n    @staticmethod\n    def _strip_tags(\n        element: Element,\n        strip: Iterable[str],\n        protect: Iterable[str],\n        protected: bool,\n    ) -&gt; tuple[Element | list, bool]:\n        \"\"\"Sub method for strip_tags().\"\"\"\n        element_clone = element.clone\n        modified = False\n        children = []\n        if protect and element.tag in protect:\n            protect_below = True\n        else:\n            protect_below = False\n        for child in element_clone.children:\n            striped_child, is_modified = Element._strip_tags(\n                child, strip, protect, protect_below\n            )\n            if is_modified:\n                modified = True\n            if isinstance(striped_child, list):\n                children.extend(striped_child)\n            else:\n                children.append(striped_child)\n\n        text = element_clone.text\n        tail = element_clone.tail\n        if not protected and strip and element.tag in strip:\n            element_result: list[Element | str] = []\n            if text is not None:\n                element_result.append(text)\n            for child in children:\n                element_result.append(child)\n            if tail is not None:\n                element_result.append(tail)\n            return (element_result, True)\n        else:\n            if not modified:\n                return (element, False)\n            element.clear()\n            try:\n                for key, value in element_clone.attributes.items():\n                    element.set_attribute(key, value)\n            except ValueError:\n                sys.stderr.write(f\"strip_tags(): bad attribute in {element_clone}\\n\")\n            if text is not None:\n                element.__append(text)\n            for child in children:\n                element.__append(child)\n            if tail is not None:\n                element.tail = tail\n            return (element, True)\n\n    def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n        \"\"\"Apply XPath query to the element and its subtree. Return list of\n        Element or EText instances translated from the nodes found.\n        \"\"\"\n        element = self.__element\n        xpath_instance = xpath_compile(xpath_query)\n        elements = xpath_instance(element)\n        result: list[Element | EText] = []\n        if hasattr(elements, \"__iter__\"):\n            for obj in elements:  # type: ignore\n                if isinstance(obj, (str, bytes)):\n                    result.append(EText(obj))\n                elif isinstance(obj, _Element):\n                    result.append(Element.from_tag(obj))\n                # else:\n                #     result.append(obj)\n        return result\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove text, children and attributes from the element.\"\"\"\n        self.__element.clear()\n\n    @property\n    def clone(self) -&gt; Element:\n        clone = deepcopy(self.__element)\n        root = lxml_Element(\"ROOT\", nsmap=ODF_NAMESPACES)\n        root.append(clone)\n        return self.from_tag(clone)\n\n        # slow data = tostring(self.__element, encoding='unicode')\n        # return self.from_tag(data)\n\n    @staticmethod\n    def _strip_namespaces(data: str) -&gt; str:\n        \"\"\"Remove xmlns:* fields from serialized XML.\"\"\"\n        return re.sub(r' xmlns:\\w*=\"[\\w:\\-\\/\\.#]*\"', \"\", data)\n\n    def serialize(self, pretty: bool = False, with_ns: bool = False) -&gt; str:\n        \"\"\"Return text serialization of XML element.\"\"\"\n        # This copy bypasses serialization side-effects in lxml\n        native = deepcopy(self.__element)\n        data = tostring(\n            native, with_tail=False, pretty_print=pretty, encoding=\"unicode\"\n        )\n        if with_ns:\n            return data\n        # Remove namespaces\n        return self._strip_namespaces(data)\n\n    # Element helpers usable from any context\n\n    @property\n    def document_body(self) -&gt; Element | None:\n        \"\"\"Return the first children of document body if any: 'office:body/*[1]'\"\"\"\n        return self.get_element(\"//office:body/*[1]\")\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        \"\"\"This function should return a beautiful version of the text.\"\"\"\n        return \"\"\n\n    def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n        \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n        name (or all by default).\n\n        Arguments:\n\n            name -- str\n\n        Return: list\n        \"\"\"\n        # FIXME incomplete (and possibly inaccurate)\n        return (\n            self._filtered_elements(\"descendant::*\", text_style=name)\n            + self._filtered_elements(\"descendant::*\", draw_style=name)\n            + self._filtered_elements(\"descendant::*\", draw_text_style=name)\n            + self._filtered_elements(\"descendant::*\", table_style=name)\n            + self._filtered_elements(\"descendant::*\", page_layout=name)\n            + self._filtered_elements(\"descendant::*\", master_page=name)\n            + self._filtered_elements(\"descendant::*\", parent_style=name)\n        )\n\n    # Common attributes\n\n    def _get_inner_text(self, tag: str) -&gt; str | None:\n        element = self.get_element(tag)\n        if element is None:\n            return None\n        return element.text\n\n    def _set_inner_text(self, tag: str, text: str) -&gt; None:\n        element = self.get_element(tag)\n        if element is None:\n            element = Element.from_tag(tag)\n            self.__append(element)\n        element.text = text\n\n    # SVG\n\n    @property\n    def svg_title(self) -&gt; str | None:\n        return self._get_inner_text(\"svg:title\")\n\n    @svg_title.setter\n    def svg_title(self, title: str) -&gt; None:\n        self._set_inner_text(\"svg:title\", title)\n\n    @property\n    def svg_description(self) -&gt; str | None:\n        return self._get_inner_text(\"svg:desc\")\n\n    @svg_description.setter\n    def svg_description(self, description: str) -&gt; None:\n        self._set_inner_text(\"svg:desc\", description)\n\n    # Sections\n\n    def get_sections(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the sections that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"text:section\", text_style=style, content=content\n        )\n\n    @property\n    def sections(\n        self,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the sections.\n\n        Return: list of Element\n        \"\"\"\n        return self.get_elements(\"text:section\")\n\n    def get_section(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the section that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:section\", position, content=content\n        )\n\n    # Paragraphs\n\n    def get_paragraphs(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the paragraphs that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Paragraph\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:p\", text_style=style, content=content\n        )\n\n    @property\n    def paragraphs(self) -&gt; list[Element]:\n        \"\"\"Return all the paragraphs.\n\n        Return: list of Paragraph\n        \"\"\"\n        return self.get_elements(\"descendant::text:p\")\n\n    def get_paragraph(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the paragraph that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Paragraph or None if not found\n        \"\"\"\n        return self._filtered_element(\"descendant::text:p\", position, content=content)\n\n    # Span\n\n    def get_spans(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the spans that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Span\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:span\", text_style=style, content=content\n        )\n\n    @property\n    def spans(self) -&gt; list[Element]:\n        \"\"\"Return all the spans.\n\n        Return: list of Span\n        \"\"\"\n        return self.get_elements(\"descendant::text:span\")\n\n    def get_span(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the span that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Span or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:span\", position, content=content\n        )\n\n    # Headers\n\n    def get_headers(\n        self,\n        style: str | None = None,\n        outline_level: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the Headers that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Header\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:h\",\n            text_style=style,\n            outline_level=outline_level,\n            content=content,\n        )\n\n    @property\n    def headers(self) -&gt; list[Element]:\n        \"\"\"Return all the Headers.\n\n        Return: list of Header\n        \"\"\"\n        return self.get_elements(\"descendant::text:h\")\n\n    def get_header(\n        self,\n        position: int = 0,\n        outline_level: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the Header that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Header or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:h\",\n            position,\n            outline_level=outline_level,\n            content=content,\n        )\n\n    # Lists\n\n    def get_lists(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the lists that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of List\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:list\", text_style=style, content=content\n        )\n\n    @property\n    def lists(self) -&gt; list[Element]:\n        \"\"\"Return all the lists.\n\n        Return: list of List\n        \"\"\"\n        return self.get_elements(\"descendant::text:list\")\n\n    def get_list(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the list that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: List or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:list\", position, content=content\n        )\n\n    # Frames\n\n    def get_frames(\n        self,\n        presentation_class: str | None = None,\n        style: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the frames that match the criteria.\n\n        Arguments:\n\n            presentation_class -- str\n\n            style -- str\n\n            title -- str regex\n\n            description -- str regex\n\n            content -- str regex\n\n        Return: list of Frame\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:frame\",\n            presentation_class=presentation_class,\n            draw_style=style,\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    @property\n    def frames(self) -&gt; list[Element]:\n        \"\"\"Return all the frames.\n\n        Return: list of Frame\n        \"\"\"\n        return self.get_elements(\"descendant::draw:frame\")\n\n    def get_frame(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        presentation_class: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the section that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            presentation_class -- str\n\n            title -- str regex\n\n            description -- str regex\n\n            content -- str regex\n\n        Return: Frame or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:frame\",\n            position,\n            draw_name=name,\n            presentation_class=presentation_class,\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    # Images\n\n    def get_images(\n        self,\n        style: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the images matching the criteria.\n\n        Arguments:\n\n            style -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:image\", text_style=style, url=url, content=content\n        )\n\n    @property\n    def images(self) -&gt; list[Element]:\n        \"\"\"Return all the images.\n\n        Return: list of Element\n        \"\"\"\n        return self.get_elements(\"descendant::draw:image\")\n\n    def get_image(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the image matching the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        # The frame is holding the name\n        if name is not None:\n            frame = self._filtered_element(\n                \"descendant::draw:frame\", position, draw_name=name\n            )\n            if frame is None:\n                return None\n            # The name is supposedly unique\n            return frame.get_element(\"draw:image\")\n        return self._filtered_element(\n            \"descendant::draw:image\", position, url=url, content=content\n        )\n\n    # Named Range\n\n    def get_named_ranges(self) -&gt; list[Element]:\n        \"\"\"Return all the tables named ranges.\n\n        Return: list of odf_named_range\n        \"\"\"\n        named_ranges = self.get_elements(\n            \"descendant::table:named-expressions/table:named-range\"\n        )\n        return named_ranges\n\n    def get_named_range(self, name: str) -&gt; Element | None:\n        \"\"\"Return the named range of specified name, or None if not found.\n\n        Arguments:\n\n            name -- str\n\n        Return: NamedRange\n        \"\"\"\n        named_range = self.get_elements(\n            f'descendant::table:named-expressions/table:named-range[@table:name=\"{name}\"][1]'\n        )\n        if named_range:\n            return named_range[0]\n        else:\n            return None\n\n    def append_named_range(self, named_range: Element) -&gt; None:\n        \"\"\"Append the named range to the spreadsheet, replacing existing named\n        range of same name if any.\n\n        Arguments:\n\n            named_range --  NamedRange\n        \"\"\"\n        if self.tag != \"office:spreadsheet\":\n            raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n        named_expressions = self.get_element(\"table:named-expressions\")\n        if not named_expressions:\n            named_expressions = Element.from_tag(\"table:named-expressions\")\n            self.__append(named_expressions)\n        # exists ?\n        current = named_expressions.get_element(\n            f'table:named-range[@table:name=\"{named_range.name}\"][1]'  # type:ignore\n        )\n        if current:\n            named_expressions.delete(current)\n        named_expressions.__append(named_range)\n\n    def delete_named_range(self, name: str) -&gt; None:\n        \"\"\"Delete the Named Range of specified name from the spreadsheet.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        if self.tag != \"office:spreadsheet\":\n            raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n        named_range = self.get_named_range(name)\n        if not named_range:\n            return\n        named_range.delete()\n        named_expressions = self.get_element(\"table:named-expressions\")\n        if not named_expressions:\n            return\n        element = named_expressions.__element\n        children = list(element.iterchildren())\n        if not children:\n            self.delete(named_expressions)\n\n    # Notes\n\n    def get_notes(\n        self,\n        note_class: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the notes that match the criteria.\n\n        Arguments:\n\n            note_class -- 'footnote' or 'endnote'\n\n            content -- str regex\n\n        Return: list of Note\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:note\", note_class=note_class, content=content\n        )\n\n    def get_note(\n        self,\n        position: int = 0,\n        note_id: str | None = None,\n        note_class: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the note that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            note_id -- str\n\n            note_class -- 'footnote' or 'endnote'\n\n            content -- str regex\n\n        Return: Note or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:note\",\n            position,\n            text_id=note_id,\n            note_class=note_class,\n            content=content,\n        )\n\n    # Annotations\n\n    def get_annotations(\n        self,\n        creator: str | None = None,\n        start_date: datetime | None = None,\n        end_date: datetime | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the annotations that match the criteria.\n\n        Arguments:\n\n            creator -- str\n\n            start_date -- datetime instance\n\n            end_date --  datetime instance\n\n            content -- str regex\n\n        Return: list of Annotation\n        \"\"\"\n        annotations = []\n        for annotation in self._filtered_elements(\n            \"descendant::office:annotation\", content=content\n        ):\n            if creator is not None and creator != annotation.dc_creator:\n                continue\n            date = annotation.date\n            if date is None:\n                continue\n            if start_date is not None and date &lt; start_date:\n                continue\n            if end_date is not None and date &gt;= end_date:\n                continue\n            annotations.append(annotation)\n        return annotations\n\n    def get_annotation(\n        self,\n        position: int = 0,\n        creator: str | None = None,\n        start_date: datetime | None = None,\n        end_date: datetime | None = None,\n        content: str | None = None,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the annotation that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            creator -- str\n\n            start_date -- datetime instance\n\n            end_date -- datetime instance\n\n            content -- str regex\n\n            name -- str\n\n        Return: Annotation or None if not found\n        \"\"\"\n        if name is not None:\n            return self._filtered_element(\n                \"descendant::office:annotation\", 0, office_name=name\n            )\n        annotations = self.get_annotations(\n            creator=creator, start_date=start_date, end_date=end_date, content=content\n        )\n        if not annotations:\n            return None\n        try:\n            return annotations[position]\n        except IndexError:\n            return None\n\n    def get_annotation_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the annotation ends.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::office:annotation-end\")\n\n    def get_annotation_end(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the annotation end that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::office:annotation-end\", position, office_name=name\n        )\n\n    # office:names\n\n    def get_office_names(self) -&gt; list[str]:\n        \"\"\"Return all the used office:name tags values of the element.\n\n        Return: list of unique str\n        \"\"\"\n        name_xpath_query = xpath_compile(\"//@office:name\")\n        response = name_xpath_query(self.__element)\n        if not isinstance(response, list):\n            return []\n        return list({str(name) for name in response if name})\n\n    # Variables\n\n    def get_variable_decls(self) -&gt; Element:\n        \"\"\"Return the container for variable declarations. Created if not\n        found.\n\n        Return: Element\n        \"\"\"\n        variable_decls = self.get_element(\"//text:variable-decls\")\n        if variable_decls is None:\n            body = self.document_body\n            if not body:\n                raise ValueError(\"Empty document.body\")\n            body.insert(Element.from_tag(\"text:variable-decls\"), FIRST_CHILD)\n            variable_decls = body.get_element(\"//text:variable-decls\")\n\n        return variable_decls  # type:ignore\n\n    def get_variable_decl_list(self) -&gt; list[Element]:\n        \"\"\"Return all the variable declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:variable-decl\")\n\n    def get_variable_decl(self, name: str, position: int = 0) -&gt; Element | None:\n        \"\"\"return the variable declaration for the given name.\n\n        Arguments:\n\n            name -- str\n\n            position -- int\n\n        return: Element or none if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:variable-decl\", position, text_name=name\n        )\n\n    def get_variable_sets(self, name: str | None = None) -&gt; list[Element]:\n        \"\"\"Return all the variable sets that match the criteria.\n\n        Arguments:\n\n            name -- str\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:variable-set\", text_name=name)\n\n    def get_variable_set(self, name: str, position: int = -1) -&gt; Element | None:\n        \"\"\"Return the variable set for the given name (last one by default).\n\n        Arguments:\n\n            name -- str\n\n            position -- int\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:variable-set\", position, text_name=name\n        )\n\n    def get_variable_set_value(\n        self,\n        name: str,\n        value_type: str | None = None,\n    ) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n        \"\"\"Return the last value of the given variable name.\n\n        Arguments:\n\n            name -- str\n\n            value_type -- 'boolean', 'currency', 'date', 'float',\n                          'percentage', 'string', 'time' or automatic\n\n        Return: most appropriate Python type\n        \"\"\"\n        variable_set = self.get_variable_set(name)\n        if not variable_set:\n            return None\n        return variable_set.get_value(value_type)  # type: ignore\n\n    # User fields\n\n    def get_user_field_decls(self) -&gt; Element | None:\n        \"\"\"Return the container for user field declarations. Created if not\n        found.\n\n        Return: Element\n        \"\"\"\n        user_field_decls = self.get_element(\"//text:user-field-decls\")\n        if user_field_decls is None:\n            body = self.document_body\n            if not body:\n                raise ValueError(\"Empty document.body\")\n            body.insert(Element.from_tag(\"text:user-field-decls\"), FIRST_CHILD)\n            user_field_decls = body.get_element(\"//text:user-field-decls\")\n\n        return user_field_decls\n\n    def get_user_field_decl_list(self) -&gt; list[Element]:\n        \"\"\"Return all the user field declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:user-field-decl\")\n\n    def get_user_field_decl(self, name: str, position: int = 0) -&gt; Element | None:\n        \"\"\"return the user field declaration for the given name.\n\n        return: Element or none if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:user-field-decl\", position, text_name=name\n        )\n\n    def get_user_field_value(\n        self, name: str, value_type: str | None = None\n    ) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n        \"\"\"Return the value of the given user field name.\n\n        Arguments:\n\n            name -- str\n\n            value_type -- 'boolean', 'currency', 'date', 'float',\n                          'percentage', 'string', 'time' or automatic\n\n        Return: most appropriate Python type\n        \"\"\"\n        user_field_decl = self.get_user_field_decl(name)\n        if user_field_decl is None:\n            return None\n        return user_field_decl.get_value(value_type)  # type: ignore\n\n    # User defined fields\n    # They are fields who should contain a copy of a user defined medtadata\n\n    def get_user_defined_list(self) -&gt; list[Element]:\n        \"\"\"Return all the user defined field declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:user-defined\")\n\n    @property\n    def user_defined_list(self) -&gt; list[Element]:\n        \"\"\"Return all the user defined field declarations.\n\n        Return: list of Element\n        \"\"\"\n        return self.get_user_defined_list()\n\n    def get_user_defined(self, name: str, position: int = 0) -&gt; Element | None:\n        \"\"\"return the user defined declaration for the given name.\n\n        return: Element or none if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:user-defined\", position, text_name=name\n        )\n\n    def get_user_defined_value(\n        self, name: str, value_type: str | None = None\n    ) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n        \"\"\"Return the value of the given user defined field name.\n\n        Arguments:\n\n            name -- str\n\n            value_type -- 'boolean', 'date', 'float',\n                          'string', 'time' or automatic\n\n        Return: most appropriate Python type\n        \"\"\"\n        user_defined = self.get_user_defined(name)\n        if user_defined is None:\n            return None\n        return user_defined.get_value(value_type)  # type: ignore\n\n    # Draw Pages\n\n    def get_draw_pages(\n        self,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw pages that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of DrawPage\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:page\", draw_style=style, content=content\n        )\n\n    def get_draw_page(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw page that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            content -- str regex\n\n        Return: DrawPage or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:page\", position, draw_name=name, content=content\n        )\n\n    # Links\n\n    def get_links(\n        self,\n        name: str | None = None,\n        title: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the links that match the criteria.\n\n        Arguments:\n\n            name -- str\n\n            title -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:a\",\n            office_name=name,\n            office_title=title,\n            url=url,\n            content=content,\n        )\n\n    def get_link(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        title: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the link that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n            title -- str\n\n            url -- str regex\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:a\",\n            position,\n            office_name=name,\n            office_title=title,\n            url=url,\n            content=content,\n        )\n\n    # Bookmarks\n\n    def get_bookmarks(self) -&gt; list[Element]:\n        \"\"\"Return all the bookmarks.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:bookmark\")\n\n    def get_bookmark(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the bookmark that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Bookmark or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:bookmark\", position, text_name=name\n        )\n\n    def get_bookmark_starts(self) -&gt; list[Element]:\n        \"\"\"Return all the bookmark starts.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:bookmark-start\")\n\n    def get_bookmark_start(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the bookmark start that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:bookmark-start\", position, text_name=name\n        )\n\n    def get_bookmark_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the bookmark ends.\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:bookmark-end\")\n\n    def get_bookmark_end(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the bookmark end that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:bookmark-end\", position, text_name=name\n        )\n\n    # Reference marks\n\n    def get_reference_marks_single(self) -&gt; list[Element]:\n        \"\"\"Return all the reference marks. Search only the tags\n        text:reference-mark.\n        Consider using : get_reference_marks()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:reference-mark\")\n\n    def get_reference_mark_single(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark that matches the criteria. Search only the\n        tags text:reference-mark.\n        Consider using : get_reference_mark()\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:reference-mark\", position, text_name=name\n        )\n\n    def get_reference_mark_starts(self) -&gt; list[Element]:\n        \"\"\"Return all the reference mark starts. Search only the tags\n        text:reference-mark-start.\n        Consider using : get_reference_marks()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:reference-mark-start\")\n\n    def get_reference_mark_start(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark start that matches the criteria. Search\n        only the tags text:reference-mark-start.\n        Consider using : get_reference_mark()\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:reference-mark-start\", position, text_name=name\n        )\n\n    def get_reference_mark_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the reference mark ends. Search only the tags\n        text:reference-mark-end.\n        Consider using : get_reference_marks()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:reference-mark-end\")\n\n    def get_reference_mark_end(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark end that matches the criteria. Search only\n        the tags text:reference-mark-end.\n        Consider using : get_reference_marks()\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:reference-mark-end\", position, text_name=name\n        )\n\n    def get_reference_marks(self) -&gt; list[Element]:\n        \"\"\"Return all the reference marks, either single position reference\n        (text:reference-mark) or start of range reference\n        (text:reference-mark-start).\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n        )\n\n    def get_reference_mark(\n        self,\n        position: int = 0,\n        name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the reference mark that match the criteria. Either single\n        position reference mark (text:reference-mark) or start of range\n        reference (text:reference-mark-start).\n\n        Arguments:\n\n            position -- int\n\n            name -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        if name:\n            request = (\n                f\"descendant::text:reference-mark-start\"\n                f'[@text:name=\"{name}\"] '\n                f\"| descendant::text:reference-mark\"\n                f'[@text:name=\"{name}\"]'\n            )\n            return self._filtered_element(request, position=0)\n        request = (\n            \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n        )\n        return self._filtered_element(request, position)\n\n    def get_references(self, name: str | None = None) -&gt; list[Element]:\n        \"\"\"Return all the references (text:reference-ref). If name is\n        provided, returns the references of that name.\n\n        Return: list of Element\n\n        Arguments:\n\n            name -- str or None\n        \"\"\"\n        if name is None:\n            return self._filtered_elements(\"descendant::text:reference-ref\")\n        request = f'descendant::text:reference-ref[@text:ref-name=\"{name}\"]'\n        return self._filtered_elements(request)\n\n    # Shapes elements\n\n    # Groups\n\n    def get_draw_groups(\n        self,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        return self._filtered_elements(\n            \"descendant::draw:g\",\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    def get_draw_group(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        return self._filtered_element(\n            \"descendant::draw:g\",\n            position,\n            draw_name=name,\n            svg_title=title,\n            svg_desc=description,\n            content=content,\n        )\n\n    # Lines\n\n    def get_draw_lines(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw lines that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:line\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_line(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw line that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:line\", position, draw_id=id, content=content\n        )\n\n    # Rectangles\n\n    def get_draw_rectangles(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw rectangles that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:rect\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_rectangle(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw rectangle that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:rect\", position, draw_id=id, content=content\n        )\n\n    # Ellipse\n\n    def get_draw_ellipses(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw ellipses that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:ellipse\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_ellipse(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw ellipse that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:ellipse\", position, draw_id=id, content=content\n        )\n\n    # Connectors\n\n    def get_draw_connectors(\n        self,\n        draw_style: str | None = None,\n        draw_text_style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Element]:\n        \"\"\"Return all the draw connectors that match the criteria.\n\n        Arguments:\n\n            draw_style -- str\n\n            draw_text_style -- str\n\n            content -- str regex\n\n        Return: list of odf_shape\n        \"\"\"\n        return self._filtered_elements(\n            \"descendant::draw:connector\",\n            draw_style=draw_style,\n            draw_text_style=draw_text_style,\n            content=content,\n        )\n\n    def get_draw_connector(\n        self,\n        position: int = 0,\n        id: str | None = None,  # noqa:A002\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the draw connector that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            id -- str\n\n            content -- str regex\n\n        Return: odf_shape or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::draw:connector\", position, draw_id=id, content=content\n        )\n\n    def get_orphan_draw_connectors(self) -&gt; list[Element]:\n        \"\"\"Return a list of connectors which don't have any shape connected\n        to them.\n        \"\"\"\n        connectors = []\n        for connector in self.get_draw_connectors():\n            start_shape = connector.get_attribute(\"draw:start-shape\")\n            end_shape = connector.get_attribute(\"draw:end-shape\")\n            if start_shape is None and end_shape is None:\n                connectors.append(connector)\n        return connectors\n\n    # Tracked changes and text change\n\n    def get_tracked_changes(self) -&gt; Element | None:\n        \"\"\"Return the tracked-changes part in the text body.\n\n        Return: Element or None\n        \"\"\"\n        return self.get_element(\"//text:tracked-changes\")\n\n    @property\n    def tracked_changes(self) -&gt; Element | None:\n        \"\"\"Return the tracked-changes part in the text body.\n\n        Return: Element or None\n        \"\"\"\n        return self.get_tracked_changes()\n\n    def get_changes_ids(self) -&gt; list[Element | EText]:\n        \"\"\"Return a list of ids that refers to a change region in the tracked\n        changes list.\n        \"\"\"\n        # Insertion changes\n        xpath_query = \"descendant::text:change-start/@text:change-id\"\n        # Deletion changes\n        xpath_query += \" | descendant::text:change/@text:change-id\"\n        return self.xpath(xpath_query)\n\n    def get_text_change_deletions(self) -&gt; list[Element]:\n        \"\"\"Return all the text changes of deletion kind: the tags text:change.\n        Consider using : get_text_changes()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:text:change\")\n\n    def get_text_change_deletion(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change of deletion kind that matches the criteria.\n        Search only for the tags text:change.\n        Consider using : get_text_change()\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:change\", position, change_id=idx\n        )\n\n    def get_text_change_starts(self) -&gt; list[Element]:\n        \"\"\"Return all the text change-start. Search only for the tags\n        text:change-start.\n        Consider using : get_text_changes()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:change-start\")\n\n    def get_text_change_start(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change-start that matches the criteria. Search\n        only the tags text:change-start.\n        Consider using : get_text_change()\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:change-start\", position, change_id=idx\n        )\n\n    def get_text_change_ends(self) -&gt; list[Element]:\n        \"\"\"Return all the text change-end. Search only the tags\n        text:change-end.\n        Consider using : get_text_changes()\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"descendant::text:change-end\")\n\n    def get_text_change_end(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change-end that matches the criteria. Search only\n        the tags text:change-end.\n        Consider using : get_text_change()\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"descendant::text:change-end\", position, change_id=idx\n        )\n\n    def get_text_changes(self) -&gt; list[Element]:\n        \"\"\"Return all the text changes, either single deletion\n        (text:change) or start of range of changes (text:change-start).\n\n        Return: list of Element\n        \"\"\"\n        request = \"descendant::text:change-start | descendant::text:change\"\n        return self._filtered_elements(request)\n\n    @property\n    def text_changes(self) -&gt; list[Element]:\n        \"\"\"Return all the text changes, either single deletion\n        (text:change) or start of range of changes (text:change-start).\n\n        Return: list of Element\n        \"\"\"\n        return self.get_text_changes()\n\n    def get_text_change(\n        self,\n        position: int = 0,\n        idx: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the text change that matches the criteria. Either single\n        deletion (text:change) or start of range of changes (text:change-start).\n        position : index of the element to retrieve if several matches, default\n        is 0.\n        idx : change-id of the element.\n\n        Arguments:\n\n            position -- int\n\n            idx -- str\n\n        Return: Element or None if not found\n        \"\"\"\n        if idx:\n            request = (\n                f'descendant::text:change-start[@text:change-id=\"{idx}\"] '\n                f'| descendant::text:change[@text:change-id=\"{idx}\"]'\n            )\n            return self._filtered_element(request, 0)\n        request = \"descendant::text:change-start | descendant::text:change\"\n        return self._filtered_element(request, position)\n\n    # Table Of Content\n\n    def get_tocs(self) -&gt; list[Element]:\n        \"\"\"Return all the tables of contents.\n\n        Return: list of odf_toc\n        \"\"\"\n        return self.get_elements(\"text:table-of-content\")\n\n    @property\n    def tocs(self) -&gt; list[Element]:\n        \"\"\"Return all the tables of contents.\n\n        Return: list of odf_toc\n        \"\"\"\n        return self.get_elements(\"text:table-of-content\")\n\n    def get_toc(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the table of contents that matches the criteria.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: odf_toc or None if not found\n        \"\"\"\n        return self._filtered_element(\n            \"text:table-of-content\", position, content=content\n        )\n\n    @property\n    def toc(self) -&gt; Element | None:\n        \"\"\"Return the first table of contents.\n\n        Return: odf_toc or None if not found\n        \"\"\"\n        return self.get_toc()\n\n    # Styles\n\n    @staticmethod\n    def _get_style_tagname(family: str | None, is_default: bool = False) -&gt; str:\n        \"\"\"Widely match possible tag names given the family (or not).\"\"\"\n        if not family:\n            tagname = \"(style:default-style|*[@style:name]|draw:fill-image|draw:marker)\"\n        elif is_default:\n            # Default style\n            tagname = \"style:default-style\"\n        else:\n            tagname = _family_style_tagname(family)\n            # if famattr:\n            #    # Include family default style\n            #    tagname = '(%s|style:default-style)' % tagname\n            if family in FAMILY_ODF_STD:\n                # Include family default style\n                tagname = f\"({tagname}|style:default-style)\"\n        return tagname\n\n    def get_styles(self, family: str | None = None) -&gt; list[Element]:\n        # Both common and default styles\n        tagname = self._get_style_tagname(family)\n        return self._filtered_elements(tagname, family=family)\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Element | None = None,\n        display_name: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the style uniquely identified by the family/name pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is not the internal name but the name you gave in the\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                      'number'\n\n            name_or_element -- str or Style\n\n            display_name -- str\n\n        Return: odf_style or None if not found\n        \"\"\"\n        if isinstance(name_or_element, Element):\n            name = self.get_attribute(\"style:name\")\n            if name is not None:\n                return name_or_element\n            else:\n                raise ValueError(f\"Not a odf_style ? {name_or_element!r}\")\n        style_name = name_or_element\n        is_default = not (style_name or display_name)\n        tagname = self._get_style_tagname(family, is_default=is_default)\n        # famattr became None if no \"style:family\" attribute\n        if family:\n            return self._filtered_element(\n                tagname,\n                0,\n                style_name=style_name,\n                display_name=display_name,\n                family=family,\n            )\n        else:\n            return self._filtered_element(\n                tagname,\n                0,\n                draw_name=style_name or display_name,\n                family=family,\n            )\n\n    def _filtered_element(\n        self,\n        query_string: str,\n        position: int,\n        **kwargs: Any,\n    ) -&gt; Element | None:\n        results = self._filtered_elements(query_string, **kwargs)\n        try:\n            return results[position]\n        except IndexError:\n            return None\n\n    def _filtered_elements(\n        self,\n        query_string: str,\n        content: str | None = None,\n        url: str | None = None,\n        svg_title: str | None = None,\n        svg_desc: str | None = None,\n        dc_creator: str | None = None,\n        dc_date: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; list[Element]:\n        query = make_xpath_query(query_string, **kwargs)\n        elements = self.get_elements(query)\n        # Filter the elements with the regex (TODO use XPath)\n        if content is not None:\n            elements = [element for element in elements if element.match(content)]\n        if url is not None:\n            filtered = []\n            for element in elements:\n                url_attr = element.get_attribute(\"xlink:href\")\n                if isinstance(url_attr, str) and search(url, url_attr) is not None:\n                    filtered.append(element)\n            elements = filtered\n        if dc_date is None:\n            dt_dc_date = None\n        else:\n            dt_dc_date = DateTime.encode(dc_date)\n        for variable, childname in [\n            (svg_title, \"svg:title\"),\n            (svg_desc, \"svg:desc\"),\n            (dc_creator, \"descendant::dc:creator\"),\n            (dt_dc_date, \"descendant::dc:date\"),\n        ]:\n            if not variable:\n                continue\n            filtered = []\n            for element in elements:\n                child = element.get_element(childname)\n                if child and child.match(variable):\n                    filtered.append(element)\n            elements = filtered\n        return elements\n</code></pre>"},{"location":"reference.html#odfdo.Element.document_body","title":"<code>document_body</code>  <code>property</code>","text":"<p>Return the first children of document body if any: \u2018office:body/*[1]\u2019</p>"},{"location":"reference.html#odfdo.Element.frames","title":"<code>frames</code>  <code>property</code>","text":"<p>Return all the frames.</p> <p>Return: list of Frame</p>"},{"location":"reference.html#odfdo.Element.headers","title":"<code>headers</code>  <code>property</code>","text":"<p>Return all the Headers.</p> <p>Return: list of Header</p>"},{"location":"reference.html#odfdo.Element.images","title":"<code>images</code>  <code>property</code>","text":"<p>Return all the images.</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.lists","title":"<code>lists</code>  <code>property</code>","text":"<p>Return all the lists.</p> <p>Return: list of List</p>"},{"location":"reference.html#odfdo.Element.paragraphs","title":"<code>paragraphs</code>  <code>property</code>","text":"<p>Return all the paragraphs.</p> <p>Return: list of Paragraph</p>"},{"location":"reference.html#odfdo.Element.sections","title":"<code>sections</code>  <code>property</code>","text":"<p>Return all the sections.</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.spans","title":"<code>spans</code>  <code>property</code>","text":"<p>Return all the spans.</p> <p>Return: list of Span</p>"},{"location":"reference.html#odfdo.Element.tag","title":"<code>tag</code>  <code>property</code> <code>writable</code>","text":"<p>Get/set the underlying xml tag with the given qualified name.</p> <p>Warning: direct change of tag does not change the element class.</p> <p>Arguments:</p> <pre><code>qname -- str (e.g. \"text:span\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.tail","title":"<code>tail</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text immediately following the element.</p>"},{"location":"reference.html#odfdo.Element.text","title":"<code>text</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text content of the element.</p>"},{"location":"reference.html#odfdo.Element.text_changes","title":"<code>text_changes</code>  <code>property</code>","text":"<p>Return all the text changes, either single deletion (text:change) or start of range of changes (text:change-start).</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.text_content","title":"<code>text_content</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text of the embedded paragraphs, including embeded annotations, cells\u2026</p> <p>Set does create a paragraph if missing.</p>"},{"location":"reference.html#odfdo.Element.toc","title":"<code>toc</code>  <code>property</code>","text":"<p>Return the first table of contents.</p> <p>Return: odf_toc or None if not found</p>"},{"location":"reference.html#odfdo.Element.tocs","title":"<code>tocs</code>  <code>property</code>","text":"<p>Return all the tables of contents.</p> <p>Return: list of odf_toc</p>"},{"location":"reference.html#odfdo.Element.tracked_changes","title":"<code>tracked_changes</code>  <code>property</code>","text":"<p>Return the tracked-changes part in the text body.</p> <p>Return: Element or None</p>"},{"location":"reference.html#odfdo.Element.user_defined_list","title":"<code>user_defined_list</code>  <code>property</code>","text":"<p>Return all the user defined field declarations.</p> <p>Return: list of Element</p>"},{"location":"reference.html#odfdo.Element.__append","title":"<code>__append(str_or_element)</code>","text":"<p>Insert element or text in the last position.</p> Source code in <code>odfdo/element.py</code> <pre><code>def __append(self, str_or_element: str | Element) -&gt; None:\n    \"\"\"Insert element or text in the last position.\"\"\"\n    current = self.__element\n    if isinstance(str_or_element, str):\n        # Has children ?\n        children = list(current.iterchildren())\n        if children:\n            # Append to tail of the last child\n            last_child = children[-1]\n            last_child.tail = self._add_text(last_child.tail, str_or_element)\n        else:\n            # Append to text of the element\n            current.text = self._add_text(current.text, str_or_element)\n    elif isinstance(str_or_element, Element):\n        current.append(str_or_element.__element)\n    else:\n        raise TypeError(f'Element or string expected, not \"{type(str_or_element)}\"')\n</code></pre>"},{"location":"reference.html#odfdo.Element.append_named_range","title":"<code>append_named_range(named_range)</code>","text":"<p>Append the named range to the spreadsheet, replacing existing named range of same name if any.</p> <p>Arguments:</p> <pre><code>named_range --  NamedRange\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def append_named_range(self, named_range: Element) -&gt; None:\n    \"\"\"Append the named range to the spreadsheet, replacing existing named\n    range of same name if any.\n\n    Arguments:\n\n        named_range --  NamedRange\n    \"\"\"\n    if self.tag != \"office:spreadsheet\":\n        raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n    named_expressions = self.get_element(\"table:named-expressions\")\n    if not named_expressions:\n        named_expressions = Element.from_tag(\"table:named-expressions\")\n        self.__append(named_expressions)\n    # exists ?\n    current = named_expressions.get_element(\n        f'table:named-range[@table:name=\"{named_range.name}\"][1]'  # type:ignore\n    )\n    if current:\n        named_expressions.delete(current)\n    named_expressions.__append(named_range)\n</code></pre>"},{"location":"reference.html#odfdo.Element.clear","title":"<code>clear()</code>","text":"<p>Remove text, children and attributes from the element.</p> Source code in <code>odfdo/element.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove text, children and attributes from the element.\"\"\"\n    self.__element.clear()\n</code></pre>"},{"location":"reference.html#odfdo.Element.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>if keep_tail is True (default), the tail text is not erased.</p> <p>Arguments:</p> <pre><code>child -- Element\n\nkeep_tail -- boolean (default to True), True for most usages.\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    if keep_tail is True (default), the tail text is not erased.\n\n    Arguments:\n\n        child -- Element\n\n        keep_tail -- boolean (default to True), True for most usages.\n    \"\"\"\n    if child is None:\n        parent = self.parent\n        if parent is None:\n            raise ValueError(f\"Can't delete the root element\\n{self.serialize()}\")\n        child = self\n    else:\n        parent = self\n    if keep_tail and child.__element.tail is not None:\n        current = child.__element\n        tail = str(current.tail)\n        current.tail = None\n        prev = current.getprevious()\n        if prev is not None:\n            if prev.tail is None:\n                prev.tail = tail\n            else:\n                prev.tail += tail\n        else:\n            if parent.__element.text is None:\n                parent.__element.text = tail\n            else:\n                parent.__element.text += tail\n    parent.__element.remove(child.__element)\n</code></pre>"},{"location":"reference.html#odfdo.Element.delete_named_range","title":"<code>delete_named_range(name)</code>","text":"<p>Delete the Named Range of specified name from the spreadsheet.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def delete_named_range(self, name: str) -&gt; None:\n    \"\"\"Delete the Named Range of specified name from the spreadsheet.\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    if self.tag != \"office:spreadsheet\":\n        raise ValueError(f\"Element is no 'office:spreadsheet' : {self.tag}\")\n    named_range = self.get_named_range(name)\n    if not named_range:\n        return\n    named_range.delete()\n    named_expressions = self.get_element(\"table:named-expressions\")\n    if not named_expressions:\n        return\n    element = named_expressions.__element\n    children = list(element.iterchildren())\n    if not children:\n        self.delete(named_expressions)\n</code></pre>"},{"location":"reference.html#odfdo.Element.elements_repeated_sequence","title":"<code>elements_repeated_sequence(xpath_instance, name)</code>","text":"<p>Utility method for table module.</p> Source code in <code>odfdo/element.py</code> <pre><code>def elements_repeated_sequence(\n    self,\n    xpath_instance: XPath,\n    name: str,\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Utility method for table module.\"\"\"\n    lxml_tag = _get_lxml_tag_or_name(name)\n    element = self.__element\n    sub_elements = xpath_instance(element)\n    if not isinstance(sub_elements, list):\n        raise TypeError(\"Bad XPath result.\")\n    result: list[tuple[int, int]] = []\n    idx = -1\n    for sub_element in sub_elements:\n        if not isinstance(sub_element, _Element):\n            continue\n        idx += 1\n        value = sub_element.get(lxml_tag)\n        if value is None:\n            result.append((idx, 1))\n            continue\n        try:\n            int_value = int(value)\n        except ValueError:\n            int_value = 1\n        result.append((idx, max(int_value, 1)))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Element.extend","title":"<code>extend(odf_elements)</code>","text":"<p>Fast append elements at the end of ourself using extend.</p> Source code in <code>odfdo/element.py</code> <pre><code>def extend(self, odf_elements: Iterable[Element]) -&gt; None:\n    \"\"\"Fast append elements at the end of ourself using extend.\"\"\"\n    if odf_elements:\n        current = self.__element\n        elements = [element.__element for element in odf_elements]\n        current.extend(elements)\n</code></pre>"},{"location":"reference.html#odfdo.Element.from_tag","title":"<code>from_tag(tag_or_elem)</code>  <code>classmethod</code>","text":"<p>Element class and subclass factory.</p> <p>Turn an lxml Element or ODF string tag into an ODF XML Element of the relevant class.</p> <p>Arguments:</p> <pre><code>tag_or_elem -- ODF str tag or lxml.Element\n</code></pre> <p>Return: Element (or subclass) instance</p> Source code in <code>odfdo/element.py</code> <pre><code>@classmethod\ndef from_tag(cls, tag_or_elem: str | _Element) -&gt; Element:\n    \"\"\"Element class and subclass factory.\n\n    Turn an lxml Element or ODF string tag into an ODF XML Element\n    of the relevant class.\n\n    Arguments:\n\n        tag_or_elem -- ODF str tag or lxml.Element\n\n    Return: Element (or subclass) instance\n    \"\"\"\n    if isinstance(tag_or_elem, str):\n        # assume the argument is a prefix:name tag\n        elem = cls.make_etree_element(tag_or_elem)\n    else:\n        elem = tag_or_elem\n    klass = _class_registry.get(elem.tag, cls)\n    return klass(tag_or_elem=elem)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotation","title":"<code>get_annotation(position=0, creator=None, start_date=None, end_date=None, content=None, name=None)</code>","text":"<p>Return the annotation that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncreator -- str\n\nstart_date -- datetime instance\n\nend_date -- datetime instance\n\ncontent -- str regex\n\nname -- str\n</code></pre> <p>Return: Annotation or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotation(\n    self,\n    position: int = 0,\n    creator: str | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    content: str | None = None,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the annotation that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        creator -- str\n\n        start_date -- datetime instance\n\n        end_date -- datetime instance\n\n        content -- str regex\n\n        name -- str\n\n    Return: Annotation or None if not found\n    \"\"\"\n    if name is not None:\n        return self._filtered_element(\n            \"descendant::office:annotation\", 0, office_name=name\n        )\n    annotations = self.get_annotations(\n        creator=creator, start_date=start_date, end_date=end_date, content=content\n    )\n    if not annotations:\n        return None\n    try:\n        return annotations[position]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotation_end","title":"<code>get_annotation_end(position=0, name=None)</code>","text":"<p>Return the annotation end that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotation_end(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the annotation end that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::office:annotation-end\", position, office_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotation_ends","title":"<code>get_annotation_ends()</code>","text":"<p>Return all the annotation ends.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotation_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the annotation ends.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::office:annotation-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_annotations","title":"<code>get_annotations(creator=None, start_date=None, end_date=None, content=None)</code>","text":"<p>Return all the annotations that match the criteria.</p> <p>Arguments:</p> <pre><code>creator -- str\n\nstart_date -- datetime instance\n\nend_date --  datetime instance\n\ncontent -- str regex\n</code></pre> <p>Return: list of Annotation</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_annotations(\n    self,\n    creator: str | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the annotations that match the criteria.\n\n    Arguments:\n\n        creator -- str\n\n        start_date -- datetime instance\n\n        end_date --  datetime instance\n\n        content -- str regex\n\n    Return: list of Annotation\n    \"\"\"\n    annotations = []\n    for annotation in self._filtered_elements(\n        \"descendant::office:annotation\", content=content\n    ):\n        if creator is not None and creator != annotation.dc_creator:\n            continue\n        date = annotation.date\n        if date is None:\n            continue\n        if start_date is not None and date &lt; start_date:\n            continue\n        if end_date is not None and date &gt;= end_date:\n            continue\n        annotations.append(annotation)\n    return annotations\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Return the attribute value as type str | bool | None.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_attribute(self, name: str) -&gt; str | bool | None:\n    \"\"\"Return the attribute value as type str | bool | None.\"\"\"\n    element = self.__element\n    lxml_tag = _get_lxml_tag_or_name(name)\n    value = element.get(lxml_tag)\n    if value is None:\n        return None\n    elif value in (\"true\", \"false\"):\n        return Boolean.decode(value)\n    return str(value)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_attribute_integer","title":"<code>get_attribute_integer(name)</code>","text":"<p>Return either the attribute as type int, or None.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_attribute_integer(self, name: str) -&gt; int | None:\n    \"\"\"Return either the attribute as type int, or None.\"\"\"\n    element = self.__element\n    lxml_tag = _get_lxml_tag_or_name(name)\n    value = element.get(lxml_tag)\n    if value is None:\n        return None\n    try:\n        return int(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_attribute_string","title":"<code>get_attribute_string(name)</code>","text":"<p>Return either the attribute as type str, or None.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_attribute_string(self, name: str) -&gt; str | None:\n    \"\"\"Return either the attribute as type str, or None.\"\"\"\n    element = self.__element\n    lxml_tag = _get_lxml_tag_or_name(name)\n    value = element.get(lxml_tag)\n    if value is None:\n        return None\n    return str(value)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_between","title":"<code>get_between(tag1, tag2, as_text=False, clean=True, no_header=True)</code>","text":"<p>Returns elements between tag1 and tag2, tag1 and tag2 shall be unique and having an id attribute. (WARN: buggy if tag1/tag2 defines a malformed odf xml.) If as_text is True: returns the text content. If clean is True: suppress unwanted tags (deletions marks, \u2026) If no_header is True: existing text:h are changed in text:p By default: returns a list of Element, cleaned and without headers.</p> <p>Implementation and standard retrictions: Only text:h and text:p sould be \u2018cut\u2019 by an insert tag, so inner parts of insert tags are:</p> <pre><code>- any text:h, text:p or sub tag of these\n\n- some text, part of a parent text:h or text:p\n</code></pre> <p>Arguments:</p> <pre><code>tag1 -- Element\n\ntag2 -- Element\n\nas_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list of odf_paragraph or odf_header</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_between(\n    self,\n    tag1: Element,\n    tag2: Element,\n    as_text: bool = False,\n    clean: bool = True,\n    no_header: bool = True,\n) -&gt; list | Element | str:\n    \"\"\"Returns elements between tag1 and tag2, tag1 and tag2 shall\n    be unique and having an id attribute.\n    (WARN: buggy if tag1/tag2 defines a malformed odf xml.)\n    If as_text is True: returns the text content.\n    If clean is True: suppress unwanted tags (deletions marks, ...)\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of Element, cleaned and without headers.\n\n    Implementation and standard retrictions:\n    Only text:h and text:p sould be 'cut' by an insert tag, so inner parts\n    of insert tags are:\n\n        - any text:h, text:p or sub tag of these\n\n        - some text, part of a parent text:h or text:p\n\n    Arguments:\n\n        tag1 -- Element\n\n        tag2 -- Element\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list of odf_paragraph or odf_header\n    \"\"\"\n    inner = self._get_between_base(tag1, tag2)\n\n    if clean:\n        clean_tags = (\n            \"text:change\",\n            \"text:change-start\",\n            \"text:change-end\",\n            \"text:reference-mark\",\n            \"text:reference-mark-start\",\n            \"text:reference-mark-end\",\n        )\n        request_self = \" | \".join([f\"self::{tag}\" for tag in clean_tags])\n        inner = [e for e in inner if not e.xpath(request_self)]\n        request = \" | \".join([f\"descendant::{tag}\" for tag in clean_tags])\n        for element in inner:\n            to_del = element.xpath(request)\n            for elem in to_del:\n                if isinstance(elem, Element):\n                    element.delete(elem)\n    if no_header:  # crude replace t:h by t:p\n        new_inner = []\n        for element in inner:\n            if element.tag == \"text:h\":\n                children = element.children\n                text = element.__element.text\n                para = Element.from_tag(\"text:p\")\n                para.text = text or \"\"\n                for child in children:\n                    para.__append(child)\n                new_inner.append(para)\n            else:\n                new_inner.append(element)\n        inner = new_inner\n    if as_text:\n        return \"\\n\".join([e.get_formatted_text() for e in inner])\n    else:\n        return inner\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark","title":"<code>get_bookmark(position=0, name=None)</code>","text":"<p>Return the bookmark that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Bookmark or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the bookmark that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Bookmark or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:bookmark\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_end","title":"<code>get_bookmark_end(position=0, name=None)</code>","text":"<p>Return the bookmark end that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_end(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the bookmark end that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:bookmark-end\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_ends","title":"<code>get_bookmark_ends()</code>","text":"<p>Return all the bookmark ends.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the bookmark ends.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:bookmark-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_start","title":"<code>get_bookmark_start(position=0, name=None)</code>","text":"<p>Return the bookmark start that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_start(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the bookmark start that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:bookmark-start\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmark_starts","title":"<code>get_bookmark_starts()</code>","text":"<p>Return all the bookmark starts.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmark_starts(self) -&gt; list[Element]:\n    \"\"\"Return all the bookmark starts.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:bookmark-start\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_bookmarks","title":"<code>get_bookmarks()</code>","text":"<p>Return all the bookmarks.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_bookmarks(self) -&gt; list[Element]:\n    \"\"\"Return all the bookmarks.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:bookmark\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_changes_ids","title":"<code>get_changes_ids()</code>","text":"<p>Return a list of ids that refers to a change region in the tracked changes list.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_changes_ids(self) -&gt; list[Element | EText]:\n    \"\"\"Return a list of ids that refers to a change region in the tracked\n    changes list.\n    \"\"\"\n    # Insertion changes\n    xpath_query = \"descendant::text:change-start/@text:change-id\"\n    # Deletion changes\n    xpath_query += \" | descendant::text:change/@text:change-id\"\n    return self.xpath(xpath_query)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_connector","title":"<code>get_draw_connector(position=0, id=None, content=None)</code>","text":"<p>Return the draw connector that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_connector(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw connector that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:connector\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_connectors","title":"<code>get_draw_connectors(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw connectors that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_connectors(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw connectors that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:connector\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_ellipse","title":"<code>get_draw_ellipse(position=0, id=None, content=None)</code>","text":"<p>Return the draw ellipse that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_ellipse(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw ellipse that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:ellipse\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_ellipses","title":"<code>get_draw_ellipses(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw ellipses that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_ellipses(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw ellipses that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:ellipse\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_line","title":"<code>get_draw_line(position=0, id=None, content=None)</code>","text":"<p>Return the draw line that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_line(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw line that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:line\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_lines","title":"<code>get_draw_lines(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw lines that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_lines(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw lines that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:line\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_page","title":"<code>get_draw_page(position=0, name=None, content=None)</code>","text":"<p>Return the draw page that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\ncontent -- str regex\n</code></pre> <p>Return: DrawPage or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_page(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw page that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        content -- str regex\n\n    Return: DrawPage or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:page\", position, draw_name=name, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_pages","title":"<code>get_draw_pages(style=None, content=None)</code>","text":"<p>Return all the draw pages that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of DrawPage</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_pages(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw pages that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of DrawPage\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:page\", draw_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_rectangle","title":"<code>get_draw_rectangle(position=0, id=None, content=None)</code>","text":"<p>Return the draw rectangle that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nid -- str\n\ncontent -- str regex\n</code></pre> <p>Return: odf_shape or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_rectangle(\n    self,\n    position: int = 0,\n    id: str | None = None,  # noqa:A002\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the draw rectangle that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        id -- str\n\n        content -- str regex\n\n    Return: odf_shape or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:rect\", position, draw_id=id, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_draw_rectangles","title":"<code>get_draw_rectangles(draw_style=None, draw_text_style=None, content=None)</code>","text":"<p>Return all the draw rectangles that match the criteria.</p> <p>Arguments:</p> <pre><code>draw_style -- str\n\ndraw_text_style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of odf_shape</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_draw_rectangles(\n    self,\n    draw_style: str | None = None,\n    draw_text_style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the draw rectangles that match the criteria.\n\n    Arguments:\n\n        draw_style -- str\n\n        draw_text_style -- str\n\n        content -- str regex\n\n    Return: list of odf_shape\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:rect\",\n        draw_style=draw_style,\n        draw_text_style=draw_text_style,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_formatted_text","title":"<code>get_formatted_text(context=None)</code>","text":"<p>This function should return a beautiful version of the text.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_formatted_text(self, context: dict | None = None) -&gt; str:\n    \"\"\"This function should return a beautiful version of the text.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_frame","title":"<code>get_frame(position=0, name=None, presentation_class=None, title=None, description=None, content=None)</code>","text":"<p>Return the section that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\npresentation_class -- str\n\ntitle -- str regex\n\ndescription -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: Frame or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_frame(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    presentation_class: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the section that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        presentation_class -- str\n\n        title -- str regex\n\n        description -- str regex\n\n        content -- str regex\n\n    Return: Frame or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::draw:frame\",\n        position,\n        draw_name=name,\n        presentation_class=presentation_class,\n        svg_title=title,\n        svg_desc=description,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_frames","title":"<code>get_frames(presentation_class=None, style=None, title=None, description=None, content=None)</code>","text":"<p>Return all the frames that match the criteria.</p> <p>Arguments:</p> <pre><code>presentation_class -- str\n\nstyle -- str\n\ntitle -- str regex\n\ndescription -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: list of Frame</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_frames(\n    self,\n    presentation_class: str | None = None,\n    style: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the frames that match the criteria.\n\n    Arguments:\n\n        presentation_class -- str\n\n        style -- str\n\n        title -- str regex\n\n        description -- str regex\n\n        content -- str regex\n\n    Return: list of Frame\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:frame\",\n        presentation_class=presentation_class,\n        draw_style=style,\n        svg_title=title,\n        svg_desc=description,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_header","title":"<code>get_header(position=0, outline_level=None, content=None)</code>","text":"<p>Return the Header that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Header or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_header(\n    self,\n    position: int = 0,\n    outline_level: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the Header that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Header or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:h\",\n        position,\n        outline_level=outline_level,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_headers","title":"<code>get_headers(style=None, outline_level=None, content=None)</code>","text":"<p>Return all the Headers that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Header</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_headers(\n    self,\n    style: str | None = None,\n    outline_level: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the Headers that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Header\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:h\",\n        text_style=style,\n        outline_level=outline_level,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_image","title":"<code>get_image(position=0, name=None, url=None, content=None)</code>","text":"<p>Return the image matching the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_image(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the image matching the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    # The frame is holding the name\n    if name is not None:\n        frame = self._filtered_element(\n            \"descendant::draw:frame\", position, draw_name=name\n        )\n        if frame is None:\n            return None\n        # The name is supposedly unique\n        return frame.get_element(\"draw:image\")\n    return self._filtered_element(\n        \"descendant::draw:image\", position, url=url, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_images","title":"<code>get_images(style=None, url=None, content=None)</code>","text":"<p>Return all the images matching the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_images(\n    self,\n    style: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the images matching the criteria.\n\n    Arguments:\n\n        style -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::draw:image\", text_style=style, url=url, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_link","title":"<code>get_link(position=0, name=None, title=None, url=None, content=None)</code>","text":"<p>Return the link that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n\ntitle -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_link(\n    self,\n    position: int = 0,\n    name: str | None = None,\n    title: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the link that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n        title -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:a\",\n        position,\n        office_name=name,\n        office_title=title,\n        url=url,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_links","title":"<code>get_links(name=None, title=None, url=None, content=None)</code>","text":"<p>Return all the links that match the criteria.</p> <p>Arguments:</p> <pre><code>name -- str\n\ntitle -- str\n\nurl -- str regex\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_links(\n    self,\n    name: str | None = None,\n    title: str | None = None,\n    url: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the links that match the criteria.\n\n    Arguments:\n\n        name -- str\n\n        title -- str\n\n        url -- str regex\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:a\",\n        office_name=name,\n        office_title=title,\n        url=url,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_list","title":"<code>get_list(position=0, content=None)</code>","text":"<p>Return the list that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: List or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_list(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the list that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: List or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:list\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_lists","title":"<code>get_lists(style=None, content=None)</code>","text":"<p>Return all the lists that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of List</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_lists(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the lists that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of List\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:list\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_named_range","title":"<code>get_named_range(name)</code>","text":"<p>Return the named range of specified name, or None if not found.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: NamedRange</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_named_range(self, name: str) -&gt; Element | None:\n    \"\"\"Return the named range of specified name, or None if not found.\n\n    Arguments:\n\n        name -- str\n\n    Return: NamedRange\n    \"\"\"\n    named_range = self.get_elements(\n        f'descendant::table:named-expressions/table:named-range[@table:name=\"{name}\"][1]'\n    )\n    if named_range:\n        return named_range[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_named_ranges","title":"<code>get_named_ranges()</code>","text":"<p>Return all the tables named ranges.</p> <p>Return: list of odf_named_range</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_named_ranges(self) -&gt; list[Element]:\n    \"\"\"Return all the tables named ranges.\n\n    Return: list of odf_named_range\n    \"\"\"\n    named_ranges = self.get_elements(\n        \"descendant::table:named-expressions/table:named-range\"\n    )\n    return named_ranges\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_note","title":"<code>get_note(position=0, note_id=None, note_class=None, content=None)</code>","text":"<p>Return the note that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\nnote_id -- str\n\nnote_class -- 'footnote' or 'endnote'\n\ncontent -- str regex\n</code></pre> <p>Return: Note or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_note(\n    self,\n    position: int = 0,\n    note_id: str | None = None,\n    note_class: str | None = None,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the note that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        note_id -- str\n\n        note_class -- 'footnote' or 'endnote'\n\n        content -- str regex\n\n    Return: Note or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:note\",\n        position,\n        text_id=note_id,\n        note_class=note_class,\n        content=content,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_notes","title":"<code>get_notes(note_class=None, content=None)</code>","text":"<p>Return all the notes that match the criteria.</p> <p>Arguments:</p> <pre><code>note_class -- 'footnote' or 'endnote'\n\ncontent -- str regex\n</code></pre> <p>Return: list of Note</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_notes(\n    self,\n    note_class: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the notes that match the criteria.\n\n    Arguments:\n\n        note_class -- 'footnote' or 'endnote'\n\n        content -- str regex\n\n    Return: list of Note\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:note\", note_class=note_class, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_office_names","title":"<code>get_office_names()</code>","text":"<p>Return all the used office:name tags values of the element.</p> <p>Return: list of unique str</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_office_names(self) -&gt; list[str]:\n    \"\"\"Return all the used office:name tags values of the element.\n\n    Return: list of unique str\n    \"\"\"\n    name_xpath_query = xpath_compile(\"//@office:name\")\n    response = name_xpath_query(self.__element)\n    if not isinstance(response, list):\n        return []\n    return list({str(name) for name in response if name})\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_orphan_draw_connectors","title":"<code>get_orphan_draw_connectors()</code>","text":"<p>Return a list of connectors which don\u2019t have any shape connected to them.</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_orphan_draw_connectors(self) -&gt; list[Element]:\n    \"\"\"Return a list of connectors which don't have any shape connected\n    to them.\n    \"\"\"\n    connectors = []\n    for connector in self.get_draw_connectors():\n        start_shape = connector.get_attribute(\"draw:start-shape\")\n        end_shape = connector.get_attribute(\"draw:end-shape\")\n        if start_shape is None and end_shape is None:\n            connectors.append(connector)\n    return connectors\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_paragraph","title":"<code>get_paragraph(position=0, content=None)</code>","text":"<p>Return the paragraph that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Paragraph or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_paragraph(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the paragraph that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Paragraph or None if not found\n    \"\"\"\n    return self._filtered_element(\"descendant::text:p\", position, content=content)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_paragraphs","title":"<code>get_paragraphs(style=None, content=None)</code>","text":"<p>Return all the paragraphs that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Paragraph</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_paragraphs(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the paragraphs that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Paragraph\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:p\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark","title":"<code>get_reference_mark(position=0, name=None)</code>","text":"<p>Return the reference mark that match the criteria. Either single position reference mark (text:reference-mark) or start of range reference (text:reference-mark-start).</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark that match the criteria. Either single\n    position reference mark (text:reference-mark) or start of range\n    reference (text:reference-mark-start).\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    if name:\n        request = (\n            f\"descendant::text:reference-mark-start\"\n            f'[@text:name=\"{name}\"] '\n            f\"| descendant::text:reference-mark\"\n            f'[@text:name=\"{name}\"]'\n        )\n        return self._filtered_element(request, position=0)\n    request = (\n        \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n    )\n    return self._filtered_element(request, position)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_end","title":"<code>get_reference_mark_end(position=0, name=None)</code>","text":"<p>Return the reference mark end that matches the criteria. Search only the tags text:reference-mark-end. Consider using : get_reference_marks()</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_end(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark end that matches the criteria. Search only\n    the tags text:reference-mark-end.\n    Consider using : get_reference_marks()\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:reference-mark-end\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_ends","title":"<code>get_reference_mark_ends()</code>","text":"<p>Return all the reference mark ends. Search only the tags text:reference-mark-end. Consider using : get_reference_marks()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the reference mark ends. Search only the tags\n    text:reference-mark-end.\n    Consider using : get_reference_marks()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:reference-mark-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_single","title":"<code>get_reference_mark_single(position=0, name=None)</code>","text":"<p>Return the reference mark that matches the criteria. Search only the tags text:reference-mark. Consider using : get_reference_mark()</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_single(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark that matches the criteria. Search only the\n    tags text:reference-mark.\n    Consider using : get_reference_mark()\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:reference-mark\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_start","title":"<code>get_reference_mark_start(position=0, name=None)</code>","text":"<p>Return the reference mark start that matches the criteria. Search only the tags text:reference-mark-start. Consider using : get_reference_mark()</p> <p>Arguments:</p> <pre><code>position -- int\n\nname -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_start(\n    self,\n    position: int = 0,\n    name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the reference mark start that matches the criteria. Search\n    only the tags text:reference-mark-start.\n    Consider using : get_reference_mark()\n\n    Arguments:\n\n        position -- int\n\n        name -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:reference-mark-start\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_mark_starts","title":"<code>get_reference_mark_starts()</code>","text":"<p>Return all the reference mark starts. Search only the tags text:reference-mark-start. Consider using : get_reference_marks()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_mark_starts(self) -&gt; list[Element]:\n    \"\"\"Return all the reference mark starts. Search only the tags\n    text:reference-mark-start.\n    Consider using : get_reference_marks()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:reference-mark-start\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_marks","title":"<code>get_reference_marks()</code>","text":"<p>Return all the reference marks, either single position reference (text:reference-mark) or start of range reference (text:reference-mark-start).</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_marks(self) -&gt; list[Element]:\n    \"\"\"Return all the reference marks, either single position reference\n    (text:reference-mark) or start of range reference\n    (text:reference-mark-start).\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:reference-mark-start | descendant::text:reference-mark\"\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_reference_marks_single","title":"<code>get_reference_marks_single()</code>","text":"<p>Return all the reference marks. Search only the tags text:reference-mark. Consider using : get_reference_marks()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_reference_marks_single(self) -&gt; list[Element]:\n    \"\"\"Return all the reference marks. Search only the tags\n    text:reference-mark.\n    Consider using : get_reference_marks()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:reference-mark\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_references","title":"<code>get_references(name=None)</code>","text":"<p>Return all the references (text:reference-ref). If name is provided, returns the references of that name.</p> <p>Return: list of Element</p> <p>Arguments:</p> <pre><code>name -- str or None\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def get_references(self, name: str | None = None) -&gt; list[Element]:\n    \"\"\"Return all the references (text:reference-ref). If name is\n    provided, returns the references of that name.\n\n    Return: list of Element\n\n    Arguments:\n\n        name -- str or None\n    \"\"\"\n    if name is None:\n        return self._filtered_elements(\"descendant::text:reference-ref\")\n    request = f'descendant::text:reference-ref[@text:ref-name=\"{name}\"]'\n    return self._filtered_elements(request)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_section","title":"<code>get_section(position=0, content=None)</code>","text":"<p>Return the section that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_section(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the section that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:section\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_sections","title":"<code>get_sections(style=None, content=None)</code>","text":"<p>Return all the sections that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_sections(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the sections that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\n        \"text:section\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_span","title":"<code>get_span(position=0, content=None)</code>","text":"<p>Return the span that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Span or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_span(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the span that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Span or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:span\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_spans","title":"<code>get_spans(style=None, content=None)</code>","text":"<p>Return all the spans that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Span</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_spans(\n    self,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Element]:\n    \"\"\"Return all the spans that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Span\n    \"\"\"\n    return self._filtered_elements(\n        \"descendant::text:span\", text_style=style, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the family/name pair. If the argument is already a style object, it will return it.</p> <p>If the name is not the internal name but the name you gave in the desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n          'number'\n\nname_or_element -- str or Style\n\ndisplay_name -- str\n</code></pre> <p>Return: odf_style or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Element | None = None,\n    display_name: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the style uniquely identified by the family/name pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is not the internal name but the name you gave in the\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text', 'graphic', 'table', 'list',\n                  'number'\n\n        name_or_element -- str or Style\n\n        display_name -- str\n\n    Return: odf_style or None if not found\n    \"\"\"\n    if isinstance(name_or_element, Element):\n        name = self.get_attribute(\"style:name\")\n        if name is not None:\n            return name_or_element\n        else:\n            raise ValueError(f\"Not a odf_style ? {name_or_element!r}\")\n    style_name = name_or_element\n    is_default = not (style_name or display_name)\n    tagname = self._get_style_tagname(family, is_default=is_default)\n    # famattr became None if no \"style:family\" attribute\n    if family:\n        return self._filtered_element(\n            tagname,\n            0,\n            style_name=style_name,\n            display_name=display_name,\n            family=family,\n        )\n    else:\n        return self._filtered_element(\n            tagname,\n            0,\n            draw_name=style_name or display_name,\n            family=family,\n        )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_styled_elements","title":"<code>get_styled_elements(name='')</code>","text":"<p>Brute-force to find paragraphs, tables, etc. using the given style name (or all by default).</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: list</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_styled_elements(self, name: str = \"\") -&gt; list[Element]:\n    \"\"\"Brute-force to find paragraphs, tables, etc. using the given style\n    name (or all by default).\n\n    Arguments:\n\n        name -- str\n\n    Return: list\n    \"\"\"\n    # FIXME incomplete (and possibly inaccurate)\n    return (\n        self._filtered_elements(\"descendant::*\", text_style=name)\n        + self._filtered_elements(\"descendant::*\", draw_style=name)\n        + self._filtered_elements(\"descendant::*\", draw_text_style=name)\n        + self._filtered_elements(\"descendant::*\", table_style=name)\n        + self._filtered_elements(\"descendant::*\", page_layout=name)\n        + self._filtered_elements(\"descendant::*\", master_page=name)\n        + self._filtered_elements(\"descendant::*\", parent_style=name)\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change","title":"<code>get_text_change(position=0, idx=None)</code>","text":"<p>Return the text change that matches the criteria. Either single deletion (text:change) or start of range of changes (text:change-start). position : index of the element to retrieve if several matches, default is 0. idx : change-id of the element.</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change that matches the criteria. Either single\n    deletion (text:change) or start of range of changes (text:change-start).\n    position : index of the element to retrieve if several matches, default\n    is 0.\n    idx : change-id of the element.\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    if idx:\n        request = (\n            f'descendant::text:change-start[@text:change-id=\"{idx}\"] '\n            f'| descendant::text:change[@text:change-id=\"{idx}\"]'\n        )\n        return self._filtered_element(request, 0)\n    request = \"descendant::text:change-start | descendant::text:change\"\n    return self._filtered_element(request, position)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_deletion","title":"<code>get_text_change_deletion(position=0, idx=None)</code>","text":"<p>Return the text change of deletion kind that matches the criteria. Search only for the tags text:change. Consider using : get_text_change()</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_deletion(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change of deletion kind that matches the criteria.\n    Search only for the tags text:change.\n    Consider using : get_text_change()\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:change\", position, change_id=idx\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_deletions","title":"<code>get_text_change_deletions()</code>","text":"<p>Return all the text changes of deletion kind: the tags text:change. Consider using : get_text_changes()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_deletions(self) -&gt; list[Element]:\n    \"\"\"Return all the text changes of deletion kind: the tags text:change.\n    Consider using : get_text_changes()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:text:change\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_end","title":"<code>get_text_change_end(position=0, idx=None)</code>","text":"<p>Return the text change-end that matches the criteria. Search only the tags text:change-end. Consider using : get_text_change()</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_end(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change-end that matches the criteria. Search only\n    the tags text:change-end.\n    Consider using : get_text_change()\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:change-end\", position, change_id=idx\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_ends","title":"<code>get_text_change_ends()</code>","text":"<p>Return all the text change-end. Search only the tags text:change-end. Consider using : get_text_changes()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_ends(self) -&gt; list[Element]:\n    \"\"\"Return all the text change-end. Search only the tags\n    text:change-end.\n    Consider using : get_text_changes()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:change-end\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_start","title":"<code>get_text_change_start(position=0, idx=None)</code>","text":"<p>Return the text change-start that matches the criteria. Search only the tags text:change-start. Consider using : get_text_change()</p> <p>Arguments:</p> <pre><code>position -- int\n\nidx -- str\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_start(\n    self,\n    position: int = 0,\n    idx: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the text change-start that matches the criteria. Search\n    only the tags text:change-start.\n    Consider using : get_text_change()\n\n    Arguments:\n\n        position -- int\n\n        idx -- str\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:change-start\", position, change_id=idx\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_change_starts","title":"<code>get_text_change_starts()</code>","text":"<p>Return all the text change-start. Search only for the tags text:change-start. Consider using : get_text_changes()</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_change_starts(self) -&gt; list[Element]:\n    \"\"\"Return all the text change-start. Search only for the tags\n    text:change-start.\n    Consider using : get_text_changes()\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:change-start\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_text_changes","title":"<code>get_text_changes()</code>","text":"<p>Return all the text changes, either single deletion (text:change) or start of range of changes (text:change-start).</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_text_changes(self) -&gt; list[Element]:\n    \"\"\"Return all the text changes, either single deletion\n    (text:change) or start of range of changes (text:change-start).\n\n    Return: list of Element\n    \"\"\"\n    request = \"descendant::text:change-start | descendant::text:change\"\n    return self._filtered_elements(request)\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_toc","title":"<code>get_toc(position=0, content=None)</code>","text":"<p>Return the table of contents that matches the criteria.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: odf_toc or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_toc(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the table of contents that matches the criteria.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: odf_toc or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"text:table-of-content\", position, content=content\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_tocs","title":"<code>get_tocs()</code>","text":"<p>Return all the tables of contents.</p> <p>Return: list of odf_toc</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_tocs(self) -&gt; list[Element]:\n    \"\"\"Return all the tables of contents.\n\n    Return: list of odf_toc\n    \"\"\"\n    return self.get_elements(\"text:table-of-content\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_tracked_changes","title":"<code>get_tracked_changes()</code>","text":"<p>Return the tracked-changes part in the text body.</p> <p>Return: Element or None</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_tracked_changes(self) -&gt; Element | None:\n    \"\"\"Return the tracked-changes part in the text body.\n\n    Return: Element or None\n    \"\"\"\n    return self.get_element(\"//text:tracked-changes\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_defined","title":"<code>get_user_defined(name, position=0)</code>","text":"<p>return the user defined declaration for the given name.</p> <p>return: Element or none if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_defined(self, name: str, position: int = 0) -&gt; Element | None:\n    \"\"\"return the user defined declaration for the given name.\n\n    return: Element or none if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:user-defined\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_defined_list","title":"<code>get_user_defined_list()</code>","text":"<p>Return all the user defined field declarations.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_defined_list(self) -&gt; list[Element]:\n    \"\"\"Return all the user defined field declarations.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:user-defined\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_defined_value","title":"<code>get_user_defined_value(name, value_type=None)</code>","text":"<p>Return the value of the given user defined field name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nvalue_type -- 'boolean', 'date', 'float',\n              'string', 'time' or automatic\n</code></pre> <p>Return: most appropriate Python type</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_defined_value(\n    self, name: str, value_type: str | None = None\n) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n    \"\"\"Return the value of the given user defined field name.\n\n    Arguments:\n\n        name -- str\n\n        value_type -- 'boolean', 'date', 'float',\n                      'string', 'time' or automatic\n\n    Return: most appropriate Python type\n    \"\"\"\n    user_defined = self.get_user_defined(name)\n    if user_defined is None:\n        return None\n    return user_defined.get_value(value_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_decl","title":"<code>get_user_field_decl(name, position=0)</code>","text":"<p>return the user field declaration for the given name.</p> <p>return: Element or none if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_decl(self, name: str, position: int = 0) -&gt; Element | None:\n    \"\"\"return the user field declaration for the given name.\n\n    return: Element or none if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:user-field-decl\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_decl_list","title":"<code>get_user_field_decl_list()</code>","text":"<p>Return all the user field declarations.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_decl_list(self) -&gt; list[Element]:\n    \"\"\"Return all the user field declarations.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:user-field-decl\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_decls","title":"<code>get_user_field_decls()</code>","text":"<p>Return the container for user field declarations. Created if not found.</p> <p>Return: Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_decls(self) -&gt; Element | None:\n    \"\"\"Return the container for user field declarations. Created if not\n    found.\n\n    Return: Element\n    \"\"\"\n    user_field_decls = self.get_element(\"//text:user-field-decls\")\n    if user_field_decls is None:\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Empty document.body\")\n        body.insert(Element.from_tag(\"text:user-field-decls\"), FIRST_CHILD)\n        user_field_decls = body.get_element(\"//text:user-field-decls\")\n\n    return user_field_decls\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_user_field_value","title":"<code>get_user_field_value(name, value_type=None)</code>","text":"<p>Return the value of the given user field name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nvalue_type -- 'boolean', 'currency', 'date', 'float',\n              'percentage', 'string', 'time' or automatic\n</code></pre> <p>Return: most appropriate Python type</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_user_field_value(\n    self, name: str, value_type: str | None = None\n) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n    \"\"\"Return the value of the given user field name.\n\n    Arguments:\n\n        name -- str\n\n        value_type -- 'boolean', 'currency', 'date', 'float',\n                      'percentage', 'string', 'time' or automatic\n\n    Return: most appropriate Python type\n    \"\"\"\n    user_field_decl = self.get_user_field_decl(name)\n    if user_field_decl is None:\n        return None\n    return user_field_decl.get_value(value_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_decl","title":"<code>get_variable_decl(name, position=0)</code>","text":"<p>return the variable declaration for the given name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nposition -- int\n</code></pre> <p>return: Element or none if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_decl(self, name: str, position: int = 0) -&gt; Element | None:\n    \"\"\"return the variable declaration for the given name.\n\n    Arguments:\n\n        name -- str\n\n        position -- int\n\n    return: Element or none if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:variable-decl\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_decl_list","title":"<code>get_variable_decl_list()</code>","text":"<p>Return all the variable declarations.</p> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_decl_list(self) -&gt; list[Element]:\n    \"\"\"Return all the variable declarations.\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:variable-decl\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_decls","title":"<code>get_variable_decls()</code>","text":"<p>Return the container for variable declarations. Created if not found.</p> <p>Return: Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_decls(self) -&gt; Element:\n    \"\"\"Return the container for variable declarations. Created if not\n    found.\n\n    Return: Element\n    \"\"\"\n    variable_decls = self.get_element(\"//text:variable-decls\")\n    if variable_decls is None:\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Empty document.body\")\n        body.insert(Element.from_tag(\"text:variable-decls\"), FIRST_CHILD)\n        variable_decls = body.get_element(\"//text:variable-decls\")\n\n    return variable_decls  # type:ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_set","title":"<code>get_variable_set(name, position=-1)</code>","text":"<p>Return the variable set for the given name (last one by default).</p> <p>Arguments:</p> <pre><code>name -- str\n\nposition -- int\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_set(self, name: str, position: int = -1) -&gt; Element | None:\n    \"\"\"Return the variable set for the given name (last one by default).\n\n    Arguments:\n\n        name -- str\n\n        position -- int\n\n    Return: Element or None if not found\n    \"\"\"\n    return self._filtered_element(\n        \"descendant::text:variable-set\", position, text_name=name\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_set_value","title":"<code>get_variable_set_value(name, value_type=None)</code>","text":"<p>Return the last value of the given variable name.</p> <p>Arguments:</p> <pre><code>name -- str\n\nvalue_type -- 'boolean', 'currency', 'date', 'float',\n              'percentage', 'string', 'time' or automatic\n</code></pre> <p>Return: most appropriate Python type</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_set_value(\n    self,\n    name: str,\n    value_type: str | None = None,\n) -&gt; bool | str | int | float | Decimal | datetime | timedelta | None:\n    \"\"\"Return the last value of the given variable name.\n\n    Arguments:\n\n        name -- str\n\n        value_type -- 'boolean', 'currency', 'date', 'float',\n                      'percentage', 'string', 'time' or automatic\n\n    Return: most appropriate Python type\n    \"\"\"\n    variable_set = self.get_variable_set(name)\n    if not variable_set:\n        return None\n    return variable_set.get_value(value_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Element.get_variable_sets","title":"<code>get_variable_sets(name=None)</code>","text":"<p>Return all the variable sets that match the criteria.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/element.py</code> <pre><code>def get_variable_sets(self, name: str | None = None) -&gt; list[Element]:\n    \"\"\"Return all the variable sets that match the criteria.\n\n    Arguments:\n\n        name -- str\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"descendant::text:variable-set\", text_name=name)\n</code></pre>"},{"location":"reference.html#odfdo.Element.index","title":"<code>index(child)</code>","text":"<p>Return the position of the child in this element.</p> <p>Inspired by lxml</p> Source code in <code>odfdo/element.py</code> <pre><code>def index(self, child: Element) -&gt; int:\n    \"\"\"Return the position of the child in this element.\n\n    Inspired by lxml\n    \"\"\"\n    return self.__element.index(child.__element)\n</code></pre>"},{"location":"reference.html#odfdo.Element.insert","title":"<code>insert(element, xmlposition=None, position=None, start=False)</code>","text":"<p>Insert an element relatively to ourself.</p> <p>Insert either using DOM vocabulary or by numeric position. If text start is True, insert the element before any existing text.</p> <p>Position start at 0.</p> <p>Arguments:</p> <pre><code>element -- Element\n\nxmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING\n               or PREV_SIBLING\n\nstart -- Boolean\n\nposition -- int\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def insert(\n    self,\n    element: Element,\n    xmlposition: int | None = None,\n    position: int | None = None,\n    start: bool = False,\n) -&gt; None:\n    \"\"\"Insert an element relatively to ourself.\n\n    Insert either using DOM vocabulary or by numeric position.\n    If text start is True, insert the element before any existing text.\n\n    Position start at 0.\n\n    Arguments:\n\n        element -- Element\n\n        xmlposition -- FIRST_CHILD, LAST_CHILD, NEXT_SIBLING\n                       or PREV_SIBLING\n\n        start -- Boolean\n\n        position -- int\n    \"\"\"\n    # child_tag = element.tag\n    current = self.__element\n    lx_element = element.__element\n    if start:\n        text = current.text\n        if text is not None:\n            current.text = None\n            tail = lx_element.tail\n            if tail is None:\n                tail = text\n            else:\n                tail = tail + text\n            lx_element.tail = tail\n        position = 0\n    if position is not None:\n        current.insert(position, lx_element)\n    elif xmlposition is FIRST_CHILD:\n        current.insert(0, lx_element)\n    elif xmlposition is LAST_CHILD:\n        current.append(lx_element)\n    elif xmlposition is NEXT_SIBLING:\n        parent = current.getparent()\n        index = parent.index(current)  # type: ignore\n        parent.insert(index + 1, lx_element)  # type: ignore\n    elif xmlposition is PREV_SIBLING:\n        parent = current.getparent()\n        index = parent.index(current)  # type: ignore\n        parent.insert(index, lx_element)  # type: ignore\n    else:\n        raise ValueError(\"(xml)position must be defined\")\n</code></pre>"},{"location":"reference.html#odfdo.Element.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the element is empty : no text, no children, no tail.</p> <p>Return: Boolean</p> Source code in <code>odfdo/element.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the element is empty : no text, no children, no tail.\n\n    Return: Boolean\n    \"\"\"\n    element = self.__element\n    if element.tail is not None:\n        return False\n    if element.text is not None:\n        return False\n    if list(element.iterchildren()):  # noqa: SIM103\n        return False\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Element.match","title":"<code>match(pattern)</code>","text":"<p>return True if the pattern is found one or more times anywhere in the text content of the element.</p> <p>Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n</code></pre> <p>Return: bool</p> Source code in <code>odfdo/element.py</code> <pre><code>def match(self, pattern: str) -&gt; bool:\n    \"\"\"return True if the pattern is found one or more times anywhere in\n    the text content of the element.\n\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n    Return: bool\n    \"\"\"\n    return self.search(pattern) is not None\n</code></pre>"},{"location":"reference.html#odfdo.Element.replace","title":"<code>replace(pattern, new=None, formatted=False)</code>","text":"<p>Replace the pattern with the given text, or delete if text is an empty string, and return the number of replacements. By default, only return the number of occurences that would be replaced.</p> <p>It cannot replace patterns found across several element, like a word split into two consecutive spans.</p> <p>Python regular expression syntax applies.</p> <p>If formatted is True, and the target is a Paragraph, Span or Header, and the replacement text contains spaces, tabs or newlines, try to convert them into actual ODF elements to obtain a formatted result. On very complex contents, result may differ of expectations.</p> <p>Arguments:</p> <pre><code>pattern -- str\n\nnew -- str\n\nformatted -- bool\n</code></pre> <p>Return: int</p> Source code in <code>odfdo/element.py</code> <pre><code>def replace(\n    self,\n    pattern: str,\n    new: str | None = None,\n    formatted: bool = False,\n) -&gt; int:\n    \"\"\"Replace the pattern with the given text, or delete if text is an\n    empty string, and return the number of replacements. By default, only\n    return the number of occurences that would be replaced.\n\n    It cannot replace patterns found across several element, like a word\n    split into two consecutive spans.\n\n    Python regular expression syntax applies.\n\n    If formatted is True, and the target is a Paragraph, Span or Header,\n    and the replacement text contains spaces, tabs or newlines, try to\n    convert them into actual ODF elements to obtain a formatted result.\n    On very complex contents, result may differ of expectations.\n\n    Arguments:\n\n        pattern -- str\n\n        new -- str\n\n        formatted -- bool\n\n    Return: int\n    \"\"\"\n    if not isinstance(pattern, str):\n        # Fail properly if the pattern is an non-ascii bytestring\n        pattern = str(pattern)\n    cpattern = re.compile(pattern)\n    count = 0\n    for text in self.xpath(\"descendant::text()\"):\n        if new is None:\n            count += len(cpattern.findall(str(text)))\n        else:\n            new_text, number = cpattern.subn(new, str(text))\n            container = text.parent\n            if not container:\n                continue\n            if text.is_text():  # type: ignore\n                container.text = new_text  # type: ignore\n            else:\n                container.tail = new_text  # type: ignore\n            if formatted and container.tag in {  # type; ignore\n                \"text:h\",\n                \"text:p\",\n                \"text:span\",\n            }:\n                container.append_plain_text(\"\")  # type; ignore\n            count += number\n    return count\n</code></pre>"},{"location":"reference.html#odfdo.Element.replace_element","title":"<code>replace_element(old_element, new_element)</code>","text":"<p>Replaces in place a sub element with the element passed as second argument.</p> <p>Warning : no clone for old element.</p> Source code in <code>odfdo/element.py</code> <pre><code>def replace_element(self, old_element: Element, new_element: Element) -&gt; None:\n    \"\"\"Replaces in place a sub element with the element passed as second\n    argument.\n\n    Warning : no clone for old element.\n    \"\"\"\n    current = self.__element\n    current.replace(old_element.__element, new_element.__element)\n</code></pre>"},{"location":"reference.html#odfdo.Element.search","title":"<code>search(pattern)</code>","text":"<p>Return the first position of the pattern in the text content of the element, or None if not found.</p> <p>Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n</code></pre> <p>Return: int or None</p> Source code in <code>odfdo/element.py</code> <pre><code>def search(self, pattern: str) -&gt; int | None:\n    \"\"\"Return the first position of the pattern in the text content of\n    the element, or None if not found.\n\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n    Return: int or None\n    \"\"\"\n    match = re.search(pattern, self.text_recursive)\n    if match is None:\n        return None\n    return match.start()\n</code></pre>"},{"location":"reference.html#odfdo.Element.search_all","title":"<code>search_all(pattern)</code>","text":"<p>Return all start and end positions of the regex pattern in the text content of the element.</p> <p>Result is a list of tuples of start and end position of the matches. Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n</code></pre> <p>Return: list[tuple[int,int]]</p> Source code in <code>odfdo/element.py</code> <pre><code>def search_all(self, pattern: str) -&gt; list[tuple[int, int]]:\n    \"\"\"Return all start and end positions of the regex pattern in\n    the text content of the element.\n\n    Result is a list of tuples of start and end position of\n    the matches.\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n    Return: list[tuple[int,int]]\n    \"\"\"\n    results: list[tuple[int, int]] = []\n    for match in re.finditer(pattern, self.text_recursive):\n        results.append((match.start(), match.end()))\n    return results\n</code></pre>"},{"location":"reference.html#odfdo.Element.search_first","title":"<code>search_first(pattern)</code>","text":"<p>Return the start and end position of the first occurence of the regex pattern in the text content of the element.</p> <p>Result is tuples of start and end position, or None. Python regular expression syntax applies.</p> <p>Arguments:</p> <pre><code>pattern -- str\n</code></pre> <p>Return: tuple[int,int] or None</p> Source code in <code>odfdo/element.py</code> <pre><code>def search_first(self, pattern: str) -&gt; tuple[int, int] | None:\n    \"\"\"Return the start and end position of the first occurence\n    of the regex pattern in the text content of the element.\n\n    Result is tuples of start and end position, or None.\n    Python regular expression syntax applies.\n\n    Arguments:\n\n        pattern -- str\n\n    Return: tuple[int,int] or None\n    \"\"\"\n    match = re.search(pattern, self.text_recursive)\n    if match is None:\n        return None\n    return match.start(), match.end()\n</code></pre>"},{"location":"reference.html#odfdo.Element.serialize","title":"<code>serialize(pretty=False, with_ns=False)</code>","text":"<p>Return text serialization of XML element.</p> Source code in <code>odfdo/element.py</code> <pre><code>def serialize(self, pretty: bool = False, with_ns: bool = False) -&gt; str:\n    \"\"\"Return text serialization of XML element.\"\"\"\n    # This copy bypasses serialization side-effects in lxml\n    native = deepcopy(self.__element)\n    data = tostring(\n        native, with_tail=False, pretty_print=pretty, encoding=\"unicode\"\n    )\n    if with_ns:\n        return data\n    # Remove namespaces\n    return self._strip_namespaces(data)\n</code></pre>"},{"location":"reference.html#odfdo.Element.set_style_attribute","title":"<code>set_style_attribute(name, value)</code>","text":"<p>Shortcut to accept a style object as a value.</p> Source code in <code>odfdo/element.py</code> <pre><code>def set_style_attribute(self, name: str, value: Element | str) -&gt; None:\n    \"\"\"Shortcut to accept a style object as a value.\"\"\"\n    if isinstance(value, Element):\n        value = str(value.name)  # type:ignore\n    return self.set_attribute(name, value)\n</code></pre>"},{"location":"reference.html#odfdo.Element.strip_elements","title":"<code>strip_elements(sub_elements)</code>","text":"<p>Remove the tags of provided elements, keeping inner childs and text.</p> <p>Return : the striped element.</p> <p>Warning : no clone in sub_elements list.</p> <p>Arguments:</p> <pre><code>sub_elements -- Element or list of Element\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def strip_elements(\n    self,\n    sub_elements: Element | Iterable[Element],\n) -&gt; Element | list:\n    \"\"\"Remove the tags of provided elements, keeping inner childs and text.\n\n    Return : the striped element.\n\n    Warning : no clone in sub_elements list.\n\n    Arguments:\n\n        sub_elements -- Element or list of Element\n    \"\"\"\n    if not sub_elements:\n        return self\n    if isinstance(sub_elements, Element):\n        sub_elements = (sub_elements,)\n    replacer = _get_lxml_tag(\"text:this-will-be-removed\")\n    for element in sub_elements:\n        element.__element.tag = replacer\n    strip = (\"text:this-will-be-removed\",)\n    return self.strip_tags(strip=strip, default=None)\n</code></pre>"},{"location":"reference.html#odfdo.Element.strip_tags","title":"<code>strip_tags(strip=None, protect=None, default='text:p')</code>","text":"<p>Remove the tags listed in strip, recursively, keeping inner childs and text. Tags listed in protect stop the removal one level depth. If the first level element is stripped, default is used to embed the content in the default element. If default is None and first level is striped, a list of text and children is returned. Return : the striped element.</p> <p>strip_tags should be used by on purpose methods (strip_span \u2026) (Method name taken from lxml).</p> <p>Arguments:</p> <pre><code>strip -- iterable list of str odf tags, or None\n\nprotect -- iterable list of str odf tags, or None\n\ndefault -- str odf tag, or None\n</code></pre> <p>Return:</p> <pre><code>Element.\n</code></pre> Source code in <code>odfdo/element.py</code> <pre><code>def strip_tags(\n    self,\n    strip: Iterable[str] | None = None,\n    protect: Iterable[str] | None = None,\n    default: str | None = \"text:p\",\n) -&gt; Element | list:\n    \"\"\"Remove the tags listed in strip, recursively, keeping inner childs\n    and text. Tags listed in protect stop the removal one level depth. If\n    the first level element is stripped, default is used to embed the\n    content in the default element. If default is None and first level is\n    striped, a list of text and children is returned. Return : the striped\n    element.\n\n    strip_tags should be used by on purpose methods (strip_span ...)\n    (Method name taken from lxml).\n\n    Arguments:\n\n        strip -- iterable list of str odf tags, or None\n\n        protect -- iterable list of str odf tags, or None\n\n        default -- str odf tag, or None\n\n    Return:\n\n        Element.\n    \"\"\"\n    if not strip:\n        return self\n    if not protect:\n        protect = ()\n    protected = False\n    element, modified = Element._strip_tags(self, strip, protect, protected)\n    if modified and isinstance(element, list) and default:\n        new = Element.from_tag(default)\n        for content in element:\n            if isinstance(content, Element):\n                new.__append(content)\n            else:\n                new.text = content\n        element = new\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Element.text_at","title":"<code>text_at(start, end=None)</code>","text":"<p>Return the text (recursive) content of the element between start and end position.</p> <p>If the end parameter is not set, return from start to the end of the recursive text.</p> <p>Arguments:</p> <pre><code>start -- int\nend -- int or None\n</code></pre> <p>Return: str</p> Source code in <code>odfdo/element.py</code> <pre><code>def text_at(self, start: int, end: int | None = None) -&gt; str:\n    \"\"\"Return the text (recursive) content of the element between\n    start and end position.\n\n    If the end parameter is not set, return from start to the end\n    of the recursive text.\n\n    Arguments:\n\n        start -- int\n        end -- int or None\n\n    Return: str\n    \"\"\"\n    if start &lt; 0:\n        start = 0\n    if end is None:\n        return self.text_recursive[start:]\n    else:\n        if end &lt; start:\n            end = start\n        return self.text_recursive[start:end]\n</code></pre>"},{"location":"reference.html#odfdo.Element.xpath","title":"<code>xpath(xpath_query)</code>","text":"<p>Apply XPath query to the element and its subtree. Return list of Element or EText instances translated from the nodes found.</p> Source code in <code>odfdo/element.py</code> <pre><code>def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n    \"\"\"Apply XPath query to the element and its subtree. Return list of\n    Element or EText instances translated from the nodes found.\n    \"\"\"\n    element = self.__element\n    xpath_instance = xpath_compile(xpath_query)\n    elements = xpath_instance(element)\n    result: list[Element | EText] = []\n    if hasattr(elements, \"__iter__\"):\n        for obj in elements:  # type: ignore\n            if isinstance(obj, (str, bytes)):\n                result.append(EText(obj))\n            elif isinstance(obj, _Element):\n                result.append(Element.from_tag(obj))\n            # else:\n            #     result.append(obj)\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.ElementTyped","title":"<code>ElementTyped</code>","text":"<p>               Bases: <code>Element</code></p> Source code in <code>odfdo/element_typed.py</code> <pre><code>class ElementTyped(Element):\n    def set_value_and_type(\n        self,\n        value: Any,\n        value_type: str | None = None,\n        text: str | None = None,\n        currency: str | None = None,\n    ) -&gt; str | None:\n        # Remove possible previous value and type\n        for name in (\n            \"office:value-type\",\n            \"office:boolean-value\",\n            \"office:value\",\n            \"office:date-value\",\n            \"office:string-value\",\n            \"office:time-value\",\n            \"table:formula\",\n            \"office:currency\",\n            \"calcext:value-type\",\n            \"loext:value-type\",\n        ):\n            with contextlib.suppress(KeyError):\n                self.del_attribute(name)\n        if isinstance(value, bytes):\n            value = bytes_to_str(value)\n        if isinstance(value_type, bytes):\n            value_type = bytes_to_str(value_type)\n        if isinstance(text, bytes):\n            text = bytes_to_str(text)\n        if isinstance(currency, bytes):\n            currency = bytes_to_str(currency)\n        if value is None:\n            self._erase_text_content()\n            return text\n        if isinstance(value, bool):\n            if value_type is None:\n                value_type = \"boolean\"\n            if text is None:\n                text = \"true\" if value else \"false\"\n            value = Boolean.encode(value)\n        elif isinstance(value, (int, float, Decimal)):\n            if value_type == \"percentage\":\n                text = f\"{int(value * 100)} %\"\n            if value_type is None:\n                value_type = \"float\"\n            if text is None:\n                text = str(value)\n            value = str(value)\n        elif isinstance(value, datetime):\n            if value_type is None:\n                value_type = \"date\"\n            if text is None:\n                text = str(DateTime.encode(value))\n            value = DateTime.encode(value)\n        elif isinstance(value, date):\n            if value_type is None:\n                value_type = \"date\"\n            if text is None:\n                text = str(Date.encode(value))\n            value = Date.encode(value)\n        elif isinstance(value, str):\n            if value_type is None:\n                value_type = \"string\"\n            if text is None:\n                text = value\n        elif isinstance(value, timedelta):\n            if value_type is None:\n                value_type = \"time\"\n            if text is None:\n                text = str(Duration.encode(value))\n            value = Duration.encode(value)\n        elif value is not None:\n            raise TypeError(f\"Type unknown: '{value!r}'\")\n\n        if value_type is not None:\n            self.set_attribute(\"office:value-type\", value_type)\n            self.set_attribute(\"calcext:value-type\", value_type)\n        if value_type == \"boolean\":\n            self.set_attribute(\"office:boolean-value\", value)\n        elif value_type == \"currency\":\n            self.set_attribute(\"office:value\", value)\n            self.set_attribute(\"office:currency\", currency)\n        elif value_type == \"date\":\n            self.set_attribute(\"office:date-value\", value)\n        elif value_type in (\"float\", \"percentage\"):\n            self.set_attribute(\"office:value\", value)\n            self.set_attribute(\"calcext:value\", value)\n        elif value_type == \"string\":\n            self.set_attribute(\"office:string-value\", value)\n        elif value_type == \"time\":\n            self.set_attribute(\"office:time-value\", value)\n\n        return text\n\n    def _get_typed_value_boolean(self) -&gt; Any:\n        return self.get_attribute(\"office:boolean-value\")\n\n    def _get_typed_value_number_type(self) -&gt; Decimal | int | float:\n        read_number = self.get_attribute(\"office:value\")\n        if not isinstance(read_number, (Decimal, str)):\n            raise TypeError(f'Wrong type for \"office:value\": {type(read_number)}')\n        value = Decimal(read_number)\n        # Return 3 instead of 3.0 if possible\n        with contextlib.suppress(ValueError):\n            if int(value) == value:\n                return int(value)\n        return value\n\n    def _get_typed_value_float(self) -&gt; Decimal | int | float:\n        return self._get_typed_value_number_type()\n\n    def _get_typed_value_percentage(self) -&gt; Decimal | int | float:\n        return self._get_typed_value_number_type()\n\n    def _get_typed_value_currency(self) -&gt; Decimal | int | float:\n        return self._get_typed_value_number_type()\n\n    def _get_typed_value_date(self) -&gt; date | datetime:\n        read_attribute = self.get_attribute(\"office:date-value\")\n        if not isinstance(read_attribute, str):\n            raise TypeError(\n                f'Wrong type for \"office:date-value\": {type(read_attribute)}'\n            )\n        if \"T\" in read_attribute:\n            return DateTime.decode(read_attribute)\n        return Date.decode(read_attribute)\n\n    def _get_typed_value_string(self, try_get_text: bool) -&gt; str | None:\n        value = self.get_attribute(\"office:string-value\")\n        if value is not None:\n            return str(value)\n        if try_get_text:\n            list_value = [para.inner_text for para in self.get_elements(\"text:p\")]\n            if list_value:\n                return \"\\n\".join(list_value)\n        return None\n\n    def _get_typed_value_time(self) -&gt; timedelta:\n        read_value = self.get_attribute(\"office:time-value\")\n        if not isinstance(read_value, str):\n            raise TypeError(f'Wrong type for \"office:time-value\": {type(read_value)}')\n        return Duration.decode(read_value)\n\n    def _get_typed_value(\n        self,\n        value_type: str = \"\",\n        try_get_text: bool = True,\n    ) -&gt; Any:\n        \"\"\"Return Python typed value.\n\n        Only for \"with office:value-type\" elements, not for meta fields.\"\"\"\n        if value_type == \"string\":\n            return self._get_typed_value_string(try_get_text)\n        method = getattr(self, f\"_get_typed_value_{value_type}\", None)\n        if method is None:\n            raise TypeError(f\"Unexpected value type: {value_type}\")\n        return method()\n\n    def _get_value_and_type(\n        self, value_type: str | None = None, try_get_text: bool = True\n    ) -&gt; tuple[Any, str]:\n        if value_type is None:\n            read_value_type = self.get_attribute(\"office:value-type\")\n            if isinstance(read_value_type, bool):\n                raise TypeError(\n                    f'Wrong type for \"office:value-type\": {type(read_value_type)}'\n                )\n            if read_value_type is None:\n                return None, None\n            value_type = read_value_type\n        return (\n            self._get_typed_value(\n                value_type=value_type,\n                try_get_text=try_get_text,\n            ),\n            value_type,\n        )\n\n    def get_value(\n        self,\n        value_type: str | None = None,\n        try_get_text: bool = True,\n        get_type: bool = False,\n    ) -&gt; Any | tuple[Any, str]:\n        \"\"\"Return Python typed value.\n\n        Only for \"with office:value-type\" elements, not for meta fields.\"\"\"\n        value, actual_type = self._get_value_and_type(\n            value_type=value_type, try_get_text=try_get_text\n        )\n        if get_type:\n            return (value, actual_type)\n        return value\n</code></pre>"},{"location":"reference.html#odfdo.ElementTyped.get_value","title":"<code>get_value(value_type=None, try_get_text=True, get_type=False)</code>","text":"<p>Return Python typed value.</p> <p>Only for \u201cwith office:value-type\u201d elements, not for meta fields.</p> Source code in <code>odfdo/element_typed.py</code> <pre><code>def get_value(\n    self,\n    value_type: str | None = None,\n    try_get_text: bool = True,\n    get_type: bool = False,\n) -&gt; Any | tuple[Any, str]:\n    \"\"\"Return Python typed value.\n\n    Only for \"with office:value-type\" elements, not for meta fields.\"\"\"\n    value, actual_type = self._get_value_and_type(\n        value_type=value_type, try_get_text=try_get_text\n    )\n    if get_type:\n        return (value, actual_type)\n    return value\n</code></pre>"},{"location":"reference.html#odfdo.EllipseShape","title":"<code>EllipseShape</code>","text":"<p>               Bases: <code>ShapeBase</code></p> <p>Create a ellipse shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\nposition -- (str, str)\n\nsize -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class EllipseShape(ShapeBase):\n    \"\"\"Create a ellipse shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        position -- (str, str)\n\n        size -- (str, str)\n\n    \"\"\"\n\n    _tag = \"draw:ellipse\"\n    _properties: tuple[PropDef, ...] = ()\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        position: tuple | None = None,\n        size: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n                \"size\": size,\n                \"position\": position,\n            }\n        )\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference.html#odfdo.Frame","title":"<code>Frame</code>","text":"<p>               Bases: <code>MDDrawFrame</code>, <code>Element</code>, <code>AnchorMix</code>, <code>PosMix</code>, <code>ZMix</code>, <code>SizeMix</code></p> <p>ODF Frame \u201cdraw:frame\u201d</p> <p>Frames are not useful by themselves. You should consider calling Frame.image_frame() or Frame.text_frame directly.</p> Source code in <code>odfdo/frame.py</code> <pre><code>class Frame(MDDrawFrame, Element, AnchorMix, PosMix, ZMix, SizeMix):\n    \"\"\"ODF Frame \"draw:frame\"\n\n    Frames are not useful by themselves. You should consider calling\n    Frame.image_frame() or Frame.text_frame directly.\n    \"\"\"\n\n    _tag = \"draw:frame\"\n    _properties = (\n        PropDef(\"name\", \"draw:name\"),\n        PropDef(\"draw_id\", \"draw:id\"),\n        PropDef(\"width\", \"svg:width\"),\n        PropDef(\"height\", \"svg:height\"),\n        PropDef(\"style\", \"draw:style-name\"),\n        PropDef(\"pos_x\", \"svg:x\"),\n        PropDef(\"pos_y\", \"svg:y\"),\n        PropDef(\"presentation_class\", \"presentation:class\"),\n        PropDef(\"layer\", \"draw:layer\"),\n        PropDef(\"presentation_style\", \"presentation:style-name\"),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        size: tuple = (\"1cm\", \"1cm\"),\n        z_index: int = 0,\n        presentation_class: str | None = None,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        layer: str | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a frame element of the given size. Position is relative to the\n        context the frame is inserted in. If positioned by page, give the page\n        number and the x, y position.\n\n        Size is a (width, height) tuple and position is a (left, top) tuple; items\n        are strings including the unit, e.g. ('10cm', '15cm').\n\n        Frames are not useful by themselves. You should consider calling:\n            Frame.image_frame()\n        or\n            Frame.text_frame()\n\n\n        Arguments:\n\n            name -- str\n\n            draw_id -- str\n\n            style -- str\n\n            position -- (str, str)\n\n            size -- (str, str)\n\n            z_index -- int (default 0)\n\n            presentation_class -- str\n\n            anchor_type -- 'page', 'frame', 'paragraph', 'char' or 'as-char'\n\n            anchor_page -- int, page number is anchor_type is 'page'\n\n            layer -- str\n\n            presentation_style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.size = size\n            self.z_index = z_index\n            if name:\n                self.name = name\n            if draw_id is not None:\n                self.draw_id = draw_id\n            if style is not None:\n                self.style = style\n            if position is not None:\n                self.position = position\n            if presentation_class is not None:\n                self.presentation_class = presentation_class\n            if anchor_type:\n                self.anchor_type = anchor_type\n            if position and not anchor_type:\n                self.anchor_type = \"paragraph\"\n            if anchor_page is not None:\n                self.anchor_page = anchor_page\n            if layer is not None:\n                self.layer = layer\n            if presentation_style is not None:\n                self.presentation_style = presentation_style\n\n    @classmethod\n    def image_frame(\n        cls,\n        image: Element | str,\n        text: str | None = None,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        size: tuple = (\"1cm\", \"1cm\"),\n        z_index: int = 0,\n        presentation_class: str | None = None,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        layer: str | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Element:\n        \"\"\"Create a ready-to-use image, since image must be embedded in a\n        frame.\n\n        The optionnal text will appear above the image.\n\n        Arguments:\n\n            image -- DrawImage or str, DrawImage element or URL of the image\n\n            text -- str, text for the image\n\n            See Frame() initialization for the other arguments\n\n        Return: Frame\n        \"\"\"\n        frame = cls(\n            name=name,\n            draw_id=draw_id,\n            style=style,\n            position=position,\n            size=size,\n            z_index=z_index,\n            presentation_class=presentation_class,\n            anchor_type=anchor_type,\n            anchor_page=anchor_page,\n            layer=layer,\n            presentation_style=presentation_style,\n            **kwargs,\n        )\n        image_element = frame.set_image(image)\n        if text:\n            image_element.text_content = text\n        return frame\n\n    @classmethod\n    def text_frame(\n        cls,\n        text_or_element: Iterable[Element] | Element | str,\n        text_style: str | None = None,\n        name: str | None = None,\n        draw_id: str | None = None,\n        style: str | None = None,\n        position: tuple | None = None,\n        size: tuple = (\"1cm\", \"1cm\"),\n        z_index: int = 0,\n        presentation_class: str | None = None,\n        anchor_type: str | None = None,\n        anchor_page: int | None = None,\n        layer: str | None = None,\n        presentation_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Element:\n        \"\"\"Create a ready-to-use text box, since text box must be embedded in\n        a frame.\n\n        The optionnal text will appear above the image.\n\n        Arguments:\n\n            text_or_element -- str or Element, or list of them, text content\n                               of the text box.\n\n            text_style -- str, name of the style for the text\n\n            See Frame() initialization for the other arguments\n\n        Return: Frame\n        \"\"\"\n        frame = cls(\n            name=name,\n            draw_id=draw_id,\n            style=style,\n            position=position,\n            size=size,\n            z_index=z_index,\n            presentation_class=presentation_class,\n            anchor_type=anchor_type,\n            anchor_page=anchor_page,\n            layer=layer,\n            presentation_style=presentation_style,\n            **kwargs,\n        )\n        frame.set_text_box(text_or_element, text_style)\n        return frame\n\n    @property\n    def text_content(self) -&gt; str:\n        text_box = self.get_element(\"draw:text-box\")\n        if text_box is None:\n            return \"\"\n        return text_box.text_content\n\n    @text_content.setter\n    def text_content(self, text: str | Element | None) -&gt; None:\n        text_box = self.get_element(\"draw:text-box\")\n        if text_box is None:\n            text_box = Element.from_tag(\"draw:text-box\")\n            self.append(text_box)\n        if isinstance(text, Element):\n            text_box.clear()\n            text_box.append(text)\n        else:\n            text_box.text_content = text\n\n    def get_image(\n        self,\n        position: int = 0,\n        name: str | None = None,\n        url: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        return self.get_element(\"draw:image\")\n\n    def set_image(self, url_or_element: Element | str) -&gt; Element:\n        image = self.get_image()\n        if image is None:\n            if isinstance(url_or_element, Element):\n                image = url_or_element\n                self.append(image)\n            else:\n                image = DrawImage(url_or_element)\n                self.append(image)\n        else:\n            if isinstance(url_or_element, Element):\n                image.delete()\n                image = url_or_element\n                self.append(image)\n            else:\n                image.set_url(url_or_element)  # type: ignore\n        return image\n\n    def get_text_box(self) -&gt; Element | None:\n        return self.get_element(\"draw:text-box\")\n\n    def set_text_box(\n        self,\n        text_or_element: Iterable[Element | str] | Element | str,\n        text_style: str | None = None,\n    ) -&gt; Element:\n        text_box = self.get_text_box()\n        if text_box is None:\n            text_box = Element.from_tag(\"draw:text-box\")\n            self.append(text_box)\n        else:\n            text_box.clear()\n        if isinstance(text_or_element, (Element, str)):\n            text_or_element_list: Iterable[Element | str] = [text_or_element]\n        else:\n            text_or_element_list = text_or_element\n        for item in text_or_element_list:\n            if isinstance(item, str):\n                text_box.append(Paragraph(item, style=text_style))\n            else:\n                text_box.append(item)\n        return text_box\n\n    @staticmethod\n    def _get_formatted_text_subresult(context: dict, element: Element) -&gt; str:\n        str_list = [\"  \"]\n        for child in element.children:\n            str_list.append(child.get_formatted_text(context))\n        subresult = \"\".join(str_list)\n        subresult = subresult.replace(\"\\n\", \"\\n  \")\n        return subresult.rstrip(\" \")\n\n    def get_formatted_text(\n        self,\n        context: dict | None = None,\n    ) -&gt; str:\n        if not context:\n            context = {}\n        result = []\n        for element in self.children:\n            tag = element.tag\n            if tag == \"draw:image\":\n                if context[\"rst_mode\"]:\n                    filename = element.get_attribute(\"xlink:href\")\n\n                    # Compute width and height\n                    width, height = self.size\n                    if width is not None:\n                        width = Unit(width)\n                        width = width.convert(\"px\", DPI)\n                    if height is not None:\n                        height = Unit(height)\n                        height = height.convert(\"px\", DPI)\n\n                    # Insert or not ?\n                    if context[\"no_img_level\"]:\n                        context[\"img_counter\"] += 1\n                        ref = f\"|img{context['img_counter']}|\"\n                        result.append(ref)\n                        context[\"images\"].append((ref, filename, (width, height)))\n                    else:\n                        result.append(f\"\\n.. image:: {filename}\\n\")\n                        if width is not None:\n                            result.append(f\"   :width: {width}\\n\")\n                        if height is not None:\n                            result.append(f\"   :height: {height}\\n\")\n                else:\n                    result.append(f\"[Image {element.get_attribute('xlink:href')}]\\n\")\n            elif tag == \"draw:text-box\":\n                result.append(self._get_formatted_text_subresult(context, element))\n            else:\n                result.append(element.get_formatted_text(context))\n        result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Frame.__init__","title":"<code>__init__(name=None, draw_id=None, style=None, position=None, size=('1cm', '1cm'), z_index=0, presentation_class=None, anchor_type=None, anchor_page=None, layer=None, presentation_style=None, **kwargs)</code>","text":"<p>Create a frame element of the given size. Position is relative to the context the frame is inserted in. If positioned by page, give the page number and the x, y position.</p> <p>Size is a (width, height) tuple and position is a (left, top) tuple; items are strings including the unit, e.g. (\u201810cm\u2019, \u201815cm\u2019).</p> <p>Frames are not useful by themselves. You should consider calling:     Frame.image_frame() or     Frame.text_frame()</p> <p>Arguments:</p> <pre><code>name -- str\n\ndraw_id -- str\n\nstyle -- str\n\nposition -- (str, str)\n\nsize -- (str, str)\n\nz_index -- int (default 0)\n\npresentation_class -- str\n\nanchor_type -- 'page', 'frame', 'paragraph', 'char' or 'as-char'\n\nanchor_page -- int, page number is anchor_type is 'page'\n\nlayer -- str\n\npresentation_style -- str\n</code></pre> Source code in <code>odfdo/frame.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    draw_id: str | None = None,\n    style: str | None = None,\n    position: tuple | None = None,\n    size: tuple = (\"1cm\", \"1cm\"),\n    z_index: int = 0,\n    presentation_class: str | None = None,\n    anchor_type: str | None = None,\n    anchor_page: int | None = None,\n    layer: str | None = None,\n    presentation_style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a frame element of the given size. Position is relative to the\n    context the frame is inserted in. If positioned by page, give the page\n    number and the x, y position.\n\n    Size is a (width, height) tuple and position is a (left, top) tuple; items\n    are strings including the unit, e.g. ('10cm', '15cm').\n\n    Frames are not useful by themselves. You should consider calling:\n        Frame.image_frame()\n    or\n        Frame.text_frame()\n\n\n    Arguments:\n\n        name -- str\n\n        draw_id -- str\n\n        style -- str\n\n        position -- (str, str)\n\n        size -- (str, str)\n\n        z_index -- int (default 0)\n\n        presentation_class -- str\n\n        anchor_type -- 'page', 'frame', 'paragraph', 'char' or 'as-char'\n\n        anchor_page -- int, page number is anchor_type is 'page'\n\n        layer -- str\n\n        presentation_style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.size = size\n        self.z_index = z_index\n        if name:\n            self.name = name\n        if draw_id is not None:\n            self.draw_id = draw_id\n        if style is not None:\n            self.style = style\n        if position is not None:\n            self.position = position\n        if presentation_class is not None:\n            self.presentation_class = presentation_class\n        if anchor_type:\n            self.anchor_type = anchor_type\n        if position and not anchor_type:\n            self.anchor_type = \"paragraph\"\n        if anchor_page is not None:\n            self.anchor_page = anchor_page\n        if layer is not None:\n            self.layer = layer\n        if presentation_style is not None:\n            self.presentation_style = presentation_style\n</code></pre>"},{"location":"reference.html#odfdo.Frame.image_frame","title":"<code>image_frame(image, text=None, name=None, draw_id=None, style=None, position=None, size=('1cm', '1cm'), z_index=0, presentation_class=None, anchor_type=None, anchor_page=None, layer=None, presentation_style=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ready-to-use image, since image must be embedded in a frame.</p> <p>The optionnal text will appear above the image.</p> <p>Arguments:</p> <pre><code>image -- DrawImage or str, DrawImage element or URL of the image\n\ntext -- str, text for the image\n\nSee Frame() initialization for the other arguments\n</code></pre> <p>Return: Frame</p> Source code in <code>odfdo/frame.py</code> <pre><code>@classmethod\ndef image_frame(\n    cls,\n    image: Element | str,\n    text: str | None = None,\n    name: str | None = None,\n    draw_id: str | None = None,\n    style: str | None = None,\n    position: tuple | None = None,\n    size: tuple = (\"1cm\", \"1cm\"),\n    z_index: int = 0,\n    presentation_class: str | None = None,\n    anchor_type: str | None = None,\n    anchor_page: int | None = None,\n    layer: str | None = None,\n    presentation_style: str | None = None,\n    **kwargs: Any,\n) -&gt; Element:\n    \"\"\"Create a ready-to-use image, since image must be embedded in a\n    frame.\n\n    The optionnal text will appear above the image.\n\n    Arguments:\n\n        image -- DrawImage or str, DrawImage element or URL of the image\n\n        text -- str, text for the image\n\n        See Frame() initialization for the other arguments\n\n    Return: Frame\n    \"\"\"\n    frame = cls(\n        name=name,\n        draw_id=draw_id,\n        style=style,\n        position=position,\n        size=size,\n        z_index=z_index,\n        presentation_class=presentation_class,\n        anchor_type=anchor_type,\n        anchor_page=anchor_page,\n        layer=layer,\n        presentation_style=presentation_style,\n        **kwargs,\n    )\n    image_element = frame.set_image(image)\n    if text:\n        image_element.text_content = text\n    return frame\n</code></pre>"},{"location":"reference.html#odfdo.Frame.text_frame","title":"<code>text_frame(text_or_element, text_style=None, name=None, draw_id=None, style=None, position=None, size=('1cm', '1cm'), z_index=0, presentation_class=None, anchor_type=None, anchor_page=None, layer=None, presentation_style=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ready-to-use text box, since text box must be embedded in a frame.</p> <p>The optionnal text will appear above the image.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or Element, or list of them, text content\n                   of the text box.\n\ntext_style -- str, name of the style for the text\n\nSee Frame() initialization for the other arguments\n</code></pre> <p>Return: Frame</p> Source code in <code>odfdo/frame.py</code> <pre><code>@classmethod\ndef text_frame(\n    cls,\n    text_or_element: Iterable[Element] | Element | str,\n    text_style: str | None = None,\n    name: str | None = None,\n    draw_id: str | None = None,\n    style: str | None = None,\n    position: tuple | None = None,\n    size: tuple = (\"1cm\", \"1cm\"),\n    z_index: int = 0,\n    presentation_class: str | None = None,\n    anchor_type: str | None = None,\n    anchor_page: int | None = None,\n    layer: str | None = None,\n    presentation_style: str | None = None,\n    **kwargs: Any,\n) -&gt; Element:\n    \"\"\"Create a ready-to-use text box, since text box must be embedded in\n    a frame.\n\n    The optionnal text will appear above the image.\n\n    Arguments:\n\n        text_or_element -- str or Element, or list of them, text content\n                           of the text box.\n\n        text_style -- str, name of the style for the text\n\n        See Frame() initialization for the other arguments\n\n    Return: Frame\n    \"\"\"\n    frame = cls(\n        name=name,\n        draw_id=draw_id,\n        style=style,\n        position=position,\n        size=size,\n        z_index=z_index,\n        presentation_class=presentation_class,\n        anchor_type=anchor_type,\n        anchor_page=anchor_page,\n        layer=layer,\n        presentation_style=presentation_style,\n        **kwargs,\n    )\n    frame.set_text_box(text_or_element, text_style)\n    return frame\n</code></pre>"},{"location":"reference.html#odfdo.Header","title":"<code>Header</code>","text":"<p>               Bases: <code>Paragraph</code>, <code>MDHeader</code></p> <p>Specialised paragraph for headings \u201ctext:h\u201d.</p> Source code in <code>odfdo/header.py</code> <pre><code>class Header(Paragraph, MDHeader):\n    \"\"\"Specialised paragraph for headings \"text:h\".\"\"\"\n\n    _tag = \"text:h\"\n    _properties = (\n        PropDef(\"level\", \"text:outline-level\"),\n        PropDef(\"restart_numbering\", \"text:restart-numbering\"),\n        PropDef(\"start_value\", \"text:start-value\"),\n        PropDef(\"suppress_numbering\", \"text:suppress-numbering\"),\n    )\n\n    def __init__(\n        self,\n        level: int = 1,\n        text: str | None = None,\n        restart_numbering: bool = False,\n        start_value: int | None = None,\n        suppress_numbering: bool = False,\n        style: str | None = None,\n        formatted: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a header element of the given style and level, containing the\n        optional given text.\n\n        Level count begins at 1.\n\n        If \"formatted\" is True (the default), the given text is appended with &lt;CR&gt;,\n        &lt;TAB&gt; and multiple spaces replaced by ODF corresponding tags.\n\n        Arguments:\n\n            level -- int\n\n            text -- str\n\n            restart_numbering -- bool\n\n            start_value -- int\n\n            style -- str\n\n            formatted -- bool\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.level = int(level)\n            if text:\n                if formatted:\n                    self.text = \"\"\n                    self.append_plain_text(text)  # type:ignore\n                else:\n                    self.text = self._unformatted(text)  # type:ignore\n            if restart_numbering:\n                self.restart_numbering = True\n            if start_value is not None:\n                self.start_value = start_value\n            if suppress_numbering:\n                self.suppress_numbering = True\n            # if style:\n            #     self.style = style\n\n    def get_formatted_text(\n        self,\n        context: dict | None = None,\n        simple: bool = False,\n    ) -&gt; str:\n        if not context:\n            context = {\n                \"document\": None,\n                \"footnotes\": [],\n                \"endnotes\": [],\n                \"annotations\": [],\n                \"rst_mode\": False,\n                \"img_counter\": 0,\n                \"images\": [],\n                \"no_img_level\": 0,\n            }\n        context[\"no_img_level\"] += 1\n        title = super().get_formatted_text(context)\n        context[\"no_img_level\"] -= 1\n        title = title.strip()\n        title = sub(r\"\\s+\", \" \", title)\n\n        # No rst_mode ?\n        if not context[\"rst_mode\"]:\n            return title\n        # If here in rst_mode!\n\n        # Get the level, max 5!\n        LEVEL_STYLES = \"#=-~`+^\u00b0'.\"\n        level = int(self.level)\n        if level &gt; len(LEVEL_STYLES):\n            raise ValueError(\"Too many levels of heading\")\n\n        # And return the result\n        result = [\"\\n\", title, \"\\n\", LEVEL_STYLES[level - 1] * len(title), \"\\n\"]\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Header.__init__","title":"<code>__init__(level=1, text=None, restart_numbering=False, start_value=None, suppress_numbering=False, style=None, formatted=True, **kwargs)</code>","text":"<p>Create a header element of the given style and level, containing the optional given text.</p> <p>Level count begins at 1.</p> <p>If \u201cformatted\u201d is True (the default), the given text is appended with ,  and multiple spaces replaced by ODF corresponding tags. <p>Arguments:</p> <pre><code>level -- int\n\ntext -- str\n\nrestart_numbering -- bool\n\nstart_value -- int\n\nstyle -- str\n\nformatted -- bool\n</code></pre> Source code in <code>odfdo/header.py</code> <pre><code>def __init__(\n    self,\n    level: int = 1,\n    text: str | None = None,\n    restart_numbering: bool = False,\n    start_value: int | None = None,\n    suppress_numbering: bool = False,\n    style: str | None = None,\n    formatted: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a header element of the given style and level, containing the\n    optional given text.\n\n    Level count begins at 1.\n\n    If \"formatted\" is True (the default), the given text is appended with &lt;CR&gt;,\n    &lt;TAB&gt; and multiple spaces replaced by ODF corresponding tags.\n\n    Arguments:\n\n        level -- int\n\n        text -- str\n\n        restart_numbering -- bool\n\n        start_value -- int\n\n        style -- str\n\n        formatted -- bool\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.level = int(level)\n        if text:\n            if formatted:\n                self.text = \"\"\n                self.append_plain_text(text)  # type:ignore\n            else:\n                self.text = self._unformatted(text)  # type:ignore\n        if restart_numbering:\n            self.restart_numbering = True\n        if start_value is not None:\n            self.start_value = start_value\n        if suppress_numbering:\n            self.suppress_numbering = True\n</code></pre>"},{"location":"reference.html#odfdo.Image","title":"<code>Image</code>","text":"<p>               Bases: <code>Body</code></p> <p>Image, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Image(Body):\n    \"\"\"Image, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:image\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.IndexTitle","title":"<code>IndexTitle</code>","text":"<p>               Bases: <code>Element</code></p> <p>The \u201ctext:index-title\u201d element contains the title of an index.</p> <p>The element has the following attributes: text:name, text:protected, text:protection-key, text:protection-key-digest-algorithm, text:style-name, xml:id.</p> <p>The actual title is stored in a child element</p> Source code in <code>odfdo/toc.py</code> <pre><code>class IndexTitle(Element):\n    \"\"\"The \"text:index-title\" element contains the title of an index.\n\n    The element has the following attributes:\n    text:name, text:protected, text:protection-key,\n    text:protection-key-digest-algorithm, text:style-name, xml:id.\n\n    The actual title is stored in a child element\n    \"\"\"\n\n    _tag = \"text:index-title\"\n    _properties = (\n        PropDef(\"name\", \"text:name\"),\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"xml_id\", \"xml:id\"),\n        PropDef(\"protected\", \"text:protected\"),\n        PropDef(\"protection_key\", \"text:protection-key\"),\n        PropDef(\n            \"protection_key_digest_algorithm\", \"text:protection-key-digest-algorithm\"\n        ),\n    )\n\n    def __init__(\n        self,\n        name: str | None = None,\n        style: str | None = None,\n        title_text: str | None = None,\n        title_text_style: str | None = None,\n        xml_id: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if name:\n                self.name = name\n            if style:\n                self.style = style\n            if xml_id:\n                self.xml_id = xml_id\n            if title_text:\n                self.set_title_text(title_text, title_text_style)\n\n    def set_title_text(\n        self,\n        title_text: str,\n        title_text_style: str | None = None,\n    ) -&gt; None:\n        title = Paragraph(title_text, style=title_text_style)\n        self.append(title)\n</code></pre>"},{"location":"reference.html#odfdo.IndexTitleTemplate","title":"<code>IndexTitleTemplate</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF \u201ctext:index-title-template\u201d</p> <p>Arguments:</p> <pre><code>style -- str\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>class IndexTitleTemplate(Element):\n    \"\"\"ODF \"text:index-title-template\"\n\n    Arguments:\n\n        style -- str\n    \"\"\"\n\n    _tag = \"text:index-title-template\"\n    _properties = (PropDef(\"style\", \"text:style-name\"),)\n\n    def __init__(self, style: str | None = None, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init and style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.LineBreak","title":"<code>LineBreak</code>","text":"<p>               Bases: <code>MDLineBreak</code>, <code>Element</code></p> <p>This element represents a line break \u201ctext:line-break\u201d</p> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>class LineBreak(MDLineBreak, Element):\n    \"\"\"This element represents a line break \"text:line-break\" \"\"\"\n\n    _tag = \"text:line-break\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n\n    def __str__(self) -&gt; str:\n        return \"\\n\"\n\n    @property\n    def text(self) -&gt; str:\n        return \"\\n\"\n</code></pre>"},{"location":"reference.html#odfdo.LineShape","title":"<code>LineShape</code>","text":"<p>               Bases: <code>ShapeBase</code></p> <p>Create a line shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\np1 -- (str, str)\n\np2 -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class LineShape(ShapeBase):\n    \"\"\"Create a line shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        p1 -- (str, str)\n\n        p2 -- (str, str)\n    \"\"\"\n\n    _tag = \"draw:line\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"x1\", \"svg:x1\"),\n        PropDef(\"y1\", \"svg:y1\"),\n        PropDef(\"x2\", \"svg:x2\"),\n        PropDef(\"y2\", \"svg:y2\"),\n    )\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        p1: tuple | None = None,\n        p2: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n            }\n        )\n        super().__init__(**kwargs)\n        if self._do_init:\n            if p1:\n                self.x1 = p1[0]\n                self.y1 = p1[1]\n            if p2:\n                self.x2 = p2[0]\n                self.y2 = p2[1]\n</code></pre>"},{"location":"reference.html#odfdo.Link","title":"<code>Link</code>","text":"<p>               Bases: <code>MDLink</code>, <code>ParagraphBase</code></p> <p>Link class, \u201ctext:a\u201d ODF element.</p> Source code in <code>odfdo/link.py</code> <pre><code>class Link(MDLink, ParagraphBase):\n    \"\"\"Link class, \"text:a\" ODF element.\"\"\"\n\n    _tag = \"text:a\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"url\", \"xlink:href\"),\n        PropDef(\"name\", \"office:name\"),\n        PropDef(\"title\", \"office:title\"),\n        PropDef(\"target_frame\", \"office:target-frame-name\"),\n        PropDef(\"show\", \"xlink:show\"),\n        PropDef(\"visited_style\", \"text:visited-style-name\"),\n        PropDef(\"style\", \"text:style-name\"),\n    )\n\n    def __init__(\n        self,\n        url: str | None = \"\",\n        name: str | None = None,\n        title: str | None = None,\n        text: str | None = None,\n        target_frame: str | None = None,\n        style: str | None = None,\n        visited_style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            url -- str\n\n            name -- str\n\n            title -- str\n\n            text -- str\n\n            target_frame -- '_self', '_blank', '_parent', '_top'\n\n            style -- str\n\n            visited_style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.url = url\n            if name is not None:\n                self.name = name\n            if title is not None:\n                self.title = title\n            if text is not None:\n                self.text = text\n            if target_frame is not None:\n                self.target_frame = target_frame\n                # show can be: 'new' or 'replace'\"\n                if target_frame == \"_blank\":\n                    self.show = \"new\"\n                else:\n                    self.show = \"replace\"\n            if style is not None:\n                self.style = style\n            if visited_style is not None:\n                self.visited_style = visited_style\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag} link={self.url}&gt;\"\n\n    def __str__(self) -&gt; str:\n        text = self.inner_text.strip()\n        if text:\n            return f\"[{text}]({self.url})\"\n        return f\"({self.url})\"\n</code></pre>"},{"location":"reference.html#odfdo.Link.__init__","title":"<code>__init__(url='', name=None, title=None, text=None, target_frame=None, style=None, visited_style=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>url -- str\n\nname -- str\n\ntitle -- str\n\ntext -- str\n\ntarget_frame -- '_self', '_blank', '_parent', '_top'\n\nstyle -- str\n\nvisited_style -- str\n</code></pre> Source code in <code>odfdo/link.py</code> <pre><code>def __init__(\n    self,\n    url: str | None = \"\",\n    name: str | None = None,\n    title: str | None = None,\n    text: str | None = None,\n    target_frame: str | None = None,\n    style: str | None = None,\n    visited_style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        url -- str\n\n        name -- str\n\n        title -- str\n\n        text -- str\n\n        target_frame -- '_self', '_blank', '_parent', '_top'\n\n        style -- str\n\n        visited_style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.url = url\n        if name is not None:\n            self.name = name\n        if title is not None:\n            self.title = title\n        if text is not None:\n            self.text = text\n        if target_frame is not None:\n            self.target_frame = target_frame\n            # show can be: 'new' or 'replace'\"\n            if target_frame == \"_blank\":\n                self.show = \"new\"\n            else:\n                self.show = \"replace\"\n        if style is not None:\n            self.style = style\n        if visited_style is not None:\n            self.visited_style = visited_style\n</code></pre>"},{"location":"reference.html#odfdo.List","title":"<code>List</code>","text":"<p>               Bases: <code>MDList</code>, <code>Element</code></p> <p>ODF List \u201ctext:list\u201d.</p> Source code in <code>odfdo/list.py</code> <pre><code>class List(MDList, Element):\n    \"\"\"ODF List \"text:list\".\"\"\"\n\n    _tag = \"text:list\"\n    _properties = (PropDef(\"style\", \"text:style-name\"),)\n\n    def __init__(\n        self,\n        list_content: str | Element | Iterable[str | Element] | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a list element, optionaly loading the list by a list of\n        item (str or elements).\n\n        The list_content argument is just a shortcut for the most common case.\n        To create more complex lists, first create an empty list, and fill it\n        afterwards.\n\n        Arguments:\n\n            list_content -- str or Element, or a list of str or Element\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if list_content:\n                if isinstance(list_content, (Element, str)):\n                    self.append(ListItem(list_content))\n                elif hasattr(list_content, \"__iter__\"):\n                    for item in list_content:\n                        self.append(ListItem(item))\n            if style is not None:\n                self.style = style\n\n    def get_items(self, content: str | None = None) -&gt; list[Element]:\n        \"\"\"Return all the list items that match the criteria.\n\n        Arguments:\n\n            style -- str\n\n            content -- str regex\n\n        Return: list of Element\n        \"\"\"\n        return self._filtered_elements(\"text:list-item\", content=content)\n\n    def get_item(\n        self,\n        position: int = 0,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        \"\"\"Return the list item that matches the criteria. In nested lists,\n        return the list item that really contains that content.\n\n        Arguments:\n\n            position -- int\n\n            content -- str regex\n\n        Return: Element or None if not found\n        \"\"\"\n        # Custom implementation because of nested lists\n        if content:\n            # Don't search recursively but on the very own paragraph(s) of\n            # each list item\n            for paragraph in self.get_elements(\"descendant::text:p\"):\n                if paragraph.match(content):\n                    return paragraph.get_element(\"parent::text:list-item\")\n            return None\n        return self._filtered_element(\"text:list-item\", position)\n\n    def set_list_header(\n        self,\n        text_or_element: str | Element | Iterable[str | Element],\n    ) -&gt; None:\n        if isinstance(text_or_element, (str, Element)):\n            actual_list: list[str | Element] | tuple = [text_or_element]\n        elif isinstance(text_or_element, (list, tuple)):\n            actual_list = text_or_element\n        else:\n            raise TypeError\n        # Remove existing header\n        for element in self.get_elements(\"text:p\"):\n            self.delete(element)\n        for paragraph in reversed(actual_list):\n            if isinstance(paragraph, str):\n                paragraph = Paragraph(paragraph)\n            self.insert(paragraph, FIRST_CHILD)\n\n    def insert_item(\n        self,\n        item: ListItem | str | Element | None,\n        position: int | None = None,\n        before: Element | None = None,\n        after: Element | None = None,\n    ) -&gt; None:\n        if not isinstance(item, ListItem):\n            item = ListItem(item)\n        if before is not None:\n            before.insert(item, xmlposition=PREV_SIBLING)\n        elif after is not None:\n            after.insert(item, xmlposition=NEXT_SIBLING)\n        elif position is not None:\n            self.insert(item, position=position)\n        else:\n            raise ValueError(\"Position must be defined\")\n\n    def append_item(\n        self,\n        item: ListItem | str | Element | None,\n    ) -&gt; None:\n        if not isinstance(item, ListItem):\n            item = ListItem(item)\n        self.append(item)\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        if context is None:\n            context = {}\n        rst_mode = context[\"rst_mode\"]\n        result = []\n        if rst_mode:\n            result.append(\"\\n\")\n        for list_item in self.get_elements(\"text:list-item\"):\n            textbuf = []\n            for child in list_item.children:\n                text = child.get_formatted_text(context)\n                tag = child.tag\n                if tag == \"text:h\":\n                    # A title in a list is a bug\n                    return text\n                if tag == \"text:list\" and not text.lstrip().startswith(\"-\"):\n                    # If the list didn't indent, don't either\n                    # (inner title)\n                    return text\n                textbuf.append(text)\n            text_sum = \"\".join(textbuf)\n            text_sum = text_sum.strip(\"\\n\")\n            # Indent the text\n            text_sum = text_sum.replace(\"\\n\", \"\\n  \")\n            text_sum = f\"- {text_sum}\\n\"\n            result.append(text_sum)\n        if rst_mode:\n            result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.List.__init__","title":"<code>__init__(list_content=None, style=None, **kwargs)</code>","text":"<p>Create a list element, optionaly loading the list by a list of item (str or elements).</p> <p>The list_content argument is just a shortcut for the most common case. To create more complex lists, first create an empty list, and fill it afterwards.</p> <p>Arguments:</p> <pre><code>list_content -- str or Element, or a list of str or Element\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/list.py</code> <pre><code>def __init__(\n    self,\n    list_content: str | Element | Iterable[str | Element] | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a list element, optionaly loading the list by a list of\n    item (str or elements).\n\n    The list_content argument is just a shortcut for the most common case.\n    To create more complex lists, first create an empty list, and fill it\n    afterwards.\n\n    Arguments:\n\n        list_content -- str or Element, or a list of str or Element\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if list_content:\n            if isinstance(list_content, (Element, str)):\n                self.append(ListItem(list_content))\n            elif hasattr(list_content, \"__iter__\"):\n                for item in list_content:\n                    self.append(ListItem(item))\n        if style is not None:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.List.get_item","title":"<code>get_item(position=0, content=None)</code>","text":"<p>Return the list item that matches the criteria. In nested lists, return the list item that really contains that content.</p> <p>Arguments:</p> <pre><code>position -- int\n\ncontent -- str regex\n</code></pre> <p>Return: Element or None if not found</p> Source code in <code>odfdo/list.py</code> <pre><code>def get_item(\n    self,\n    position: int = 0,\n    content: str | None = None,\n) -&gt; Element | None:\n    \"\"\"Return the list item that matches the criteria. In nested lists,\n    return the list item that really contains that content.\n\n    Arguments:\n\n        position -- int\n\n        content -- str regex\n\n    Return: Element or None if not found\n    \"\"\"\n    # Custom implementation because of nested lists\n    if content:\n        # Don't search recursively but on the very own paragraph(s) of\n        # each list item\n        for paragraph in self.get_elements(\"descendant::text:p\"):\n            if paragraph.match(content):\n                return paragraph.get_element(\"parent::text:list-item\")\n        return None\n    return self._filtered_element(\"text:list-item\", position)\n</code></pre>"},{"location":"reference.html#odfdo.List.get_items","title":"<code>get_items(content=None)</code>","text":"<p>Return all the list items that match the criteria.</p> <p>Arguments:</p> <pre><code>style -- str\n\ncontent -- str regex\n</code></pre> <p>Return: list of Element</p> Source code in <code>odfdo/list.py</code> <pre><code>def get_items(self, content: str | None = None) -&gt; list[Element]:\n    \"\"\"Return all the list items that match the criteria.\n\n    Arguments:\n\n        style -- str\n\n        content -- str regex\n\n    Return: list of Element\n    \"\"\"\n    return self._filtered_elements(\"text:list-item\", content=content)\n</code></pre>"},{"location":"reference.html#odfdo.ListItem","title":"<code>ListItem</code>","text":"<p>               Bases: <code>MDListItem</code>, <code>Element</code></p> <p>ODF element \u201ctext:list-item\u201d, item of a List.</p> Source code in <code>odfdo/list.py</code> <pre><code>class ListItem(MDListItem, Element):\n    \"\"\"ODF element \"text:list-item\", item of a List.\"\"\"\n\n    _tag = \"text:list-item\"\n\n    def __init__(\n        self,\n        text_or_element: str | Element | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a list item element, optionaly passing at creation time a\n        string or Element as content.\n\n        Arguments:\n\n            text_or_element -- str or ODF Element\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if isinstance(text_or_element, str):\n                self.text_content = text_or_element\n            elif isinstance(text_or_element, Element):\n                self.append(text_or_element)\n            elif text_or_element is not None:\n                raise TypeError(\"Expected str or Element\")\n\n    def __str__(self) -&gt; str:\n        self._md_initialize_level()\n        return \"\\n\".join(self._md_collect())\n</code></pre>"},{"location":"reference.html#odfdo.ListItem.__init__","title":"<code>__init__(text_or_element=None, **kwargs)</code>","text":"<p>Create a list item element, optionaly passing at creation time a string or Element as content.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or ODF Element\n</code></pre> Source code in <code>odfdo/list.py</code> <pre><code>def __init__(\n    self,\n    text_or_element: str | Element | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a list item element, optionaly passing at creation time a\n    string or Element as content.\n\n    Arguments:\n\n        text_or_element -- str or ODF Element\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if isinstance(text_or_element, str):\n            self.text_content = text_or_element\n        elif isinstance(text_or_element, Element):\n            self.append(text_or_element)\n        elif text_or_element is not None:\n            raise TypeError(\"Expected str or Element\")\n</code></pre>"},{"location":"reference.html#odfdo.Manifest","title":"<code>Manifest</code>","text":"<p>               Bases: <code>XmlPart</code></p> Source code in <code>odfdo/manifest.py</code> <pre><code>class Manifest(XmlPart):\n    def get_paths(self) -&gt; list[Element | EText]:\n        \"\"\"Return the list of full paths in the manifest.\n\n        Return: list of str\n        \"\"\"\n        xpath_query = \"//manifest:file-entry/attribute::manifest:full-path\"\n        return self.xpath(xpath_query)\n\n    def _file_entry(self, full_path: str) -&gt; Element:\n        xpath_query = (\n            f'//manifest:file-entry[attribute::manifest:full-path=\"{full_path}\"]'\n        )\n        result = self.xpath(xpath_query)\n        if not result:\n            raise KeyError(f\"Path not found: '{full_path}'\")\n        return result[0]  # type: ignore\n\n    def get_path_medias(self) -&gt; list[tuple]:\n        \"\"\"Return the list of (full_path, media_type) pairs in the manifest.\n\n        Return: list of str tuples\n        \"\"\"\n        xpath_query = \"//manifest:file-entry\"\n        result = []\n        for file_entry in self.xpath(xpath_query):\n            if not isinstance(file_entry, Element):  # pragma: no cover\n                continue\n            result.append(\n                (\n                    file_entry.get_attribute_string(\"manifest:full-path\"),\n                    file_entry.get_attribute_string(\"manifest:media-type\"),\n                )\n            )\n        return result\n\n    def get_media_type(self, full_path: str) -&gt; str | None:\n        \"\"\"Get the media type of an existing path.\n\n        Return: str\n        \"\"\"\n        xpath_query = (\n            f'//manifest:file-entry[attribute::manifest:full-path=\"{full_path}\"]'\n            \"/attribute::manifest:media-type\"\n        )\n        result = self.xpath(xpath_query)\n        if not result:\n            return None\n        return str(result[0])\n\n    def set_media_type(self, full_path: str, media_type: str) -&gt; None:\n        \"\"\"Set the media type of an existing path.\n\n        Arguments:\n\n            full_path -- str\n\n            media_type -- str\n        \"\"\"\n        file_entry = self._file_entry(full_path)\n        file_entry.set_attribute(\"manifest:media-type\", media_type)\n\n    @staticmethod\n    def make_file_entry(full_path: str, media_type: str) -&gt; Element:\n        tag = (\n            f\"&lt;manifest:file-entry \"\n            f'manifest:media-type=\"{media_type}\" '\n            f'manifest:full-path=\"{full_path}\"/&gt;'\n        )\n        return Element.from_tag(tag)\n\n    def add_full_path(self, full_path: str, media_type: str = \"\") -&gt; None:\n        # Existing?\n        existing = self.get_media_type(full_path)\n        if existing is not None:\n            self.set_media_type(full_path, media_type)\n        root = self.root\n        root.append(self.make_file_entry(full_path, media_type))\n\n    def del_full_path(self, full_path: str) -&gt; None:\n        file_entry = self._file_entry(full_path)\n        self.root.delete(file_entry)\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.get_media_type","title":"<code>get_media_type(full_path)</code>","text":"<p>Get the media type of an existing path.</p> <p>Return: str</p> Source code in <code>odfdo/manifest.py</code> <pre><code>def get_media_type(self, full_path: str) -&gt; str | None:\n    \"\"\"Get the media type of an existing path.\n\n    Return: str\n    \"\"\"\n    xpath_query = (\n        f'//manifest:file-entry[attribute::manifest:full-path=\"{full_path}\"]'\n        \"/attribute::manifest:media-type\"\n    )\n    result = self.xpath(xpath_query)\n    if not result:\n        return None\n    return str(result[0])\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.get_path_medias","title":"<code>get_path_medias()</code>","text":"<p>Return the list of (full_path, media_type) pairs in the manifest.</p> <p>Return: list of str tuples</p> Source code in <code>odfdo/manifest.py</code> <pre><code>def get_path_medias(self) -&gt; list[tuple]:\n    \"\"\"Return the list of (full_path, media_type) pairs in the manifest.\n\n    Return: list of str tuples\n    \"\"\"\n    xpath_query = \"//manifest:file-entry\"\n    result = []\n    for file_entry in self.xpath(xpath_query):\n        if not isinstance(file_entry, Element):  # pragma: no cover\n            continue\n        result.append(\n            (\n                file_entry.get_attribute_string(\"manifest:full-path\"),\n                file_entry.get_attribute_string(\"manifest:media-type\"),\n            )\n        )\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.get_paths","title":"<code>get_paths()</code>","text":"<p>Return the list of full paths in the manifest.</p> <p>Return: list of str</p> Source code in <code>odfdo/manifest.py</code> <pre><code>def get_paths(self) -&gt; list[Element | EText]:\n    \"\"\"Return the list of full paths in the manifest.\n\n    Return: list of str\n    \"\"\"\n    xpath_query = \"//manifest:file-entry/attribute::manifest:full-path\"\n    return self.xpath(xpath_query)\n</code></pre>"},{"location":"reference.html#odfdo.Manifest.set_media_type","title":"<code>set_media_type(full_path, media_type)</code>","text":"<p>Set the media type of an existing path.</p> <p>Arguments:</p> <pre><code>full_path -- str\n\nmedia_type -- str\n</code></pre> Source code in <code>odfdo/manifest.py</code> <pre><code>def set_media_type(self, full_path: str, media_type: str) -&gt; None:\n    \"\"\"Set the media type of an existing path.\n\n    Arguments:\n\n        full_path -- str\n\n        media_type -- str\n    \"\"\"\n    file_entry = self._file_entry(full_path)\n    file_entry.set_attribute(\"manifest:media-type\", media_type)\n</code></pre>"},{"location":"reference.html#odfdo.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>XmlPart</code>, <code>DcCreatorMixin</code>, <code>DcDateMixin</code></p> Source code in <code>odfdo/meta.py</code> <pre><code>class Meta(XmlPart, DcCreatorMixin, DcDateMixin):\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self._generator_modified: bool = False\n\n    def get_meta_body(self) -&gt; Element:\n        return self.get_element(\"//office:meta\")\n\n    def get_title(self) -&gt; str | None:\n        \"\"\"Get the title of the document.\n\n        This is not the first heading but the title metadata.\n\n        (Also available as \"self.title\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//dc:title\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_title(self, title: str) -&gt; None:\n        \"\"\"Set the title of the document.\n\n        This is not the first heading but the title metadata.\n\n        (Also available as \"self.title\" property.)\n\n        Arguments:\n\n            title -- str\n        \"\"\"\n        element = self.get_element(\"//dc:title\")\n        if element is None:\n            element = Element.from_tag(\"dc:title\")\n            self.get_meta_body().append(element)\n        element.text = title\n\n    @property\n    def title(self) -&gt; str | None:\n        \"\"\"Get or set the title of the document &lt;dc:title&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_title()\n\n    @title.setter\n    def title(self, title: str) -&gt; None:\n        return self.set_title(title)\n\n    def get_description(self) -&gt; str | None:\n        \"\"\"Get the description of the document. Also known as comments.\n\n        (Also available as \"self.description\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//dc:description\")\n        if element is None:\n            return None\n        return element.text\n\n    # As named in OOo\n    get_comments = get_description\n\n    def set_description(self, description: str) -&gt; None:\n        \"\"\"Set the description of the document. Also known as comments.\n\n        (Also available as \"self.description\" property.)\n\n        Arguments:\n\n            description -- str\n        \"\"\"\n        element = self.get_element(\"//dc:description\")\n        if element is None:\n            element = Element.from_tag(\"dc:description\")\n            self.get_meta_body().append(element)\n        element.text = description\n\n    set_comments = set_description\n\n    @property\n    def description(self) -&gt; str | None:\n        \"\"\"Get or set the description of a document &lt;dc:description&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_description()\n\n    @description.setter\n    def description(self, description: str) -&gt; None:\n        return self.set_description(description)\n\n    def get_subject(self) -&gt; str | None:\n        \"\"\"Get the subject of the document.\n\n        (Also available as \"self.subject\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//dc:subject\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_subject(self, subject: str) -&gt; None:\n        \"\"\"Set the subject of the document.\n\n        (Also available as \"self.subject\" property.)\n\n        Arguments:\n\n            subject -- str\n        \"\"\"\n        element = self.get_element(\"//dc:subject\")\n        if element is None:\n            element = Element.from_tag(\"dc:subject\")\n            self.get_meta_body().append(element)\n        element.text = subject\n\n    @property\n    def subject(self) -&gt; str | None:\n        \"\"\"Get or set the subject of a document &lt;dc:subject&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_subject()\n\n    @subject.setter\n    def subject(self, subject: str) -&gt; None:\n        return self.set_subject(subject)\n\n    def get_language(self) -&gt; str | None:\n        \"\"\"Get the default language of the document.\n\n        (Also available as \"self.language\" property.)\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.get_language()\n            fr-FR\n        \"\"\"\n        element = self.get_element(\"//dc:language\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_language(self, language: str) -&gt; None:\n        \"\"\"Set the default language of the document.\n\n        (Also available as \"self.language\" property.)\n\n        Arguments:\n\n            language -- str\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_language('fr-FR')\n        \"\"\"\n        language = str(language)\n        if not self._is_RFC3066(language):\n            raise TypeError(\n                'Language must be \"xx\" lang or \"xx-YY\" lang-COUNTRY code (RFC3066)'\n            )\n        element = self.get_element(\"//dc:language\")\n        if element is None:\n            element = Element.from_tag(\"dc:language\")\n            self.get_meta_body().append(element)\n        element.text = language\n\n    @staticmethod\n    def _is_RFC3066(lang: str) -&gt; bool:\n        def test_part1(part1: str) -&gt; bool:\n            if not 2 &lt;= len(part1) &lt;= 3:\n                return False\n            return all(x in ascii_letters for x in part1)\n\n        def test_part2(part2: str) -&gt; bool:\n            return all(x in ascii_letters or x in digits for x in part2)\n\n        if not lang or not isinstance(lang, str):\n            return False\n        if \"-\" not in lang:\n            return test_part1(lang)\n        parts = lang.split(\"-\")\n        if len(parts) &gt; 3:\n            return False\n        if not test_part1(parts[0]):\n            return False\n        return all(test_part2(p) for p in parts[1:])\n\n    @property\n    def language(self) -&gt; str | None:\n        \"\"\"Get or set the default language of the document &lt;dc:language&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_language()\n\n    @language.setter\n    def language(self, language: str) -&gt; None:\n        return self.set_language(language)\n\n    def get_creation_date(self) -&gt; datetime | None:\n        \"\"\"Get the creation date of the document.\n\n        (Also available as \"self.creation_date\" property.)\n\n        Return: datetime (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:creation-date\")\n        if element is None:\n            return None\n        creation_date = element.text\n        return DateTime.decode(creation_date)\n\n    def set_creation_date(self, date: datetime | None = None) -&gt; None:\n        \"\"\"Set the creation date of the document.\n\n        If provided datetime is None, use current time.\n\n        (Also available as \"self.creation_date\" property.)\n\n        Arguments:\n\n            date -- datetime\n        \"\"\"\n        element = self.get_element(\"//meta:creation-date\")\n        if element is None:\n            element = Element.from_tag(\"meta:creation-date\")\n            self.get_meta_body().append(element)\n        if date is None:\n            date = datetime.now()\n        element.text = DateTime.encode(date)\n\n    @property\n    def creation_date(self) -&gt; datetime | None:\n        \"\"\"Get or set the date and time when a document was created\n        &lt;meta:creation-date&gt;.\n\n        If provided datetime is None, use current time.\n\n        Return: datetime (or None if inexistant)\n        \"\"\"\n        return self.get_creation_date()\n\n    @creation_date.setter\n    def creation_date(self, date: datetime | None = None) -&gt; None:\n        return self.set_creation_date(date)\n\n    @property\n    def print_date(self) -&gt; datetime | None:\n        \"\"\"Get or set the date and time when a document when a document was last printed\n        &lt;meta:print-date&gt;\n\n        If provided datetime is None, use current time.\n\n        Return: datetime (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:print-date\")\n        if element is None:\n            return None\n        date = element.text\n        return DateTime.decode(date)\n\n    @print_date.setter\n    def print_date(self, date: datetime | None = None) -&gt; None:\n        element = self.get_element(\"//meta:print-date\")\n        if element is None:\n            element = Element.from_tag(\"meta:print-date\")\n            self.get_meta_body().append(element)\n        if date is None:\n            date = datetime.now()\n        element.text = DateTime.encode(date)\n\n    def get_template(self) -&gt; MetaTemplate | None:\n        \"\"\"Get the MetaTemplate &lt;meta:template&gt; element or None.\"\"\"\n        element = self.get_element(\"//meta:template\")\n        if element is None:\n            return None\n        return element\n\n    @property\n    def template(self) -&gt; MetaTemplate | None:\n        \"\"\"Get the MetaTemplate &lt;meta:template&gt; element or None.\"\"\"\n        return self.get_template()\n\n    def set_template(\n        self,\n        date: datetime | None = None,\n        href: str = \"\",\n        title: str = \"\",\n    ) -&gt; None:\n        \"\"\"Set the MetaTemplate &lt;meta:template&gt; element.\"\"\"\n        template = MetaTemplate(date=date, href=href, title=title)\n        current = self.template\n        if isinstance(current, MetaTemplate):\n            current.delete()\n        self.get_meta_body().append(template)\n\n    def get_auto_reload(self) -&gt; MetaAutoReload | None:\n        \"\"\"Get the MetaAutoReload &lt;meta:auto-reload&gt; element or None.\"\"\"\n        element = self.get_element(\"//meta:auto-reload\")\n        if element is None:\n            return None\n        return element\n\n    @property\n    def auto_reload(self) -&gt; MetaAutoReload | None:\n        \"\"\"Get the MetaAutoReload &lt;meta:auto-reload&gt; element or None.\"\"\"\n        return self.get_auto_reload()\n\n    def set_auto_reload(self, delay: timedelta, href: str = \"\") -&gt; None:\n        \"\"\"Set the MetaAutoReload &lt;meta:auto-reload&gt; element.\"\"\"\n        autoreload = MetaAutoReload(delay=delay, href=href)\n        current = self.auto_reload\n        if isinstance(current, MetaAutoReload):\n            current.delete()\n        self.get_meta_body().append(autoreload)\n\n    def get_hyperlink_behaviour(self) -&gt; MetaHyperlinkBehaviour | None:\n        \"\"\"Get the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element or None.\"\"\"\n        element = self.get_element(\"//meta:hyperlink-behaviour\")\n        if element is None:\n            return None\n        return element\n\n    @property\n    def hyperlink_behaviour(self) -&gt; MetaAutoReload | None:\n        \"\"\"Get the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element or None.\"\"\"\n        return self.get_hyperlink_behaviour()\n\n    def set_hyperlink_behaviour(\n        self,\n        target_frame_name: str = \"_blank\",\n        show: str = \"replace\",\n    ) -&gt; None:\n        \"\"\"Set the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element.\"\"\"\n        behaviour = MetaHyperlinkBehaviour(\n            target_frame_name=target_frame_name, show=show\n        )\n        current = self.hyperlink_behaviour\n        if isinstance(current, MetaHyperlinkBehaviour):\n            current.delete()\n        self.get_meta_body().append(behaviour)\n\n    def get_initial_creator(self) -&gt; str | None:\n        \"\"\"Get the first creator of the document.\n\n        (Also available as \"self.initial_creator\" property.)\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.get_initial_creator()\n            Unknown\n        \"\"\"\n        element = self.get_element(\"//meta:initial-creator\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_initial_creator(self, creator: str) -&gt; None:\n        \"\"\"Set the first creator of the document.\n\n        (Also available as \"self.initial_creator\" property.)\n\n        Arguments:\n\n            creator -- str\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_initial_creator(\"Plato\")\n        \"\"\"\n        element = self.get_element(\"//meta:initial-creator\")\n        if element is None:\n            element = Element.from_tag(\"meta:initial-creator\")\n            self.get_meta_body().append(element)\n        element.text = creator\n\n    @property\n    def initial_creator(self) -&gt; str | None:\n        \"\"\"Get or set the initial creator of a document\n        &lt;meta:initial-creator&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_initial_creator()\n\n    @initial_creator.setter\n    def initial_creator(self, creator: str) -&gt; None:\n        return self.set_initial_creator(creator)\n\n    @property\n    def printed_by(self) -&gt; str | None:\n        \"\"\"Get or set the name of the last person who printed a document.\n        &lt;meta:printed-by&gt;\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:printed-by\")\n        if element is None:\n            return None\n        return element.text\n\n    @printed_by.setter\n    def printed_by(self, printed_by: str) -&gt; None:\n        element = self.get_element(\"//meta:printed-by\")\n        if element is None:\n            element = Element.from_tag(\"meta:printed-by\")\n            self.get_meta_body().append(element)\n        element.text = printed_by\n\n    def get_keywords(self) -&gt; str | None:\n        \"\"\"Get the keywords of the document. Return the field as-is, without\n        any assumption on the keyword separator.\n\n        (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:keyword\")\n        if element is None:\n            return None\n        return element.text\n\n    def set_keywords(self, keywords: str) -&gt; None:\n        \"\"\"Set the keywords of the document. Although the name is plural, a\n        str string is required, so join your list first.\n\n        (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n        Arguments:\n\n            keywords -- str\n        \"\"\"\n        element = self.get_element(\"//meta:keyword\")\n        if element is None:\n            element = Element.from_tag(\"meta:keyword\")\n            self.get_meta_body().append(element)\n        element.text = keywords\n\n    @property\n    def keyword(self) -&gt; str | None:\n        \"\"\"Get or set some keyword(s) keyword pertaining to a document\n        &lt;dc:keyword&gt;.\n\n        Return: str (or None if inexistant)\n        \"\"\"\n        return self.get_keywords()\n\n    @keyword.setter\n    def keyword(self, keyword: str) -&gt; None:\n        return self.set_keywords(keyword)\n\n    keywords = keyword\n\n    def get_editing_duration(self) -&gt; timedelta | None:\n        \"\"\"Get the time the document was edited, as reported by the\n        generator.\n\n        (Also available as \"self.editing_duration\" property.)\n\n        Return: timedelta (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:editing-duration\")\n        if element is None:\n            return None\n        duration = element.text\n        return Duration.decode(duration)\n\n    def set_editing_duration(self, duration: timedelta) -&gt; None:\n        \"\"\"Set the time the document was edited.\n\n        (Also available as \"self.editing_duration\" property.)\n\n        Arguments:\n\n            duration -- timedelta\n        \"\"\"\n        if not isinstance(duration, timedelta):\n            raise TypeError(\"duration must be a timedelta\")\n        element = self.get_element(\"//meta:editing-duration\")\n        if element is None:\n            element = Element.from_tag(\"meta:editing-duration\")\n            self.get_meta_body().append(element)\n        element.text = Duration.encode(duration)\n\n    @property\n    def editing_duration(self) -&gt; timedelta | None:\n        \"\"\"Get or set the total time spent editing a document\n        &lt;meta:editing-duration&gt;.\n\n        Return: timedelta (or None if inexistant)\n        \"\"\"\n        return self.get_editing_duration()\n\n    @editing_duration.setter\n    def editing_duration(self, duration: timedelta) -&gt; None:\n        return self.set_editing_duration(duration)\n\n    def get_editing_cycles(self) -&gt; int | None:\n        \"\"\"Get the number of times the document was edited, as reported by\n        the generator.\n\n        (Also available as \"self.editing_cycles\" property.)\n\n        Return: int (or None if inexistant)\n        \"\"\"\n        element = self.get_element(\"//meta:editing-cycles\")\n        if element is None:\n            return None\n        cycles = element.text\n        return int(cycles)\n\n    def set_editing_cycles(self, cycles: int) -&gt; None:\n        \"\"\"Set the number of times the document was edited.\n\n        (Also available as \"self.editing_cycles\" property.)\n\n        Arguments:\n\n            cycles -- int\n        \"\"\"\n        if not isinstance(cycles, int):\n            raise TypeError(\"cycles must be an int\")\n        if cycles &lt; 1:\n            raise ValueError(\"cycles must be a positive int\")\n        element = self.get_element(\"//meta:editing-cycles\")\n        if element is None:\n            element = Element.from_tag(\"meta:editing-cycles\")\n            self.get_meta_body().append(element)\n        element.text = str(cycles)\n\n    @property\n    def editing_cycles(self) -&gt; int | None:\n        \"\"\"Get or set the number of times a document has been edited\n        &lt;meta:editing-cycles&gt;.\n\n        When a document is created, this value is set to 1. Each time\n        a document is saved, the editing-cycles number is incremented by 1.\n\n        Return: int (or None if inexistant)\n        \"\"\"\n        return self.get_editing_cycles()\n\n    @editing_cycles.setter\n    def editing_cycles(self, cycles: int) -&gt; None:\n        return self.set_editing_cycles(cycles)\n\n    @property\n    def generator(self) -&gt; str | None:\n        \"\"\"Get or set the signature of the software that generated this\n        document.\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.generator\n            KOffice/2.0.0\n            &gt;&gt;&gt; document.meta.generator = \"Odfdo experiment\"\n        \"\"\"\n        element = self.get_element(\"//meta:generator\")\n        if element is None:\n            return None\n        return element.text\n\n    @generator.setter\n    def generator(self, generator: str) -&gt; None:\n        element = self.get_element(\"//meta:generator\")\n        if element is None:\n            element = Element.from_tag(\"meta:generator\")\n            self.get_meta_body().append(element)\n        element.text = generator\n        self._generator_modified = True\n\n    def get_generator(self) -&gt; str | None:\n        \"\"\"Get the signature of the software that generated this document.\n\n        (Also available as \"self.generator\" property.)\n\n        Return: str (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.get_generator()\n            KOffice/2.0.0\n        \"\"\"\n        return self.generator\n\n    def set_generator(self, generator: str) -&gt; None:\n        \"\"\"Set the signature of the software that generated this document.\n\n        (Also available as \"self.generator\" property.)\n\n        Arguments:\n\n            generator -- str\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_generator(\"Odfdo experiment\")\n        \"\"\"\n        self.generator = generator\n\n    def set_generator_default(self) -&gt; None:\n        \"\"\"Set the signature of the software that generated this document\n        to ourself.\n\n        Example::\n\n            &gt;&gt;&gt; document.meta.set_generator_default()\n        \"\"\"\n        if not self._generator_modified:\n            self.generator = GENERATOR\n\n    def get_statistic(self) -&gt; dict[str, int] | None:\n        \"\"\"Get the statistics about a document.\n\n        (Also available as \"self.statistic\" property.)\n\n        Return: dict (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.get_statistic():\n            {'meta:table-count': 1,\n             'meta:image-count': 2,\n             'meta:object-count': 3,\n             'meta:page-count': 4,\n             'meta:paragraph-count': 5,\n             'meta:word-count': 6,\n             'meta:character-count': 7,\n             'meta:non-whitespace-character-count': 3}\n        \"\"\"\n        element = self.get_element(\"//meta:document-statistic\")\n        if element is None:\n            return None\n        statistic = {}\n        for key, value in element.attributes.items():\n            statistic[to_str(key)] = int(value)\n        return statistic\n\n    def set_statistic(self, statistic: dict[str, int]) -&gt; None:\n        \"\"\"Set the statistics about a document.\n\n        (Also available as \"self.statistic\" property.)\n\n        Arguments:\n\n            statistic -- dict\n\n        Example::\n\n            &gt;&gt;&gt; statistic = {'meta:table-count': 1,\n                             'meta:image-count': 2,\n                             'meta:object-count': 3,\n                             'meta:page-count': 4,\n                             'meta:paragraph-count': 5,\n                             'meta:word-count': 6,\n                             'meta:character-count': 7,\n                             'meta:non-whitespace-character-count': 3}\n            &gt;&gt;&gt; document.meta.set_statistic(statistic)\n        \"\"\"\n        if not isinstance(statistic, dict):\n            raise TypeError(\"Statistic must be a dict\")\n        element = self.get_element(\"//meta:document-statistic\")\n        for key, value in statistic.items():\n            try:\n                ivalue = int(value)\n            except ValueError as e:\n                raise TypeError(\"Statistic value must be a int\") from e\n            element.set_attribute(to_str(key), str(ivalue))\n\n    @property\n    def statistic(self) -&gt; dict[str, int] | None:\n        \"\"\"Get or set the statistics about a document\n        &lt;meta:document-statistic&gt;.\n\n        Return: dict (or None if inexistant)\n\n        Example::\n\n            &gt;&gt;&gt; document.get_statistic():\n            {'meta:table-count': 1,\n             'meta:image-count': 2,\n             'meta:object-count': 3,\n             'meta:page-count': 4,\n             'meta:paragraph-count': 5,\n             'meta:word-count': 6,\n             'meta:character-count': 7,\n             'meta:non-whitespace-character-count':3}\n        \"\"\"\n        return self.get_statistic()\n\n    @statistic.setter\n    def statistic(self, statistic: dict[str, int]) -&gt; None:\n        return self.set_statistic(statistic)\n\n    def get_user_defined_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Get all additional user-defined metadata for a document.\n\n        (Also available as \"self.user_defined_metadata\" property.)\n\n        Return a dict of str/value mapping.\n\n        Value types can be: Decimal, date, time, boolean or str.\n        \"\"\"\n        result: dict[str, Any] = {}\n        for item in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(item, Element):\n                continue\n            # Read the values\n            name = item.get_attribute_string(\"meta:name\")\n            if name is None:\n                continue\n            value = self._get_meta_value(item)\n            result[name] = value\n        return result\n\n    def _user_defined_metadata_list(self) -&gt; list[dict[str, Any]]:\n        user_defined: list[dict[str, Any]] = []\n        for item in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(item, Element):\n                continue\n            # Read the values\n            name = item.get_attribute_string(\"meta:name\")\n            if not name:\n                continue\n            value, value_type, _text = self._get_meta_value_full(item)\n            user_defined.append(\n                {\"meta:name\": name, \"meta:value-type\": value_type, \"value\": value}\n            )\n        return sorted(user_defined, key=itemgetter(\"meta:name\"))\n\n    def clear_user_defined_metadata(self) -&gt; None:\n        \"\"\"Remove all user-defined metadata.\"\"\"\n        while True:\n            element = self.get_element(\"//meta:user-defined\")\n            if isinstance(element, Element):\n                element.delete()\n                continue\n            break\n\n    @property\n    def user_defined_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Get or set all additional user-defined metadata for a document.\n\n        Return a dict of str/value mapping.\n\n        Value types can be: Decimal, date, time, boolean or str.\n        \"\"\"\n        return self.get_user_defined_metadata()\n\n    @user_defined_metadata.setter\n    def user_defined_metadata(self, metadata: dict[str, Any]) -&gt; None:\n        self.clear_user_defined_metadata()\n        for key, val in metadata.items():\n            self.set_user_defined_metadata(name=key, value=val)\n\n    def get_user_defined_metadata_of_name(self, keyname: str) -&gt; dict[str, Any] | None:\n        \"\"\"Return the content of the user defined metadata of that name.\n        Return None if no name matchs or a dic of fields.\n\n        Arguments:\n\n            name -- string, name (meta:name content)\n        \"\"\"\n        result = {}\n        found = False\n        for item in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(item, Element):\n                continue\n            # Read the values\n            name = item.get_attribute(\"meta:name\")\n            if name == keyname:\n                found = True\n                break\n        if not found:\n            return None\n        result[\"name\"] = name\n        value, value_type, text = self._get_meta_value(item, full=True)  # type: ignore\n        result[\"value\"] = value\n        result[\"value_type\"] = value_type\n        result[\"text\"] = text\n        return result\n\n    def set_user_defined_metadata(self, name: str, value: Any) -&gt; None:\n        if isinstance(value, bool):\n            value_type = \"boolean\"\n            value = \"true\" if value else \"false\"\n        elif isinstance(value, (int, float, Decimal)):\n            value_type = \"float\"\n            value = str(value)\n        elif isinstance(value, dtdate):\n            value_type = \"date\"\n            value = str(Date.encode(value))\n        elif isinstance(value, datetime):\n            value_type = \"date\"\n            value = str(DateTime.encode(value))\n        elif isinstance(value, str):\n            value_type = \"string\"\n        elif isinstance(value, timedelta):\n            value_type = \"time\"\n            value = str(Duration.encode(value))\n        else:\n            raise TypeError(f'unexpected type \"{type(value)}\" for value')\n        # Already the same element ?\n        for metadata in self.get_elements(\"//meta:user-defined\"):\n            if not isinstance(metadata, Element):\n                continue\n            if metadata.get_attribute(\"meta:name\") == name:\n                break\n        else:\n            metadata = Element.from_tag(\"meta:user-defined\")\n            metadata.set_attribute(\"meta:name\", name)\n            self.get_meta_body().append(metadata)\n        metadata.set_attribute(\"meta:value-type\", value_type)\n        metadata.text = value\n\n    def _get_meta_value(\n        self, element: Element, full: bool = False\n    ) -&gt; Any | tuple[Any, str, str]:\n        \"\"\"get_value() deicated to the meta data part, for one meta element.\"\"\"\n        if full:\n            return self._get_meta_value_full(element)\n        else:\n            return self._get_meta_value_full(element)[0]\n\n    @staticmethod\n    def _get_meta_value_full(element: Element) -&gt; tuple[Any, str, str]:\n        \"\"\"get_value deicated to the meta data part, for one meta element.\"\"\"\n        # name = element.get_attribute('meta:name')\n        value_type = element.get_attribute_string(\"meta:value-type\")\n        if value_type is None:\n            value_type = \"string\"\n        text = element.text\n        # Interpretation\n        if value_type == \"boolean\":\n            return (Boolean.decode(text), value_type, text)\n        if value_type in (\"float\", \"percentage\", \"currency\"):\n            return (Decimal(text), value_type, text)\n        if value_type == \"date\":\n            if \"T\" in text:\n                return (DateTime.decode(text), value_type, text)\n            else:\n                return (Date.decode(text), value_type, text)\n        if value_type == \"string\":\n            return (text, value_type, text)\n        if value_type == \"time\":\n            return (Duration.decode(text), value_type, text)\n        raise TypeError(f\"Unknown value type: '{value_type!r}'\")\n\n    def as_dict(self, full: bool = False) -&gt; dict[str, Any]:\n        \"\"\"Return the metadata of the document as a Python dict.\n\n        if 'full' is True, export also the keys with no value assigned.\n\n        Arguments:\n\n            full -- boolean\n        \"\"\"\n\n        def _stats() -&gt; dict[str, int]:\n            doc_stats = self.statistic\n            if doc_stats is None:\n                msg = \"Document statitics not found\"\n                raise LookupError(msg)\n            return {\n                key: doc_stats.get(key, 0)\n                for key in (\n                    \"meta:table-count\",\n                    \"meta:image-count\",\n                    \"meta:object-count\",\n                    \"meta:page-count\",\n                    \"meta:paragraph-count\",\n                    \"meta:word-count\",\n                    \"meta:character-count\",\n                    \"meta:non-whitespace-character-count\",\n                )\n            }\n\n        def _meta_template() -&gt; dict[str, Any] | None:\n            template = self.template\n            if template is None:\n                return None\n            return template.as_dict()\n\n        def _meta_reload() -&gt; dict[str, Any] | None:\n            reload = self.auto_reload\n            if reload is None:\n                return None\n            return reload.as_dict()\n\n        def _meta_behaviour() -&gt; dict[str, Any] | None:\n            behaviour = self.hyperlink_behaviour\n            if behaviour is None:\n                return None\n            return behaviour.as_dict()\n\n        meta_data: dict[str, Any] = {\n            \"meta:creation-date\": self.creation_date,\n            \"dc:date\": self.date,\n            \"meta:editing-duration\": self.editing_duration,\n            \"meta:editing-cycles\": self.editing_cycles,\n            \"meta:document-statistic\": _stats(),\n            \"meta:generator\": self.generator,\n            \"dc:title\": self.title,\n            \"dc:description\": self.description,\n            \"dc:creator\": self.creator,\n            \"meta:keyword\": self.keyword,\n            \"dc:subject\": self.subject,\n            \"dc:language\": self.language,\n            \"meta:initial-creator\": self.initial_creator,\n            \"meta:print-date\": self.print_date,\n            \"meta:printed-by\": self.printed_by,\n            \"meta:template\": _meta_template(),\n            \"meta:auto-reload\": _meta_reload(),\n            \"meta:hyperlink-behaviour\": _meta_behaviour(),\n            \"meta:user-defined\": self._user_defined_metadata_list(),\n        }\n\n        if not full:\n            meta_data = {key: val for key, val in meta_data.items() if val}\n        return meta_data\n\n    def _as_json_dict(self, full: bool = False) -&gt; dict[str, Any]:\n        def _convert(data: dict[str, Any]) -&gt; None:\n            for key, val in data.items():\n                if isinstance(val, datetime):\n                    data[key] = DateTime.encode(val)\n                elif isinstance(val, timedelta):\n                    data[key] = Duration.encode(val)\n                elif isinstance(val, Decimal):\n                    data[key] = json.loads(str(Decimal(val)))\n\n        meta_data: dict[str, Any] = self.as_dict(full=full)\n        user_defined = meta_data.get(\"meta:user-defined\", [])\n        for item in user_defined:\n            _convert(item)\n        meta_data[\"meta:user-defined\"] = user_defined\n        _convert(meta_data)\n        return meta_data\n\n    def as_json(self, full: bool = False) -&gt; str:\n        \"\"\"Return the metadata of the document as a JSON string.\n\n        if 'full' is True, export also the keys with no value assigned.\n\n        Arguments:\n\n            full -- boolean\n        \"\"\"\n        return json.dumps(\n            self._as_json_dict(full=full),\n            ensure_ascii=False,\n            sort_keys=False,\n            indent=4,\n        )\n\n    def as_text(self) -&gt; str:\n        \"\"\"Return meta informations as text, with some formatting for printing.\"\"\"\n        data = self._as_json_dict(full=False)\n        result: list[str] = []\n\n        def _append_info(name: str, key: str) -&gt; None:\n            value = data.get(key)\n            if value:\n                result.append(f\"{name}: {value}\")\n\n        _append_info(\"Title\", \"dc:title\")\n        _append_info(\"Subject\", \"dc:subject\")\n        _append_info(\"Description\", \"dc:description\")\n        _append_info(\"Language\", \"dc:language\")\n        _append_info(\"Modification date\", \"dc:date\")\n        _append_info(\"Creation date\", \"meta:creation-date\")\n        _append_info(\"Creator\", \"dc:creator\")\n        _append_info(\"Initial creator\", \"meta:initial-creator\")\n        _append_info(\"Keyword\", \"meta:keyword\")\n        _append_info(\"Editing duration\", \"meta:editing-duration\")\n        _append_info(\"Editing cycles\", \"meta:editing-cycles\")\n        _append_info(\"Generator\", \"meta:generator\")\n\n        result.append(\"Statistic:\")\n        statistic = data.get(\"meta:document-statistic\", {})\n        if statistic:\n            for name, value in statistic.items():\n                result.append(f\"  - {name[5:].replace('-', ' ').capitalize()}: {value}\")\n\n        result.append(\"User defined metadata:\")\n        user_metadata = data.get(\"meta:user-defined\", [])\n        for item in user_metadata:\n            result.append(f\"  - {item['meta:name']}: {item['value']}\")\n\n        return \"\\n\".join(result)\n\n    @staticmethod\n    def _complete_stats(\n        current_stats: dict[str, int],\n        imported_stats: dict[str, int] | None,\n    ) -&gt; dict[str, int]:\n        if imported_stats is None:\n            imported_stats = {}\n            current_stats = {}\n        new: dict[str, int] = {}\n        for key in (\n            \"meta:table-count\",\n            \"meta:image-count\",\n            \"meta:object-count\",\n            \"meta:page-count\",\n            \"meta:paragraph-count\",\n            \"meta:word-count\",\n            \"meta:character-count\",\n            \"meta:non-whitespace-character-count\",\n        ):\n            new[key] = imported_stats.get(key, current_stats.get(key, 0))\n        return new\n\n    def from_dict(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Set the metadata of the document from a Python dict.\n\n        The loaded metadata are merged with the existing metadata.\n        If the new value of a key is None:\n            - meta:creation-date: use current time,\n            - dc:date: use creation date,\n            - meta:editing-duration: set to zero,\n            - meta:editing-cycles: set to 1,\n            - meta:generator: use odfdo generator string.\n            Other keys (not mandatory keys): remove key/value pair from\n            metadata.\n\n        Arguments:\n\n            data -- dict of metadata.\n        \"\"\"\n\n        def _value_delete(key: str) -&gt; Any:\n            value = data.get(key, current.get(key))\n            if value is None:\n                child = self.get_element(f\"//{key}\")\n                if child is not None:\n                    self.delete_element(child)\n            return value\n\n        current = self.as_dict()\n        new_stats = self._complete_stats(\n            current[\"meta:document-statistic\"],\n            data.get(\"meta:document-statistic\", {}),\n        )\n        # mandatory\n        self.statistic = new_stats\n\n        key = \"meta:creation-date\"\n        creation_date = data.get(key, current.get(key))\n        if creation_date is None:\n            creation_date = datetime.now().replace(microsecond=0)\n        self.creation_date = creation_date\n\n        key = \"dc:date\"\n        dc_date = data.get(key, current.get(key))\n        if dc_date is None:\n            dc_date = creation_date\n        if dc_date &lt; creation_date:\n            dc_date = creation_date\n        max_editing = dc_date - creation_date\n        self.date = dc_date\n\n        key = \"meta:editing-duration\"\n        editing_duration = data.get(key, current.get(key))\n        if editing_duration is None:\n            editing_duration = timedelta(0)\n        if editing_duration &gt; max_editing:\n            editing_duration = max_editing\n        self.editing_duration = editing_duration\n\n        key = \"meta:editing-cycles\"\n        editing_cycles = data.get(key, current.get(key))\n        if editing_cycles is None:\n            editing_cycles = 1\n        self.editing_cycles = max(editing_cycles, 1)\n\n        key = \"meta:generator\"\n        generator = data.get(key, current.get(key))\n        if not generator:\n            generator = GENERATOR\n        self.generator = generator\n\n        # not mandatory values\n        # - if not in imported: keep original value\n        # - if imported is None: erase original value\n\n        key = \"dc:title\"\n        value = _value_delete(key)\n        if value is not None:\n            self.title = value\n\n        key = \"dc:description\"\n        value = _value_delete(key)\n        if value is not None:\n            self.description = value\n\n        key = \"dc:creator\"\n        value = _value_delete(key)\n        if value is not None:\n            self.creator = value\n\n        key = \"meta:keyword\"\n        value = _value_delete(key)\n        if value is not None:\n            self.keyword = value\n\n        key = \"dc:subject\"\n        value = _value_delete(key)\n        if value is not None:\n            self.subject = value\n\n        key = \"dc:language\"\n        value = _value_delete(key)\n        if value is not None:\n            self.language = value\n\n        key = \"meta:initial-creator\"\n        value = _value_delete(key)\n        if value is not None:\n            self.initial_creator = value\n\n        key = \"meta:print-date\"\n        value = _value_delete(key)\n        if value is not None:\n            self.print_date = value\n\n        key = \"meta:printed-by\"\n        value = _value_delete(key)\n        if value is not None:\n            self.printed_by = value\n\n        key = \"meta:template\"\n        value = _value_delete(key)\n        if value is not None:\n            value = value.as_dict()\n            self.set_template(\n                date=value[\"meta:date\"],\n                href=value[\"xlink:href\"],\n                title=value[\"xlink:title\"],\n            )\n\n        key = \"meta:auto-reload\"\n        value = _value_delete(key)\n        if value is not None:\n            value = value.as_dict()\n            self.set_auto_reload(\n                delay=value[\"meta:delay\"],\n                href=value[\"xlink:href\"],\n            )\n\n        key = \"meta:hyperlink-behaviour\"\n        value = _value_delete(key)\n        if value is not None:\n            value = value.as_dict()\n            self.set_hyperlink_behaviour(\n                target_frame_name=value[\"office:target-frame-name\"],\n                show=value[\"xlink:show\"],\n            )\n\n        key = \"meta:user-defined\"\n        if key in data:\n            value = data[key]\n            if value is None:\n                self.clear_user_defined_metadata()\n            else:\n                current = self._user_defined_metadata_list()\n                current_dict = {d[\"meta:name\"]: d for d in current}\n                current_value = {d[\"meta:name\"]: d for d in value}\n                current_dict.update(current_value)\n                new_ud = {\n                    v[\"meta:name\"]: v[\"value\"]\n                    for v in current_dict.values()\n                    if v[\"value\"] is not None\n                }\n                self.user_defined_metadata = new_ud\n</code></pre>"},{"location":"reference.html#odfdo.Meta.auto_reload","title":"<code>auto_reload</code>  <code>property</code>","text":"<p>Get the MetaAutoReload  element or None."},{"location":"reference.html#odfdo.Meta.creation_date","title":"<code>creation_date</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the date and time when a document was created . <p>If provided datetime is None, use current time.</p> <p>Return: datetime (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.description","title":"<code>description</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the description of a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.editing_cycles","title":"<code>editing_cycles</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the number of times a document has been edited . <p>When a document is created, this value is set to 1. Each time a document is saved, the editing-cycles number is incremented by 1.</p> <p>Return: int (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.editing_duration","title":"<code>editing_duration</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the total time spent editing a document . <p>Return: timedelta (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.generator","title":"<code>generator</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the signature of the software that generated this document.</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.generator\nKOffice/2.0.0\n&gt;&gt;&gt; document.meta.generator = \"Odfdo experiment\"\n</code></pre>"},{"location":"reference.html#odfdo.Meta.hyperlink_behaviour","title":"<code>hyperlink_behaviour</code>  <code>property</code>","text":"<p>Get the MetaHyperlinkBehaviour  element or None."},{"location":"reference.html#odfdo.Meta.initial_creator","title":"<code>initial_creator</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the initial creator of a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.keyword","title":"<code>keyword</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set some keyword(s) keyword pertaining to a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.language","title":"<code>language</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the default language of the document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.print_date","title":"<code>print_date</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the date and time when a document when a document was last printed  <p>If provided datetime is None, use current time.</p> <p>Return: datetime (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.printed_by","title":"<code>printed_by</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the name of the last person who printed a document.  <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.statistic","title":"<code>statistic</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the statistics about a document . <p>Return: dict (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.get_statistic():\n{'meta:table-count': 1,\n 'meta:image-count': 2,\n 'meta:object-count': 3,\n 'meta:page-count': 4,\n 'meta:paragraph-count': 5,\n 'meta:word-count': 6,\n 'meta:character-count': 7,\n 'meta:non-whitespace-character-count':3}\n</code></pre>"},{"location":"reference.html#odfdo.Meta.subject","title":"<code>subject</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the subject of a document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.template","title":"<code>template</code>  <code>property</code>","text":"<p>Get the MetaTemplate  element or None."},{"location":"reference.html#odfdo.Meta.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the title of the document . <p>Return: str (or None if inexistant)</p>"},{"location":"reference.html#odfdo.Meta.user_defined_metadata","title":"<code>user_defined_metadata</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set all additional user-defined metadata for a document.</p> <p>Return a dict of str/value mapping.</p> <p>Value types can be: Decimal, date, time, boolean or str.</p>"},{"location":"reference.html#odfdo.Meta.as_dict","title":"<code>as_dict(full=False)</code>","text":"<p>Return the metadata of the document as a Python dict.</p> <p>if \u2018full\u2019 is True, export also the keys with no value assigned.</p> <p>Arguments:</p> <pre><code>full -- boolean\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def as_dict(self, full: bool = False) -&gt; dict[str, Any]:\n    \"\"\"Return the metadata of the document as a Python dict.\n\n    if 'full' is True, export also the keys with no value assigned.\n\n    Arguments:\n\n        full -- boolean\n    \"\"\"\n\n    def _stats() -&gt; dict[str, int]:\n        doc_stats = self.statistic\n        if doc_stats is None:\n            msg = \"Document statitics not found\"\n            raise LookupError(msg)\n        return {\n            key: doc_stats.get(key, 0)\n            for key in (\n                \"meta:table-count\",\n                \"meta:image-count\",\n                \"meta:object-count\",\n                \"meta:page-count\",\n                \"meta:paragraph-count\",\n                \"meta:word-count\",\n                \"meta:character-count\",\n                \"meta:non-whitespace-character-count\",\n            )\n        }\n\n    def _meta_template() -&gt; dict[str, Any] | None:\n        template = self.template\n        if template is None:\n            return None\n        return template.as_dict()\n\n    def _meta_reload() -&gt; dict[str, Any] | None:\n        reload = self.auto_reload\n        if reload is None:\n            return None\n        return reload.as_dict()\n\n    def _meta_behaviour() -&gt; dict[str, Any] | None:\n        behaviour = self.hyperlink_behaviour\n        if behaviour is None:\n            return None\n        return behaviour.as_dict()\n\n    meta_data: dict[str, Any] = {\n        \"meta:creation-date\": self.creation_date,\n        \"dc:date\": self.date,\n        \"meta:editing-duration\": self.editing_duration,\n        \"meta:editing-cycles\": self.editing_cycles,\n        \"meta:document-statistic\": _stats(),\n        \"meta:generator\": self.generator,\n        \"dc:title\": self.title,\n        \"dc:description\": self.description,\n        \"dc:creator\": self.creator,\n        \"meta:keyword\": self.keyword,\n        \"dc:subject\": self.subject,\n        \"dc:language\": self.language,\n        \"meta:initial-creator\": self.initial_creator,\n        \"meta:print-date\": self.print_date,\n        \"meta:printed-by\": self.printed_by,\n        \"meta:template\": _meta_template(),\n        \"meta:auto-reload\": _meta_reload(),\n        \"meta:hyperlink-behaviour\": _meta_behaviour(),\n        \"meta:user-defined\": self._user_defined_metadata_list(),\n    }\n\n    if not full:\n        meta_data = {key: val for key, val in meta_data.items() if val}\n    return meta_data\n</code></pre>"},{"location":"reference.html#odfdo.Meta.as_json","title":"<code>as_json(full=False)</code>","text":"<p>Return the metadata of the document as a JSON string.</p> <p>if \u2018full\u2019 is True, export also the keys with no value assigned.</p> <p>Arguments:</p> <pre><code>full -- boolean\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def as_json(self, full: bool = False) -&gt; str:\n    \"\"\"Return the metadata of the document as a JSON string.\n\n    if 'full' is True, export also the keys with no value assigned.\n\n    Arguments:\n\n        full -- boolean\n    \"\"\"\n    return json.dumps(\n        self._as_json_dict(full=full),\n        ensure_ascii=False,\n        sort_keys=False,\n        indent=4,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Meta.as_text","title":"<code>as_text()</code>","text":"<p>Return meta informations as text, with some formatting for printing.</p> Source code in <code>odfdo/meta.py</code> <pre><code>def as_text(self) -&gt; str:\n    \"\"\"Return meta informations as text, with some formatting for printing.\"\"\"\n    data = self._as_json_dict(full=False)\n    result: list[str] = []\n\n    def _append_info(name: str, key: str) -&gt; None:\n        value = data.get(key)\n        if value:\n            result.append(f\"{name}: {value}\")\n\n    _append_info(\"Title\", \"dc:title\")\n    _append_info(\"Subject\", \"dc:subject\")\n    _append_info(\"Description\", \"dc:description\")\n    _append_info(\"Language\", \"dc:language\")\n    _append_info(\"Modification date\", \"dc:date\")\n    _append_info(\"Creation date\", \"meta:creation-date\")\n    _append_info(\"Creator\", \"dc:creator\")\n    _append_info(\"Initial creator\", \"meta:initial-creator\")\n    _append_info(\"Keyword\", \"meta:keyword\")\n    _append_info(\"Editing duration\", \"meta:editing-duration\")\n    _append_info(\"Editing cycles\", \"meta:editing-cycles\")\n    _append_info(\"Generator\", \"meta:generator\")\n\n    result.append(\"Statistic:\")\n    statistic = data.get(\"meta:document-statistic\", {})\n    if statistic:\n        for name, value in statistic.items():\n            result.append(f\"  - {name[5:].replace('-', ' ').capitalize()}: {value}\")\n\n    result.append(\"User defined metadata:\")\n    user_metadata = data.get(\"meta:user-defined\", [])\n    for item in user_metadata:\n        result.append(f\"  - {item['meta:name']}: {item['value']}\")\n\n    return \"\\n\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.clear_user_defined_metadata","title":"<code>clear_user_defined_metadata()</code>","text":"<p>Remove all user-defined metadata.</p> Source code in <code>odfdo/meta.py</code> <pre><code>def clear_user_defined_metadata(self) -&gt; None:\n    \"\"\"Remove all user-defined metadata.\"\"\"\n    while True:\n        element = self.get_element(\"//meta:user-defined\")\n        if isinstance(element, Element):\n            element.delete()\n            continue\n        break\n</code></pre>"},{"location":"reference.html#odfdo.Meta.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Set the metadata of the document from a Python dict.</p> <p>The loaded metadata are merged with the existing metadata. If the new value of a key is None:     - meta:creation-date: use current time,     - dc:date: use creation date,     - meta:editing-duration: set to zero,     - meta:editing-cycles: set to 1,     - meta:generator: use odfdo generator string.     Other keys (not mandatory keys): remove key/value pair from     metadata.</p> <p>Arguments:</p> <pre><code>data -- dict of metadata.\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def from_dict(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"Set the metadata of the document from a Python dict.\n\n    The loaded metadata are merged with the existing metadata.\n    If the new value of a key is None:\n        - meta:creation-date: use current time,\n        - dc:date: use creation date,\n        - meta:editing-duration: set to zero,\n        - meta:editing-cycles: set to 1,\n        - meta:generator: use odfdo generator string.\n        Other keys (not mandatory keys): remove key/value pair from\n        metadata.\n\n    Arguments:\n\n        data -- dict of metadata.\n    \"\"\"\n\n    def _value_delete(key: str) -&gt; Any:\n        value = data.get(key, current.get(key))\n        if value is None:\n            child = self.get_element(f\"//{key}\")\n            if child is not None:\n                self.delete_element(child)\n        return value\n\n    current = self.as_dict()\n    new_stats = self._complete_stats(\n        current[\"meta:document-statistic\"],\n        data.get(\"meta:document-statistic\", {}),\n    )\n    # mandatory\n    self.statistic = new_stats\n\n    key = \"meta:creation-date\"\n    creation_date = data.get(key, current.get(key))\n    if creation_date is None:\n        creation_date = datetime.now().replace(microsecond=0)\n    self.creation_date = creation_date\n\n    key = \"dc:date\"\n    dc_date = data.get(key, current.get(key))\n    if dc_date is None:\n        dc_date = creation_date\n    if dc_date &lt; creation_date:\n        dc_date = creation_date\n    max_editing = dc_date - creation_date\n    self.date = dc_date\n\n    key = \"meta:editing-duration\"\n    editing_duration = data.get(key, current.get(key))\n    if editing_duration is None:\n        editing_duration = timedelta(0)\n    if editing_duration &gt; max_editing:\n        editing_duration = max_editing\n    self.editing_duration = editing_duration\n\n    key = \"meta:editing-cycles\"\n    editing_cycles = data.get(key, current.get(key))\n    if editing_cycles is None:\n        editing_cycles = 1\n    self.editing_cycles = max(editing_cycles, 1)\n\n    key = \"meta:generator\"\n    generator = data.get(key, current.get(key))\n    if not generator:\n        generator = GENERATOR\n    self.generator = generator\n\n    # not mandatory values\n    # - if not in imported: keep original value\n    # - if imported is None: erase original value\n\n    key = \"dc:title\"\n    value = _value_delete(key)\n    if value is not None:\n        self.title = value\n\n    key = \"dc:description\"\n    value = _value_delete(key)\n    if value is not None:\n        self.description = value\n\n    key = \"dc:creator\"\n    value = _value_delete(key)\n    if value is not None:\n        self.creator = value\n\n    key = \"meta:keyword\"\n    value = _value_delete(key)\n    if value is not None:\n        self.keyword = value\n\n    key = \"dc:subject\"\n    value = _value_delete(key)\n    if value is not None:\n        self.subject = value\n\n    key = \"dc:language\"\n    value = _value_delete(key)\n    if value is not None:\n        self.language = value\n\n    key = \"meta:initial-creator\"\n    value = _value_delete(key)\n    if value is not None:\n        self.initial_creator = value\n\n    key = \"meta:print-date\"\n    value = _value_delete(key)\n    if value is not None:\n        self.print_date = value\n\n    key = \"meta:printed-by\"\n    value = _value_delete(key)\n    if value is not None:\n        self.printed_by = value\n\n    key = \"meta:template\"\n    value = _value_delete(key)\n    if value is not None:\n        value = value.as_dict()\n        self.set_template(\n            date=value[\"meta:date\"],\n            href=value[\"xlink:href\"],\n            title=value[\"xlink:title\"],\n        )\n\n    key = \"meta:auto-reload\"\n    value = _value_delete(key)\n    if value is not None:\n        value = value.as_dict()\n        self.set_auto_reload(\n            delay=value[\"meta:delay\"],\n            href=value[\"xlink:href\"],\n        )\n\n    key = \"meta:hyperlink-behaviour\"\n    value = _value_delete(key)\n    if value is not None:\n        value = value.as_dict()\n        self.set_hyperlink_behaviour(\n            target_frame_name=value[\"office:target-frame-name\"],\n            show=value[\"xlink:show\"],\n        )\n\n    key = \"meta:user-defined\"\n    if key in data:\n        value = data[key]\n        if value is None:\n            self.clear_user_defined_metadata()\n        else:\n            current = self._user_defined_metadata_list()\n            current_dict = {d[\"meta:name\"]: d for d in current}\n            current_value = {d[\"meta:name\"]: d for d in value}\n            current_dict.update(current_value)\n            new_ud = {\n                v[\"meta:name\"]: v[\"value\"]\n                for v in current_dict.values()\n                if v[\"value\"] is not None\n            }\n            self.user_defined_metadata = new_ud\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_auto_reload","title":"<code>get_auto_reload()</code>","text":"<p>Get the MetaAutoReload  element or None. Source code in <code>odfdo/meta.py</code> <pre><code>def get_auto_reload(self) -&gt; MetaAutoReload | None:\n    \"\"\"Get the MetaAutoReload &lt;meta:auto-reload&gt; element or None.\"\"\"\n    element = self.get_element(\"//meta:auto-reload\")\n    if element is None:\n        return None\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_creation_date","title":"<code>get_creation_date()</code>","text":"<p>Get the creation date of the document.</p> <p>(Also available as \u201cself.creation_date\u201d property.)</p> <p>Return: datetime (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_creation_date(self) -&gt; datetime | None:\n    \"\"\"Get the creation date of the document.\n\n    (Also available as \"self.creation_date\" property.)\n\n    Return: datetime (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:creation-date\")\n    if element is None:\n        return None\n    creation_date = element.text\n    return DateTime.decode(creation_date)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_description","title":"<code>get_description()</code>","text":"<p>Get the description of the document. Also known as comments.</p> <p>(Also available as \u201cself.description\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_description(self) -&gt; str | None:\n    \"\"\"Get the description of the document. Also known as comments.\n\n    (Also available as \"self.description\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//dc:description\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_editing_cycles","title":"<code>get_editing_cycles()</code>","text":"<p>Get the number of times the document was edited, as reported by the generator.</p> <p>(Also available as \u201cself.editing_cycles\u201d property.)</p> <p>Return: int (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_editing_cycles(self) -&gt; int | None:\n    \"\"\"Get the number of times the document was edited, as reported by\n    the generator.\n\n    (Also available as \"self.editing_cycles\" property.)\n\n    Return: int (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:editing-cycles\")\n    if element is None:\n        return None\n    cycles = element.text\n    return int(cycles)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_editing_duration","title":"<code>get_editing_duration()</code>","text":"<p>Get the time the document was edited, as reported by the generator.</p> <p>(Also available as \u201cself.editing_duration\u201d property.)</p> <p>Return: timedelta (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_editing_duration(self) -&gt; timedelta | None:\n    \"\"\"Get the time the document was edited, as reported by the\n    generator.\n\n    (Also available as \"self.editing_duration\" property.)\n\n    Return: timedelta (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:editing-duration\")\n    if element is None:\n        return None\n    duration = element.text\n    return Duration.decode(duration)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_generator","title":"<code>get_generator()</code>","text":"<p>Get the signature of the software that generated this document.</p> <p>(Also available as \u201cself.generator\u201d property.)</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.get_generator()\nKOffice/2.0.0\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_generator(self) -&gt; str | None:\n    \"\"\"Get the signature of the software that generated this document.\n\n    (Also available as \"self.generator\" property.)\n\n    Return: str (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.get_generator()\n        KOffice/2.0.0\n    \"\"\"\n    return self.generator\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_hyperlink_behaviour","title":"<code>get_hyperlink_behaviour()</code>","text":"<p>Get the MetaHyperlinkBehaviour  element or None. Source code in <code>odfdo/meta.py</code> <pre><code>def get_hyperlink_behaviour(self) -&gt; MetaHyperlinkBehaviour | None:\n    \"\"\"Get the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element or None.\"\"\"\n    element = self.get_element(\"//meta:hyperlink-behaviour\")\n    if element is None:\n        return None\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_initial_creator","title":"<code>get_initial_creator()</code>","text":"<p>Get the first creator of the document.</p> <p>(Also available as \u201cself.initial_creator\u201d property.)</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.get_initial_creator()\nUnknown\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_initial_creator(self) -&gt; str | None:\n    \"\"\"Get the first creator of the document.\n\n    (Also available as \"self.initial_creator\" property.)\n\n    Return: str (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.get_initial_creator()\n        Unknown\n    \"\"\"\n    element = self.get_element(\"//meta:initial-creator\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_keywords","title":"<code>get_keywords()</code>","text":"<p>Get the keywords of the document. Return the field as-is, without any assumption on the keyword separator.</p> <p>(Also available as \u201cself.keyword\u201d and \u201cself.keywords\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_keywords(self) -&gt; str | None:\n    \"\"\"Get the keywords of the document. Return the field as-is, without\n    any assumption on the keyword separator.\n\n    (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//meta:keyword\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_language","title":"<code>get_language()</code>","text":"<p>Get the default language of the document.</p> <p>(Also available as \u201cself.language\u201d property.)</p> <p>Return: str (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.get_language()\nfr-FR\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_language(self) -&gt; str | None:\n    \"\"\"Get the default language of the document.\n\n    (Also available as \"self.language\" property.)\n\n    Return: str (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.get_language()\n        fr-FR\n    \"\"\"\n    element = self.get_element(\"//dc:language\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_statistic","title":"<code>get_statistic()</code>","text":"<p>Get the statistics about a document.</p> <p>(Also available as \u201cself.statistic\u201d property.)</p> <p>Return: dict (or None if inexistant)</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.get_statistic():\n{'meta:table-count': 1,\n 'meta:image-count': 2,\n 'meta:object-count': 3,\n 'meta:page-count': 4,\n 'meta:paragraph-count': 5,\n 'meta:word-count': 6,\n 'meta:character-count': 7,\n 'meta:non-whitespace-character-count': 3}\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_statistic(self) -&gt; dict[str, int] | None:\n    \"\"\"Get the statistics about a document.\n\n    (Also available as \"self.statistic\" property.)\n\n    Return: dict (or None if inexistant)\n\n    Example::\n\n        &gt;&gt;&gt; document.get_statistic():\n        {'meta:table-count': 1,\n         'meta:image-count': 2,\n         'meta:object-count': 3,\n         'meta:page-count': 4,\n         'meta:paragraph-count': 5,\n         'meta:word-count': 6,\n         'meta:character-count': 7,\n         'meta:non-whitespace-character-count': 3}\n    \"\"\"\n    element = self.get_element(\"//meta:document-statistic\")\n    if element is None:\n        return None\n    statistic = {}\n    for key, value in element.attributes.items():\n        statistic[to_str(key)] = int(value)\n    return statistic\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_subject","title":"<code>get_subject()</code>","text":"<p>Get the subject of the document.</p> <p>(Also available as \u201cself.subject\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_subject(self) -&gt; str | None:\n    \"\"\"Get the subject of the document.\n\n    (Also available as \"self.subject\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//dc:subject\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_template","title":"<code>get_template()</code>","text":"<p>Get the MetaTemplate  element or None. Source code in <code>odfdo/meta.py</code> <pre><code>def get_template(self) -&gt; MetaTemplate | None:\n    \"\"\"Get the MetaTemplate &lt;meta:template&gt; element or None.\"\"\"\n    element = self.get_element(\"//meta:template\")\n    if element is None:\n        return None\n    return element\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_title","title":"<code>get_title()</code>","text":"<p>Get the title of the document.</p> <p>This is not the first heading but the title metadata.</p> <p>(Also available as \u201cself.title\u201d property.)</p> <p>Return: str (or None if inexistant)</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_title(self) -&gt; str | None:\n    \"\"\"Get the title of the document.\n\n    This is not the first heading but the title metadata.\n\n    (Also available as \"self.title\" property.)\n\n    Return: str (or None if inexistant)\n    \"\"\"\n    element = self.get_element(\"//dc:title\")\n    if element is None:\n        return None\n    return element.text\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_user_defined_metadata","title":"<code>get_user_defined_metadata()</code>","text":"<p>Get all additional user-defined metadata for a document.</p> <p>(Also available as \u201cself.user_defined_metadata\u201d property.)</p> <p>Return a dict of str/value mapping.</p> <p>Value types can be: Decimal, date, time, boolean or str.</p> Source code in <code>odfdo/meta.py</code> <pre><code>def get_user_defined_metadata(self) -&gt; dict[str, Any]:\n    \"\"\"Get all additional user-defined metadata for a document.\n\n    (Also available as \"self.user_defined_metadata\" property.)\n\n    Return a dict of str/value mapping.\n\n    Value types can be: Decimal, date, time, boolean or str.\n    \"\"\"\n    result: dict[str, Any] = {}\n    for item in self.get_elements(\"//meta:user-defined\"):\n        if not isinstance(item, Element):\n            continue\n        # Read the values\n        name = item.get_attribute_string(\"meta:name\")\n        if name is None:\n            continue\n        value = self._get_meta_value(item)\n        result[name] = value\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Meta.get_user_defined_metadata_of_name","title":"<code>get_user_defined_metadata_of_name(keyname)</code>","text":"<p>Return the content of the user defined metadata of that name. Return None if no name matchs or a dic of fields.</p> <p>Arguments:</p> <pre><code>name -- string, name (meta:name content)\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def get_user_defined_metadata_of_name(self, keyname: str) -&gt; dict[str, Any] | None:\n    \"\"\"Return the content of the user defined metadata of that name.\n    Return None if no name matchs or a dic of fields.\n\n    Arguments:\n\n        name -- string, name (meta:name content)\n    \"\"\"\n    result = {}\n    found = False\n    for item in self.get_elements(\"//meta:user-defined\"):\n        if not isinstance(item, Element):\n            continue\n        # Read the values\n        name = item.get_attribute(\"meta:name\")\n        if name == keyname:\n            found = True\n            break\n    if not found:\n        return None\n    result[\"name\"] = name\n    value, value_type, text = self._get_meta_value(item, full=True)  # type: ignore\n    result[\"value\"] = value\n    result[\"value_type\"] = value_type\n    result[\"text\"] = text\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_auto_reload","title":"<code>set_auto_reload(delay, href='')</code>","text":"<p>Set the MetaAutoReload  element. Source code in <code>odfdo/meta.py</code> <pre><code>def set_auto_reload(self, delay: timedelta, href: str = \"\") -&gt; None:\n    \"\"\"Set the MetaAutoReload &lt;meta:auto-reload&gt; element.\"\"\"\n    autoreload = MetaAutoReload(delay=delay, href=href)\n    current = self.auto_reload\n    if isinstance(current, MetaAutoReload):\n        current.delete()\n    self.get_meta_body().append(autoreload)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_creation_date","title":"<code>set_creation_date(date=None)</code>","text":"<p>Set the creation date of the document.</p> <p>If provided datetime is None, use current time.</p> <p>(Also available as \u201cself.creation_date\u201d property.)</p> <p>Arguments:</p> <pre><code>date -- datetime\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_creation_date(self, date: datetime | None = None) -&gt; None:\n    \"\"\"Set the creation date of the document.\n\n    If provided datetime is None, use current time.\n\n    (Also available as \"self.creation_date\" property.)\n\n    Arguments:\n\n        date -- datetime\n    \"\"\"\n    element = self.get_element(\"//meta:creation-date\")\n    if element is None:\n        element = Element.from_tag(\"meta:creation-date\")\n        self.get_meta_body().append(element)\n    if date is None:\n        date = datetime.now()\n    element.text = DateTime.encode(date)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_description","title":"<code>set_description(description)</code>","text":"<p>Set the description of the document. Also known as comments.</p> <p>(Also available as \u201cself.description\u201d property.)</p> <p>Arguments:</p> <pre><code>description -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_description(self, description: str) -&gt; None:\n    \"\"\"Set the description of the document. Also known as comments.\n\n    (Also available as \"self.description\" property.)\n\n    Arguments:\n\n        description -- str\n    \"\"\"\n    element = self.get_element(\"//dc:description\")\n    if element is None:\n        element = Element.from_tag(\"dc:description\")\n        self.get_meta_body().append(element)\n    element.text = description\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_editing_cycles","title":"<code>set_editing_cycles(cycles)</code>","text":"<p>Set the number of times the document was edited.</p> <p>(Also available as \u201cself.editing_cycles\u201d property.)</p> <p>Arguments:</p> <pre><code>cycles -- int\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_editing_cycles(self, cycles: int) -&gt; None:\n    \"\"\"Set the number of times the document was edited.\n\n    (Also available as \"self.editing_cycles\" property.)\n\n    Arguments:\n\n        cycles -- int\n    \"\"\"\n    if not isinstance(cycles, int):\n        raise TypeError(\"cycles must be an int\")\n    if cycles &lt; 1:\n        raise ValueError(\"cycles must be a positive int\")\n    element = self.get_element(\"//meta:editing-cycles\")\n    if element is None:\n        element = Element.from_tag(\"meta:editing-cycles\")\n        self.get_meta_body().append(element)\n    element.text = str(cycles)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_editing_duration","title":"<code>set_editing_duration(duration)</code>","text":"<p>Set the time the document was edited.</p> <p>(Also available as \u201cself.editing_duration\u201d property.)</p> <p>Arguments:</p> <pre><code>duration -- timedelta\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_editing_duration(self, duration: timedelta) -&gt; None:\n    \"\"\"Set the time the document was edited.\n\n    (Also available as \"self.editing_duration\" property.)\n\n    Arguments:\n\n        duration -- timedelta\n    \"\"\"\n    if not isinstance(duration, timedelta):\n        raise TypeError(\"duration must be a timedelta\")\n    element = self.get_element(\"//meta:editing-duration\")\n    if element is None:\n        element = Element.from_tag(\"meta:editing-duration\")\n        self.get_meta_body().append(element)\n    element.text = Duration.encode(duration)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_generator","title":"<code>set_generator(generator)</code>","text":"<p>Set the signature of the software that generated this document.</p> <p>(Also available as \u201cself.generator\u201d property.)</p> <p>Arguments:</p> <pre><code>generator -- str\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_generator(\"Odfdo experiment\")\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_generator(self, generator: str) -&gt; None:\n    \"\"\"Set the signature of the software that generated this document.\n\n    (Also available as \"self.generator\" property.)\n\n    Arguments:\n\n        generator -- str\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_generator(\"Odfdo experiment\")\n    \"\"\"\n    self.generator = generator\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_generator_default","title":"<code>set_generator_default()</code>","text":"<p>Set the signature of the software that generated this document to ourself.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_generator_default()\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_generator_default(self) -&gt; None:\n    \"\"\"Set the signature of the software that generated this document\n    to ourself.\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_generator_default()\n    \"\"\"\n    if not self._generator_modified:\n        self.generator = GENERATOR\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_hyperlink_behaviour","title":"<code>set_hyperlink_behaviour(target_frame_name='_blank', show='replace')</code>","text":"<p>Set the MetaHyperlinkBehaviour  element. Source code in <code>odfdo/meta.py</code> <pre><code>def set_hyperlink_behaviour(\n    self,\n    target_frame_name: str = \"_blank\",\n    show: str = \"replace\",\n) -&gt; None:\n    \"\"\"Set the MetaHyperlinkBehaviour &lt;meta:hyperlink-behaviour&gt; element.\"\"\"\n    behaviour = MetaHyperlinkBehaviour(\n        target_frame_name=target_frame_name, show=show\n    )\n    current = self.hyperlink_behaviour\n    if isinstance(current, MetaHyperlinkBehaviour):\n        current.delete()\n    self.get_meta_body().append(behaviour)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_initial_creator","title":"<code>set_initial_creator(creator)</code>","text":"<p>Set the first creator of the document.</p> <p>(Also available as \u201cself.initial_creator\u201d property.)</p> <p>Arguments:</p> <pre><code>creator -- str\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_initial_creator(\"Plato\")\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_initial_creator(self, creator: str) -&gt; None:\n    \"\"\"Set the first creator of the document.\n\n    (Also available as \"self.initial_creator\" property.)\n\n    Arguments:\n\n        creator -- str\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_initial_creator(\"Plato\")\n    \"\"\"\n    element = self.get_element(\"//meta:initial-creator\")\n    if element is None:\n        element = Element.from_tag(\"meta:initial-creator\")\n        self.get_meta_body().append(element)\n    element.text = creator\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_keywords","title":"<code>set_keywords(keywords)</code>","text":"<p>Set the keywords of the document. Although the name is plural, a str string is required, so join your list first.</p> <p>(Also available as \u201cself.keyword\u201d and \u201cself.keywords\u201d property.)</p> <p>Arguments:</p> <pre><code>keywords -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_keywords(self, keywords: str) -&gt; None:\n    \"\"\"Set the keywords of the document. Although the name is plural, a\n    str string is required, so join your list first.\n\n    (Also available as \"self.keyword\" and \"self.keywords\" property.)\n\n    Arguments:\n\n        keywords -- str\n    \"\"\"\n    element = self.get_element(\"//meta:keyword\")\n    if element is None:\n        element = Element.from_tag(\"meta:keyword\")\n        self.get_meta_body().append(element)\n    element.text = keywords\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_language","title":"<code>set_language(language)</code>","text":"<p>Set the default language of the document.</p> <p>(Also available as \u201cself.language\u201d property.)</p> <p>Arguments:</p> <pre><code>language -- str\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; document.meta.set_language('fr-FR')\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_language(self, language: str) -&gt; None:\n    \"\"\"Set the default language of the document.\n\n    (Also available as \"self.language\" property.)\n\n    Arguments:\n\n        language -- str\n\n    Example::\n\n        &gt;&gt;&gt; document.meta.set_language('fr-FR')\n    \"\"\"\n    language = str(language)\n    if not self._is_RFC3066(language):\n        raise TypeError(\n            'Language must be \"xx\" lang or \"xx-YY\" lang-COUNTRY code (RFC3066)'\n        )\n    element = self.get_element(\"//dc:language\")\n    if element is None:\n        element = Element.from_tag(\"dc:language\")\n        self.get_meta_body().append(element)\n    element.text = language\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_statistic","title":"<code>set_statistic(statistic)</code>","text":"<p>Set the statistics about a document.</p> <p>(Also available as \u201cself.statistic\u201d property.)</p> <p>Arguments:</p> <pre><code>statistic -- dict\n</code></pre> <p>Example::</p> <pre><code>&gt;&gt;&gt; statistic = {'meta:table-count': 1,\n                 'meta:image-count': 2,\n                 'meta:object-count': 3,\n                 'meta:page-count': 4,\n                 'meta:paragraph-count': 5,\n                 'meta:word-count': 6,\n                 'meta:character-count': 7,\n                 'meta:non-whitespace-character-count': 3}\n&gt;&gt;&gt; document.meta.set_statistic(statistic)\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_statistic(self, statistic: dict[str, int]) -&gt; None:\n    \"\"\"Set the statistics about a document.\n\n    (Also available as \"self.statistic\" property.)\n\n    Arguments:\n\n        statistic -- dict\n\n    Example::\n\n        &gt;&gt;&gt; statistic = {'meta:table-count': 1,\n                         'meta:image-count': 2,\n                         'meta:object-count': 3,\n                         'meta:page-count': 4,\n                         'meta:paragraph-count': 5,\n                         'meta:word-count': 6,\n                         'meta:character-count': 7,\n                         'meta:non-whitespace-character-count': 3}\n        &gt;&gt;&gt; document.meta.set_statistic(statistic)\n    \"\"\"\n    if not isinstance(statistic, dict):\n        raise TypeError(\"Statistic must be a dict\")\n    element = self.get_element(\"//meta:document-statistic\")\n    for key, value in statistic.items():\n        try:\n            ivalue = int(value)\n        except ValueError as e:\n            raise TypeError(\"Statistic value must be a int\") from e\n        element.set_attribute(to_str(key), str(ivalue))\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_subject","title":"<code>set_subject(subject)</code>","text":"<p>Set the subject of the document.</p> <p>(Also available as \u201cself.subject\u201d property.)</p> <p>Arguments:</p> <pre><code>subject -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_subject(self, subject: str) -&gt; None:\n    \"\"\"Set the subject of the document.\n\n    (Also available as \"self.subject\" property.)\n\n    Arguments:\n\n        subject -- str\n    \"\"\"\n    element = self.get_element(\"//dc:subject\")\n    if element is None:\n        element = Element.from_tag(\"dc:subject\")\n        self.get_meta_body().append(element)\n    element.text = subject\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_template","title":"<code>set_template(date=None, href='', title='')</code>","text":"<p>Set the MetaTemplate  element. Source code in <code>odfdo/meta.py</code> <pre><code>def set_template(\n    self,\n    date: datetime | None = None,\n    href: str = \"\",\n    title: str = \"\",\n) -&gt; None:\n    \"\"\"Set the MetaTemplate &lt;meta:template&gt; element.\"\"\"\n    template = MetaTemplate(date=date, href=href, title=title)\n    current = self.template\n    if isinstance(current, MetaTemplate):\n        current.delete()\n    self.get_meta_body().append(template)\n</code></pre>"},{"location":"reference.html#odfdo.Meta.set_title","title":"<code>set_title(title)</code>","text":"<p>Set the title of the document.</p> <p>This is not the first heading but the title metadata.</p> <p>(Also available as \u201cself.title\u201d property.)</p> <p>Arguments:</p> <pre><code>title -- str\n</code></pre> Source code in <code>odfdo/meta.py</code> <pre><code>def set_title(self, title: str) -&gt; None:\n    \"\"\"Set the title of the document.\n\n    This is not the first heading but the title metadata.\n\n    (Also available as \"self.title\" property.)\n\n    Arguments:\n\n        title -- str\n    \"\"\"\n    element = self.get_element(\"//dc:title\")\n    if element is None:\n        element = Element.from_tag(\"dc:title\")\n        self.get_meta_body().append(element)\n    element.text = title\n</code></pre>"},{"location":"reference.html#odfdo.MetaAutoReload","title":"<code>MetaAutoReload</code>","text":"<p>               Bases: <code>Element</code></p> Source code in <code>odfdo/meta_auto_reload.py</code> <pre><code>class MetaAutoReload(Element):\n    _tag = \"meta:auto-reload\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"delay\", \"meta:delay\"),\n        PropDef(\"actuate\", \"xlink:actuate\"),\n        PropDef(\"href\", \"xlink:href\"),\n        PropDef(\"show\", \"xlink:show\"),\n        PropDef(\"type\", \"xlink:type\"),\n    )\n\n    def __init__(\n        self,\n        delay: timedelta | None = None,\n        href: str = \"\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The &lt;meta:auto-reload&gt; element specifies whether a document is\n        reloaded or replaced by another document after a specified period\n        of time has elapsed.\n\n        Arguments:\n\n            delay -- timedelta\n\n            href -- str\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.actuate = \"onLoad\"\n        self.show = \"replace\"\n        self.type = \"simple\"\n        if self._do_init:\n            if not isinstance(delay, timedelta):\n                raise TypeError(\"delay must be a timedelta\")\n            self.delay = Duration.encode(delay)\n            self.href = href\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;{self.__class__.__name__} tag={self.tag} \"\n            f\"href={self.href} delay={Duration.decode(self.delay)}&gt;\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"({self.href})\"\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the MetaAutoReload attributes as a Python dict.\"\"\"\n        return {\n            \"meta:delay\": self.delay,\n            \"xlink:actuate\": self.actuate,\n            \"xlink:href\": self.href,\n            \"xlink:show\": self.show,\n            \"xlink:type\": self.type,\n        }\n</code></pre>"},{"location":"reference.html#odfdo.MetaAutoReload.__init__","title":"<code>__init__(delay=None, href='', **kwargs)</code>","text":"<p>The  element specifies whether a document is reloaded or replaced by another document after a specified period of time has elapsed. <p>Arguments:</p> <pre><code>delay -- timedelta\n\nhref -- str\n</code></pre> Source code in <code>odfdo/meta_auto_reload.py</code> <pre><code>def __init__(\n    self,\n    delay: timedelta | None = None,\n    href: str = \"\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The &lt;meta:auto-reload&gt; element specifies whether a document is\n    reloaded or replaced by another document after a specified period\n    of time has elapsed.\n\n    Arguments:\n\n        delay -- timedelta\n\n        href -- str\n    \"\"\"\n    super().__init__(**kwargs)\n\n    self.actuate = \"onLoad\"\n    self.show = \"replace\"\n    self.type = \"simple\"\n    if self._do_init:\n        if not isinstance(delay, timedelta):\n            raise TypeError(\"delay must be a timedelta\")\n        self.delay = Duration.encode(delay)\n        self.href = href\n</code></pre>"},{"location":"reference.html#odfdo.MetaAutoReload.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the MetaAutoReload attributes as a Python dict.</p> Source code in <code>odfdo/meta_auto_reload.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the MetaAutoReload attributes as a Python dict.\"\"\"\n    return {\n        \"meta:delay\": self.delay,\n        \"xlink:actuate\": self.actuate,\n        \"xlink:href\": self.href,\n        \"xlink:show\": self.show,\n        \"xlink:type\": self.type,\n    }\n</code></pre>"},{"location":"reference.html#odfdo.MetaHyperlinkBehaviour","title":"<code>MetaHyperlinkBehaviour</code>","text":"<p>               Bases: <code>Element</code></p> Source code in <code>odfdo/meta_hyperlink_behaviour.py</code> <pre><code>class MetaHyperlinkBehaviour(Element):\n    _tag = \"meta:hyperlink-behaviour\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"target_frame_name\", \"office:target-frame-name\"),\n        PropDef(\"show\", \"xlink:show\"),\n    )\n\n    def __init__(\n        self,\n        target_frame_name: str = \"_blank\",\n        show: str = \"replace\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The &lt;meta:hyperlink-behaviour&gt; element specifies the default behavior\n        for hyperlinks in a document.\n\n        Arguments:\n\n            target_frame_name -- str\n\n            show -- str\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if self._do_init:\n            self.target_frame_name = target_frame_name\n            self.show = show\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;{self.__class__.__name__} tag={self.tag} \"\n            f\"target={self.target_frame_name} show={self.show}&gt;\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"({self.target_frame_name})\"\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the MetaHyperlinkBehaviour attributes as a Python dict.\"\"\"\n        return {\n            \"office:target-frame-name\": self.target_frame_name,\n            \"xlink:show\": self.show,\n        }\n</code></pre>"},{"location":"reference.html#odfdo.MetaHyperlinkBehaviour.__init__","title":"<code>__init__(target_frame_name='_blank', show='replace', **kwargs)</code>","text":"<p>The  element specifies the default behavior for hyperlinks in a document. <p>Arguments:</p> <pre><code>target_frame_name -- str\n\nshow -- str\n</code></pre> Source code in <code>odfdo/meta_hyperlink_behaviour.py</code> <pre><code>def __init__(\n    self,\n    target_frame_name: str = \"_blank\",\n    show: str = \"replace\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The &lt;meta:hyperlink-behaviour&gt; element specifies the default behavior\n    for hyperlinks in a document.\n\n    Arguments:\n\n        target_frame_name -- str\n\n        show -- str\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if self._do_init:\n        self.target_frame_name = target_frame_name\n        self.show = show\n</code></pre>"},{"location":"reference.html#odfdo.MetaHyperlinkBehaviour.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the MetaHyperlinkBehaviour attributes as a Python dict.</p> Source code in <code>odfdo/meta_hyperlink_behaviour.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the MetaHyperlinkBehaviour attributes as a Python dict.\"\"\"\n    return {\n        \"office:target-frame-name\": self.target_frame_name,\n        \"xlink:show\": self.show,\n    }\n</code></pre>"},{"location":"reference.html#odfdo.MetaTemplate","title":"<code>MetaTemplate</code>","text":"<p>               Bases: <code>Element</code></p> Source code in <code>odfdo/meta_template.py</code> <pre><code>class MetaTemplate(Element):\n    _tag = \"meta:template\"\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"date\", \"meta:date\"),\n        PropDef(\"actuate\", \"xlink:actuate\"),\n        PropDef(\"href\", \"xlink:href\"),\n        PropDef(\"title\", \"xlink:title\"),\n        PropDef(\"type\", \"xlink:type\"),\n    )\n\n    def __init__(\n        self,\n        date: datetime | None = None,\n        href: str = \"\",\n        title: str = \"\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The &lt;meta:template&gt; element specifies a IRI for the document template\n        that was used to create a document. The IRI is specified as an\n        Xlink.\n\n        Arguments:\n\n            date -- datetime or None\n\n            href -- str\n\n            title -- str\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.actuate = \"onRequest\"\n        self.type = \"simple\"\n        if self._do_init:\n            if date is None:\n                date = datetime.now()\n            self.date = DateTime.encode(date)\n            self.href = href\n            self.title = title\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} tag={self.tag} href={self.href}&gt;\"\n\n    def __str__(self) -&gt; str:\n        if self.title:\n            return f\"[{self.title}]({self.href})\"\n        return f\"({self.href})\"\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the MetaTemplate attributes as a Python dict.\"\"\"\n        return {\n            \"meta:date\": self.date,\n            \"xlink:actuate\": self.actuate,\n            \"xlink:href\": self.href,\n            \"xlink:title\": self.title,\n            \"xlink:type\": self.type,\n        }\n</code></pre>"},{"location":"reference.html#odfdo.MetaTemplate.__init__","title":"<code>__init__(date=None, href='', title='', **kwargs)</code>","text":"<p>The  element specifies a IRI for the document template that was used to create a document. The IRI is specified as an Xlink. <p>Arguments:</p> <pre><code>date -- datetime or None\n\nhref -- str\n\ntitle -- str\n</code></pre> Source code in <code>odfdo/meta_template.py</code> <pre><code>def __init__(\n    self,\n    date: datetime | None = None,\n    href: str = \"\",\n    title: str = \"\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The &lt;meta:template&gt; element specifies a IRI for the document template\n    that was used to create a document. The IRI is specified as an\n    Xlink.\n\n    Arguments:\n\n        date -- datetime or None\n\n        href -- str\n\n        title -- str\n    \"\"\"\n    super().__init__(**kwargs)\n\n    self.actuate = \"onRequest\"\n    self.type = \"simple\"\n    if self._do_init:\n        if date is None:\n            date = datetime.now()\n        self.date = DateTime.encode(date)\n        self.href = href\n        self.title = title\n</code></pre>"},{"location":"reference.html#odfdo.MetaTemplate.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the MetaTemplate attributes as a Python dict.</p> Source code in <code>odfdo/meta_template.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the MetaTemplate attributes as a Python dict.\"\"\"\n    return {\n        \"meta:date\": self.date,\n        \"xlink:actuate\": self.actuate,\n        \"xlink:href\": self.href,\n        \"xlink:title\": self.title,\n        \"xlink:type\": self.type,\n    }\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange","title":"<code>NamedRange</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF Named Range \u201ctable:named-range\u201d. Identifies inside the spreadsheet a range of cells of a table by a name and the name of the table.</p> <p>Name Ranges have the following attributes:</p> <pre><code>name -- name of the named range\n\ntable_name -- name of the table\n\nstart -- first cell of the named range, tuple (x, y)\n\nend -- last cell of the named range, tuple (x, y)\n\ncrange -- range of the named range, tuple (x, y, z, t)\n\nusage -- None or str, usage of the named range.\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>class NamedRange(Element):\n    \"\"\"ODF Named Range \"table:named-range\". Identifies inside the spreadsheet\n    a range of cells of a table by a name and the name of the table.\n\n    Name Ranges have the following attributes:\n\n        name -- name of the named range\n\n        table_name -- name of the table\n\n        start -- first cell of the named range, tuple (x, y)\n\n        end -- last cell of the named range, tuple (x, y)\n\n        crange -- range of the named range, tuple (x, y, z, t)\n\n        usage -- None or str, usage of the named range.\n    \"\"\"\n\n    _tag = \"table:named-range\"\n\n    def __init__(\n        self,\n        name: str | None = None,\n        crange: str | tuple | list | None = None,\n        table_name: str | None = None,\n        usage: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a Named Range element. 'name' must contains only letters, digits\n           and '_', and must not be like a coordinate as 'A1'. 'table_name' must be\n           a correct table name (no \"'\" or \"/\" in it).\n\n        Arguments:\n\n             name -- str, name of the named range\n\n             crange -- str or tuple of int, cell or area coordinate\n\n             table_name -- str, name of the table\n\n             usage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n        \"\"\"\n        super().__init__(**kwargs)\n        self.usage = None\n        if self._do_init:\n            self.name = name or \"\"\n            self.table_name = _table_name_check(table_name)\n            self.set_range(crange or \"\")\n            self.set_usage(usage)\n        cell_range_address = self.get_attribute_string(\"table:cell-range-address\") or \"\"\n        if not cell_range_address:\n            self.table_name = \"\"\n            self.start = None\n            self.end = None\n            self.crange = None\n            self.usage = None\n            return\n        self.usage = self.get_attribute(\"table:range-usable-as\")\n        name_range = cell_range_address.replace(\"$\", \"\")\n        name, crange = name_range.split(\".\", 1)\n        if name.startswith(\"'\") and name.endswith(\"'\"):\n            name = name[1:-1]\n        self.table_name = name\n        crange = crange.replace(\".\", \"\")\n        self._set_range(crange)\n\n    def set_usage(self, usage: str | None = None) -&gt; None:\n        \"\"\"Set the usage of the Named Range. Usage can be None (default) or one\n        of :\n            'print-range'\n            'filter'\n            'repeat-column'\n            'repeat-row'\n\n        Arguments:\n\n            usage -- None or str\n        \"\"\"\n        if usage is not None:\n            usage = usage.strip().lower()\n            if usage not in (\"print-range\", \"filter\", \"repeat-column\", \"repeat-row\"):\n                usage = None\n        if usage is None:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:range-usable-as\")\n            self.usage = None\n        else:\n            self.set_attribute(\"table:range-usable-as\", usage)\n            self.usage = usage\n\n    @property\n    def name(self) -&gt; str | None:\n        \"\"\"Get / set the name of the table.\"\"\"\n        return self.get_attribute_string(\"table:name\")\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"Set the name of the Named Range. The name is mandatory, if a Named\n        Range of the same name exists, it will be replaced. Name must contains\n        only alphanumerics characters and '_', and can not be of a cell\n        coordinates form like 'AB12'.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name required.\")\n        for x in name:\n            if x in forbidden_in_named_range():\n                raise ValueError(f\"Character forbidden '{x}' \")\n        step = \"\"\n        for x in name:\n            if x in string.ascii_letters and step in (\"\", \"A\"):\n                step = \"A\"\n                continue\n            elif step in (\"A\", \"A1\") and x in string.digits:\n                step = \"A1\"\n                continue\n            else:\n                step = \"\"\n                break\n        if step == \"A1\":\n            raise ValueError(\"Name of the type 'ABC123' is not allowed.\")\n        with contextlib.suppress(Exception):\n            # we are not on an inserted in a document.\n            body = self.document_body\n            named_range = body.get_named_range(name)  # type: ignore\n            if named_range:\n                named_range.delete()\n        self.set_attribute(\"table:name\", name)\n\n    def set_table_name(self, name: str) -&gt; None:\n        \"\"\"Set the name of the table of the Named Range. The name is mandatory.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        self.table_name = _table_name_check(name)\n        self._update_attributes()\n\n    def _set_range(self, coord: tuple | list | str) -&gt; None:\n        digits = convert_coordinates(coord)\n        if len(digits) == 4:\n            x, y, z, t = digits\n        else:\n            x, y = digits\n            z, t = digits\n        self.start = x, y  # type: ignore\n        self.end = z, t  # type: ignore\n        self.crange = x, y, z, t  # type: ignore\n\n    def set_range(self, crange: str | tuple | list) -&gt; None:\n        \"\"\"Set the range of the named range. Range can be either one cell\n        (like 'A1') or an area ('A1:B2'). It can be provided as an alpha numeric\n        value like \"A1:B2' or a tuple like (0, 0, 1, 1) or (0, 0).\n\n        Arguments:\n\n            crange -- str or tuple of int, cell or area coordinate\n        \"\"\"\n        self._set_range(crange)\n        self._update_attributes()\n\n    def _update_attributes(self) -&gt; None:\n        self.set_attribute(\"table:base-cell-address\", self._make_base_cell_address())\n        self.set_attribute(\"table:cell-range-address\", self._make_cell_range_address())\n\n    def _make_base_cell_address(self) -&gt; str:\n        # assuming we got table_name and range\n        if \" \" in self.table_name:\n            name = f\"'{self.table_name}'\"\n        else:\n            name = self.table_name\n        return f\"${name}.${digit_to_alpha(self.start[0])}${self.start[1] + 1}\"  # type: ignore\n\n    def _make_cell_range_address(self) -&gt; str:\n        # assuming we got table_name and range\n        if \" \" in self.table_name:\n            name = f\"'{self.table_name}'\"\n        else:\n            name = self.table_name\n        if self.start == self.end:\n            return self._make_base_cell_address()\n        return (\n            f\"${name}.${digit_to_alpha(self.start[0])}${self.start[1] + 1}:\"  # type: ignore\n            f\".${digit_to_alpha(self.end[0])}${self.end[1] + 1}\"  # type: ignore\n        )\n\n    def get_values(\n        self,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n        flat: bool = False,\n    ) -&gt; list:\n        \"\"\"Shortcut to retrieve the values of the cells of the named range. See\n        table.get_values() for the arguments description and return format.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore\n\n    def get_value(self, get_type: bool = False) -&gt; Any:\n        \"\"\"Shortcut to retrieve the value of the first cell of the named range.\n        See table.get_value() for the arguments description and return format.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        return table.get_value(self.start, get_type)  # type: ignore\n\n    def set_values(\n        self,\n        values: list,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the values of the cells of the named range.\n        See table.set_values() for the arguments description.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        table.set_values(  # type: ignore\n            values,\n            coord=self.crange,\n            style=style,\n            cell_type=cell_type,\n            currency=currency,\n        )\n\n    def set_value(\n        self,\n        value: Any,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the value of the first cell of the named range.\n        See table.set_value() for the arguments description.\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        table = body.get_table(name=self.table_name)\n        if table is None:\n            raise ValueError\n        table.set_value(  # type: ignore\n            coord=self.start,\n            value=value,\n            cell_type=cell_type,\n            currency=currency,\n            style=style,\n        )\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the name of the table.</p>"},{"location":"reference.html#odfdo.NamedRange.__init__","title":"<code>__init__(name=None, crange=None, table_name=None, usage=None, **kwargs)</code>","text":"<p>Create a Named Range element. \u2018name\u2019 must contains only letters, digits    and \u2018_\u2019, and must not be like a coordinate as \u2018A1\u2019. \u2018table_name\u2019 must be    a correct table name (no \u201c\u2019\u201d or \u201c/\u201d in it).</p> <p>Arguments:</p> <pre><code> name -- str, name of the named range\n\n crange -- str or tuple of int, cell or area coordinate\n\n table_name -- str, name of the table\n\n usage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    crange: str | tuple | list | None = None,\n    table_name: str | None = None,\n    usage: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a Named Range element. 'name' must contains only letters, digits\n       and '_', and must not be like a coordinate as 'A1'. 'table_name' must be\n       a correct table name (no \"'\" or \"/\" in it).\n\n    Arguments:\n\n         name -- str, name of the named range\n\n         crange -- str or tuple of int, cell or area coordinate\n\n         table_name -- str, name of the table\n\n         usage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n    \"\"\"\n    super().__init__(**kwargs)\n    self.usage = None\n    if self._do_init:\n        self.name = name or \"\"\n        self.table_name = _table_name_check(table_name)\n        self.set_range(crange or \"\")\n        self.set_usage(usage)\n    cell_range_address = self.get_attribute_string(\"table:cell-range-address\") or \"\"\n    if not cell_range_address:\n        self.table_name = \"\"\n        self.start = None\n        self.end = None\n        self.crange = None\n        self.usage = None\n        return\n    self.usage = self.get_attribute(\"table:range-usable-as\")\n    name_range = cell_range_address.replace(\"$\", \"\")\n    name, crange = name_range.split(\".\", 1)\n    if name.startswith(\"'\") and name.endswith(\"'\"):\n        name = name[1:-1]\n    self.table_name = name\n    crange = crange.replace(\".\", \"\")\n    self._set_range(crange)\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.get_value","title":"<code>get_value(get_type=False)</code>","text":"<p>Shortcut to retrieve the value of the first cell of the named range. See table.get_value() for the arguments description and return format.</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_value(self, get_type: bool = False) -&gt; Any:\n    \"\"\"Shortcut to retrieve the value of the first cell of the named range.\n    See table.get_value() for the arguments description and return format.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    return table.get_value(self.start, get_type)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.get_values","title":"<code>get_values(cell_type=None, complete=True, get_type=False, flat=False)</code>","text":"<p>Shortcut to retrieve the values of the cells of the named range. See table.get_values() for the arguments description and return format.</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_values(\n    self,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n    flat: bool = False,\n) -&gt; list:\n    \"\"\"Shortcut to retrieve the values of the cells of the named range. See\n    table.get_values() for the arguments description and return format.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_range","title":"<code>set_range(crange)</code>","text":"<p>Set the range of the named range. Range can be either one cell (like \u2018A1\u2019) or an area (\u2018A1:B2\u2019). It can be provided as an alpha numeric value like \u201cA1:B2\u2019 or a tuple like (0, 0, 1, 1) or (0, 0).</p> <p>Arguments:</p> <pre><code>crange -- str or tuple of int, cell or area coordinate\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_range(self, crange: str | tuple | list) -&gt; None:\n    \"\"\"Set the range of the named range. Range can be either one cell\n    (like 'A1') or an area ('A1:B2'). It can be provided as an alpha numeric\n    value like \"A1:B2' or a tuple like (0, 0, 1, 1) or (0, 0).\n\n    Arguments:\n\n        crange -- str or tuple of int, cell or area coordinate\n    \"\"\"\n    self._set_range(crange)\n    self._update_attributes()\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_table_name","title":"<code>set_table_name(name)</code>","text":"<p>Set the name of the table of the Named Range. The name is mandatory.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_table_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the table of the Named Range. The name is mandatory.\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    self.table_name = _table_name_check(name)\n    self._update_attributes()\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_usage","title":"<code>set_usage(usage=None)</code>","text":"<p>Set the usage of the Named Range. Usage can be None (default) or one of :     \u2018print-range\u2019     \u2018filter\u2019     \u2018repeat-column\u2019     \u2018repeat-row\u2019</p> <p>Arguments:</p> <pre><code>usage -- None or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_usage(self, usage: str | None = None) -&gt; None:\n    \"\"\"Set the usage of the Named Range. Usage can be None (default) or one\n    of :\n        'print-range'\n        'filter'\n        'repeat-column'\n        'repeat-row'\n\n    Arguments:\n\n        usage -- None or str\n    \"\"\"\n    if usage is not None:\n        usage = usage.strip().lower()\n        if usage not in (\"print-range\", \"filter\", \"repeat-column\", \"repeat-row\"):\n            usage = None\n    if usage is None:\n        with contextlib.suppress(KeyError):\n            self.del_attribute(\"table:range-usable-as\")\n        self.usage = None\n    else:\n        self.set_attribute(\"table:range-usable-as\", usage)\n        self.usage = usage\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_value","title":"<code>set_value(value, cell_type=None, currency=None, style=None)</code>","text":"<p>Shortcut to set the value of the first cell of the named range. See table.set_value() for the arguments description.</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_value(\n    self,\n    value: Any,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the value of the first cell of the named range.\n    See table.set_value() for the arguments description.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    table.set_value(  # type: ignore\n        coord=self.start,\n        value=value,\n        cell_type=cell_type,\n        currency=currency,\n        style=style,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.NamedRange.set_values","title":"<code>set_values(values, style=None, cell_type=None, currency=None)</code>","text":"<p>Shortcut to set the values of the cells of the named range. See table.set_values() for the arguments description.</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_values(\n    self,\n    values: list,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the values of the cells of the named range.\n    See table.set_values() for the arguments description.\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    table = body.get_table(name=self.table_name)\n    if table is None:\n        raise ValueError\n    table.set_values(  # type: ignore\n        values,\n        coord=self.crange,\n        style=style,\n        cell_type=cell_type,\n        currency=currency,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Note","title":"<code>Note</code>","text":"<p>               Bases: <code>MDNote</code>, <code>Element</code></p> <p>Either a footnote or a endnote element with the given text, optionally referencing it using the given note_id.</p> <p>Arguments:</p> <pre><code>note_class -- 'footnote' or 'endnote'\n\nnote_id -- str\n\ncitation -- str\n\nbody -- str or Element\n</code></pre> Source code in <code>odfdo/note.py</code> <pre><code>class Note(MDNote, Element):\n    \"\"\"Either a footnote or a endnote element with the given text,\n    optionally referencing it using the given note_id.\n\n    Arguments:\n\n        note_class -- 'footnote' or 'endnote'\n\n        note_id -- str\n\n        citation -- str\n\n        body -- str or Element\n    \"\"\"\n\n    _tag = \"text:note\"\n    _properties = (\n        PropDef(\"note_class\", \"text:note-class\"),\n        PropDef(\"note_id\", \"text:id\"),\n    )\n\n    def __init__(\n        self,\n        note_class: str = \"footnote\",\n        note_id: str | None = None,\n        citation: str | None = None,\n        body: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.insert(Element.from_tag(\"text:note-body\"), position=0)\n            self.insert(Element.from_tag(\"text:note-citation\"), position=0)\n            self.note_class = note_class\n            if note_id is not None:\n                self.note_id = note_id\n            if citation is not None:\n                self.citation = citation\n            if body is not None:\n                self.note_body = body\n\n    @property\n    def citation(self) -&gt; str:\n        note_citation = self.get_element(\"text:note-citation\")\n        if note_citation:\n            return note_citation.text\n        return \"\"\n\n    @citation.setter\n    def citation(self, text: str | None) -&gt; None:\n        note_citation = self.get_element(\"text:note-citation\")\n        if note_citation:\n            note_citation.text = text  # type:ignore\n\n    @property\n    def note_body(self) -&gt; str:\n        note_body = self.get_element(\"text:note-body\")\n        if note_body:\n            return note_body.text_content\n        return \"\"\n\n    @note_body.setter\n    def note_body(self, text_or_element: Element | str | None) -&gt; None:\n        note_body = self.get_element(\"text:note-body\")\n        if not note_body:\n            return None\n        if text_or_element is None:\n            note_body.text_content = \"\"\n        elif isinstance(text_or_element, str):\n            note_body.text_content = text_or_element\n        elif isinstance(text_or_element, Element):\n            note_body.clear()\n            note_body.append(text_or_element)\n        else:\n            raise TypeError(f'Unexpected type for body: \"{type(text_or_element)}\"')\n\n    def check_validity(self) -&gt; None:\n        if not self.note_class:\n            raise ValueError('Note class must be \"footnote\" or \"endnote\"')\n        if not self.note_id:\n            raise ValueError(\"Note must have an id\")\n        if not self.citation:\n            raise ValueError(\"Note must have a citation\")\n        if not self.note_body:\n            pass\n\n    def __str__(self) -&gt; str:\n        if self.citation:\n            return f\"{self.citation}. {self.note_body}\"\n        return self.note_body\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph","title":"<code>Paragraph</code>","text":"<p>               Bases: <code>MDParagraph</code>, <code>ParagraphBase</code></p> <p>Specialised element for paragraphs \u201ctext:p\u201d. The \u201ctext:p\u201d element represents a paragraph, which is the basic unit of text in an OpenDocument file.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>class Paragraph(MDParagraph, ParagraphBase):\n    \"\"\"Specialised element for paragraphs \"text:p\". The \"text:p\" element\n    represents a paragraph, which is the basic unit of text in an OpenDocument\n    file.\n    \"\"\"\n\n    _tag = \"text:p\"\n\n    def __init__(\n        self,\n        text_or_element: str | bytes | Element | None = None,\n        style: str | None = None,\n        formatted: bool = True,\n        **kwargs: Any,\n    ):\n        \"\"\"Create a paragraph element of the given style containing the optional\n        given text.\n\n        If \"formatted\" is True (the default), the given text is appended with &lt;CR&gt;,\n        &lt;TAB&gt; and multiple spaces replaced by ODF corresponding tags.\n\n        Arguments:\n\n            text -- str, bytes or Element\n\n            style -- str\n\n            formatted -- bool\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if isinstance(text_or_element, Element):\n                self.append(text_or_element)\n            else:\n                self.text = \"\"\n                if formatted:\n                    self.append_plain_text(text_or_element)\n                else:\n                    self.append_plain_text(self._unformatted(text_or_element))\n            if style is not None:\n                self.style = style\n\n    def __str__(self) -&gt; str:\n        # '\\n' at the end slightly breaks compatibility, but is clearly better\n        return self.inner_text + \"\\n\"\n\n    def _expand_spaces(self, added_string: str) -&gt; list[Element | str]:\n        result: list[Element | str] = []\n\n        def _merge_text(txt: str):\n            nonlocal result\n            if result and isinstance(result[-1], str):\n                result[-1] += txt\n            else:\n                result.append(txt)\n\n        for obj in self.xpath(\"*|text()\"):\n            if isinstance(obj, EText):\n                _merge_text(str(obj))\n                continue\n            obj.tail = \"\"\n            if obj.tag != \"text:s\":\n                result.append(obj)\n                continue\n            _merge_text(obj.text)\n        _merge_text(added_string)\n        return result\n\n    def _merge_spaces(self, content: list[Element | str]) -&gt; list[Element | str]:\n        result: list[Element | str] = []\n        for item in content:\n            if isinstance(item, str):\n                result.extend(self._sub_merge_spaces(item))\n            else:\n                result.append(item)\n        return result\n\n    @staticmethod\n    def _sub_merge_spaces(text: str) -&gt; list[Element | str]:\n        result: list[Element | str] = []\n        content = [x for x in _re_spaces_split.split(text) if x]\n\n        def _merge_text(txt: str):\n            nonlocal result\n            if result and isinstance(result[-1], str):\n                result[-1] += txt\n            else:\n                result.append(txt)\n\n        if content:\n            item0 = content[0]\n            if isinstance(item0, str) and _re_only_spaces.match(item0):\n                spacer = Spacer(len(item0))\n                result.append(spacer)\n            else:\n                result.append(item0)\n        for item in content[1:-1]:\n            if isinstance(item, str):\n                if len(item) &gt; 1 and _re_only_spaces.match(item):\n                    spacer = Spacer(len(item) - 1)\n                    _merge_text(\" \")\n                    result.append(spacer)\n                else:\n                    _merge_text(item)\n            else:\n                result.append(item)\n        if len(content) &gt; 1:\n            last_item = content[-1]\n            if isinstance(last_item, str):\n                if _re_only_spaces.match(last_item):\n                    spacer = Spacer(len(last_item))\n                    result.append(spacer)\n                else:\n                    _merge_text(last_item)\n            else:\n                result.append(last_item)\n        return result\n\n    def _replace_tabs_lb(self, content: list[Element | str]) -&gt; list[Element | str]:\n        result: list[Element | str] = []\n        for item in content:\n            if isinstance(item, str):\n                result.extend(self._sub_replace_tabs_lb(item))\n            else:\n                result.append(item)\n        return result\n\n    @staticmethod\n    def _sub_replace_tabs_lb(text: str) -&gt; list[Element | str]:\n        if not text:\n            return []\n        blocs = _re_splitter.split(text)\n        result: list[Element | str] = []\n        for bloc in blocs:\n            if not bloc:\n                continue\n            if bloc == \"\\n\":\n                result.append(LineBreak())\n                continue\n            if bloc == \"\\t\":\n                result.append(Tab())\n                continue\n            result.append(bloc)\n        return result\n\n    def append_plain_text(self, text: str | bytes | None = \"\") -&gt; None:\n        \"\"\"Append plain text to the paragraph, replacing &lt;CR&gt;, &lt;TAB&gt;\n        and multiple spaces by ODF corresponding tags.\n        \"\"\"\n        if text is None:\n            stext = \"\"\n        elif isinstance(text, bytes):\n            stext = text.decode(\"utf-8\")\n        else:\n            stext = str(text)\n        content = self._expand_spaces(stext)\n        content = self._merge_spaces(content)\n        content = self._replace_tabs_lb(content)\n        for child in self.children:\n            self.delete(child, keep_tail=False)\n        self.text = None\n        for element in content:\n            self._Element__append(element)\n\n    @staticmethod\n    def _unformatted(text: str | bytes | None) -&gt; str:\n        if not text:\n            return \"\"\n        if isinstance(text, bytes):\n            stext = text.decode(\"utf-8\")\n        else:\n            stext = str(text)\n        return _re_sub_splitter.sub(\" \", stext)\n\n    def append(\n        self,\n        str_or_element: str | bytes | Element,\n        formatted: bool = True,\n    ) -&gt; None:\n        if isinstance(str_or_element, Element):\n            self._Element__append(str_or_element)\n        elif formatted:\n            self.append_plain_text(str_or_element)\n        else:\n            # self._Element__append(self._unformatted(str_or_element))\n            # The added text is first \"unformatted\", but result needs\n            # to be compliant\n            self.append_plain_text(self._unformatted(str_or_element))\n\n    def insert_note(\n        self,\n        note_element: Note | None = None,\n        after: str | Element | None = None,\n        note_class: str = \"footnote\",\n        note_id: str | None = None,\n        citation: str | None = None,\n        body: str | None = None,\n    ) -&gt; None:\n        if note_element is None:\n            note_element = Note(\n                note_class=note_class, note_id=note_id, citation=citation, body=body\n            )\n        else:\n            # XXX clone or modify the argument?\n            if note_class:\n                note_element.note_class = note_class\n            if note_id:\n                note_element.note_id = note_id\n            if citation:\n                note_element.citation = citation\n            if body:\n                note_element.note_body = body\n        note_element.check_validity()\n        if isinstance(after, str):\n            self._insert(note_element, after=after, main_text=True)\n        elif isinstance(after, Element):\n            after.insert(note_element, FIRST_CHILD)\n        else:\n            self.insert(note_element, FIRST_CHILD)\n\n    def insert_annotation(\n        self,\n        annotation_element: Annotation | None = None,\n        before: str | None = None,\n        after: str | Element | None = None,\n        position: int | tuple = 0,\n        content: str | Element | None = None,\n        body: str | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n    ) -&gt; Annotation:\n        \"\"\"Insert an annotation, at the position defined by the regex (before,\n        after, content) or by positionnal argument (position). If content is\n        provided, the annotation covers the full content regex. Else, the\n        annotation is positionned either 'before' or 'after' provided regex.\n\n        If content is an odf element (ie: paragraph, span, ...), the full inner\n        content is covered by the annotation (of the position just after if\n        content is a single empty tag).\n\n        If content/before or after exists (regex) and return a group of matching\n        positions, the position value is the index of matching place to use.\n\n        annotation_element can contain a previously created annotation, else\n        the annotation is created from the body, creator and optional date\n        (current date by default).\n\n        Arguments:\n\n            annotation_element -- Annotation or None\n\n            before -- str regular expression or None\n\n            after -- str regular expression or Element or None\n\n            content -- str regular expression or None, or Element\n\n            position -- int or tuple of int\n\n            body -- str or Element\n\n            creator -- str\n\n            date -- datetime\n        \"\"\"\n\n        if annotation_element is None:\n            annotation_element = Annotation(\n                text_or_element=body, creator=creator, date=date, parent=self\n            )\n        else:\n            # XXX clone or modify the argument?\n            if body:\n                annotation_element.note_body = body\n            if creator:\n                annotation_element.creator = creator\n            if date:\n                annotation_element.date = date\n        annotation_element.check_validity()\n\n        # special case: content is an odf element (ie: a paragraph)\n        if isinstance(content, Element):\n            if content.is_empty():\n                content.insert(annotation_element, xmlposition=NEXT_SIBLING)\n                return annotation_element\n            content.insert(annotation_element, start=True)\n            annotation_end = AnnotationEnd(annotation_element)\n            content.append(annotation_end)\n            return annotation_element\n\n        # special case\n        if isinstance(after, Element):\n            after.insert(annotation_element, FIRST_CHILD)\n            return annotation_element\n\n        # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and content is not None\n            and isinstance(position, int)\n        ):\n            # Start tag\n            self._insert(\n                annotation_element, before=content, position=position, main_text=True\n            )\n            # End tag\n            annotation_end = AnnotationEnd(annotation_element)\n            self._insert(\n                annotation_end, after=content, position=position, main_text=True\n            )\n            return annotation_element\n\n        # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and content is None\n            and isinstance(position, tuple)\n        ):\n            # Start\n            self._insert(annotation_element, position=position[0], main_text=True)\n            # End\n            annotation_end = AnnotationEnd(annotation_element)\n            self._insert(annotation_end, position=position[1], main_text=True)\n            return annotation_element\n\n        # Without \"content\" nor \"position\"\n        if content is not None or not isinstance(position, int):\n            raise ValueError(\"Bad arguments\")\n\n        # Insert\n        self._insert(\n            annotation_element,\n            before=before,\n            after=after,\n            position=position,\n            main_text=True,\n        )\n        return annotation_element\n\n    def insert_annotation_end(\n        self,\n        annotation_element: Annotation,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n    ) -&gt; AnnotationEnd:\n        \"\"\"Insert an annotation end tag for an existing annotation. If some end\n        tag already exists, replace it. Annotation end tag is set at the\n        position defined by the regex (before or after).\n\n        If content/before or after (regex) returns a group of matching\n        positions, the position value is the index of matching place to use.\n\n        Arguments:\n\n            annotation_element -- Annotation (mandatory)\n\n            before -- str regular expression or None\n\n            after -- str regular expression or None\n\n            position -- int\n        \"\"\"\n\n        if annotation_element is None:\n            raise ValueError\n        if not isinstance(annotation_element, Annotation):\n            raise TypeError(\"Not a &lt;office:annotation&gt; Annotation\")\n\n        # remove existing end tag\n        name = annotation_element.name\n        existing_end_tag = self.get_annotation_end(name=name)\n        if existing_end_tag:\n            existing_end_tag.delete()\n\n        # create the end tag\n        end_tag = AnnotationEnd(annotation_element)\n\n        # Insert\n        self._insert(\n            end_tag, before=before, after=after, position=position, main_text=True\n        )\n        return end_tag\n\n    def set_reference_mark(\n        self,\n        name: str,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n        content: str | Element | None = None,\n    ) -&gt; Element:\n        \"\"\"Insert a reference mark, at the position defined by the regex\n        (before, after, content) or by positionnal argument (position). If\n        content is provided, the annotation covers the full range content regex\n        (instances of ReferenceMarkStart and ReferenceMarkEnd are\n        created). Else, an instance of ReferenceMark is positionned either\n        'before' or 'after' provided regex.\n\n        If content is an ODF Element (ie: Paragraph, Span, ...), the full inner\n        content is referenced (of the position just after if content is a single\n        empty tag).\n\n        If content/before or after exists (regex) and return a group of matching\n        positions, the position value is the index of matching place to use.\n\n        Name is mandatory and shall be unique in the document for the preference\n        mark range.\n\n        Arguments:\n\n            name -- str\n\n            before -- str regular expression or None\n\n            after -- str regular expression or None,\n\n            content -- str regular expression or None, or Element\n\n            position -- int or tuple of int\n\n        Return: the created ReferenceMark or ReferenceMarkStart\n        \"\"\"\n        # special case: content is an odf element (ie: a paragraph)\n        if isinstance(content, Element):\n            if content.is_empty():\n                reference = ReferenceMark(name)\n                content.insert(reference, xmlposition=NEXT_SIBLING)\n                return reference\n            reference_start = ReferenceMarkStart(name)\n            content.insert(reference_start, start=True)\n            reference_end = ReferenceMarkEnd(name)\n            content.append(reference_end)\n            return reference_start\n\n        # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n        # reference\n        if (\n            before is None\n            and after is None\n            and content is not None\n            and isinstance(position, int)\n        ):\n            # Start tag\n            reference_start = ReferenceMarkStart(name)\n            self._insert(\n                reference_start, before=content, position=position, main_text=True\n            )\n            # End tag\n            reference_end = ReferenceMarkEnd(name)\n            self._insert(\n                reference_end, after=content, position=position, main_text=True\n            )\n            return reference_start\n\n        # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n        if (\n            before is None\n            and after is None\n            and content is None\n            and isinstance(position, tuple)\n        ):\n            # Start\n            reference_start = ReferenceMarkStart(name)\n            self._insert(reference_start, position=position[0], main_text=True)\n            # End\n            reference_end = ReferenceMarkEnd(name)\n            self._insert(reference_end, position=position[1], main_text=True)\n            return reference_start\n\n        # Without \"content\" nor \"position\"\n        if content is not None or not isinstance(position, int):\n            raise ValueError(\"bad arguments\")\n\n        # Insert a positional reference mark\n        reference = ReferenceMark(name)\n        self._insert(\n            reference,\n            before=before,\n            after=after,\n            position=position,\n            main_text=True,\n        )\n        return reference\n\n    def set_reference_mark_end(\n        self,\n        reference_mark: Element,\n        before: str | None = None,\n        after: str | None = None,\n        position: int = 0,\n    ) -&gt; ReferenceMarkEnd:\n        \"\"\"Insert/move a ReferenceMarkEnd for an existing reference mark. If\n        some end tag already exists, replace it. Reference tag is set at the\n        position defined by the regex (before or after).\n\n        If content/before or after (regex) returns a group of matching\n        positions, the position value is the index of matching place to use.\n\n        Arguments:\n\n            reference_mark -- ReferenceMark or ReferenceMarkStart (mandatory)\n\n            before -- str regular expression or None\n\n            after -- str regular expression or None\n\n            position -- int\n        \"\"\"\n        if not isinstance(reference_mark, (ReferenceMark, ReferenceMarkStart)):\n            raise TypeError(\"Not a ReferenceMark or ReferenceMarkStart\")\n        name = reference_mark.name\n        if isinstance(reference_mark, ReferenceMark):\n            # change it to a range reference:\n            reference_mark.tag = ReferenceMarkStart._tag\n\n        existing_end_tag = self.get_reference_mark_end(name=name)\n        if existing_end_tag:\n            existing_end_tag.delete()\n\n        # create the end tag\n        end_tag = ReferenceMarkEnd(name)\n\n        # Insert\n        self._insert(\n            end_tag, before=before, after=after, position=position, main_text=True\n        )\n        return end_tag\n\n    def insert_variable(self, variable_element: Element, after: str | None) -&gt; None:\n        self._insert(variable_element, after=after, main_text=True)\n\n    @_by_regex_offset\n    def set_span(\n        self,\n        match: str,\n        tail: str,\n        style: str,\n        regex: str | None = None,\n        offset: int | None = None,\n        length: int = 0,\n    ) -&gt; Span:\n        \"\"\"\n        set_span(style, regex=None, offset=None, length=0)\n        Apply the given style to text content matching the regex OR the\n        positional arguments offset and length.\n\n        (match, tail: provided by regex decorator)\n\n        Arguments:\n\n            style -- str\n\n            regex -- str regular expression\n\n            offset -- int\n\n            length -- int\n        \"\"\"\n        span = Span(match, style=style)\n        span.tail = tail\n        return span\n\n    def remove_spans(self, keep_heading: bool = True) -&gt; Element | list:\n        \"\"\"Send back a copy of the element, without span styles.\n        If keep_heading is True (default), the first level heading style is left\n        unchanged.\n        \"\"\"\n        strip = (Span._tag,)\n        if keep_heading:\n            protect = (\"text:h\",)\n        else:\n            protect = None\n        return self.strip_tags(strip=strip, protect=protect)\n\n    def remove_span(self, spans: Element | list[Element]) -&gt; Element | list:\n        \"\"\"Send back a copy of the element, the spans (not a clone) removed.\n\n        Arguments:\n\n            spans -- Element or list of Element\n        \"\"\"\n        return self.strip_elements(spans)\n\n    @_by_regex_offset\n    def set_link(\n        self,\n        match: str,\n        tail: str,\n        url: str,\n        regex: str | None = None,\n        offset: int | None = None,\n        length: int = 0,\n    ) -&gt; Element:\n        \"\"\"\n        set_link(url, regex=None, offset=None, length=0)\n        Make a link to the provided url from text content matching the regex\n        OR the positional arguments offset and length.\n\n        (match, tail: provided by regex decorator)\n\n        Arguments:\n\n            url -- str\n\n            regex -- str regular expression\n\n            offset -- int\n\n            length -- int\n        \"\"\"\n        link = Link(url, text=match)\n        link.tail = tail\n        return link\n\n    def remove_links(self) -&gt; Element | list:\n        \"\"\"Send back a copy of the element, without links tags.\"\"\"\n        strip = (Link._tag,)\n        return self.strip_tags(strip=strip)\n\n    def remove_link(self, links: Link | list[Link]) -&gt; Element | list:\n        \"\"\"Send back a copy of the element (not a clone), with the sub links\n           removed.\n\n        Arguments:\n\n            links -- Link or list of Link\n        \"\"\"\n        return self.strip_elements(links)\n\n    def insert_reference(\n        self,\n        name: str,\n        ref_format: str = \"\",\n        before: str | None = None,\n        after: str | Element | None = None,\n        position: int = 0,\n        display: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create and insert a reference to a content marked by a reference\n        mark. The Reference element (\"text:reference-ref\") represents a\n        field that references a \"text:reference-mark-start\" or\n        \"text:reference-mark\" element. Its \"text:reference-format\" attribute\n        specifies what is displayed from the referenced element. Default is\n        'page'. Actual content is not automatically updated except for the 'text'\n        format.\n\n        name is mandatory and should represent an existing reference mark of the\n        document.\n\n        ref_format is the argument for format reference (default is 'page').\n\n        The reference is inserted the position defined by the regex (before /\n        after), or by positionnal argument (position). If 'display' is provided,\n        it will be used as the text value for the reference.\n\n        If after is an ODF Element, the reference is inserted as first child of\n        this element.\n\n        Arguments:\n\n            name -- str\n\n            ref_format -- one of : 'chapter', 'direction', 'page', 'text',\n                                    'caption', 'category-and-value', 'value',\n                                    'number', 'number-all-superior',\n                                    'number-no-superior'\n\n            before -- str regular expression or None\n\n            after -- str regular expression or odf element or None\n\n            position -- int\n\n            display -- str or None\n        \"\"\"\n        reference = Reference(name, ref_format)\n        if display is None and ref_format == \"text\":\n            # get reference content\n            body = self.document_body\n            if not body:\n                body = self.root\n            mark = body.get_reference_mark(name=name)\n            if mark:\n                display = mark.referenced_text  # type: ignore\n        if not display:\n            display = \" \"\n        reference.text = display\n        if isinstance(after, Element):\n            after.insert(reference, FIRST_CHILD)\n        else:\n            self._insert(\n                reference, before=before, after=after, position=position, main_text=True\n            )\n\n    def set_bookmark(\n        self,\n        name: str,\n        before: str | None = None,\n        after: str | None = None,\n        position: int | tuple = 0,\n        role: str | None = None,\n        content: str | None = None,\n    ) -&gt; Element | tuple[Element, Element]:\n        \"\"\"Insert a bookmark before or after the characters in the text which\n        match the regex before/after. When the regex matches more of one part\n        of the text, position can be set to choose which part must be used.\n        If before and after are None, we use only position that is the number\n        of characters.\n\n        So, by default, this function inserts a bookmark before the first\n        character of the content. Role can be None, \"start\" or \"end\", we\n        insert respectively a position bookmark a bookmark-start or a\n        bookmark-end.\n\n        If content is not None these 2 calls are equivalent:\n\n          paragraph.set_bookmark(\"bookmark\", content=\"xyz\")\n\n        and:\n\n          paragraph.set_bookmark(\"bookmark\", before=\"xyz\", role=\"start\")\n          paragraph.set_bookmark(\"bookmark\", after=\"xyz\", role=\"end\")\n\n\n        If position is a 2-tuple, these 2 calls are equivalent:\n\n          paragraph.set_bookmark(\"bookmark\", position=(10, 20))\n\n        and:\n\n          paragraph.set_bookmark(\"bookmark\", position=10, role=\"start\")\n          paragraph.set_bookmark(\"bookmark\", position=20, role=\"end\")\n\n\n        Arguments:\n\n            name -- str\n\n            before -- str regex\n\n            after -- str regex\n\n            position -- int or (int, int)\n\n            role -- None, \"start\" or \"end\"\n\n            content -- str regex\n        \"\"\"\n        # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and role is None\n            and content is not None\n            and isinstance(position, int)\n        ):\n            # Start\n            start = BookmarkStart(name)\n            self._insert(start, before=content, position=position, main_text=True)\n            # End\n            end = BookmarkEnd(name)\n            self._insert(end, after=content, position=position, main_text=True)\n            return start, end\n\n        # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n        # bookmark\n        if (\n            before is None\n            and after is None\n            and role is None\n            and content is None\n            and isinstance(position, tuple)\n        ):\n            # Start\n            start = BookmarkStart(name)\n            self._insert(start, position=position[0], main_text=True)\n            # End\n            end = BookmarkEnd(name)\n            self._insert(end, position=position[1], main_text=True)\n            return start, end\n\n        # Without \"content\" nor \"position\"\n        if content is not None or not isinstance(position, int):\n            raise ValueError(\"bad arguments\")\n\n        # Role\n        if role is None:\n            bookmark: Element = Bookmark(name)\n        elif role == \"start\":\n            bookmark = BookmarkStart(name)\n        elif role == \"end\":\n            bookmark = BookmarkEnd(name)\n        else:\n            raise ValueError(\"bad arguments\")\n\n        # Insert\n        self._insert(\n            bookmark, before=before, after=after, position=position, main_text=True\n        )\n\n        return bookmark\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.__init__","title":"<code>__init__(text_or_element=None, style=None, formatted=True, **kwargs)</code>","text":"<p>Create a paragraph element of the given style containing the optional given text.</p> <p>If \u201cformatted\u201d is True (the default), the given text is appended with ,  and multiple spaces replaced by ODF corresponding tags. <p>Arguments:</p> <pre><code>text -- str, bytes or Element\n\nstyle -- str\n\nformatted -- bool\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def __init__(\n    self,\n    text_or_element: str | bytes | Element | None = None,\n    style: str | None = None,\n    formatted: bool = True,\n    **kwargs: Any,\n):\n    \"\"\"Create a paragraph element of the given style containing the optional\n    given text.\n\n    If \"formatted\" is True (the default), the given text is appended with &lt;CR&gt;,\n    &lt;TAB&gt; and multiple spaces replaced by ODF corresponding tags.\n\n    Arguments:\n\n        text -- str, bytes or Element\n\n        style -- str\n\n        formatted -- bool\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if isinstance(text_or_element, Element):\n            self.append(text_or_element)\n        else:\n            self.text = \"\"\n            if formatted:\n                self.append_plain_text(text_or_element)\n            else:\n                self.append_plain_text(self._unformatted(text_or_element))\n        if style is not None:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.append_plain_text","title":"<code>append_plain_text(text='')</code>","text":"<p>Append plain text to the paragraph, replacing ,  and multiple spaces by ODF corresponding tags. Source code in <code>odfdo/paragraph.py</code> <pre><code>def append_plain_text(self, text: str | bytes | None = \"\") -&gt; None:\n    \"\"\"Append plain text to the paragraph, replacing &lt;CR&gt;, &lt;TAB&gt;\n    and multiple spaces by ODF corresponding tags.\n    \"\"\"\n    if text is None:\n        stext = \"\"\n    elif isinstance(text, bytes):\n        stext = text.decode(\"utf-8\")\n    else:\n        stext = str(text)\n    content = self._expand_spaces(stext)\n    content = self._merge_spaces(content)\n    content = self._replace_tabs_lb(content)\n    for child in self.children:\n        self.delete(child, keep_tail=False)\n    self.text = None\n    for element in content:\n        self._Element__append(element)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.insert_annotation","title":"<code>insert_annotation(annotation_element=None, before=None, after=None, position=0, content=None, body=None, creator=None, date=None)</code>","text":"<p>Insert an annotation, at the position defined by the regex (before, after, content) or by positionnal argument (position). If content is provided, the annotation covers the full content regex. Else, the annotation is positionned either \u2018before\u2019 or \u2018after\u2019 provided regex.</p> <p>If content is an odf element (ie: paragraph, span, \u2026), the full inner content is covered by the annotation (of the position just after if content is a single empty tag).</p> <p>If content/before or after exists (regex) and return a group of matching positions, the position value is the index of matching place to use.</p> <p>annotation_element can contain a previously created annotation, else the annotation is created from the body, creator and optional date (current date by default).</p> <p>Arguments:</p> <pre><code>annotation_element -- Annotation or None\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or Element or None\n\ncontent -- str regular expression or None, or Element\n\nposition -- int or tuple of int\n\nbody -- str or Element\n\ncreator -- str\n\ndate -- datetime\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def insert_annotation(\n    self,\n    annotation_element: Annotation | None = None,\n    before: str | None = None,\n    after: str | Element | None = None,\n    position: int | tuple = 0,\n    content: str | Element | None = None,\n    body: str | None = None,\n    creator: str | None = None,\n    date: datetime | None = None,\n) -&gt; Annotation:\n    \"\"\"Insert an annotation, at the position defined by the regex (before,\n    after, content) or by positionnal argument (position). If content is\n    provided, the annotation covers the full content regex. Else, the\n    annotation is positionned either 'before' or 'after' provided regex.\n\n    If content is an odf element (ie: paragraph, span, ...), the full inner\n    content is covered by the annotation (of the position just after if\n    content is a single empty tag).\n\n    If content/before or after exists (regex) and return a group of matching\n    positions, the position value is the index of matching place to use.\n\n    annotation_element can contain a previously created annotation, else\n    the annotation is created from the body, creator and optional date\n    (current date by default).\n\n    Arguments:\n\n        annotation_element -- Annotation or None\n\n        before -- str regular expression or None\n\n        after -- str regular expression or Element or None\n\n        content -- str regular expression or None, or Element\n\n        position -- int or tuple of int\n\n        body -- str or Element\n\n        creator -- str\n\n        date -- datetime\n    \"\"\"\n\n    if annotation_element is None:\n        annotation_element = Annotation(\n            text_or_element=body, creator=creator, date=date, parent=self\n        )\n    else:\n        # XXX clone or modify the argument?\n        if body:\n            annotation_element.note_body = body\n        if creator:\n            annotation_element.creator = creator\n        if date:\n            annotation_element.date = date\n    annotation_element.check_validity()\n\n    # special case: content is an odf element (ie: a paragraph)\n    if isinstance(content, Element):\n        if content.is_empty():\n            content.insert(annotation_element, xmlposition=NEXT_SIBLING)\n            return annotation_element\n        content.insert(annotation_element, start=True)\n        annotation_end = AnnotationEnd(annotation_element)\n        content.append(annotation_end)\n        return annotation_element\n\n    # special case\n    if isinstance(after, Element):\n        after.insert(annotation_element, FIRST_CHILD)\n        return annotation_element\n\n    # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and content is not None\n        and isinstance(position, int)\n    ):\n        # Start tag\n        self._insert(\n            annotation_element, before=content, position=position, main_text=True\n        )\n        # End tag\n        annotation_end = AnnotationEnd(annotation_element)\n        self._insert(\n            annotation_end, after=content, position=position, main_text=True\n        )\n        return annotation_element\n\n    # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and content is None\n        and isinstance(position, tuple)\n    ):\n        # Start\n        self._insert(annotation_element, position=position[0], main_text=True)\n        # End\n        annotation_end = AnnotationEnd(annotation_element)\n        self._insert(annotation_end, position=position[1], main_text=True)\n        return annotation_element\n\n    # Without \"content\" nor \"position\"\n    if content is not None or not isinstance(position, int):\n        raise ValueError(\"Bad arguments\")\n\n    # Insert\n    self._insert(\n        annotation_element,\n        before=before,\n        after=after,\n        position=position,\n        main_text=True,\n    )\n    return annotation_element\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.insert_annotation_end","title":"<code>insert_annotation_end(annotation_element, before=None, after=None, position=0)</code>","text":"<p>Insert an annotation end tag for an existing annotation. If some end tag already exists, replace it. Annotation end tag is set at the position defined by the regex (before or after).</p> <p>If content/before or after (regex) returns a group of matching positions, the position value is the index of matching place to use.</p> <p>Arguments:</p> <pre><code>annotation_element -- Annotation (mandatory)\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or None\n\nposition -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def insert_annotation_end(\n    self,\n    annotation_element: Annotation,\n    before: str | None = None,\n    after: str | None = None,\n    position: int = 0,\n) -&gt; AnnotationEnd:\n    \"\"\"Insert an annotation end tag for an existing annotation. If some end\n    tag already exists, replace it. Annotation end tag is set at the\n    position defined by the regex (before or after).\n\n    If content/before or after (regex) returns a group of matching\n    positions, the position value is the index of matching place to use.\n\n    Arguments:\n\n        annotation_element -- Annotation (mandatory)\n\n        before -- str regular expression or None\n\n        after -- str regular expression or None\n\n        position -- int\n    \"\"\"\n\n    if annotation_element is None:\n        raise ValueError\n    if not isinstance(annotation_element, Annotation):\n        raise TypeError(\"Not a &lt;office:annotation&gt; Annotation\")\n\n    # remove existing end tag\n    name = annotation_element.name\n    existing_end_tag = self.get_annotation_end(name=name)\n    if existing_end_tag:\n        existing_end_tag.delete()\n\n    # create the end tag\n    end_tag = AnnotationEnd(annotation_element)\n\n    # Insert\n    self._insert(\n        end_tag, before=before, after=after, position=position, main_text=True\n    )\n    return end_tag\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.insert_reference","title":"<code>insert_reference(name, ref_format='', before=None, after=None, position=0, display=None)</code>","text":"<p>Create and insert a reference to a content marked by a reference mark. The Reference element (\u201ctext:reference-ref\u201d) represents a field that references a \u201ctext:reference-mark-start\u201d or \u201ctext:reference-mark\u201d element. Its \u201ctext:reference-format\u201d attribute specifies what is displayed from the referenced element. Default is \u2018page\u2019. Actual content is not automatically updated except for the \u2018text\u2019 format.</p> <p>name is mandatory and should represent an existing reference mark of the document.</p> <p>ref_format is the argument for format reference (default is \u2018page\u2019).</p> <p>The reference is inserted the position defined by the regex (before / after), or by positionnal argument (position). If \u2018display\u2019 is provided, it will be used as the text value for the reference.</p> <p>If after is an ODF Element, the reference is inserted as first child of this element.</p> <p>Arguments:</p> <pre><code>name -- str\n\nref_format -- one of : 'chapter', 'direction', 'page', 'text',\n                        'caption', 'category-and-value', 'value',\n                        'number', 'number-all-superior',\n                        'number-no-superior'\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or odf element or None\n\nposition -- int\n\ndisplay -- str or None\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def insert_reference(\n    self,\n    name: str,\n    ref_format: str = \"\",\n    before: str | None = None,\n    after: str | Element | None = None,\n    position: int = 0,\n    display: str | None = None,\n) -&gt; None:\n    \"\"\"Create and insert a reference to a content marked by a reference\n    mark. The Reference element (\"text:reference-ref\") represents a\n    field that references a \"text:reference-mark-start\" or\n    \"text:reference-mark\" element. Its \"text:reference-format\" attribute\n    specifies what is displayed from the referenced element. Default is\n    'page'. Actual content is not automatically updated except for the 'text'\n    format.\n\n    name is mandatory and should represent an existing reference mark of the\n    document.\n\n    ref_format is the argument for format reference (default is 'page').\n\n    The reference is inserted the position defined by the regex (before /\n    after), or by positionnal argument (position). If 'display' is provided,\n    it will be used as the text value for the reference.\n\n    If after is an ODF Element, the reference is inserted as first child of\n    this element.\n\n    Arguments:\n\n        name -- str\n\n        ref_format -- one of : 'chapter', 'direction', 'page', 'text',\n                                'caption', 'category-and-value', 'value',\n                                'number', 'number-all-superior',\n                                'number-no-superior'\n\n        before -- str regular expression or None\n\n        after -- str regular expression or odf element or None\n\n        position -- int\n\n        display -- str or None\n    \"\"\"\n    reference = Reference(name, ref_format)\n    if display is None and ref_format == \"text\":\n        # get reference content\n        body = self.document_body\n        if not body:\n            body = self.root\n        mark = body.get_reference_mark(name=name)\n        if mark:\n            display = mark.referenced_text  # type: ignore\n    if not display:\n        display = \" \"\n    reference.text = display\n    if isinstance(after, Element):\n        after.insert(reference, FIRST_CHILD)\n    else:\n        self._insert(\n            reference, before=before, after=after, position=position, main_text=True\n        )\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_link","title":"<code>remove_link(links)</code>","text":"<p>Send back a copy of the element (not a clone), with the sub links    removed.</p> <p>Arguments:</p> <pre><code>links -- Link or list of Link\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_link(self, links: Link | list[Link]) -&gt; Element | list:\n    \"\"\"Send back a copy of the element (not a clone), with the sub links\n       removed.\n\n    Arguments:\n\n        links -- Link or list of Link\n    \"\"\"\n    return self.strip_elements(links)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_links","title":"<code>remove_links()</code>","text":"<p>Send back a copy of the element, without links tags.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_links(self) -&gt; Element | list:\n    \"\"\"Send back a copy of the element, without links tags.\"\"\"\n    strip = (Link._tag,)\n    return self.strip_tags(strip=strip)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_span","title":"<code>remove_span(spans)</code>","text":"<p>Send back a copy of the element, the spans (not a clone) removed.</p> <p>Arguments:</p> <pre><code>spans -- Element or list of Element\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_span(self, spans: Element | list[Element]) -&gt; Element | list:\n    \"\"\"Send back a copy of the element, the spans (not a clone) removed.\n\n    Arguments:\n\n        spans -- Element or list of Element\n    \"\"\"\n    return self.strip_elements(spans)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.remove_spans","title":"<code>remove_spans(keep_heading=True)</code>","text":"<p>Send back a copy of the element, without span styles. If keep_heading is True (default), the first level heading style is left unchanged.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def remove_spans(self, keep_heading: bool = True) -&gt; Element | list:\n    \"\"\"Send back a copy of the element, without span styles.\n    If keep_heading is True (default), the first level heading style is left\n    unchanged.\n    \"\"\"\n    strip = (Span._tag,)\n    if keep_heading:\n        protect = (\"text:h\",)\n    else:\n        protect = None\n    return self.strip_tags(strip=strip, protect=protect)\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_bookmark","title":"<code>set_bookmark(name, before=None, after=None, position=0, role=None, content=None)</code>","text":"<p>Insert a bookmark before or after the characters in the text which match the regex before/after. When the regex matches more of one part of the text, position can be set to choose which part must be used. If before and after are None, we use only position that is the number of characters.</p> <p>So, by default, this function inserts a bookmark before the first character of the content. Role can be None, \u201cstart\u201d or \u201cend\u201d, we insert respectively a position bookmark a bookmark-start or a bookmark-end.</p> <p>If content is not None these 2 calls are equivalent:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, content=\u201dxyz\u201d)</p> <p>and:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, before=\u201dxyz\u201d, role=\u201dstart\u201d)   paragraph.set_bookmark(\u201cbookmark\u201d, after=\u201dxyz\u201d, role=\u201dend\u201d)</p> <p>If position is a 2-tuple, these 2 calls are equivalent:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, position=(10, 20))</p> <p>and:</p> <p>paragraph.set_bookmark(\u201cbookmark\u201d, position=10, role=\u201dstart\u201d)   paragraph.set_bookmark(\u201cbookmark\u201d, position=20, role=\u201dend\u201d)</p> <p>Arguments:</p> <pre><code>name -- str\n\nbefore -- str regex\n\nafter -- str regex\n\nposition -- int or (int, int)\n\nrole -- None, \"start\" or \"end\"\n\ncontent -- str regex\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def set_bookmark(\n    self,\n    name: str,\n    before: str | None = None,\n    after: str | None = None,\n    position: int | tuple = 0,\n    role: str | None = None,\n    content: str | None = None,\n) -&gt; Element | tuple[Element, Element]:\n    \"\"\"Insert a bookmark before or after the characters in the text which\n    match the regex before/after. When the regex matches more of one part\n    of the text, position can be set to choose which part must be used.\n    If before and after are None, we use only position that is the number\n    of characters.\n\n    So, by default, this function inserts a bookmark before the first\n    character of the content. Role can be None, \"start\" or \"end\", we\n    insert respectively a position bookmark a bookmark-start or a\n    bookmark-end.\n\n    If content is not None these 2 calls are equivalent:\n\n      paragraph.set_bookmark(\"bookmark\", content=\"xyz\")\n\n    and:\n\n      paragraph.set_bookmark(\"bookmark\", before=\"xyz\", role=\"start\")\n      paragraph.set_bookmark(\"bookmark\", after=\"xyz\", role=\"end\")\n\n\n    If position is a 2-tuple, these 2 calls are equivalent:\n\n      paragraph.set_bookmark(\"bookmark\", position=(10, 20))\n\n    and:\n\n      paragraph.set_bookmark(\"bookmark\", position=10, role=\"start\")\n      paragraph.set_bookmark(\"bookmark\", position=20, role=\"end\")\n\n\n    Arguments:\n\n        name -- str\n\n        before -- str regex\n\n        after -- str regex\n\n        position -- int or (int, int)\n\n        role -- None, \"start\" or \"end\"\n\n        content -- str regex\n    \"\"\"\n    # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and role is None\n        and content is not None\n        and isinstance(position, int)\n    ):\n        # Start\n        start = BookmarkStart(name)\n        self._insert(start, before=content, position=position, main_text=True)\n        # End\n        end = BookmarkEnd(name)\n        self._insert(end, after=content, position=position, main_text=True)\n        return start, end\n\n    # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n    # bookmark\n    if (\n        before is None\n        and after is None\n        and role is None\n        and content is None\n        and isinstance(position, tuple)\n    ):\n        # Start\n        start = BookmarkStart(name)\n        self._insert(start, position=position[0], main_text=True)\n        # End\n        end = BookmarkEnd(name)\n        self._insert(end, position=position[1], main_text=True)\n        return start, end\n\n    # Without \"content\" nor \"position\"\n    if content is not None or not isinstance(position, int):\n        raise ValueError(\"bad arguments\")\n\n    # Role\n    if role is None:\n        bookmark: Element = Bookmark(name)\n    elif role == \"start\":\n        bookmark = BookmarkStart(name)\n    elif role == \"end\":\n        bookmark = BookmarkEnd(name)\n    else:\n        raise ValueError(\"bad arguments\")\n\n    # Insert\n    self._insert(\n        bookmark, before=before, after=after, position=position, main_text=True\n    )\n\n    return bookmark\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_link","title":"<code>set_link(match, tail, url, regex=None, offset=None, length=0)</code>","text":"<p>set_link(url, regex=None, offset=None, length=0) Make a link to the provided url from text content matching the regex OR the positional arguments offset and length.</p> <p>(match, tail: provided by regex decorator)</p> <p>Arguments:</p> <pre><code>url -- str\n\nregex -- str regular expression\n\noffset -- int\n\nlength -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>@_by_regex_offset\ndef set_link(\n    self,\n    match: str,\n    tail: str,\n    url: str,\n    regex: str | None = None,\n    offset: int | None = None,\n    length: int = 0,\n) -&gt; Element:\n    \"\"\"\n    set_link(url, regex=None, offset=None, length=0)\n    Make a link to the provided url from text content matching the regex\n    OR the positional arguments offset and length.\n\n    (match, tail: provided by regex decorator)\n\n    Arguments:\n\n        url -- str\n\n        regex -- str regular expression\n\n        offset -- int\n\n        length -- int\n    \"\"\"\n    link = Link(url, text=match)\n    link.tail = tail\n    return link\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_reference_mark","title":"<code>set_reference_mark(name, before=None, after=None, position=0, content=None)</code>","text":"<p>Insert a reference mark, at the position defined by the regex (before, after, content) or by positionnal argument (position). If content is provided, the annotation covers the full range content regex (instances of ReferenceMarkStart and ReferenceMarkEnd are created). Else, an instance of ReferenceMark is positionned either \u2018before\u2019 or \u2018after\u2019 provided regex.</p> <p>If content is an ODF Element (ie: Paragraph, Span, \u2026), the full inner content is referenced (of the position just after if content is a single empty tag).</p> <p>If content/before or after exists (regex) and return a group of matching positions, the position value is the index of matching place to use.</p> <p>Name is mandatory and shall be unique in the document for the preference mark range.</p> <p>Arguments:</p> <pre><code>name -- str\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or None,\n\ncontent -- str regular expression or None, or Element\n\nposition -- int or tuple of int\n</code></pre> <p>Return: the created ReferenceMark or ReferenceMarkStart</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def set_reference_mark(\n    self,\n    name: str,\n    before: str | None = None,\n    after: str | None = None,\n    position: int = 0,\n    content: str | Element | None = None,\n) -&gt; Element:\n    \"\"\"Insert a reference mark, at the position defined by the regex\n    (before, after, content) or by positionnal argument (position). If\n    content is provided, the annotation covers the full range content regex\n    (instances of ReferenceMarkStart and ReferenceMarkEnd are\n    created). Else, an instance of ReferenceMark is positionned either\n    'before' or 'after' provided regex.\n\n    If content is an ODF Element (ie: Paragraph, Span, ...), the full inner\n    content is referenced (of the position just after if content is a single\n    empty tag).\n\n    If content/before or after exists (regex) and return a group of matching\n    positions, the position value is the index of matching place to use.\n\n    Name is mandatory and shall be unique in the document for the preference\n    mark range.\n\n    Arguments:\n\n        name -- str\n\n        before -- str regular expression or None\n\n        after -- str regular expression or None,\n\n        content -- str regular expression or None, or Element\n\n        position -- int or tuple of int\n\n    Return: the created ReferenceMark or ReferenceMarkStart\n    \"\"\"\n    # special case: content is an odf element (ie: a paragraph)\n    if isinstance(content, Element):\n        if content.is_empty():\n            reference = ReferenceMark(name)\n            content.insert(reference, xmlposition=NEXT_SIBLING)\n            return reference\n        reference_start = ReferenceMarkStart(name)\n        content.insert(reference_start, start=True)\n        reference_end = ReferenceMarkEnd(name)\n        content.append(reference_end)\n        return reference_start\n\n    # With \"content\" =&gt; automatically insert a \"start\" and an \"end\"\n    # reference\n    if (\n        before is None\n        and after is None\n        and content is not None\n        and isinstance(position, int)\n    ):\n        # Start tag\n        reference_start = ReferenceMarkStart(name)\n        self._insert(\n            reference_start, before=content, position=position, main_text=True\n        )\n        # End tag\n        reference_end = ReferenceMarkEnd(name)\n        self._insert(\n            reference_end, after=content, position=position, main_text=True\n        )\n        return reference_start\n\n    # With \"(int, int)\" =&gt;  automatically insert a \"start\" and an \"end\"\n    if (\n        before is None\n        and after is None\n        and content is None\n        and isinstance(position, tuple)\n    ):\n        # Start\n        reference_start = ReferenceMarkStart(name)\n        self._insert(reference_start, position=position[0], main_text=True)\n        # End\n        reference_end = ReferenceMarkEnd(name)\n        self._insert(reference_end, position=position[1], main_text=True)\n        return reference_start\n\n    # Without \"content\" nor \"position\"\n    if content is not None or not isinstance(position, int):\n        raise ValueError(\"bad arguments\")\n\n    # Insert a positional reference mark\n    reference = ReferenceMark(name)\n    self._insert(\n        reference,\n        before=before,\n        after=after,\n        position=position,\n        main_text=True,\n    )\n    return reference\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_reference_mark_end","title":"<code>set_reference_mark_end(reference_mark, before=None, after=None, position=0)</code>","text":"<p>Insert/move a ReferenceMarkEnd for an existing reference mark. If some end tag already exists, replace it. Reference tag is set at the position defined by the regex (before or after).</p> <p>If content/before or after (regex) returns a group of matching positions, the position value is the index of matching place to use.</p> <p>Arguments:</p> <pre><code>reference_mark -- ReferenceMark or ReferenceMarkStart (mandatory)\n\nbefore -- str regular expression or None\n\nafter -- str regular expression or None\n\nposition -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def set_reference_mark_end(\n    self,\n    reference_mark: Element,\n    before: str | None = None,\n    after: str | None = None,\n    position: int = 0,\n) -&gt; ReferenceMarkEnd:\n    \"\"\"Insert/move a ReferenceMarkEnd for an existing reference mark. If\n    some end tag already exists, replace it. Reference tag is set at the\n    position defined by the regex (before or after).\n\n    If content/before or after (regex) returns a group of matching\n    positions, the position value is the index of matching place to use.\n\n    Arguments:\n\n        reference_mark -- ReferenceMark or ReferenceMarkStart (mandatory)\n\n        before -- str regular expression or None\n\n        after -- str regular expression or None\n\n        position -- int\n    \"\"\"\n    if not isinstance(reference_mark, (ReferenceMark, ReferenceMarkStart)):\n        raise TypeError(\"Not a ReferenceMark or ReferenceMarkStart\")\n    name = reference_mark.name\n    if isinstance(reference_mark, ReferenceMark):\n        # change it to a range reference:\n        reference_mark.tag = ReferenceMarkStart._tag\n\n    existing_end_tag = self.get_reference_mark_end(name=name)\n    if existing_end_tag:\n        existing_end_tag.delete()\n\n    # create the end tag\n    end_tag = ReferenceMarkEnd(name)\n\n    # Insert\n    self._insert(\n        end_tag, before=before, after=after, position=position, main_text=True\n    )\n    return end_tag\n</code></pre>"},{"location":"reference.html#odfdo.Paragraph.set_span","title":"<code>set_span(match, tail, style, regex=None, offset=None, length=0)</code>","text":"<p>set_span(style, regex=None, offset=None, length=0) Apply the given style to text content matching the regex OR the positional arguments offset and length.</p> <p>(match, tail: provided by regex decorator)</p> <p>Arguments:</p> <pre><code>style -- str\n\nregex -- str regular expression\n\noffset -- int\n\nlength -- int\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>@_by_regex_offset\ndef set_span(\n    self,\n    match: str,\n    tail: str,\n    style: str,\n    regex: str | None = None,\n    offset: int | None = None,\n    length: int = 0,\n) -&gt; Span:\n    \"\"\"\n    set_span(style, regex=None, offset=None, length=0)\n    Apply the given style to text content matching the regex OR the\n    positional arguments offset and length.\n\n    (match, tail: provided by regex decorator)\n\n    Arguments:\n\n        style -- str\n\n        regex -- str regular expression\n\n        offset -- int\n\n        length -- int\n    \"\"\"\n    span = Span(match, style=style)\n    span.tail = tail\n    return span\n</code></pre>"},{"location":"reference.html#odfdo.Presentation","title":"<code>Presentation</code>","text":"<p>               Bases: <code>Body</code></p> <p>Presentation, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Presentation(Body):\n    \"\"\"Presentation, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:presentation\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.RectangleShape","title":"<code>RectangleShape</code>","text":"<p>               Bases: <code>ShapeBase</code></p> <p>Create a rectangle shape.</p> <p>Arguments:</p> <pre><code>style -- str\n\ntext_style -- str\n\ndraw_id -- str\n\nlayer -- str\n\nposition -- (str, str)\n\nsize -- (str, str)\n</code></pre> Source code in <code>odfdo/shapes.py</code> <pre><code>class RectangleShape(ShapeBase):\n    \"\"\"Create a rectangle shape.\n\n    Arguments:\n\n        style -- str\n\n        text_style -- str\n\n        draw_id -- str\n\n        layer -- str\n\n        position -- (str, str)\n\n        size -- (str, str)\n\n    \"\"\"\n\n    _tag = \"draw:rect\"\n    _properties: tuple[PropDef, ...] = ()\n\n    def __init__(\n        self,\n        style: str | None = None,\n        text_style: str | None = None,\n        draw_id: str | None = None,\n        layer: str | None = None,\n        position: tuple | None = None,\n        size: tuple | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        kwargs.update(\n            {\n                \"style\": style,\n                \"text_style\": text_style,\n                \"draw_id\": draw_id,\n                \"layer\": layer,\n                \"size\": size,\n                \"position\": position,\n            }\n        )\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference.html#odfdo.Reference","title":"<code>Reference</code>","text":"<p>               Bases: <code>Element</code></p> <p>A reference to a content marked by a reference mark. The odf_reference element (\u201ctext:reference-ref\u201d) represents a field that references a \u201ctext:reference-mark-start\u201d or \u201ctext:reference-mark\u201d element. Its text:reference-format attribute specifies what is displayed from the referenced element. Default is \u2018page\u2019 Actual content is not updated except for the \u2018text\u2019 format by the update() method.</p> <p>Creation of references can be tricky, consider using this method:     odfdo.paragraph.insert_reference()</p> <p>Values for text:reference-format :     The defined values for the text:reference-format attribute supported by     all reference fields are:       - \u2018chapter\u2019: displays the number of the chapter in which the         referenced item appears.       - \u2018direction\u2019: displays whether the referenced item is above or         below the reference field.       - \u2018page\u2019: displays the number of the page on which the referenced         item appears.       - \u2018text\u2019: displays the text of the referenced item.     Additional defined values for the text:reference-format attribute     supported by references to sequence fields are:       - \u2018caption\u2019: displays the caption in which the sequence is used.       - \u2018category-and-value\u2019: displays the name and value of the sequence.       - \u2018value\u2019: displays the value of the sequence.</p> <pre><code>References to bookmarks and other references support additional values,\nwhich display the list label of the referenced item. If the referenced\nitem is contained in a list or a numbered paragraph, the list label is\nthe formatted number of the paragraph which contains the referenced\nitem. If the referenced item is not contained in a list or numbered\nparagraph, the list label is empty, and the referenced field therefore\ndisplays nothing. If the referenced bookmark or reference contains more\nthan one paragraph, the list label of the paragraph at which the\nbookmark or reference starts is taken.\n\nAdditional defined values for the text:reference-format attribute\nsupported by all references to bookmark's or other reference fields\nare:\n  - 'number': displays the list label of the referenced item. [...]\n  - 'number-all-superior': displays the list label of the referenced\n    item and adds the contents of all list labels of superior levels\n    in front of it. [...]\n  - 'number-no-superior': displays the contents of the list label of\n    the referenced item.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>class Reference(Element):\n    \"\"\"A reference to a content marked by a reference mark.\n    The odf_reference element (\"text:reference-ref\") represents a field that\n    references a \"text:reference-mark-start\" or \"text:reference-mark\" element.\n    Its text:reference-format attribute specifies what is displayed from the\n    referenced element. Default is 'page'\n    Actual content is not updated except for the 'text' format by the\n    update() method.\n\n\n    Creation of references can be tricky, consider using this method:\n        odfdo.paragraph.insert_reference()\n\n    Values for text:reference-format :\n        The defined values for the text:reference-format attribute supported by\n        all reference fields are:\n          - 'chapter': displays the number of the chapter in which the\n            referenced item appears.\n          - 'direction': displays whether the referenced item is above or\n            below the reference field.\n          - 'page': displays the number of the page on which the referenced\n            item appears.\n          - 'text': displays the text of the referenced item.\n        Additional defined values for the text:reference-format attribute\n        supported by references to sequence fields are:\n          - 'caption': displays the caption in which the sequence is used.\n          - 'category-and-value': displays the name and value of the sequence.\n          - 'value': displays the value of the sequence.\n\n        References to bookmarks and other references support additional values,\n        which display the list label of the referenced item. If the referenced\n        item is contained in a list or a numbered paragraph, the list label is\n        the formatted number of the paragraph which contains the referenced\n        item. If the referenced item is not contained in a list or numbered\n        paragraph, the list label is empty, and the referenced field therefore\n        displays nothing. If the referenced bookmark or reference contains more\n        than one paragraph, the list label of the paragraph at which the\n        bookmark or reference starts is taken.\n\n        Additional defined values for the text:reference-format attribute\n        supported by all references to bookmark's or other reference fields\n        are:\n          - 'number': displays the list label of the referenced item. [...]\n          - 'number-all-superior': displays the list label of the referenced\n            item and adds the contents of all list labels of superior levels\n            in front of it. [...]\n          - 'number-no-superior': displays the contents of the list label of\n            the referenced item.\n    \"\"\"\n\n    _tag = \"text:reference-ref\"\n    _properties = (PropDef(\"name\", \"text:ref-name\"),)\n    format_allowed = (\n        \"chapter\",\n        \"direction\",\n        \"page\",\n        \"text\",\n        \"caption\",\n        \"category-and-value\",\n        \"value\",\n        \"number\",\n        \"number-all-superior\",\n        \"number-no-superior\",\n    )\n\n    def __init__(self, name: str = \"\", ref_format: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"Create a reference to a content marked by a reference mark. An\n        actual reference mark with the provided name should exist.\n\n        Consider using: odfdo.paragraph.insert_reference()\n\n        The text:ref-name attribute identifies a \"text:reference-mark\" or\n        \"text:referencemark-start\" element by the value of that element's\n        text:name attribute.\n        If ref_format is 'text', the current text content of the reference_mark\n        is retrieved.\n\n        Arguments:\n\n            name -- str : name of the reference mark\n\n            ref_format -- str : format of the field. Default is 'page', allowed\n                            values are 'chapter', 'direction', 'page', 'text',\n                            'caption', 'category-and-value', 'value', 'number',\n                            'number-all-superior', 'number-no-superior'.\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n            self.ref_format = ref_format\n\n    @property\n    def ref_format(self) -&gt; str | None:\n        reference = self.get_attribute(\"text:reference-format\")\n        if isinstance(reference, str):\n            return reference\n        return None\n\n    @ref_format.setter\n    def ref_format(self, ref_format: str) -&gt; None:\n        \"\"\"Set the text:reference-format attribute.\n\n        Arguments:\n\n            ref_format -- str\n        \"\"\"\n        if not ref_format or ref_format not in self.format_allowed:\n            ref_format = \"page\"\n        self.set_attribute(\"text:reference-format\", ref_format)\n\n    def update(self) -&gt; None:\n        \"\"\"Update the content of the reference text field. Currently only\n        'text' format is implemented. Other values, for example the 'page' text\n        field, may need to be refreshed through a visual ODF parser.\n        \"\"\"\n        ref_format = self.ref_format\n        if ref_format != \"text\":\n            # only 'text' is implemented\n            return None\n        body = self.document_body\n        if not body:\n            body = self.root\n        name = self.name\n        reference = body.get_reference_mark(name=name)\n        if not reference:\n            return None\n        # we know it is a ReferenceMarkStart:\n        self.text = reference.referenced_text()  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Reference.__init__","title":"<code>__init__(name='', ref_format='', **kwargs)</code>","text":"<p>Create a reference to a content marked by a reference mark. An actual reference mark with the provided name should exist.</p> <p>Consider using: odfdo.paragraph.insert_reference()</p> <p>The text:ref-name attribute identifies a \u201ctext:reference-mark\u201d or \u201ctext:referencemark-start\u201d element by the value of that element\u2019s text:name attribute. If ref_format is \u2018text\u2019, the current text content of the reference_mark is retrieved.</p> <p>Arguments:</p> <pre><code>name -- str : name of the reference mark\n\nref_format -- str : format of the field. Default is 'page', allowed\n                values are 'chapter', 'direction', 'page', 'text',\n                'caption', 'category-and-value', 'value', 'number',\n                'number-all-superior', 'number-no-superior'.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", ref_format: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"Create a reference to a content marked by a reference mark. An\n    actual reference mark with the provided name should exist.\n\n    Consider using: odfdo.paragraph.insert_reference()\n\n    The text:ref-name attribute identifies a \"text:reference-mark\" or\n    \"text:referencemark-start\" element by the value of that element's\n    text:name attribute.\n    If ref_format is 'text', the current text content of the reference_mark\n    is retrieved.\n\n    Arguments:\n\n        name -- str : name of the reference mark\n\n        ref_format -- str : format of the field. Default is 'page', allowed\n                        values are 'chapter', 'direction', 'page', 'text',\n                        'caption', 'category-and-value', 'value', 'number',\n                        'number-all-superior', 'number-no-superior'.\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n        self.ref_format = ref_format\n</code></pre>"},{"location":"reference.html#odfdo.Reference.update","title":"<code>update()</code>","text":"<p>Update the content of the reference text field. Currently only \u2018text\u2019 format is implemented. Other values, for example the \u2018page\u2019 text field, may need to be refreshed through a visual ODF parser.</p> Source code in <code>odfdo/reference.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the content of the reference text field. Currently only\n    'text' format is implemented. Other values, for example the 'page' text\n    field, may need to be refreshed through a visual ODF parser.\n    \"\"\"\n    ref_format = self.ref_format\n    if ref_format != \"text\":\n        # only 'text' is implemented\n        return None\n    body = self.document_body\n    if not body:\n        body = self.root\n    name = self.name\n    reference = body.get_reference_mark(name=name)\n    if not reference:\n        return None\n    # we know it is a ReferenceMarkStart:\n    self.text = reference.referenced_text()  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMark","title":"<code>ReferenceMark</code>","text":"<p>               Bases: <code>Element</code></p> <p>A point reference. A point reference marks a position in text and is represented by a single \u201ctext:reference-mark\u201d element.</p> Source code in <code>odfdo/reference.py</code> <pre><code>class ReferenceMark(Element):\n    \"\"\"A point reference.\n    A point reference marks a position in text and is represented by a single\n    \"text:reference-mark\" element.\n    \"\"\"\n\n    _tag = \"text:reference-mark\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"A point reference. A point reference marks a position in text and is\n        represented by a single \"text:reference-mark\" element.\n        Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMark.__init__","title":"<code>__init__(name='', **kwargs)</code>","text":"<p>A point reference. A point reference marks a position in text and is represented by a single \u201ctext:reference-mark\u201d element. Consider using the wrapper: odfdo.paragraph.set_reference_mark()</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"A point reference. A point reference marks a position in text and is\n    represented by a single \"text:reference-mark\" element.\n    Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkEnd","title":"<code>ReferenceMarkEnd</code>","text":"<p>               Bases: <code>Element</code></p> <p>The \u201ctext:reference-mark-end\u201d element represents the end of a range reference.</p> Source code in <code>odfdo/reference.py</code> <pre><code>class ReferenceMarkEnd(Element):\n    \"\"\"The \"text:reference-mark-end\" element represents the end of a range\n    reference.\n    \"\"\"\n\n    _tag = \"text:reference-mark-end\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"The \"text:reference-mark-end\" element represent the end of a range\n        reference.\n        Consider using the wrappers: odfdo.paragraph.set_reference_mark() and\n        odfdo.paragraph.set_reference_mark_end()\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n\n    def referenced_text(self) -&gt; str:\n        \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n        name = self.name\n        request = (\n            f\"//text()\"\n            f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n            f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n        )\n        result = \" \".join(str(x) for x in self.xpath(request))\n        return result\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkEnd.__init__","title":"<code>__init__(name='', **kwargs)</code>","text":"<p>The \u201ctext:reference-mark-end\u201d element represent the end of a range reference. Consider using the wrappers: odfdo.paragraph.set_reference_mark() and odfdo.paragraph.set_reference_mark_end()</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"The \"text:reference-mark-end\" element represent the end of a range\n    reference.\n    Consider using the wrappers: odfdo.paragraph.set_reference_mark() and\n    odfdo.paragraph.set_reference_mark_end()\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkEnd.referenced_text","title":"<code>referenced_text()</code>","text":"<p>Return the text between reference-mark-start and reference-mark-end.</p> Source code in <code>odfdo/reference.py</code> <pre><code>def referenced_text(self) -&gt; str:\n    \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n    name = self.name\n    request = (\n        f\"//text()\"\n        f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n        f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n    )\n    result = \" \".join(str(x) for x in self.xpath(request))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart","title":"<code>ReferenceMarkStart</code>","text":"<p>               Bases: <code>Element</code></p> <p>The \u201ctext:reference-mark-start\u201d element represents the start of a range reference.</p> Source code in <code>odfdo/reference.py</code> <pre><code>class ReferenceMarkStart(Element):\n    \"\"\"The \"text:reference-mark-start\" element represents the start of a\n    range reference.\n    \"\"\"\n\n    _tag = \"text:reference-mark-start\"\n    _properties = (PropDef(\"name\", \"text:name\"),)\n\n    def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n        \"\"\"The \"text:reference-mark-start\" element represent the start of a range\n        reference.\n        Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            self.name = name\n\n    def referenced_text(self) -&gt; str:\n        \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n        name = self.name\n        request = (\n            f\"//text()\"\n            f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n            f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n        )\n        result = \" \".join(str(x) for x in self.xpath(request))\n        return result\n\n    def get_referenced(\n        self,\n        no_header: bool = False,\n        clean: bool = True,\n        as_xml: bool = False,\n        as_list: bool = False,\n    ) -&gt; Element | list | str | None:\n        \"\"\"Return the document content between the start and end tags of the\n        reference. The content returned by this method can spread over several\n        headers and paragraphs.\n        By default, the content is returned as an \"office:text\" odf element.\n\n\n        Arguments:\n\n            no_header -- boolean (default to False), translate existing headers\n                         tags \"text:h\" into paragraphs \"text:p\".\n\n            clean -- boolean (default to True), suppress unwanted tags. Striped\n                     tags are : 'text:change', 'text:change-start',\n                     'text:change-end', 'text:reference-mark',\n                     'text:reference-mark-start', 'text:reference-mark-end'.\n\n            as_xml -- boolean (default to False), format the returned content as\n                      a XML string (serialization).\n\n            as_list -- boolean (default to False), do not embed the returned\n                       content in a \"office:text'\" element, instead simply\n                       return a raw list of odf elements.\n        \"\"\"\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Reference need some upper document part\")\n        body = self.document_body\n        if not body:\n            body = parent\n        end = body.get_reference_mark_end(name=name)\n        if end is None:\n            raise ValueError(\"No reference-end found\")\n        start = self\n        return _get_referenced(body, start, end, no_header, clean, as_xml, as_list)\n\n    def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        For odf_reference_mark_start : delete the reference-end tag if exists.\n\n        Arguments:\n\n            child -- Element\n\n            keep_tail -- boolean (default to True), True for most usages.\n        \"\"\"\n        if child is not None:  # act like normal delete\n            return super().delete(child, keep_tail)\n        name = self.name\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can't delete the root element\")\n        body = self.document_body\n        if not body:\n            body = parent\n        end = body.get_reference_mark_end(name=name)\n        if end:\n            end.delete()\n        # act like normal delete\n        return super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.__init__","title":"<code>__init__(name='', **kwargs)</code>","text":"<p>The \u201ctext:reference-mark-start\u201d element represent the start of a range reference. Consider using the wrapper: odfdo.paragraph.set_reference_mark()</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def __init__(self, name: str = \"\", **kwargs: Any) -&gt; None:\n    \"\"\"The \"text:reference-mark-start\" element represent the start of a range\n    reference.\n    Consider using the wrapper: odfdo.paragraph.set_reference_mark()\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        self.name = name\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>For odf_reference_mark_start : delete the reference-end tag if exists.</p> <p>Arguments:</p> <pre><code>child -- Element\n\nkeep_tail -- boolean (default to True), True for most usages.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def delete(self, child: Element | None = None, keep_tail: bool = True) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    For odf_reference_mark_start : delete the reference-end tag if exists.\n\n    Arguments:\n\n        child -- Element\n\n        keep_tail -- boolean (default to True), True for most usages.\n    \"\"\"\n    if child is not None:  # act like normal delete\n        return super().delete(child, keep_tail)\n    name = self.name\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Can't delete the root element\")\n    body = self.document_body\n    if not body:\n        body = parent\n    end = body.get_reference_mark_end(name=name)\n    if end:\n        end.delete()\n    # act like normal delete\n    return super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.get_referenced","title":"<code>get_referenced(no_header=False, clean=True, as_xml=False, as_list=False)</code>","text":"<p>Return the document content between the start and end tags of the reference. The content returned by this method can spread over several headers and paragraphs. By default, the content is returned as an \u201coffice:text\u201d odf element.</p> <p>Arguments:</p> <pre><code>no_header -- boolean (default to False), translate existing headers\n             tags \"text:h\" into paragraphs \"text:p\".\n\nclean -- boolean (default to True), suppress unwanted tags. Striped\n         tags are : 'text:change', 'text:change-start',\n         'text:change-end', 'text:reference-mark',\n         'text:reference-mark-start', 'text:reference-mark-end'.\n\nas_xml -- boolean (default to False), format the returned content as\n          a XML string (serialization).\n\nas_list -- boolean (default to False), do not embed the returned\n           content in a \"office:text'\" element, instead simply\n           return a raw list of odf elements.\n</code></pre> Source code in <code>odfdo/reference.py</code> <pre><code>def get_referenced(\n    self,\n    no_header: bool = False,\n    clean: bool = True,\n    as_xml: bool = False,\n    as_list: bool = False,\n) -&gt; Element | list | str | None:\n    \"\"\"Return the document content between the start and end tags of the\n    reference. The content returned by this method can spread over several\n    headers and paragraphs.\n    By default, the content is returned as an \"office:text\" odf element.\n\n\n    Arguments:\n\n        no_header -- boolean (default to False), translate existing headers\n                     tags \"text:h\" into paragraphs \"text:p\".\n\n        clean -- boolean (default to True), suppress unwanted tags. Striped\n                 tags are : 'text:change', 'text:change-start',\n                 'text:change-end', 'text:reference-mark',\n                 'text:reference-mark-start', 'text:reference-mark-end'.\n\n        as_xml -- boolean (default to False), format the returned content as\n                  a XML string (serialization).\n\n        as_list -- boolean (default to False), do not embed the returned\n                   content in a \"office:text'\" element, instead simply\n                   return a raw list of odf elements.\n    \"\"\"\n    name = self.name\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Reference need some upper document part\")\n    body = self.document_body\n    if not body:\n        body = parent\n    end = body.get_reference_mark_end(name=name)\n    if end is None:\n        raise ValueError(\"No reference-end found\")\n    start = self\n    return _get_referenced(body, start, end, no_header, clean, as_xml, as_list)\n</code></pre>"},{"location":"reference.html#odfdo.ReferenceMarkStart.referenced_text","title":"<code>referenced_text()</code>","text":"<p>Return the text between reference-mark-start and reference-mark-end.</p> Source code in <code>odfdo/reference.py</code> <pre><code>def referenced_text(self) -&gt; str:\n    \"\"\"Return the text between reference-mark-start and reference-mark-end.\"\"\"\n    name = self.name\n    request = (\n        f\"//text()\"\n        f\"[preceding::text:reference-mark-start[@text:name='{name}'] \"\n        f\"and following::text:reference-mark-end[@text:name='{name}']]\"\n    )\n    result = \" \".join(str(x) for x in self.xpath(request))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.Row","title":"<code>Row</code>","text":"<p>               Bases: <code>CachedElement</code></p> <p>ODF table row \u201ctable:table-row\u201d</p> Source code in <code>odfdo/row.py</code> <pre><code>class Row(CachedElement):\n    \"\"\"ODF table row \"table:table-row\" \"\"\"\n\n    _tag = \"table:table-row\"\n    _append = Element.append\n\n    def __init__(\n        self,\n        width: int | None = None,\n        repeated: int | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"create a Row, optionally filled with \"width\" number of cells.\n\n        Rows contain cells, their number determine the number of columns.\n\n        You don't generally have to create rows by hand, use the Table API.\n\n        Arguments:\n\n            width -- int\n\n            repeated -- int\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self.y = None\n        self._indexes = {}\n        self._indexes[\"_rmap\"] = {}\n        self._compute_row_cache()\n        self._tmap = []\n        self._cmap = []\n        if self._do_init:\n            if width is not None:\n                for _i in range(width):\n                    self.append(Cell())  # type:ignore\n            if repeated:\n                self.repeated = repeated\n            if style is not None:\n                self.style = style\n            self._compute_row_cache()\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} y={self.y}&gt;\"\n\n    def _get_cells(self) -&gt; list[Element]:\n        return self.get_elements(_xpath_cell)\n\n    def _translate_row_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, int | None]:\n        xyzt = convert_coordinates(coord)\n        if len(xyzt) == 2:\n            x, z = xyzt\n        else:\n            x, _, z, __ = xyzt\n        if x and x &lt; 0:\n            x = increment(x, self.width)\n        if z and z &lt; 0:\n            z = increment(z, self.width)\n        return (x, z)\n\n    def _compute_row_cache(self) -&gt; None:\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_cell, \"table:number-columns-repeated\"\n        )\n        self._rmap = make_cache_map(idx_repeated_seq)\n\n    # Public API\n\n    @property\n    def clone(self) -&gt; Row:\n        clone = Element.clone.fget(self)  # type: ignore\n        clone.y = self.y\n        clone._rmap = self._rmap[:]\n        clone._tmap = self._tmap[:]\n        clone._cmap = self._cmap[:]\n        return clone\n\n    def _set_repeated(self, repeated: int | None) -&gt; None:\n        \"\"\"Method Internal only. Set the numnber of times the row is\n        repeated, or None to delete it. Without changing cache.\n\n        Arguments:\n\n            repeated -- int\n        \"\"\"\n        if repeated is None or repeated &lt; 2:\n            with contextlib.suppress(KeyError):\n                self.del_attribute(\"table:number-rows-repeated\")\n            return\n        self.set_attribute(\"table:number-rows-repeated\", str(repeated))\n\n    @property\n    def repeated(self) -&gt; int | None:\n        \"\"\"Get / set the number of times the row is repeated.\n\n        Always None when using the table API.\n\n        Return: int or None\n        \"\"\"\n        repeated = self.get_attribute(\"table:number-rows-repeated\")\n        if repeated is None:\n            return None\n        return int(repeated)\n\n    @repeated.setter\n    def repeated(self, repeated: int | None) -&gt; None:\n        self._set_repeated(repeated)\n        # update cache\n        current: Element = self\n        while True:\n            # look for Table, parent may be group of rows\n            upper = current.parent\n            if not upper:\n                # lonely row\n                return\n            # parent may be group of rows, not table\n            if isinstance(upper, Element) and upper._tag == \"table:table\":\n                upper._compute_table_cache()\n                if hasattr(self, \"_tmap\"):\n                    self._tmap.clear()\n                    self._tmap.extend(upper._tmap)\n                else:\n                    self._tmap = upper._tmap\n                return\n            current = upper\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get /set the style of the row itself.\n\n        Return: str\n        \"\"\"\n        return self.get_attribute(\"table:style-name\")  # type: ignore\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Get the number of expected cells in the row, i.e. addition\n        repetitions.\n\n        Return: int\n        \"\"\"\n        try:\n            value = self._rmap[-1] + 1\n        except Exception:\n            value = 0\n        return value\n\n    def _translate_x_from_any(self, x: str | int) -&gt; int:\n        return translate_from_any(x, self.width, 0)\n\n    def traverse(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; Iterator[Cell]:\n        \"\"\"Yield as many cell elements as expected cells in the row, i.e.\n        expand repetitions by returning the same cell as many times as\n        necessary.\n\n            Arguments:\n\n                start -- int\n\n                end -- int\n\n        Copies are returned, use set_cell() to push them back.\n        \"\"\"\n        idx = -1\n        before = -1\n        x = 0\n        cell: Cell\n        if start is None and end is None:\n            for juska in self._rmap:\n                idx += 1\n                if idx in self._indexes[\"_rmap\"]:\n                    cell = self._indexes[\"_rmap\"][idx]\n                else:\n                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                    if not isinstance(cell, Cell):\n                        raise TypeError(f\"Not a cell: {cell!r}\")  # pragma: no cover\n                    self._indexes[\"_rmap\"][idx] = cell\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    # Return a copy without the now obsolete repetition\n                    if cell is None:\n                        cell = Cell()  # pragma: no cover\n                    else:\n                        cell = cell.clone\n                        if repeated &gt; 1:\n                            cell.repeated = None\n                    cell.y = self.y\n                    cell.x = x\n                    x += 1\n                    yield cell\n        else:\n            if start is None:\n                start = 0\n            start = max(0, start)\n            if end is None:\n                try:\n                    end = self._rmap[-1]\n                except Exception:  # pragma: no cover\n                    end = -1\n            start_map = find_odf_idx(self._rmap, start)\n            if start_map is None:\n                return\n            if start_map &gt; 0:\n                before = self._rmap[start_map - 1]\n            idx = start_map - 1\n            before = start - 1\n            x = start\n            for juska in self._rmap[start_map:]:\n                idx += 1\n                if idx in self._indexes[\"_rmap\"]:\n                    cell = self._indexes[\"_rmap\"][idx]\n                else:\n                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                    if not isinstance(cell, Cell):\n                        raise TypeError(f\"Not a cell: {cell!r}\")  # pragma: no cover\n                    self._indexes[\"_rmap\"][idx] = cell\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    if x &lt;= end:\n                        if cell is None:\n                            cell = Cell()  # pragma: no cover\n                        else:\n                            cell = cell.clone\n                            if repeated &gt; 1 or (x == start and start &gt; 0):\n                                cell.repeated = None\n                        cell.y = self.y\n                        cell.x = x\n                        x += 1\n                        yield cell\n\n    def get_cells(\n        self,\n        coord: str | tuple | None = None,\n        style: str | None = None,\n        content: str | None = None,\n        cell_type: str | None = None,\n    ) -&gt; list[Cell]:\n        \"\"\"Get the list of cells matching the criteria.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n\n        Filter by coordinates will retrieve the amount of cells defined by\n        'coord', minus the other filters.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            content -- str regex\n\n            style -- str\n\n        Return: list of Cell\n        \"\"\"\n        # fixme : not clones ?\n        if coord:\n            x, z = self._translate_row_coordinates(coord)\n        else:\n            x = None\n            z = None\n        if cell_type:\n            cell_type = cell_type.lower().strip()\n        cells: list[Cell] = []\n        for cell in self.traverse(start=x, end=z):\n            # Filter the cells by cell_type\n            if cell_type:\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    continue\n            # Filter the cells with the regex\n            if content and not cell.match(content):\n                continue\n            # Filter the cells with the style\n            if style and style != cell.style:\n                continue\n            cells.append(cell)\n        return cells\n\n    @property\n    def cells(self) -&gt; list[Cell]:\n        \"\"\"Get the list of all cells.\n\n        Return: list of Cell\n        \"\"\"\n        # fixme : not clones ?\n        return list(self.traverse())\n\n    def _get_cell2(self, x: int, clone: bool = True) -&gt; Cell | None:\n        if x &gt;= self.width:\n            return Cell()\n        if clone:\n            return self._get_cell2_base(x).clone  # type: ignore\n        else:\n            return self._get_cell2_base(x)\n\n    def _get_cell2_base(self, x: int) -&gt; Cell | None:\n        idx = find_odf_idx(self._rmap, x)\n        cell: Cell\n        if idx is not None:\n            if idx in self._indexes[\"_rmap\"]:\n                cell = self._indexes[\"_rmap\"][idx]\n            else:\n                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                self._indexes[\"_rmap\"][idx] = cell\n            return cell\n        return None\n\n    def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:\n        \"\"\"Get the cell at position \"x\" starting from 0. Alphabetical\n        positions like \"D\" are accepted.\n\n        A  copy is returned, use set_cell() to push it back.\n\n        Arguments:\n\n            x -- int or str\n\n        Return: Cell | None\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        cell = self._get_cell2(x, clone=clone)\n        if not cell:\n            return None  # pragma: no cover\n        cell.y = self.y\n        cell.x = x\n        return cell\n\n    def get_value(\n        self,\n        x: int | str,\n        get_type: bool = False,\n    ) -&gt; Any | tuple[Any, str]:\n        \"\"\"Shortcut to get the value of the cell at position \"x\".\n        If get_type is True, returns the tuples (value, ODF type).\n\n        If the cell is empty, returns None or (None, None)\n\n        See get_cell() and Cell.get_value().\n        \"\"\"\n        if get_type:\n            x = self._translate_x_from_any(x)\n            cell = self._get_cell2_base(x)\n            if cell is None:\n                return (None, None)\n            return cell.get_value(get_type=get_type)\n        x = self._translate_x_from_any(x)\n        cell = self._get_cell2_base(x)\n        if cell is None:\n            return None\n        return cell.get_value()\n\n    def set_cell(\n        self,\n        x: int | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Push the cell back in the row at position \"x\" starting from 0.\n        Alphabetical positions like \"D\" are accepted.\n\n        Arguments:\n\n            x -- int or str\n\n        returns the cell with x and y updated\n        \"\"\"\n        cell_back: Cell\n        if cell is None:\n            cell = Cell()\n            repeated = 1\n            clone = False\n        else:\n            repeated = cell.repeated or 1\n        x = self._translate_x_from_any(x)\n        # Outside the defined row\n        diff = x - self.width\n        if diff == 0:\n            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n        elif diff &gt; 0:\n            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n        else:\n            # Inside the defined row\n            set_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\", clone=clone)\n            cell.x = x\n            cell.y = self.y\n            cell_back = cell\n        return cell_back\n\n    def set_value(\n        self,\n        x: int | str,\n        value: Any,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the value of the cell at position \"x\".\n\n        Arguments:\n\n            x -- int or str\n\n            value -- Python type\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n\n        See get_cell() and Cell.get_value().\n        \"\"\"\n        self.set_cell(\n            x,\n            Cell(value, style=style, cell_type=cell_type, currency=currency),\n            clone=False,\n        )\n\n    def insert_cell(\n        self,\n        x: int | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Insert the given cell at position \"x\" starting from 0. If no cell\n        is given, an empty one is created.\n\n        Alphabetical positions like \"D\" are accepted.\n\n        Do not use when working on a table, use Table.insert_cell().\n\n        Arguments:\n\n            x -- int or str\n\n            cell -- Cell\n\n        returns the cell with x and y updated\n        \"\"\"\n        cell_back: Cell\n        if cell is None:\n            cell = Cell()\n        x = self._translate_x_from_any(x)\n        # Outside the defined row\n        diff = x - self.width\n        if diff &lt; 0:\n            insert_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\")\n            cell.x = x\n            cell.y = self.y\n            cell_back = cell\n        elif diff == 0:\n            cell_back = self.append_cell(cell, clone=clone)\n        else:\n            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n            cell_back = self.append_cell(cell, clone=clone)\n        return cell_back\n\n    def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:\n        if cells is None:\n            cells = []\n        self.extend(cells)\n        self._compute_row_cache()\n\n    def append_cell(\n        self,\n        cell: Cell | None = None,\n        clone: bool = True,\n        _repeated: int | None = None,\n    ) -&gt; Cell:\n        \"\"\"Append the given cell at the end of the row. Repeated cells are\n        accepted. If no cell is given, an empty one is created.\n\n        Do not use when working on a table, use Table.append_cell().\n\n        Arguments:\n\n            cell -- Cell\n\n            _repeated -- (optional), repeated value of the row\n\n        returns the cell with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        if clone:\n            cell = cell.clone\n        self._append(cell)\n        if _repeated is None:\n            _repeated = cell.repeated or 1\n        self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)\n        cell.x = self.width - 1\n        cell.y = self.y\n        return cell\n\n    # fix for unit test and typos\n    append = append_cell  # type: ignore\n\n    def delete_cell(self, x: int | str) -&gt; None:\n        \"\"\"Delete the cell at the given position \"x\" starting from 0.\n        Alphabetical positions like \"D\" are accepted.\n\n        Cells on the right will be shifted to the left. In a table, other\n        rows remain unaffected.\n\n        Arguments:\n\n            x -- int or str\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        if x &gt;= self.width:\n            return\n        delete_item_in_vault(x, self, _xpath_cell_idx, \"_rmap\")\n\n    def get_values(\n        self,\n        coord: str | tuple | None = None,\n        cell_type: str | None = None,\n        complete: bool = False,\n        get_type: bool = False,\n    ) -&gt; list[Any | tuple[Any, Any]]:\n        \"\"\"Shortcut to get the cell values in this row.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n        If cell_type is used and complete is True, missing values are\n        replaced by None.\n        If cell_type is None, complete is always True : with no cell type\n        queried, get_values() returns None for each empty cell, the length\n        of the list is equal to the length of the row (depending on\n        coordinates use).\n\n        If get_type is True, returns a tuple (value, ODF type of value), or\n        (None, None) for empty cells if complete is True.\n\n        Filter by coordinates will retrieve the amount of cells defined by\n        coordinates with None for empty cells, except when using cell_type.\n\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates in row\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of Python types, or list of tuples.\n        \"\"\"\n        if coord:\n            x, z = self._translate_row_coordinates(coord)\n        else:\n            x = None\n            z = None\n        if cell_type:\n            cell_type = cell_type.lower().strip()\n            values: list[Any | tuple[Any, Any]] = []\n            for cell in self.traverse(start=x, end=z):\n                # Filter the cells by cell_type\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    if complete:\n                        if get_type:\n                            values.append((None, None))\n                        else:\n                            values.append(None)\n                    continue\n                values.append(cell.get_value(get_type=get_type))\n            return values\n        else:\n            return [\n                cell.get_value(get_type=get_type)\n                for cell in self.traverse(start=x, end=z)\n            ]\n\n    def get_sub_elements(\n        self,\n    ) -&gt; list[Any]:\n        \"\"\"Shortcut to get the Elements inside cells in this row.\n\n        Missing values are replaced by None. Cell type should be always\n        'string' when using this method, the length of the list is equal\n        to the length of the row.\n\n        Return: list of Elements.\n        \"\"\"\n        return [cell.children for cell in self.traverse()]\n\n    def set_cells(\n        self,\n        cells: list[Cell] | tuple[Cell] | None = None,\n        start: int | str = 0,\n        clone: bool = True,\n    ) -&gt; None:\n        \"\"\"Set the cells in the row, from the 'start' column.\n        This method does not clear the row, use row.clear() before to start\n        with an empty row.\n\n        Arguments:\n\n            cells -- list of cells\n\n            start -- int or str\n        \"\"\"\n        if cells is None:\n            cells = []\n        if start is None:\n            start = 0\n        else:\n            start = self._translate_x_from_any(start)\n        if start == 0 and clone is False and (len(cells) &gt;= self.width):\n            self.clear()\n            self.extend_cells(cells)\n        else:\n            x = start\n            for cell in cells:\n                self.set_cell(x, cell, clone=clone)\n                if cell:\n                    x += cell.repeated or 1\n                else:\n                    x += 1\n\n    def set_values(\n        self,\n        values: list[Any],\n        start: int | str = 0,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the value of cells in the row, from the 'start'\n        column vith values.\n        This method does not clear the row, use row.clear() before to start\n        with an empty row.\n\n        Arguments:\n\n            values -- list of Python types\n\n            start -- int or str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency' or 'percentage'\n\n            currency -- three-letter str\n\n            style -- cell style\n        \"\"\"\n        # fixme : if values n, n+ are same, use repeat\n        if start is None:\n            start = 0\n        else:\n            start = self._translate_x_from_any(start)\n        if start == 0 and (len(values) &gt;= self.width):\n            self.clear()\n            cells = [\n                Cell(value, style=style, cell_type=cell_type, currency=currency)\n                for value in values\n            ]\n            self.extend_cells(cells)\n        else:\n            x = start\n            for value in values:\n                self.set_cell(\n                    x,\n                    Cell(value, style=style, cell_type=cell_type, currency=currency),\n                    clone=False,\n                )\n                x += 1\n\n    def rstrip(self, aggressive: bool = False) -&gt; None:\n        \"\"\"Remove *in-place* empty cells at the right of the row. An empty\n        cell has no value but can have style. If \"aggressive\" is True, style\n        is ignored.\n\n        Arguments:\n\n            aggressive -- bool\n        \"\"\"\n        for cell in reversed(self._get_cells()):\n            if not cell.is_empty(aggressive=aggressive):  # type: ignore\n                break\n            self.delete(cell)\n        self._compute_row_cache()\n        self._indexes[\"_rmap\"] = {}\n\n    def _current_length(self) -&gt; int:\n        \"\"\"Return the current estimated length of the row.\n\n        Return: int\n        \"\"\"\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_cell, \"table:number-columns-repeated\"\n        )\n        repeated = [item[1] for item in idx_repeated_seq]\n        if repeated:\n            return sum(repeated)\n        return 1\n\n    def minimized_width(self) -&gt; int:\n        \"\"\"Return the length of the row if the last repeated sequence is\n        reduced to one.\n\n        Return: int\n        \"\"\"\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_cell, \"table:number-columns-repeated\"\n        )\n        repeated = [item[1] for item in idx_repeated_seq]\n        if repeated:\n            cell = self.last_cell()\n            if cell is not None and cell.is_empty(aggressive=True):\n                repeated[-1] = 1\n            min_width = sum(repeated)\n        else:\n            min_width = 1\n        self._compute_row_cache()\n        self._indexes[\"_rmap\"] = {}\n        return min_width\n\n    def last_cell(self) -&gt; Cell | None:\n        \"\"\"Return the las cell of the row.\n\n        Return Cell | None\n        \"\"\"\n        try:\n            return self._get_cells()[-1]  # type: ignore\n        except IndexError:\n            return None\n\n    def force_width(self, width: int) -&gt; None:\n        \"\"\"Change the repeated property of the last cell of the row\n        to comply with the required max width.\n\n        Arguments:\n\n            width -- int\n        \"\"\"\n        cell = self.last_cell()\n        if cell is None or not cell.is_empty(aggressive=True):\n            return\n        repeated = cell.repeated\n        if repeated is None:\n            return\n        # empty repeated cell\n        delta = self._current_length() - width\n        if delta &gt; 0:\n            cell._set_repeated(repeated - delta)\n            self._compute_row_cache()\n\n    def is_empty(self, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return whether every cell in the row has no value or the value\n        evaluates to False (empty string), and no style.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            aggressive -- bool\n\n        Return: bool\n        \"\"\"\n        return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Row.cells","title":"<code>cells</code>  <code>property</code>","text":"<p>Get the list of all cells.</p> <p>Return: list of Cell</p>"},{"location":"reference.html#odfdo.Row.repeated","title":"<code>repeated</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the number of times the row is repeated.</p> <p>Always None when using the table API.</p> <p>Return: int or None</p>"},{"location":"reference.html#odfdo.Row.style","title":"<code>style</code>  <code>property</code> <code>writable</code>","text":"<p>Get /set the style of the row itself.</p> <p>Return: str</p>"},{"location":"reference.html#odfdo.Row.width","title":"<code>width</code>  <code>property</code>","text":"<p>Get the number of expected cells in the row, i.e. addition repetitions.</p> <p>Return: int</p>"},{"location":"reference.html#odfdo.Row.__init__","title":"<code>__init__(width=None, repeated=None, style=None, **kwargs)</code>","text":"<p>create a Row, optionally filled with \u201cwidth\u201d number of cells.</p> <p>Rows contain cells, their number determine the number of columns.</p> <p>You don\u2019t generally have to create rows by hand, use the Table API.</p> <p>Arguments:</p> <pre><code>width -- int\n\nrepeated -- int\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def __init__(\n    self,\n    width: int | None = None,\n    repeated: int | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"create a Row, optionally filled with \"width\" number of cells.\n\n    Rows contain cells, their number determine the number of columns.\n\n    You don't generally have to create rows by hand, use the Table API.\n\n    Arguments:\n\n        width -- int\n\n        repeated -- int\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self.y = None\n    self._indexes = {}\n    self._indexes[\"_rmap\"] = {}\n    self._compute_row_cache()\n    self._tmap = []\n    self._cmap = []\n    if self._do_init:\n        if width is not None:\n            for _i in range(width):\n                self.append(Cell())  # type:ignore\n        if repeated:\n            self.repeated = repeated\n        if style is not None:\n            self.style = style\n        self._compute_row_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Row.append_cell","title":"<code>append_cell(cell=None, clone=True, _repeated=None)</code>","text":"<p>Append the given cell at the end of the row. Repeated cells are accepted. If no cell is given, an empty one is created.</p> <p>Do not use when working on a table, use Table.append_cell().</p> <p>Arguments:</p> <pre><code>cell -- Cell\n\n_repeated -- (optional), repeated value of the row\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/row.py</code> <pre><code>def append_cell(\n    self,\n    cell: Cell | None = None,\n    clone: bool = True,\n    _repeated: int | None = None,\n) -&gt; Cell:\n    \"\"\"Append the given cell at the end of the row. Repeated cells are\n    accepted. If no cell is given, an empty one is created.\n\n    Do not use when working on a table, use Table.append_cell().\n\n    Arguments:\n\n        cell -- Cell\n\n        _repeated -- (optional), repeated value of the row\n\n    returns the cell with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    if clone:\n        cell = cell.clone\n    self._append(cell)\n    if _repeated is None:\n        _repeated = cell.repeated or 1\n    self._rmap = insert_map_once(self._rmap, len(self._rmap), _repeated)\n    cell.x = self.width - 1\n    cell.y = self.y\n    return cell\n</code></pre>"},{"location":"reference.html#odfdo.Row.delete_cell","title":"<code>delete_cell(x)</code>","text":"<p>Delete the cell at the given position \u201cx\u201d starting from 0. Alphabetical positions like \u201cD\u201d are accepted.</p> <p>Cells on the right will be shifted to the left. In a table, other rows remain unaffected.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def delete_cell(self, x: int | str) -&gt; None:\n    \"\"\"Delete the cell at the given position \"x\" starting from 0.\n    Alphabetical positions like \"D\" are accepted.\n\n    Cells on the right will be shifted to the left. In a table, other\n    rows remain unaffected.\n\n    Arguments:\n\n        x -- int or str\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    if x &gt;= self.width:\n        return\n    delete_item_in_vault(x, self, _xpath_cell_idx, \"_rmap\")\n</code></pre>"},{"location":"reference.html#odfdo.Row.force_width","title":"<code>force_width(width)</code>","text":"<p>Change the repeated property of the last cell of the row to comply with the required max width.</p> <p>Arguments:</p> <pre><code>width -- int\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def force_width(self, width: int) -&gt; None:\n    \"\"\"Change the repeated property of the last cell of the row\n    to comply with the required max width.\n\n    Arguments:\n\n        width -- int\n    \"\"\"\n    cell = self.last_cell()\n    if cell is None or not cell.is_empty(aggressive=True):\n        return\n    repeated = cell.repeated\n    if repeated is None:\n        return\n    # empty repeated cell\n    delta = self._current_length() - width\n    if delta &gt; 0:\n        cell._set_repeated(repeated - delta)\n        self._compute_row_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_cell","title":"<code>get_cell(x, clone=True)</code>","text":"<p>Get the cell at position \u201cx\u201d starting from 0. Alphabetical positions like \u201cD\u201d are accepted.</p> <p>A  copy is returned, use set_cell() to push it back.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> <p>Return: Cell | None</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:\n    \"\"\"Get the cell at position \"x\" starting from 0. Alphabetical\n    positions like \"D\" are accepted.\n\n    A  copy is returned, use set_cell() to push it back.\n\n    Arguments:\n\n        x -- int or str\n\n    Return: Cell | None\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    cell = self._get_cell2(x, clone=clone)\n    if not cell:\n        return None  # pragma: no cover\n    cell.y = self.y\n    cell.x = x\n    return cell\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_cells","title":"<code>get_cells(coord=None, style=None, content=None, cell_type=None)</code>","text":"<p>Get the list of cells matching the criteria.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells.</p> <p>Filter by coordinates will retrieve the amount of cells defined by \u2018coord\u2019, minus the other filters.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncontent -- str regex\n\nstyle -- str\n</code></pre> <p>Return: list of Cell</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_cells(\n    self,\n    coord: str | tuple | None = None,\n    style: str | None = None,\n    content: str | None = None,\n    cell_type: str | None = None,\n) -&gt; list[Cell]:\n    \"\"\"Get the list of cells matching the criteria.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n\n    Filter by coordinates will retrieve the amount of cells defined by\n    'coord', minus the other filters.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        content -- str regex\n\n        style -- str\n\n    Return: list of Cell\n    \"\"\"\n    # fixme : not clones ?\n    if coord:\n        x, z = self._translate_row_coordinates(coord)\n    else:\n        x = None\n        z = None\n    if cell_type:\n        cell_type = cell_type.lower().strip()\n    cells: list[Cell] = []\n    for cell in self.traverse(start=x, end=z):\n        # Filter the cells by cell_type\n        if cell_type:\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                continue\n        # Filter the cells with the regex\n        if content and not cell.match(content):\n            continue\n        # Filter the cells with the style\n        if style and style != cell.style:\n            continue\n        cells.append(cell)\n    return cells\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_sub_elements","title":"<code>get_sub_elements()</code>","text":"<p>Shortcut to get the Elements inside cells in this row.</p> <p>Missing values are replaced by None. Cell type should be always \u2018string\u2019 when using this method, the length of the list is equal to the length of the row.</p> <p>Return: list of Elements.</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_sub_elements(\n    self,\n) -&gt; list[Any]:\n    \"\"\"Shortcut to get the Elements inside cells in this row.\n\n    Missing values are replaced by None. Cell type should be always\n    'string' when using this method, the length of the list is equal\n    to the length of the row.\n\n    Return: list of Elements.\n    \"\"\"\n    return [cell.children for cell in self.traverse()]\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_value","title":"<code>get_value(x, get_type=False)</code>","text":"<p>Shortcut to get the value of the cell at position \u201cx\u201d. If get_type is True, returns the tuples (value, ODF type).</p> <p>If the cell is empty, returns None or (None, None)</p> <p>See get_cell() and Cell.get_value().</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_value(\n    self,\n    x: int | str,\n    get_type: bool = False,\n) -&gt; Any | tuple[Any, str]:\n    \"\"\"Shortcut to get the value of the cell at position \"x\".\n    If get_type is True, returns the tuples (value, ODF type).\n\n    If the cell is empty, returns None or (None, None)\n\n    See get_cell() and Cell.get_value().\n    \"\"\"\n    if get_type:\n        x = self._translate_x_from_any(x)\n        cell = self._get_cell2_base(x)\n        if cell is None:\n            return (None, None)\n        return cell.get_value(get_type=get_type)\n    x = self._translate_x_from_any(x)\n    cell = self._get_cell2_base(x)\n    if cell is None:\n        return None\n    return cell.get_value()\n</code></pre>"},{"location":"reference.html#odfdo.Row.get_values","title":"<code>get_values(coord=None, cell_type=None, complete=False, get_type=False)</code>","text":"<p>Shortcut to get the cell values in this row.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells. If cell_type is used and complete is True, missing values are replaced by None. If cell_type is None, complete is always True : with no cell type queried, get_values() returns None for each empty cell, the length of the list is equal to the length of the row (depending on coordinates use).</p> <p>If get_type is True, returns a tuple (value, ODF type of value), or (None, None) for empty cells if complete is True.</p> <p>Filter by coordinates will retrieve the amount of cells defined by coordinates with None for empty cells, except when using cell_type.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates in row\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of Python types, or list of tuples.</p> Source code in <code>odfdo/row.py</code> <pre><code>def get_values(\n    self,\n    coord: str | tuple | None = None,\n    cell_type: str | None = None,\n    complete: bool = False,\n    get_type: bool = False,\n) -&gt; list[Any | tuple[Any, Any]]:\n    \"\"\"Shortcut to get the cell values in this row.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n    If cell_type is used and complete is True, missing values are\n    replaced by None.\n    If cell_type is None, complete is always True : with no cell type\n    queried, get_values() returns None for each empty cell, the length\n    of the list is equal to the length of the row (depending on\n    coordinates use).\n\n    If get_type is True, returns a tuple (value, ODF type of value), or\n    (None, None) for empty cells if complete is True.\n\n    Filter by coordinates will retrieve the amount of cells defined by\n    coordinates with None for empty cells, except when using cell_type.\n\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates in row\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of Python types, or list of tuples.\n    \"\"\"\n    if coord:\n        x, z = self._translate_row_coordinates(coord)\n    else:\n        x = None\n        z = None\n    if cell_type:\n        cell_type = cell_type.lower().strip()\n        values: list[Any | tuple[Any, Any]] = []\n        for cell in self.traverse(start=x, end=z):\n            # Filter the cells by cell_type\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                if complete:\n                    if get_type:\n                        values.append((None, None))\n                    else:\n                        values.append(None)\n                continue\n            values.append(cell.get_value(get_type=get_type))\n        return values\n    else:\n        return [\n            cell.get_value(get_type=get_type)\n            for cell in self.traverse(start=x, end=z)\n        ]\n</code></pre>"},{"location":"reference.html#odfdo.Row.insert_cell","title":"<code>insert_cell(x, cell=None, clone=True)</code>","text":"<p>Insert the given cell at position \u201cx\u201d starting from 0. If no cell is given, an empty one is created.</p> <p>Alphabetical positions like \u201cD\u201d are accepted.</p> <p>Do not use when working on a table, use Table.insert_cell().</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncell -- Cell\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/row.py</code> <pre><code>def insert_cell(\n    self,\n    x: int | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Insert the given cell at position \"x\" starting from 0. If no cell\n    is given, an empty one is created.\n\n    Alphabetical positions like \"D\" are accepted.\n\n    Do not use when working on a table, use Table.insert_cell().\n\n    Arguments:\n\n        x -- int or str\n\n        cell -- Cell\n\n    returns the cell with x and y updated\n    \"\"\"\n    cell_back: Cell\n    if cell is None:\n        cell = Cell()\n    x = self._translate_x_from_any(x)\n    # Outside the defined row\n    diff = x - self.width\n    if diff &lt; 0:\n        insert_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\")\n        cell.x = x\n        cell.y = self.y\n        cell_back = cell\n    elif diff == 0:\n        cell_back = self.append_cell(cell, clone=clone)\n    else:\n        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n        cell_back = self.append_cell(cell, clone=clone)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Row.is_empty","title":"<code>is_empty(aggressive=False)</code>","text":"<p>Return whether every cell in the row has no value or the value evaluates to False (empty string), and no style.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> <p>Return: bool</p> Source code in <code>odfdo/row.py</code> <pre><code>def is_empty(self, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return whether every cell in the row has no value or the value\n    evaluates to False (empty string), and no style.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        aggressive -- bool\n\n    Return: bool\n    \"\"\"\n    return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Row.last_cell","title":"<code>last_cell()</code>","text":"<p>Return the las cell of the row.</p> <p>Return Cell | None</p> Source code in <code>odfdo/row.py</code> <pre><code>def last_cell(self) -&gt; Cell | None:\n    \"\"\"Return the las cell of the row.\n\n    Return Cell | None\n    \"\"\"\n    try:\n        return self._get_cells()[-1]  # type: ignore\n    except IndexError:\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Row.minimized_width","title":"<code>minimized_width()</code>","text":"<p>Return the length of the row if the last repeated sequence is reduced to one.</p> <p>Return: int</p> Source code in <code>odfdo/row.py</code> <pre><code>def minimized_width(self) -&gt; int:\n    \"\"\"Return the length of the row if the last repeated sequence is\n    reduced to one.\n\n    Return: int\n    \"\"\"\n    idx_repeated_seq = self.elements_repeated_sequence(\n        _xpath_cell, \"table:number-columns-repeated\"\n    )\n    repeated = [item[1] for item in idx_repeated_seq]\n    if repeated:\n        cell = self.last_cell()\n        if cell is not None and cell.is_empty(aggressive=True):\n            repeated[-1] = 1\n        min_width = sum(repeated)\n    else:\n        min_width = 1\n    self._compute_row_cache()\n    self._indexes[\"_rmap\"] = {}\n    return min_width\n</code></pre>"},{"location":"reference.html#odfdo.Row.rstrip","title":"<code>rstrip(aggressive=False)</code>","text":"<p>Remove in-place empty cells at the right of the row. An empty cell has no value but can have style. If \u201caggressive\u201d is True, style is ignored.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def rstrip(self, aggressive: bool = False) -&gt; None:\n    \"\"\"Remove *in-place* empty cells at the right of the row. An empty\n    cell has no value but can have style. If \"aggressive\" is True, style\n    is ignored.\n\n    Arguments:\n\n        aggressive -- bool\n    \"\"\"\n    for cell in reversed(self._get_cells()):\n        if not cell.is_empty(aggressive=aggressive):  # type: ignore\n            break\n        self.delete(cell)\n    self._compute_row_cache()\n    self._indexes[\"_rmap\"] = {}\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_cell","title":"<code>set_cell(x, cell=None, clone=True)</code>","text":"<p>Push the cell back in the row at position \u201cx\u201d starting from 0. Alphabetical positions like \u201cD\u201d are accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/row.py</code> <pre><code>def set_cell(\n    self,\n    x: int | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Push the cell back in the row at position \"x\" starting from 0.\n    Alphabetical positions like \"D\" are accepted.\n\n    Arguments:\n\n        x -- int or str\n\n    returns the cell with x and y updated\n    \"\"\"\n    cell_back: Cell\n    if cell is None:\n        cell = Cell()\n        repeated = 1\n        clone = False\n    else:\n        repeated = cell.repeated or 1\n    x = self._translate_x_from_any(x)\n    # Outside the defined row\n    diff = x - self.width\n    if diff == 0:\n        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n    elif diff &gt; 0:\n        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)\n        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)\n    else:\n        # Inside the defined row\n        set_item_in_vault(x, cell, self, _xpath_cell_idx, \"_rmap\", clone=clone)\n        cell.x = x\n        cell.y = self.y\n        cell_back = cell\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_cells","title":"<code>set_cells(cells=None, start=0, clone=True)</code>","text":"<p>Set the cells in the row, from the \u2018start\u2019 column. This method does not clear the row, use row.clear() before to start with an empty row.</p> <p>Arguments:</p> <pre><code>cells -- list of cells\n\nstart -- int or str\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def set_cells(\n    self,\n    cells: list[Cell] | tuple[Cell] | None = None,\n    start: int | str = 0,\n    clone: bool = True,\n) -&gt; None:\n    \"\"\"Set the cells in the row, from the 'start' column.\n    This method does not clear the row, use row.clear() before to start\n    with an empty row.\n\n    Arguments:\n\n        cells -- list of cells\n\n        start -- int or str\n    \"\"\"\n    if cells is None:\n        cells = []\n    if start is None:\n        start = 0\n    else:\n        start = self._translate_x_from_any(start)\n    if start == 0 and clone is False and (len(cells) &gt;= self.width):\n        self.clear()\n        self.extend_cells(cells)\n    else:\n        x = start\n        for cell in cells:\n            self.set_cell(x, cell, clone=clone)\n            if cell:\n                x += cell.repeated or 1\n            else:\n                x += 1\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_value","title":"<code>set_value(x, value, style=None, cell_type=None, currency=None)</code>","text":"<p>Shortcut to set the value of the cell at position \u201cx\u201d.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\nvalue -- Python type\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n         'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> <p>See get_cell() and Cell.get_value().</p> Source code in <code>odfdo/row.py</code> <pre><code>def set_value(\n    self,\n    x: int | str,\n    value: Any,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the value of the cell at position \"x\".\n\n    Arguments:\n\n        x -- int or str\n\n        value -- Python type\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                 'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n\n    See get_cell() and Cell.get_value().\n    \"\"\"\n    self.set_cell(\n        x,\n        Cell(value, style=style, cell_type=cell_type, currency=currency),\n        clone=False,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Row.set_values","title":"<code>set_values(values, start=0, style=None, cell_type=None, currency=None)</code>","text":"<p>Shortcut to set the value of cells in the row, from the \u2018start\u2019 column vith values. This method does not clear the row, use row.clear() before to start with an empty row.</p> <p>Arguments:</p> <pre><code>values -- list of Python types\n\nstart -- int or str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency' or 'percentage'\n\ncurrency -- three-letter str\n\nstyle -- cell style\n</code></pre> Source code in <code>odfdo/row.py</code> <pre><code>def set_values(\n    self,\n    values: list[Any],\n    start: int | str = 0,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the value of cells in the row, from the 'start'\n    column vith values.\n    This method does not clear the row, use row.clear() before to start\n    with an empty row.\n\n    Arguments:\n\n        values -- list of Python types\n\n        start -- int or str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency' or 'percentage'\n\n        currency -- three-letter str\n\n        style -- cell style\n    \"\"\"\n    # fixme : if values n, n+ are same, use repeat\n    if start is None:\n        start = 0\n    else:\n        start = self._translate_x_from_any(start)\n    if start == 0 and (len(values) &gt;= self.width):\n        self.clear()\n        cells = [\n            Cell(value, style=style, cell_type=cell_type, currency=currency)\n            for value in values\n        ]\n        self.extend_cells(cells)\n    else:\n        x = start\n        for value in values:\n            self.set_cell(\n                x,\n                Cell(value, style=style, cell_type=cell_type, currency=currency),\n                clone=False,\n            )\n            x += 1\n</code></pre>"},{"location":"reference.html#odfdo.Row.traverse","title":"<code>traverse(start=None, end=None)</code>","text":"<p>Yield as many cell elements as expected cells in the row, i.e. expand repetitions by returning the same cell as many times as necessary.</p> <pre><code>Arguments:\n\n    start -- int\n\n    end -- int\n</code></pre> <p>Copies are returned, use set_cell() to push them back.</p> Source code in <code>odfdo/row.py</code> <pre><code>def traverse(\n    self,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; Iterator[Cell]:\n    \"\"\"Yield as many cell elements as expected cells in the row, i.e.\n    expand repetitions by returning the same cell as many times as\n    necessary.\n\n        Arguments:\n\n            start -- int\n\n            end -- int\n\n    Copies are returned, use set_cell() to push them back.\n    \"\"\"\n    idx = -1\n    before = -1\n    x = 0\n    cell: Cell\n    if start is None and end is None:\n        for juska in self._rmap:\n            idx += 1\n            if idx in self._indexes[\"_rmap\"]:\n                cell = self._indexes[\"_rmap\"][idx]\n            else:\n                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                if not isinstance(cell, Cell):\n                    raise TypeError(f\"Not a cell: {cell!r}\")  # pragma: no cover\n                self._indexes[\"_rmap\"][idx] = cell\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                # Return a copy without the now obsolete repetition\n                if cell is None:\n                    cell = Cell()  # pragma: no cover\n                else:\n                    cell = cell.clone\n                    if repeated &gt; 1:\n                        cell.repeated = None\n                cell.y = self.y\n                cell.x = x\n                x += 1\n                yield cell\n    else:\n        if start is None:\n            start = 0\n        start = max(0, start)\n        if end is None:\n            try:\n                end = self._rmap[-1]\n            except Exception:  # pragma: no cover\n                end = -1\n        start_map = find_odf_idx(self._rmap, start)\n        if start_map is None:\n            return\n        if start_map &gt; 0:\n            before = self._rmap[start_map - 1]\n        idx = start_map - 1\n        before = start - 1\n        x = start\n        for juska in self._rmap[start_map:]:\n            idx += 1\n            if idx in self._indexes[\"_rmap\"]:\n                cell = self._indexes[\"_rmap\"][idx]\n            else:\n                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore\n                if not isinstance(cell, Cell):\n                    raise TypeError(f\"Not a cell: {cell!r}\")  # pragma: no cover\n                self._indexes[\"_rmap\"][idx] = cell\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                if x &lt;= end:\n                    if cell is None:\n                        cell = Cell()  # pragma: no cover\n                    else:\n                        cell = cell.clone\n                        if repeated &gt; 1 or (x == start and start &gt; 0):\n                            cell.repeated = None\n                    cell.y = self.y\n                    cell.x = x\n                    x += 1\n                    yield cell\n</code></pre>"},{"location":"reference.html#odfdo.RowGroup","title":"<code>RowGroup</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF row group \u201ctable:table-row-group\u201d with common properties.</p> <p>Partial implementation.</p> <p>The  element groups adjacent table rows. Every row group can contain header rows, and nested row groups. A row group can be visible or hidden. Source code in <code>odfdo/row_group.py</code> <pre><code>class RowGroup(Element):\n    \"\"\"ODF row group \"table:table-row-group\" with common properties.\n\n    Partial implementation.\n\n    The &lt;table:table-row-group&gt; element groups adjacent table rows.\n    Every row group can contain header rows, and nested row groups.\n    A row group can be visible or hidden.\"\"\"\n\n    # TODO\n    _tag = \"table:table-row-group\"\n\n    def __init__(\n        self,\n        height: int | None = None,\n        width: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a group of rows, optionnaly filled with \"height\" number of\n        rows, of \"width\" cells each.\n\n        Row group bear style information applied to a series of rows.\n\n        Arguments:\n\n            height -- int\n\n            width -- int\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init and height is not None:\n            for _i in range(height):\n                row = Row(width=width)\n                self.append(row)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt;\"\n</code></pre>"},{"location":"reference.html#odfdo.RowGroup.__init__","title":"<code>__init__(height=None, width=None, **kwargs)</code>","text":"<p>Create a group of rows, optionnaly filled with \u201cheight\u201d number of rows, of \u201cwidth\u201d cells each.</p> <p>Row group bear style information applied to a series of rows.</p> <p>Arguments:</p> <pre><code>height -- int\n\nwidth -- int\n</code></pre> Source code in <code>odfdo/row_group.py</code> <pre><code>def __init__(\n    self,\n    height: int | None = None,\n    width: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a group of rows, optionnaly filled with \"height\" number of\n    rows, of \"width\" cells each.\n\n    Row group bear style information applied to a series of rows.\n\n    Arguments:\n\n        height -- int\n\n        width -- int\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init and height is not None:\n        for _i in range(height):\n            row = Row(width=width)\n            self.append(row)\n</code></pre>"},{"location":"reference.html#odfdo.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF section \u201ctext:section\u201d</p> <p>Arguments:</p> <pre><code>style -- str\n\nname -- str\n</code></pre> Source code in <code>odfdo/section.py</code> <pre><code>class Section(Element):\n    \"\"\"ODF section \"text:section\"\n\n    Arguments:\n\n        style -- str\n\n        name -- str\n    \"\"\"\n\n    _tag = \"text:section\"\n    _properties = (\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"name\", \"text:name\"),\n    )\n\n    def __init__(\n        self,\n        style: str | None = None,\n        name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style:\n                self.style = style\n            if name:\n                self.name = name\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        result = [element.get_formatted_text(context) for element in self.children]\n        result.append(\"\\n\")\n        return \"\".join(result)\n</code></pre>"},{"location":"reference.html#odfdo.Spacer","title":"<code>Spacer</code>","text":"<p>               Bases: <code>MDSpacer</code>, <code>Element</code></p> <p>This element shall be used to represent the second and all following \u201c \u201c (U+0020, SPACE) characters in a sequence of \u201c \u201c (U+0020, SPACE) characters. Note: It is not an error if the character preceding the element is not a white space character, but it is good practice to use this element only for the second and all following SPACE characters in a sequence.</p> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>class Spacer(MDSpacer, Element):\n    \"\"\"This element shall be used to represent the second and all following \u201c \u201c\n    (U+0020, SPACE) characters in a sequence of \u201c \u201c (U+0020, SPACE) characters.\n    Note: It is not an error if the character preceding the element is not a\n    white space character, but it is good practice to use this element only for\n    the second and all following SPACE characters in a sequence.\n    \"\"\"\n\n    _tag = \"text:s\"\n    _properties: tuple[PropDef, ...] = (PropDef(\"number\", \"text:c\"),)\n\n    def __init__(self, number: int | None = 1, **kwargs: Any):\n        \"\"\"\n        Arguments:\n\n            number -- int\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if number and number &gt;= 2:\n                self.number = str(number)\n            else:\n                self.number = None\n\n    def __str__(self) -&gt; str:\n        return self.text\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"Get / set the text content of the element.\"\"\"\n        return \" \" * self.length\n\n    @text.setter\n    def text(self, text: str | None) -&gt; None:\n        if text is None:\n            text = \"\"\n        self.length = len(text)\n\n    @property\n    def length(self) -&gt; int:\n        name = _get_lxml_tag(\"text:c\")\n        value = self._Element__element.get(name)\n        if value is None:\n            return 1  # minimum 1 space\n        return int(value)\n\n    @length.setter\n    def length(self, value: int | None) -&gt; None:\n        name = _get_lxml_tag(\"text:c\")\n        if value is None or value &lt; 2:\n            with contextlib.suppress(KeyError):\n                del self._Element__element.attrib[name]\n            return\n        self._Element__element.set(name, str(value))\n</code></pre>"},{"location":"reference.html#odfdo.Spacer.text","title":"<code>text</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the text content of the element.</p>"},{"location":"reference.html#odfdo.Spacer.__init__","title":"<code>__init__(number=1, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>number -- int\n</code></pre> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>def __init__(self, number: int | None = 1, **kwargs: Any):\n    \"\"\"\n    Arguments:\n\n        number -- int\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if number and number &gt;= 2:\n            self.number = str(number)\n        else:\n            self.number = None\n</code></pre>"},{"location":"reference.html#odfdo.Span","title":"<code>Span</code>","text":"<p>               Bases: <code>MDSpan</code>, <code>Paragraph</code></p> <p>Specialised paragraph for span \u201ctext:span\u201d.</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>class Span(MDSpan, Paragraph):\n    \"\"\"Specialised paragraph for span \"text:span\".\"\"\"\n\n    _tag = \"text:span\"\n    _properties = (\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"class_names\", \"text:class-names\"),\n    )\n\n    def __init__(\n        self,\n        text: str | None = None,\n        style: str | None = None,\n        formatted: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a span element \"text:span\" of the given style containing the optional\n        given text.\n\n        If \"formatted\" is True (the default), the given text is appended with &lt;CR&gt;,\n        &lt;TAB&gt; and multiple spaces replaced by ODF corresponding tags.\n\n        Arguments:\n\n            text -- str\n\n            style -- str\n\n            formatted -- bool\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if text:\n                if formatted:\n                    self.text = \"\"\n                    self.append_plain_text(text)  # type:ignore\n                else:\n                    self.text = self._unformatted(text)  # type:ignore\n            if style:\n                self.style = style\n\n    def __str__(self) -&gt; str:\n        return self.inner_text\n</code></pre>"},{"location":"reference.html#odfdo.Span.__init__","title":"<code>__init__(text=None, style=None, formatted=True, **kwargs)</code>","text":"<p>Create a span element \u201ctext:span\u201d of the given style containing the optional given text.</p> <p>If \u201cformatted\u201d is True (the default), the given text is appended with ,  and multiple spaces replaced by ODF corresponding tags. <p>Arguments:</p> <pre><code>text -- str\n\nstyle -- str\n\nformatted -- bool\n</code></pre> Source code in <code>odfdo/paragraph.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    style: str | None = None,\n    formatted: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a span element \"text:span\" of the given style containing the optional\n    given text.\n\n    If \"formatted\" is True (the default), the given text is appended with &lt;CR&gt;,\n    &lt;TAB&gt; and multiple spaces replaced by ODF corresponding tags.\n\n    Arguments:\n\n        text -- str\n\n        style -- str\n\n        formatted -- bool\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if text:\n            if formatted:\n                self.text = \"\"\n                self.append_plain_text(text)  # type:ignore\n            else:\n                self.text = self._unformatted(text)  # type:ignore\n        if style:\n            self.style = style\n</code></pre>"},{"location":"reference.html#odfdo.Spreadsheet","title":"<code>Spreadsheet</code>","text":"<p>               Bases: <code>Body</code></p> <p>Spreadsheet, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Spreadsheet(Body):\n    \"\"\"Spreadsheet, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:spreadsheet\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>Element</code></p> <p>Style class for all these tags:</p> <p>\u2018style:style\u2019 \u2018number:date-style\u2019, \u2018number:number-style\u2019, \u2018number:percentage-style\u2019, \u2018number:time-style\u2019 \u2018style:font-face\u2019, \u2018style:master-page\u2019, \u2018style:page-layout\u2019, \u2018style:presentation-page-layout\u2019, \u2018text:list-style\u2019, \u2018text:outline-style\u2019, \u2018style:tab-stops\u2019, \u2026</p> Source code in <code>odfdo/style.py</code> <pre><code>class Style(Element):\n    \"\"\"Style class for all these tags:\n\n    'style:style'\n    'number:date-style',\n    'number:number-style',\n    'number:percentage-style',\n    'number:time-style'\n    'style:font-face',\n    'style:master-page',\n    'style:page-layout',\n    'style:presentation-page-layout',\n    'text:list-style',\n    'text:outline-style',\n    'style:tab-stops',\n    ...\n    \"\"\"\n\n    _properties: tuple[PropDef, ...] = (\n        PropDef(\"page_layout\", \"style:page-layout-name\", \"master-page\"),\n        PropDef(\"next_style\", \"style:next-style-name\", \"master-page\"),\n        PropDef(\"name\", \"style:name\"),\n        PropDef(\"parent_style\", \"style:parent-style-name\"),\n        PropDef(\"display_name\", \"style:display-name\"),\n        PropDef(\"svg_font_family\", \"svg:font-family\"),\n        PropDef(\"font_family_generic\", \"style:font-family-generic\"),\n        PropDef(\"font_pitch\", \"style:font-pitch\"),\n        PropDef(\"text_style\", \"text:style-name\"),\n        PropDef(\"master_page\", \"style:master-page-name\", \"paragraph\"),\n        PropDef(\"master_page\", \"style:master-page-name\", \"paragraph\"),\n        PropDef(\"master_page\", \"style:master-page-name\", \"paragraph\"),\n        # style:tab-stop\n        PropDef(\"style_type\", \"style:type\"),\n        PropDef(\"leader_style\", \"style:leader-style\"),\n        PropDef(\"leader_text\", \"style:leader-text\"),\n        PropDef(\"style_position\", \"style:position\"),\n        PropDef(\"leader_text\", \"style:position\"),\n        PropDef(\"list_style_name\", \"style:list-style-name\"),\n        PropDef(\"style_num_format\", \"style:num-format\"),\n    )\n\n    def __init__(\n        self,\n        family: str | None = None,\n        name: str | None = None,\n        display_name: str | None = None,\n        parent_style: str | None = None,\n        # Where properties apply\n        area: str | None = None,\n        # For family 'text':\n        color: str | tuple | None = None,\n        background_color: str | tuple | None = None,\n        italic: bool = False,\n        bold: bool = False,\n        # For family 'paragraph'\n        master_page: str | None = None,\n        # For family 'master-page'\n        page_layout: str | None = None,\n        next_style: str | None = None,\n        # For family 'table-cell'\n        data_style: str | None = None,  # unused\n        border: str | None = None,\n        border_top: str | None = None,\n        border_right: str | None = None,\n        border_bottom: str | None = None,\n        border_left: str | None = None,\n        padding: str | None = None,\n        padding_top: str | None = None,\n        padding_bottom: str | None = None,\n        padding_left: str | None = None,\n        padding_right: str | None = None,\n        shadow: str | None = None,\n        # For family 'table-row'\n        height: str | None = None,\n        use_optimal_height: bool = False,\n        # For family 'table-column'\n        break_before: str | None = None,\n        break_after: str | None = None,\n        # for family 'table'\n        align: str | None = None,\n        # For family 'table-column' or 'table'\n        width: str | None = None,\n        # For family 'graphic'\n        min_height: str | None = None,\n        # For family 'font-face'\n        font_name: str | None = None,\n        font_family: str | None = None,\n        font_family_generic: str | None = None,\n        font_pitch: str = \"variable\",\n        # Every other property\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a style of the given family. The name is not mandatory at this\n        point but will become required when inserting in a document as a common\n        style.\n\n        The display name is the name the user sees in an office application.\n\n        The parent_style is the name of the style this style will inherit from.\n\n        To set properties, pass them as keyword arguments. The area properties\n        apply to is optional and defaults to the family.\n\n        Arguments:\n\n            family -- 'paragraph', 'text', 'section', 'table', 'table-column',\n                      'table-row', 'table-cell', 'table-page', 'chart',\n                      'drawing-page', 'graphic', 'presentation',\n                      'control', 'ruby', 'list', 'number', 'page-layout'\n                      'font-face', or 'master-page'\n\n            name -- str\n\n            display_name -- str\n\n            parent_style -- str\n\n            area -- str\n\n        'text' Properties:\n\n            italic -- bool\n\n            bold -- bool\n\n        'paragraph' Properties:\n\n            master_page -- str\n\n        'master-page' Properties:\n\n            page_layout -- str\n\n            next_style -- str\n\n        'table-cell' Properties:\n\n            border, border_top, border_right, border_bottom, border_left -- str,\n            e.g. \"0.002cm solid #000000\" or 'none'\n\n            padding, padding_top, padding_right, padding_bottom, padding_left -- str,\n            e.g. \"0.002cm\" or 'none'\n\n            shadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\n        'table-row' Properties:\n\n            height -- str, e.g. '5cm'\n\n            use_optimal_height -- bool\n\n        'table-column' Properties:\n\n            width -- str, e.g. '5cm'\n\n            break_before -- 'page', 'column' or 'auto'\n\n            break_after -- 'page', 'column' or 'auto'\n\n        'table' Properties:\n\n            width -- str, e.g. '5cm'\n\n            align -- 'left', 'center', 'margins' or 'right'\n        \"\"\"\n        self._family: str | None = None\n        tag_or_elem = kwargs.get(\"tag_or_elem\")\n        if tag_or_elem is None:\n            family = to_str(family)\n            if family not in FAMILY_MAPPING:\n                raise ValueError(f\"Unknown family value: '{family}'\")\n            kwargs[\"tag\"] = FAMILY_MAPPING[family]\n        super().__init__(**kwargs)\n        if self._do_init and family not in SUBCLASSED_STYLES:\n            kwargs.pop(\"tag\", None)\n            kwargs.pop(\"tag_or_elem\", None)\n            self.family = family  # relevant test made by property\n            # Common attributes\n            if name:\n                self.name = name\n            if display_name:\n                self.display_name = display_name\n            if parent_style:\n                self.parent_style = parent_style\n            # Paragraph\n            if family == \"paragraph\":\n                if master_page:\n                    self.master_page = master_page\n            # Master Page\n            elif family == \"master-page\":\n                if page_layout:\n                    self.page_layout = page_layout\n                if next_style:\n                    self.next_style = next_style\n            # Font face\n            elif family == \"font-face\":\n                if not font_name:\n                    raise ValueError(\"A font_name is required for 'font-face' style\")\n                self.set_font(\n                    font_name,\n                    family=font_family,\n                    family_generic=font_family_generic,\n                    pitch=font_pitch,\n                )\n            # Properties\n            if area is None:\n                area = family\n            area = to_str(area)\n            # Text\n            if area == \"text\":\n                if color:\n                    kwargs[\"fo:color\"] = color\n                if background_color:\n                    kwargs[\"fo:background-color\"] = background_color\n                if italic:\n                    kwargs[\"fo:font-style\"] = \"italic\"\n                    kwargs[\"style:font-style-asian\"] = \"italic\"\n                    kwargs[\"style:font-style-complex\"] = \"italic\"\n                if bold:\n                    kwargs[\"fo:font-weight\"] = \"bold\"\n                    kwargs[\"style:font-weight-asian\"] = \"bold\"\n                    kwargs[\"style:font-weight-complex\"] = \"bold\"\n            # Table cell\n            elif area == \"table-cell\":\n                if border:\n                    kwargs[\"fo:border\"] = border\n                elif border_top or border_right or border_bottom or border_left:\n                    kwargs[\"fo:border-top\"] = border_top or \"none\"\n                    kwargs[\"fo:border-right\"] = border_right or \"none\"\n                    kwargs[\"fo:border-bottom\"] = border_bottom or \"none\"\n                    kwargs[\"fo:border-left\"] = border_left or \"none\"\n                else:  # no border_top, ... neither border are defined\n                    pass  # left untouched\n                if padding:\n                    kwargs[\"fo:padding\"] = padding\n                elif padding_top or padding_right or padding_bottom or padding_left:\n                    kwargs[\"fo:padding-top\"] = padding_top or \"none\"\n                    kwargs[\"fo:padding-right\"] = padding_right or \"none\"\n                    kwargs[\"fo:padding-bottom\"] = padding_bottom or \"none\"\n                    kwargs[\"fo:padding-left\"] = padding_left or \"none\"\n                else:  # no border_top, ... neither border are defined\n                    pass  # left untouched\n                if shadow:\n                    kwargs[\"style:shadow\"] = shadow\n                if background_color:\n                    kwargs[\"fo:background-color\"] = background_color\n            # Table row\n            elif area == \"table-row\":\n                if height:\n                    kwargs[\"style:row-height\"] = height\n                if use_optimal_height:\n                    kwargs[\"style:use-optimal-row-height\"] = Boolean.encode(\n                        use_optimal_height\n                    )\n                if background_color:\n                    kwargs[\"fo:background-color\"] = background_color\n            # Table column\n            elif area == \"table-column\":\n                if width:\n                    kwargs[\"style:column-width\"] = width\n                if break_before:\n                    kwargs[\"fo:break-before\"] = break_before\n                if break_after:\n                    kwargs[\"fo:break-after\"] = break_after\n            # Table\n            elif area == \"table\":\n                if width:\n                    kwargs[\"style:width\"] = width\n                if align:\n                    if align not in {\"center\", \"left\", \"margins\", \"right\"}:\n                        raise ValueError(f\"Invalid align value: {align!r}\")\n                    kwargs[\"table:align\"] = align\n            # Graphic\n            elif area == \"graphic\":\n                if min_height:\n                    kwargs[\"fo:min-height\"] = min_height\n            # Every other properties\n            if kwargs:\n                self.set_properties(kwargs, area=area)\n\n    @property\n    def family(self) -&gt; str | None:\n        if self._family is None:\n            self._family = FALSE_FAMILY_MAP_REVERSE.get(\n                self.tag, self.get_attribute_string(\"style:family\")\n            )\n        return self._family\n\n    @family.setter\n    def family(self, family: str | None) -&gt; None:\n        self._family = family\n        if family in FAMILY_ODF_STD and self.tag == \"style:style\":\n            self.set_attribute(\"style:family\", family)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Style family={self.family} name={self.name}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return repr(self)\n\n    def get_properties(self, area: str | None = None) -&gt; dict[str, str | dict] | None:\n        \"\"\"Get the mapping of all properties of this style. By default the\n        properties of the same family, e.g. a paragraph style and its\n        paragraph properties. Specify the area to get the text properties of\n        a paragraph style for example.\n\n        Arguments:\n\n            area -- str\n\n        Return: dict\n        \"\"\"\n        if area is None:\n            area = self.family\n        element = self.get_element(f\"style:{area}-properties\")\n        if element is None:\n            return None\n        properties: dict[str, str | dict] = element.attributes  # type: ignore\n        # Nested properties are nested dictionaries\n        for child in element.children:\n            properties[child.tag] = child.attributes\n        return properties\n\n    @staticmethod\n    def _update_boolean_styles(props: dict[str, str | bool]) -&gt; None:\n        strike = props.get(\"style:text-line-through-style\", \"\")\n        if strike == \"none\":\n            strike = \"\"\n        underline = props.get(\"style:text-underline-style\", \"\")\n        if underline == \"none\":\n            underline = \"\"\n        props.update(\n            {\n                \"color\": props.get(\"fo:color\") or \"\",\n                \"background_color\": props.get(\"fo:background-color\") or \"\",\n                \"italic\": props.get(\"fo:font-style\", \"\") == \"italic\",\n                \"bold\": props.get(\"fo:font-weight\", \"\") == \"bold\",\n                \"fixed\": props.get(\"style:font-pitch\", \"\") == \"fixed\",\n                \"underline\": bool(underline),\n                \"strike\": bool(strike),\n            }\n        )\n\n    def get_list_style_properties(self) -&gt; dict[str, str | bool]:\n        \"\"\"Get text properties of style as a dict, with some enhanced values.\n\n        Enhanced values returned:\n         - \"color\": str\n         - \"background_color\": str\n         - \"italic\": bool\n         - \"bold\": bool\n         - \"fixed\": bool\n         - \"underline\": bool\n         - \"strike\": bool\n\n        Return: dict[str, str | bool]\n        \"\"\"\n        return self.get_text_properties()\n\n    def get_text_properties(self) -&gt; dict[str, str | bool]:\n        \"\"\"Get text properties of style as a dict, with some enhanced values.\n\n        Enhanced values returned:\n         - \"color\": str\n         - \"background_color\": str\n         - \"italic\": bool\n         - \"bold\": bool\n         - \"fixed\": bool\n         - \"underline\": bool\n         - \"strike\": bool\n\n        Return: dict[str, str | bool]\n        \"\"\"\n        props: dict[str, str | bool] = self.get_properties(area=\"text\") or {}\n        self._update_boolean_styles(props)\n        return props\n\n    def set_properties(\n        self,\n        properties: dict[str, str | dict] | None = None,\n        style: Style | None = None,\n        area: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Set the properties of the \"area\" type of this style. Properties\n        are given either as a dict or as named arguments (or both). The area\n        is identical to the style family by default. If the properties\n        element is missing, it is created.\n\n        Instead of properties, you can pass a style with properties of the\n        same area. These will be copied.\n\n        Arguments:\n\n            properties -- dict\n\n            style -- Style\n\n            area -- 'paragraph', 'text'...\n        \"\"\"\n        if properties is None:\n            properties = {}\n        if area is None:\n            if isinstance(self.family, bool):\n                area = None\n            else:\n                area = self.family\n        element = self.get_element(f\"style:{area}-properties\")\n        if element is None:\n            element = Element.from_tag(f\"style:{area}-properties\")\n            self.append(element)\n        if properties or kwargs:\n            properties = _expand_properties_dict(_merge_dicts(properties, kwargs))\n        elif style is not None:\n            properties = style.get_properties(area=area)\n            if properties is None:\n                return\n        if properties is None:\n            return\n        for key, value in properties.items():\n            if value is None:\n                element.del_attribute(key)\n            elif isinstance(value, (str, bool, tuple)):\n                element.set_attribute(key, value)\n\n    def del_properties(\n        self,\n        properties: list[str] | None = None,\n        area: str | None = None,\n    ) -&gt; None:\n        \"\"\"Delete the given properties, either by list argument or\n        positional argument (or both). Remove only from the given area,\n        identical to the style family by default.\n\n        Arguments:\n\n            properties -- list\n\n            area -- str\n        \"\"\"\n        if properties is None:\n            properties = []\n        if area is None:\n            area = self.family\n        element = self.get_element(f\"style:{area}-properties\")\n        if element is None:\n            raise ValueError(\n                f\"properties element is inexistent for: style:{area}-properties\"\n            )\n        for key in _expand_properties_list(properties):\n            element.del_attribute(key)\n\n    def set_background(\n        self,\n        color: str | None = None,\n        url: str | None = None,\n        position: str | None = \"center\",\n        repeat: str | None = None,\n        opacity: str | None = None,\n        filter: str | None = None,  # noqa: A002\n    ) -&gt; None:\n        \"\"\"Set the background color of a text style, or the background color\n        or image of a paragraph style or page layout.\n\n        With no argument, remove any existing background.\n\n        The position is one or two of 'center', 'left', 'right', 'top' or\n        'bottom'.\n\n        The repeat is 'no-repeat', 'repeat' or 'stretch'.\n\n        The opacity is a percentage integer (not a string with the '%s' sign)\n\n        The filter is an application-specific filter name defined elsewhere.\n\n        Though this method is defined on the base style class, it will raise\n        an error if the style type is not compatible.\n\n        Arguments:\n\n            color -- '#rrggbb'\n\n            url -- str\n\n            position -- str\n\n            repeat -- str\n\n            opacity -- int\n\n            filter -- str\n        \"\"\"\n        family = self.family\n        if family not in {\n            \"text\",\n            \"paragraph\",\n            \"page-layout\",\n            \"section\",\n            \"table\",\n            \"table-row\",\n            \"table-cell\",\n            \"graphic\",\n        }:\n            raise TypeError(\"No background support for this family\")\n        if url is not None and family == \"text\":\n            raise TypeError(\"No background image for text styles\")\n        properties = self.get_element(f\"style:{family}-properties\")\n        bg_image: BackgroundImage | None = None\n        if properties is not None:\n            bg_image = properties.get_element(\"style:background-image\")  # type:ignore\n        # Erasing\n        if color is None and url is None:\n            if properties is None:\n                return\n            properties.del_attribute(\"fo:background-color\")\n            if bg_image is not None:\n                properties.delete(bg_image)\n            return\n        # Add the properties if necessary\n        if properties is None:\n            properties = Element.from_tag(f\"style:{family}-properties\")\n            self.append(properties)\n        # Add the color...\n        if color:\n            properties.set_attribute(\"fo:background-color\", color)\n            if bg_image is not None:\n                properties.delete(bg_image)\n        # ... or the background\n        elif url:\n            properties.set_attribute(\"fo:background-color\", \"transparent\")\n            if bg_image is None:\n                bg_image = Element.from_tag(\"style:background-image\")  # type:ignore\n                properties.append(bg_image)  # type:ignore\n            bg_image.url = url  # type:ignore\n            if position:\n                bg_image.position = position  # type:ignore\n            if repeat:\n                bg_image.repeat = repeat  # type:ignore\n            if opacity:\n                bg_image.opacity = opacity  # type:ignore\n            if filter:\n                bg_image.filter = filter  # type:ignore\n\n    # list-style only:\n\n    def get_level_style(self, level: int) -&gt; Style | None:\n        if self.family != \"list\":\n            return None\n        level_styles = (\n            \"(text:list-level-style-number\"\n            \"|text:list-level-style-bullet\"\n            \"|text:list-level-style-image)\"\n        )\n        return self._filtered_element(level_styles, 0, level=level)  # type: ignore\n\n    def set_level_style(\n        self,\n        level: int,\n        num_format: str | None = None,\n        bullet_char: str | None = None,\n        url: str | None = None,\n        display_levels: int | None = None,\n        prefix: str | None = None,\n        suffix: str | None = None,\n        start_value: int | None = None,\n        style: str | None = None,\n        clone: Style | None = None,\n    ) -&gt; Style | None:\n        \"\"\"\n        Arguments:\n\n            level -- int\n\n            num_format (for number) -- int\n\n            bullet_char (for bullet) -- str\n\n            url (for image) -- str\n\n            display_levels -- int\n\n            prefix -- str\n\n            suffix -- str\n\n            start_value -- int\n\n            style -- str\n\n            clone -- List Style\n\n        Return:\n            level_style created\n        \"\"\"\n        if self.family != \"list\":\n            return None\n        # Expected name\n        if num_format is not None:\n            level_style_name = \"text:list-level-style-number\"\n        elif bullet_char is not None:\n            level_style_name = \"text:list-level-style-bullet\"\n        elif url is not None:\n            level_style_name = \"text:list-level-style-image\"\n        elif clone is not None:\n            level_style_name = clone.tag\n        else:\n            raise ValueError(\"unknown level style type\")\n        was_created = False\n        # Cloning or reusing an existing element\n        level_style: Style | None = None\n        if clone is not None:\n            level_style = clone.clone  # type: ignore\n            was_created = True\n        else:\n            level_style = self.get_level_style(level)\n            if level_style is None:\n                level_style = Element.from_tag(level_style_name)  # type: ignore\n                was_created = True\n        if level_style is None:\n            return None\n        # Transmute if the type changed\n        if level_style.tag != level_style_name:\n            print(\"Warn: different style\", level_style_name, level_style.tag)\n            level_style.tag = level_style_name\n        # Set the level\n        level_style.set_attribute(\"text:level\", str(level))\n        # Set the main attribute\n        if num_format is not None:\n            level_style.set_attribute(\"fo:num-format\", num_format)\n        elif bullet_char is not None:\n            level_style.set_attribute(\"text:bullet-char\", bullet_char)\n        elif url is not None:\n            level_style.set_attribute(\"xlink:href\", url)\n        # Set attributes\n        if prefix:\n            level_style.set_attribute(\"style:num-prefix\", prefix)\n        if suffix:\n            level_style.set_attribute(\"style:num-suffix\", suffix)\n        if display_levels:\n            level_style.set_attribute(\"text:display-levels\", str(display_levels))\n        if start_value:\n            level_style.set_attribute(\"text:start-value\", str(start_value))\n        if style:\n            level_style.text_style = style  # type: ignore\n        # Commit the creation\n        if was_created:\n            self.append(level_style)\n        return level_style\n\n    # page-layout only:\n\n    def get_header_style(self) -&gt; Element | None:\n        if self.family != \"page-layout\":\n            return None\n        return self.get_element(\"style:header-style\")\n\n    def set_header_style(self, new_style: Style) -&gt; None:\n        if self.family != \"page-layout\":\n            return\n        header_style = self.get_header_style()\n        if header_style is not None:\n            self.delete(header_style)\n        self.append(new_style)\n\n    def get_footer_style(self) -&gt; Style | None:\n        if self.family != \"page-layout\":\n            return None\n        return self.get_element(\"style:footer-style\")  # type: ignore\n\n    def set_footer_style(self, new_style: Style) -&gt; None:\n        if self.family != \"page-layout\":\n            return\n        footer_style = self.get_footer_style()\n        if footer_style is not None:\n            self.delete(footer_style)\n        self.append(new_style)\n\n    # master-page only:\n\n    def _set_header_or_footer(\n        self,\n        text_or_element: str | Element | list[Element | str],\n        name: str = \"header\",\n        style: str = \"Header\",\n    ) -&gt; None:\n        if name == \"header\":\n            header_or_footer = self.get_page_header()\n        else:\n            header_or_footer = self.get_page_footer()\n        if header_or_footer is None:\n            header_or_footer = Element.from_tag(\"style:\" + name)\n            self.append(header_or_footer)\n        else:\n            header_or_footer.clear()\n        if (\n            isinstance(text_or_element, Element)\n            and text_or_element.tag == f\"style:{name}\"\n        ):\n            # Already a header or footer?\n            self.delete(header_or_footer)\n            self.append(text_or_element)\n            return\n        if isinstance(text_or_element, (Element, str)):\n            elem_list: list[Element | str] = [text_or_element]\n        else:\n            elem_list = text_or_element\n        for item in elem_list:\n            if isinstance(item, str):\n                paragraph = Element.from_tag(\"text:p\")\n                paragraph.append_plain_text(item)  # type: ignore\n                paragraph.style = style  # type: ignore\n                header_or_footer.append(paragraph)\n            elif isinstance(item, Element):\n                header_or_footer.append(item)\n\n    def get_page_header(self) -&gt; Element | None:\n        \"\"\"Get the element that contains the header contents.\n\n        If None, no header was set.\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        return self.get_element(\"style:header\")\n\n    def set_page_header(\n        self,\n        text_or_element: str | Element | list[Element | str],\n    ) -&gt; None:\n        \"\"\"Create or replace the header by the given content. It can already\n        be a complete header.\n\n        If you only want to update the existing header, get it and use the\n        API.\n\n        Arguments:\n\n            text_or_element -- str or Element or a list of them\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        self._set_header_or_footer(text_or_element)\n\n    def get_page_footer(self) -&gt; Element | None:\n        \"\"\"Get the element that contains the footer contents.\n\n        If None, no footer was set.\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        return self.get_element(\"style:footer\")\n\n    def set_page_footer(\n        self,\n        text_or_element: str | Element | list[Element | str],\n    ) -&gt; None:\n        \"\"\"Create or replace the footer by the given content. It can already\n        be a complete footer.\n\n        If you only want to update the existing footer, get it and use the\n        API.\n\n        Arguments:\n\n            text_or_element -- str or Element or a list of them\n        \"\"\"\n        if self.family != \"master-page\":\n            return None\n        self._set_header_or_footer(text_or_element, name=\"footer\", style=\"Footer\")\n\n    # font-face only:\n\n    def set_font(\n        self,\n        name: str,\n        family: str | None = None,\n        family_generic: str | None = None,\n        pitch: str = \"variable\",\n    ) -&gt; None:\n        if self.family != \"font-face\":\n            return\n        self.name = name\n        if family is None:\n            family = name\n        self.svg_font_family = f'\"{family}\"'\n        if family_generic is not None:\n            self.font_family_generic = family_generic\n        self.font_pitch = pitch\n</code></pre>"},{"location":"reference.html#odfdo.Style.__init__","title":"<code>__init__(family=None, name=None, display_name=None, parent_style=None, area=None, color=None, background_color=None, italic=False, bold=False, master_page=None, page_layout=None, next_style=None, data_style=None, border=None, border_top=None, border_right=None, border_bottom=None, border_left=None, padding=None, padding_top=None, padding_bottom=None, padding_left=None, padding_right=None, shadow=None, height=None, use_optimal_height=False, break_before=None, break_after=None, align=None, width=None, min_height=None, font_name=None, font_family=None, font_family_generic=None, font_pitch='variable', **kwargs)</code>","text":"<p>Create a style of the given family. The name is not mandatory at this point but will become required when inserting in a document as a common style.</p> <p>The display name is the name the user sees in an office application.</p> <p>The parent_style is the name of the style this style will inherit from.</p> <p>To set properties, pass them as keyword arguments. The area properties apply to is optional and defaults to the family.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text', 'section', 'table', 'table-column',\n          'table-row', 'table-cell', 'table-page', 'chart',\n          'drawing-page', 'graphic', 'presentation',\n          'control', 'ruby', 'list', 'number', 'page-layout'\n          'font-face', or 'master-page'\n\nname -- str\n\ndisplay_name -- str\n\nparent_style -- str\n\narea -- str\n</code></pre> <p>\u2018text\u2019 Properties:</p> <pre><code>italic -- bool\n\nbold -- bool\n</code></pre> <p>\u2018paragraph\u2019 Properties:</p> <pre><code>master_page -- str\n</code></pre> <p>\u2018master-page\u2019 Properties:</p> <pre><code>page_layout -- str\n\nnext_style -- str\n</code></pre> <p>\u2018table-cell\u2019 Properties:</p> <pre><code>border, border_top, border_right, border_bottom, border_left -- str,\ne.g. \"0.002cm solid #000000\" or 'none'\n\npadding, padding_top, padding_right, padding_bottom, padding_left -- str,\ne.g. \"0.002cm\" or 'none'\n\nshadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n</code></pre> <p>\u2018table-row\u2019 Properties:</p> <pre><code>height -- str, e.g. '5cm'\n\nuse_optimal_height -- bool\n</code></pre> <p>\u2018table-column\u2019 Properties:</p> <pre><code>width -- str, e.g. '5cm'\n\nbreak_before -- 'page', 'column' or 'auto'\n\nbreak_after -- 'page', 'column' or 'auto'\n</code></pre> <p>\u2018table\u2019 Properties:</p> <pre><code>width -- str, e.g. '5cm'\n\nalign -- 'left', 'center', 'margins' or 'right'\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def __init__(\n    self,\n    family: str | None = None,\n    name: str | None = None,\n    display_name: str | None = None,\n    parent_style: str | None = None,\n    # Where properties apply\n    area: str | None = None,\n    # For family 'text':\n    color: str | tuple | None = None,\n    background_color: str | tuple | None = None,\n    italic: bool = False,\n    bold: bool = False,\n    # For family 'paragraph'\n    master_page: str | None = None,\n    # For family 'master-page'\n    page_layout: str | None = None,\n    next_style: str | None = None,\n    # For family 'table-cell'\n    data_style: str | None = None,  # unused\n    border: str | None = None,\n    border_top: str | None = None,\n    border_right: str | None = None,\n    border_bottom: str | None = None,\n    border_left: str | None = None,\n    padding: str | None = None,\n    padding_top: str | None = None,\n    padding_bottom: str | None = None,\n    padding_left: str | None = None,\n    padding_right: str | None = None,\n    shadow: str | None = None,\n    # For family 'table-row'\n    height: str | None = None,\n    use_optimal_height: bool = False,\n    # For family 'table-column'\n    break_before: str | None = None,\n    break_after: str | None = None,\n    # for family 'table'\n    align: str | None = None,\n    # For family 'table-column' or 'table'\n    width: str | None = None,\n    # For family 'graphic'\n    min_height: str | None = None,\n    # For family 'font-face'\n    font_name: str | None = None,\n    font_family: str | None = None,\n    font_family_generic: str | None = None,\n    font_pitch: str = \"variable\",\n    # Every other property\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a style of the given family. The name is not mandatory at this\n    point but will become required when inserting in a document as a common\n    style.\n\n    The display name is the name the user sees in an office application.\n\n    The parent_style is the name of the style this style will inherit from.\n\n    To set properties, pass them as keyword arguments. The area properties\n    apply to is optional and defaults to the family.\n\n    Arguments:\n\n        family -- 'paragraph', 'text', 'section', 'table', 'table-column',\n                  'table-row', 'table-cell', 'table-page', 'chart',\n                  'drawing-page', 'graphic', 'presentation',\n                  'control', 'ruby', 'list', 'number', 'page-layout'\n                  'font-face', or 'master-page'\n\n        name -- str\n\n        display_name -- str\n\n        parent_style -- str\n\n        area -- str\n\n    'text' Properties:\n\n        italic -- bool\n\n        bold -- bool\n\n    'paragraph' Properties:\n\n        master_page -- str\n\n    'master-page' Properties:\n\n        page_layout -- str\n\n        next_style -- str\n\n    'table-cell' Properties:\n\n        border, border_top, border_right, border_bottom, border_left -- str,\n        e.g. \"0.002cm solid #000000\" or 'none'\n\n        padding, padding_top, padding_right, padding_bottom, padding_left -- str,\n        e.g. \"0.002cm\" or 'none'\n\n        shadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\n    'table-row' Properties:\n\n        height -- str, e.g. '5cm'\n\n        use_optimal_height -- bool\n\n    'table-column' Properties:\n\n        width -- str, e.g. '5cm'\n\n        break_before -- 'page', 'column' or 'auto'\n\n        break_after -- 'page', 'column' or 'auto'\n\n    'table' Properties:\n\n        width -- str, e.g. '5cm'\n\n        align -- 'left', 'center', 'margins' or 'right'\n    \"\"\"\n    self._family: str | None = None\n    tag_or_elem = kwargs.get(\"tag_or_elem\")\n    if tag_or_elem is None:\n        family = to_str(family)\n        if family not in FAMILY_MAPPING:\n            raise ValueError(f\"Unknown family value: '{family}'\")\n        kwargs[\"tag\"] = FAMILY_MAPPING[family]\n    super().__init__(**kwargs)\n    if self._do_init and family not in SUBCLASSED_STYLES:\n        kwargs.pop(\"tag\", None)\n        kwargs.pop(\"tag_or_elem\", None)\n        self.family = family  # relevant test made by property\n        # Common attributes\n        if name:\n            self.name = name\n        if display_name:\n            self.display_name = display_name\n        if parent_style:\n            self.parent_style = parent_style\n        # Paragraph\n        if family == \"paragraph\":\n            if master_page:\n                self.master_page = master_page\n        # Master Page\n        elif family == \"master-page\":\n            if page_layout:\n                self.page_layout = page_layout\n            if next_style:\n                self.next_style = next_style\n        # Font face\n        elif family == \"font-face\":\n            if not font_name:\n                raise ValueError(\"A font_name is required for 'font-face' style\")\n            self.set_font(\n                font_name,\n                family=font_family,\n                family_generic=font_family_generic,\n                pitch=font_pitch,\n            )\n        # Properties\n        if area is None:\n            area = family\n        area = to_str(area)\n        # Text\n        if area == \"text\":\n            if color:\n                kwargs[\"fo:color\"] = color\n            if background_color:\n                kwargs[\"fo:background-color\"] = background_color\n            if italic:\n                kwargs[\"fo:font-style\"] = \"italic\"\n                kwargs[\"style:font-style-asian\"] = \"italic\"\n                kwargs[\"style:font-style-complex\"] = \"italic\"\n            if bold:\n                kwargs[\"fo:font-weight\"] = \"bold\"\n                kwargs[\"style:font-weight-asian\"] = \"bold\"\n                kwargs[\"style:font-weight-complex\"] = \"bold\"\n        # Table cell\n        elif area == \"table-cell\":\n            if border:\n                kwargs[\"fo:border\"] = border\n            elif border_top or border_right or border_bottom or border_left:\n                kwargs[\"fo:border-top\"] = border_top or \"none\"\n                kwargs[\"fo:border-right\"] = border_right or \"none\"\n                kwargs[\"fo:border-bottom\"] = border_bottom or \"none\"\n                kwargs[\"fo:border-left\"] = border_left or \"none\"\n            else:  # no border_top, ... neither border are defined\n                pass  # left untouched\n            if padding:\n                kwargs[\"fo:padding\"] = padding\n            elif padding_top or padding_right or padding_bottom or padding_left:\n                kwargs[\"fo:padding-top\"] = padding_top or \"none\"\n                kwargs[\"fo:padding-right\"] = padding_right or \"none\"\n                kwargs[\"fo:padding-bottom\"] = padding_bottom or \"none\"\n                kwargs[\"fo:padding-left\"] = padding_left or \"none\"\n            else:  # no border_top, ... neither border are defined\n                pass  # left untouched\n            if shadow:\n                kwargs[\"style:shadow\"] = shadow\n            if background_color:\n                kwargs[\"fo:background-color\"] = background_color\n        # Table row\n        elif area == \"table-row\":\n            if height:\n                kwargs[\"style:row-height\"] = height\n            if use_optimal_height:\n                kwargs[\"style:use-optimal-row-height\"] = Boolean.encode(\n                    use_optimal_height\n                )\n            if background_color:\n                kwargs[\"fo:background-color\"] = background_color\n        # Table column\n        elif area == \"table-column\":\n            if width:\n                kwargs[\"style:column-width\"] = width\n            if break_before:\n                kwargs[\"fo:break-before\"] = break_before\n            if break_after:\n                kwargs[\"fo:break-after\"] = break_after\n        # Table\n        elif area == \"table\":\n            if width:\n                kwargs[\"style:width\"] = width\n            if align:\n                if align not in {\"center\", \"left\", \"margins\", \"right\"}:\n                    raise ValueError(f\"Invalid align value: {align!r}\")\n                kwargs[\"table:align\"] = align\n        # Graphic\n        elif area == \"graphic\":\n            if min_height:\n                kwargs[\"fo:min-height\"] = min_height\n        # Every other properties\n        if kwargs:\n            self.set_properties(kwargs, area=area)\n</code></pre>"},{"location":"reference.html#odfdo.Style.del_properties","title":"<code>del_properties(properties=None, area=None)</code>","text":"<p>Delete the given properties, either by list argument or positional argument (or both). Remove only from the given area, identical to the style family by default.</p> <p>Arguments:</p> <pre><code>properties -- list\n\narea -- str\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def del_properties(\n    self,\n    properties: list[str] | None = None,\n    area: str | None = None,\n) -&gt; None:\n    \"\"\"Delete the given properties, either by list argument or\n    positional argument (or both). Remove only from the given area,\n    identical to the style family by default.\n\n    Arguments:\n\n        properties -- list\n\n        area -- str\n    \"\"\"\n    if properties is None:\n        properties = []\n    if area is None:\n        area = self.family\n    element = self.get_element(f\"style:{area}-properties\")\n    if element is None:\n        raise ValueError(\n            f\"properties element is inexistent for: style:{area}-properties\"\n        )\n    for key in _expand_properties_list(properties):\n        element.del_attribute(key)\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_list_style_properties","title":"<code>get_list_style_properties()</code>","text":"<p>Get text properties of style as a dict, with some enhanced values.</p> Enhanced values returned <ul> <li>\u201ccolor\u201d: str</li> <li>\u201cbackground_color\u201d: str</li> <li>\u201citalic\u201d: bool</li> <li>\u201cbold\u201d: bool</li> <li>\u201cfixed\u201d: bool</li> <li>\u201cunderline\u201d: bool</li> <li>\u201cstrike\u201d: bool</li> </ul> <p>Return: dict[str, str | bool]</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_list_style_properties(self) -&gt; dict[str, str | bool]:\n    \"\"\"Get text properties of style as a dict, with some enhanced values.\n\n    Enhanced values returned:\n     - \"color\": str\n     - \"background_color\": str\n     - \"italic\": bool\n     - \"bold\": bool\n     - \"fixed\": bool\n     - \"underline\": bool\n     - \"strike\": bool\n\n    Return: dict[str, str | bool]\n    \"\"\"\n    return self.get_text_properties()\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_page_footer","title":"<code>get_page_footer()</code>","text":"<p>Get the element that contains the footer contents.</p> <p>If None, no footer was set.</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_page_footer(self) -&gt; Element | None:\n    \"\"\"Get the element that contains the footer contents.\n\n    If None, no footer was set.\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    return self.get_element(\"style:footer\")\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_page_header","title":"<code>get_page_header()</code>","text":"<p>Get the element that contains the header contents.</p> <p>If None, no header was set.</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_page_header(self) -&gt; Element | None:\n    \"\"\"Get the element that contains the header contents.\n\n    If None, no header was set.\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    return self.get_element(\"style:header\")\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_properties","title":"<code>get_properties(area=None)</code>","text":"<p>Get the mapping of all properties of this style. By default the properties of the same family, e.g. a paragraph style and its paragraph properties. Specify the area to get the text properties of a paragraph style for example.</p> <p>Arguments:</p> <pre><code>area -- str\n</code></pre> <p>Return: dict</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_properties(self, area: str | None = None) -&gt; dict[str, str | dict] | None:\n    \"\"\"Get the mapping of all properties of this style. By default the\n    properties of the same family, e.g. a paragraph style and its\n    paragraph properties. Specify the area to get the text properties of\n    a paragraph style for example.\n\n    Arguments:\n\n        area -- str\n\n    Return: dict\n    \"\"\"\n    if area is None:\n        area = self.family\n    element = self.get_element(f\"style:{area}-properties\")\n    if element is None:\n        return None\n    properties: dict[str, str | dict] = element.attributes  # type: ignore\n    # Nested properties are nested dictionaries\n    for child in element.children:\n        properties[child.tag] = child.attributes\n    return properties\n</code></pre>"},{"location":"reference.html#odfdo.Style.get_text_properties","title":"<code>get_text_properties()</code>","text":"<p>Get text properties of style as a dict, with some enhanced values.</p> Enhanced values returned <ul> <li>\u201ccolor\u201d: str</li> <li>\u201cbackground_color\u201d: str</li> <li>\u201citalic\u201d: bool</li> <li>\u201cbold\u201d: bool</li> <li>\u201cfixed\u201d: bool</li> <li>\u201cunderline\u201d: bool</li> <li>\u201cstrike\u201d: bool</li> </ul> <p>Return: dict[str, str | bool]</p> Source code in <code>odfdo/style.py</code> <pre><code>def get_text_properties(self) -&gt; dict[str, str | bool]:\n    \"\"\"Get text properties of style as a dict, with some enhanced values.\n\n    Enhanced values returned:\n     - \"color\": str\n     - \"background_color\": str\n     - \"italic\": bool\n     - \"bold\": bool\n     - \"fixed\": bool\n     - \"underline\": bool\n     - \"strike\": bool\n\n    Return: dict[str, str | bool]\n    \"\"\"\n    props: dict[str, str | bool] = self.get_properties(area=\"text\") or {}\n    self._update_boolean_styles(props)\n    return props\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_background","title":"<code>set_background(color=None, url=None, position='center', repeat=None, opacity=None, filter=None)</code>","text":"<p>Set the background color of a text style, or the background color or image of a paragraph style or page layout.</p> <p>With no argument, remove any existing background.</p> <p>The position is one or two of \u2018center\u2019, \u2018left\u2019, \u2018right\u2019, \u2018top\u2019 or \u2018bottom\u2019.</p> <p>The repeat is \u2018no-repeat\u2019, \u2018repeat\u2019 or \u2018stretch\u2019.</p> <p>The opacity is a percentage integer (not a string with the \u2018%s\u2019 sign)</p> <p>The filter is an application-specific filter name defined elsewhere.</p> <p>Though this method is defined on the base style class, it will raise an error if the style type is not compatible.</p> <p>Arguments:</p> <pre><code>color -- '#rrggbb'\n\nurl -- str\n\nposition -- str\n\nrepeat -- str\n\nopacity -- int\n\nfilter -- str\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_background(\n    self,\n    color: str | None = None,\n    url: str | None = None,\n    position: str | None = \"center\",\n    repeat: str | None = None,\n    opacity: str | None = None,\n    filter: str | None = None,  # noqa: A002\n) -&gt; None:\n    \"\"\"Set the background color of a text style, or the background color\n    or image of a paragraph style or page layout.\n\n    With no argument, remove any existing background.\n\n    The position is one or two of 'center', 'left', 'right', 'top' or\n    'bottom'.\n\n    The repeat is 'no-repeat', 'repeat' or 'stretch'.\n\n    The opacity is a percentage integer (not a string with the '%s' sign)\n\n    The filter is an application-specific filter name defined elsewhere.\n\n    Though this method is defined on the base style class, it will raise\n    an error if the style type is not compatible.\n\n    Arguments:\n\n        color -- '#rrggbb'\n\n        url -- str\n\n        position -- str\n\n        repeat -- str\n\n        opacity -- int\n\n        filter -- str\n    \"\"\"\n    family = self.family\n    if family not in {\n        \"text\",\n        \"paragraph\",\n        \"page-layout\",\n        \"section\",\n        \"table\",\n        \"table-row\",\n        \"table-cell\",\n        \"graphic\",\n    }:\n        raise TypeError(\"No background support for this family\")\n    if url is not None and family == \"text\":\n        raise TypeError(\"No background image for text styles\")\n    properties = self.get_element(f\"style:{family}-properties\")\n    bg_image: BackgroundImage | None = None\n    if properties is not None:\n        bg_image = properties.get_element(\"style:background-image\")  # type:ignore\n    # Erasing\n    if color is None and url is None:\n        if properties is None:\n            return\n        properties.del_attribute(\"fo:background-color\")\n        if bg_image is not None:\n            properties.delete(bg_image)\n        return\n    # Add the properties if necessary\n    if properties is None:\n        properties = Element.from_tag(f\"style:{family}-properties\")\n        self.append(properties)\n    # Add the color...\n    if color:\n        properties.set_attribute(\"fo:background-color\", color)\n        if bg_image is not None:\n            properties.delete(bg_image)\n    # ... or the background\n    elif url:\n        properties.set_attribute(\"fo:background-color\", \"transparent\")\n        if bg_image is None:\n            bg_image = Element.from_tag(\"style:background-image\")  # type:ignore\n            properties.append(bg_image)  # type:ignore\n        bg_image.url = url  # type:ignore\n        if position:\n            bg_image.position = position  # type:ignore\n        if repeat:\n            bg_image.repeat = repeat  # type:ignore\n        if opacity:\n            bg_image.opacity = opacity  # type:ignore\n        if filter:\n            bg_image.filter = filter  # type:ignore\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_level_style","title":"<code>set_level_style(level, num_format=None, bullet_char=None, url=None, display_levels=None, prefix=None, suffix=None, start_value=None, style=None, clone=None)</code>","text":"<p>Arguments:</p> <pre><code>level -- int\n\nnum_format (for number) -- int\n\nbullet_char (for bullet) -- str\n\nurl (for image) -- str\n\ndisplay_levels -- int\n\nprefix -- str\n\nsuffix -- str\n\nstart_value -- int\n\nstyle -- str\n\nclone -- List Style\n</code></pre> Return <p>level_style created</p> Source code in <code>odfdo/style.py</code> <pre><code>def set_level_style(\n    self,\n    level: int,\n    num_format: str | None = None,\n    bullet_char: str | None = None,\n    url: str | None = None,\n    display_levels: int | None = None,\n    prefix: str | None = None,\n    suffix: str | None = None,\n    start_value: int | None = None,\n    style: str | None = None,\n    clone: Style | None = None,\n) -&gt; Style | None:\n    \"\"\"\n    Arguments:\n\n        level -- int\n\n        num_format (for number) -- int\n\n        bullet_char (for bullet) -- str\n\n        url (for image) -- str\n\n        display_levels -- int\n\n        prefix -- str\n\n        suffix -- str\n\n        start_value -- int\n\n        style -- str\n\n        clone -- List Style\n\n    Return:\n        level_style created\n    \"\"\"\n    if self.family != \"list\":\n        return None\n    # Expected name\n    if num_format is not None:\n        level_style_name = \"text:list-level-style-number\"\n    elif bullet_char is not None:\n        level_style_name = \"text:list-level-style-bullet\"\n    elif url is not None:\n        level_style_name = \"text:list-level-style-image\"\n    elif clone is not None:\n        level_style_name = clone.tag\n    else:\n        raise ValueError(\"unknown level style type\")\n    was_created = False\n    # Cloning or reusing an existing element\n    level_style: Style | None = None\n    if clone is not None:\n        level_style = clone.clone  # type: ignore\n        was_created = True\n    else:\n        level_style = self.get_level_style(level)\n        if level_style is None:\n            level_style = Element.from_tag(level_style_name)  # type: ignore\n            was_created = True\n    if level_style is None:\n        return None\n    # Transmute if the type changed\n    if level_style.tag != level_style_name:\n        print(\"Warn: different style\", level_style_name, level_style.tag)\n        level_style.tag = level_style_name\n    # Set the level\n    level_style.set_attribute(\"text:level\", str(level))\n    # Set the main attribute\n    if num_format is not None:\n        level_style.set_attribute(\"fo:num-format\", num_format)\n    elif bullet_char is not None:\n        level_style.set_attribute(\"text:bullet-char\", bullet_char)\n    elif url is not None:\n        level_style.set_attribute(\"xlink:href\", url)\n    # Set attributes\n    if prefix:\n        level_style.set_attribute(\"style:num-prefix\", prefix)\n    if suffix:\n        level_style.set_attribute(\"style:num-suffix\", suffix)\n    if display_levels:\n        level_style.set_attribute(\"text:display-levels\", str(display_levels))\n    if start_value:\n        level_style.set_attribute(\"text:start-value\", str(start_value))\n    if style:\n        level_style.text_style = style  # type: ignore\n    # Commit the creation\n    if was_created:\n        self.append(level_style)\n    return level_style\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_page_footer","title":"<code>set_page_footer(text_or_element)</code>","text":"<p>Create or replace the footer by the given content. It can already be a complete footer.</p> <p>If you only want to update the existing footer, get it and use the API.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or Element or a list of them\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_page_footer(\n    self,\n    text_or_element: str | Element | list[Element | str],\n) -&gt; None:\n    \"\"\"Create or replace the footer by the given content. It can already\n    be a complete footer.\n\n    If you only want to update the existing footer, get it and use the\n    API.\n\n    Arguments:\n\n        text_or_element -- str or Element or a list of them\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    self._set_header_or_footer(text_or_element, name=\"footer\", style=\"Footer\")\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_page_header","title":"<code>set_page_header(text_or_element)</code>","text":"<p>Create or replace the header by the given content. It can already be a complete header.</p> <p>If you only want to update the existing header, get it and use the API.</p> <p>Arguments:</p> <pre><code>text_or_element -- str or Element or a list of them\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_page_header(\n    self,\n    text_or_element: str | Element | list[Element | str],\n) -&gt; None:\n    \"\"\"Create or replace the header by the given content. It can already\n    be a complete header.\n\n    If you only want to update the existing header, get it and use the\n    API.\n\n    Arguments:\n\n        text_or_element -- str or Element or a list of them\n    \"\"\"\n    if self.family != \"master-page\":\n        return None\n    self._set_header_or_footer(text_or_element)\n</code></pre>"},{"location":"reference.html#odfdo.Style.set_properties","title":"<code>set_properties(properties=None, style=None, area=None, **kwargs)</code>","text":"<p>Set the properties of the \u201carea\u201d type of this style. Properties are given either as a dict or as named arguments (or both). The area is identical to the style family by default. If the properties element is missing, it is created.</p> <p>Instead of properties, you can pass a style with properties of the same area. These will be copied.</p> <p>Arguments:</p> <pre><code>properties -- dict\n\nstyle -- Style\n\narea -- 'paragraph', 'text'...\n</code></pre> Source code in <code>odfdo/style.py</code> <pre><code>def set_properties(\n    self,\n    properties: dict[str, str | dict] | None = None,\n    style: Style | None = None,\n    area: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Set the properties of the \"area\" type of this style. Properties\n    are given either as a dict or as named arguments (or both). The area\n    is identical to the style family by default. If the properties\n    element is missing, it is created.\n\n    Instead of properties, you can pass a style with properties of the\n    same area. These will be copied.\n\n    Arguments:\n\n        properties -- dict\n\n        style -- Style\n\n        area -- 'paragraph', 'text'...\n    \"\"\"\n    if properties is None:\n        properties = {}\n    if area is None:\n        if isinstance(self.family, bool):\n            area = None\n        else:\n            area = self.family\n    element = self.get_element(f\"style:{area}-properties\")\n    if element is None:\n        element = Element.from_tag(f\"style:{area}-properties\")\n        self.append(element)\n    if properties or kwargs:\n        properties = _expand_properties_dict(_merge_dicts(properties, kwargs))\n    elif style is not None:\n        properties = style.get_properties(area=area)\n        if properties is None:\n            return\n    if properties is None:\n        return\n    for key, value in properties.items():\n        if value is None:\n            element.del_attribute(key)\n        elif isinstance(value, (str, bool, tuple)):\n            element.set_attribute(key, value)\n</code></pre>"},{"location":"reference.html#odfdo.Styles","title":"<code>Styles</code>","text":"<p>               Bases: <code>XmlPart</code></p> Source code in <code>odfdo/styles.py</code> <pre><code>class Styles(XmlPart):\n    def _get_style_contexts(\n        self, family: str, automatic: bool = False\n    ) -&gt; list[Element]:\n        if automatic:\n            return [self.get_element(\"//office:automatic-styles\")]\n        if not family:\n            # All possibilities\n            return [\n                self.get_element(\"//office:automatic-styles\"),\n                self.get_element(\"//office:styles\"),\n                self.get_element(\"//office:master-styles\"),\n                self.get_element(\"//office:font-face-decls\"),\n            ]\n        queries = CONTEXT_MAPPING.get(family) or (\n            \"//office:styles\",\n            \"//office:automatic-styles\",\n        )\n        # if queries is None:\n        #     raise ValueError(f\"unknown family: {family}\")\n        return [self.get_element(query) for query in queries]\n\n    def get_styles(self, family: str = \"\", automatic: bool = False) -&gt; list[Element]:\n        \"\"\"Return the list of styles in the Content part, optionally limited\n        to the given family, optionaly limited to automatic styles.\n\n        Arguments:\n\n            family -- str\n\n            automatic -- bool\n\n        Return: list of Style\n        \"\"\"\n        result = []\n        for context in self._get_style_contexts(family, automatic=automatic):\n            if context is None:\n                continue\n            # print('-ctx----', automatic)\n            # print(context.tag)\n            # print(context.__class__)\n            # print(context.serialize())\n            result.extend(context.get_styles(family=family))\n        return result\n\n    def get_style(\n        self,\n        family: str,\n        name_or_element: str | Style | None = None,\n        display_name: str | None = None,\n    ) -&gt; Style | None:\n        \"\"\"Return the style uniquely identified by the name/family pair. If\n        the argument is already a style object, it will return it.\n\n        If the name is None, the default style is fetched.\n\n        If the name is not the internal name but the name you gave in the\n        desktop application, use display_name instead.\n\n        Arguments:\n\n            family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                      'number', 'page-layout', 'master-page'\n\n            name_or_element -- str, odf_style or None\n\n            display_name -- str or None\n\n        Return: odf_style or None if not found\n        \"\"\"\n        for context in self._get_style_contexts(family):\n            if context is None:\n                continue\n            style = context.get_style(\n                family,\n                name_or_element=name_or_element,\n                display_name=display_name,\n            )\n            if style is not None:\n                return style  # type: ignore\n        return None\n\n    def get_master_pages(self) -&gt; list[Element]:\n        query = make_xpath_query(\"descendant::style:master-page\")\n        return self.get_elements(query)  # type:ignore\n\n    def get_master_page(self, position: int = 0) -&gt; Element | None:\n        results = self.get_master_pages()\n        try:\n            return results[position]\n        except IndexError:\n            return None\n</code></pre>"},{"location":"reference.html#odfdo.Styles.get_style","title":"<code>get_style(family, name_or_element=None, display_name=None)</code>","text":"<p>Return the style uniquely identified by the name/family pair. If the argument is already a style object, it will return it.</p> <p>If the name is None, the default style is fetched.</p> <p>If the name is not the internal name but the name you gave in the desktop application, use display_name instead.</p> <p>Arguments:</p> <pre><code>family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n          'number', 'page-layout', 'master-page'\n\nname_or_element -- str, odf_style or None\n\ndisplay_name -- str or None\n</code></pre> <p>Return: odf_style or None if not found</p> Source code in <code>odfdo/styles.py</code> <pre><code>def get_style(\n    self,\n    family: str,\n    name_or_element: str | Style | None = None,\n    display_name: str | None = None,\n) -&gt; Style | None:\n    \"\"\"Return the style uniquely identified by the name/family pair. If\n    the argument is already a style object, it will return it.\n\n    If the name is None, the default style is fetched.\n\n    If the name is not the internal name but the name you gave in the\n    desktop application, use display_name instead.\n\n    Arguments:\n\n        family -- 'paragraph', 'text',  'graphic', 'table', 'list',\n                  'number', 'page-layout', 'master-page'\n\n        name_or_element -- str, odf_style or None\n\n        display_name -- str or None\n\n    Return: odf_style or None if not found\n    \"\"\"\n    for context in self._get_style_contexts(family):\n        if context is None:\n            continue\n        style = context.get_style(\n            family,\n            name_or_element=name_or_element,\n            display_name=display_name,\n        )\n        if style is not None:\n            return style  # type: ignore\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Styles.get_styles","title":"<code>get_styles(family='', automatic=False)</code>","text":"<p>Return the list of styles in the Content part, optionally limited to the given family, optionaly limited to automatic styles.</p> <p>Arguments:</p> <pre><code>family -- str\n\nautomatic -- bool\n</code></pre> <p>Return: list of Style</p> Source code in <code>odfdo/styles.py</code> <pre><code>def get_styles(self, family: str = \"\", automatic: bool = False) -&gt; list[Element]:\n    \"\"\"Return the list of styles in the Content part, optionally limited\n    to the given family, optionaly limited to automatic styles.\n\n    Arguments:\n\n        family -- str\n\n        automatic -- bool\n\n    Return: list of Style\n    \"\"\"\n    result = []\n    for context in self._get_style_contexts(family, automatic=automatic):\n        if context is None:\n            continue\n        # print('-ctx----', automatic)\n        # print(context.tag)\n        # print(context.__class__)\n        # print(context.serialize())\n        result.extend(context.get_styles(family=family))\n    return result\n</code></pre>"},{"location":"reference.html#odfdo.TOC","title":"<code>TOC</code>","text":"<p>               Bases: <code>MDToc</code>, <code>Element</code></p> <p>Table of content. The \u201ctext:table-of-content\u201d element represents a table of contents for a document. The items that can be listed in a table of contents are:   - Headings (as defined by the outline structure of the document), up to     a selected level.   - Table of contents index marks.   - Paragraphs formatted with specified paragraph styles.</p> <p>Implementation: Default parameters are what most people use: protected from manual modifications and not limited in title levels.</p> <p>The name is mandatory and derived automatically from the title if not given. Provide one in case of a conflict with other TOCs in the same document.</p> <p>The \u201ctext:table-of-content\u201d element has the following attributes: text:name, text:protected, text:protection-key, text:protection-key-digest-algorithm, text:style-name and xml:id.</p> <p>Arguments:</p> <pre><code>title -- str\n\nname -- str\n\nprotected -- bool\n\noutline_level -- int\n\nstyle -- str\n\ntitle_style -- str\n\nentry_style -- str\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>class TOC(MDToc, Element):\n    \"\"\"Table of content.\n    The \"text:table-of-content\" element represents a table of contents for a\n    document. The items that can be listed in a table of contents are:\n      - Headings (as defined by the outline structure of the document), up to\n        a selected level.\n      - Table of contents index marks.\n      - Paragraphs formatted with specified paragraph styles.\n\n\n    Implementation:\n    Default parameters are what most people use: protected from manual\n    modifications and not limited in title levels.\n\n    The name is mandatory and derived automatically from the title if not\n    given. Provide one in case of a conflict with other TOCs in the same\n    document.\n\n    The \"text:table-of-content\" element has the following attributes:\n    text:name, text:protected, text:protection-key,\n    text:protection-key-digest-algorithm, text:style-name and xml:id.\n\n    Arguments:\n\n        title -- str\n\n        name -- str\n\n        protected -- bool\n\n        outline_level -- int\n\n        style -- str\n\n        title_style -- str\n\n        entry_style -- str\n    \"\"\"\n\n    _tag = \"text:table-of-content\"\n    _properties = (\n        PropDef(\"name\", \"text:name\"),\n        PropDef(\"style\", \"text:style-name\"),\n        PropDef(\"xml_id\", \"xml:id\"),\n        PropDef(\"protected\", \"text:protected\"),\n        PropDef(\"protection_key\", \"text:protection-key\"),\n        PropDef(\n            \"protection_key_digest_algorithm\", \"text:protection-key-digest-algorithm\"\n        ),\n    )\n\n    def __init__(\n        self,\n        title: str = \"Table of Contents\",\n        name: str | None = None,\n        protected: bool = True,\n        outline_level: int = 0,\n        style: str | None = None,\n        title_style: str = \"Contents_20_Heading\",\n        entry_style: str = \"Contents_20_%d\",\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style:\n                self.style = style\n            if protected:\n                self.protected = protected\n            if name is None:\n                self.name = f\"{title}1\"\n            # Create the source template\n            toc_source = self.create_toc_source(\n                title, outline_level, title_style, entry_style\n            )\n            self.append(toc_source)\n            # Create the index body automatically with the index title\n            if title:\n                # This style is in the template document\n                self.set_toc_title(title, text_style=title_style)\n\n    @staticmethod\n    def create_toc_source(\n        title: str,\n        outline_level: int,\n        title_style: str,\n        entry_style: str,\n    ) -&gt; Element:\n        toc_source = Element.from_tag(\"text:table-of-content-source\")\n        toc_source.set_attribute(\"text:outline-level\", str(outline_level))\n        if title:\n            title_template = IndexTitleTemplate()\n            if title_style:\n                # This style is in the template document\n                title_template.style = title_style\n            title_template.text = title\n            toc_source.append(title_template)\n        for level in range(1, 11):\n            template = TocEntryTemplate(outline_level=level)\n            if entry_style:\n                template.style = entry_style % level\n            toc_source.append(template)\n        return toc_source\n\n    def __str__(self) -&gt; str:\n        return self.get_formatted_text()\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        index_body = self.get_element(\"text:index-body\")\n\n        if index_body is None:\n            return \"\"\n        if context is None:\n            context = {}\n        if context.get(\"rst_mode\"):\n            return \"\\n.. contents::\\n\\n\"\n\n        result = []\n        for element in index_body.children:\n            if element.tag == \"text:index-title\":\n                for child_element in element.children:\n                    result.append(child_element.get_formatted_text(context).strip())\n            else:\n                result.append(element.get_formatted_text(context).strip())\n        return \"\\n\".join(x for x in result if x)\n\n    @property\n    def outline_level(self) -&gt; int | None:\n        source = self.get_element(\"text:table-of-content-source\")\n        if source is None:\n            return None\n        return source.get_attribute_integer(\"text:outline-level\")\n\n    @outline_level.setter\n    def outline_level(self, level: int) -&gt; None:\n        source = self.get_element(\"text:table-of-content-source\")\n        if source is None:\n            source = Element.from_tag(\"text:table-of-content-source\")\n            self.insert(source, FIRST_CHILD)\n        source.set_attribute(\"text:outline-level\", str(level))\n\n    @property\n    def body(self) -&gt; Element | None:\n        return self.get_element(\"text:index-body\")\n\n    @body.setter\n    def body(self, body: Element | None = None) -&gt; Element | None:\n        old_body = self.body\n        if old_body is not None:\n            self.delete(old_body)\n        if body is None:\n            body = Element.from_tag(\"text:index-body\")\n        self.append(body)\n        return body\n\n    def get_title(self) -&gt; str:\n        index_body = self.body\n        if index_body is None:\n            return \"\"\n        index_title = index_body.get_element(IndexTitle._tag)\n        if index_title is None:\n            return \"\"\n        return index_title.text_content\n\n    def set_toc_title(\n        self,\n        title: str,\n        style: str | None = None,\n        text_style: str | None = None,\n    ) -&gt; None:\n        index_body = self.body\n        if index_body is None:\n            self.body = None\n            index_body = self.body\n        index_title = index_body.get_element(IndexTitle._tag)  # type: ignore\n        if index_title is None:\n            name = f\"{self.name}_Head\"\n            index_title = IndexTitle(\n                name=name, style=style, title_text=title, text_style=text_style\n            )\n            index_body.append(index_title)  # type: ignore\n        else:\n            if style:\n                index_title.style = style  # type: ignore\n            paragraph = index_title.get_paragraph()\n            if paragraph is None:\n                paragraph = Paragraph()\n                index_title.append(paragraph)\n            if text_style:\n                paragraph.style = text_style  # type: ignore\n            paragraph.text = title\n\n    @staticmethod\n    def _header_numbering(level_indexes: dict[int, int], level: int) -&gt; str:\n        \"\"\"Return the header hierarchical number (like \"1.2.3.\").\"\"\"\n        numbers: list[int] = []\n        # before header level\n        for idx in range(1, level):\n            numbers.append(level_indexes.setdefault(idx, 1))\n        # header level\n        index = level_indexes.get(level, 0) + 1\n        level_indexes[level] = index\n        numbers.append(index)\n        # after header level\n        idx = level + 1\n        while idx in level_indexes:\n            del level_indexes[idx]\n            idx += 1\n        return \".\".join(str(x) for x in numbers) + \".\"\n\n    def fill(\n        self,\n        document: Document | None = None,\n        use_default_styles: bool = True,\n    ) -&gt; None:\n        \"\"\"Fill the TOC with the titles found in the document. A TOC is not\n        contextual so it will catch all titles before and after its insertion.\n        If the TOC is not attached to a document, attach it beforehand or\n        provide one as argument.\n\n        For having a pretty TOC, let use_default_styles by default.\n\n        Arguments:\n\n            document -- Document\n\n            use_default_styles -- bool\n        \"\"\"\n        # Find the body\n        if document is not None:\n            body: Element | None = document.body\n        else:\n            body = self.document_body\n        if body is None:\n            raise ValueError(\"The TOC must be related to a document somehow\")\n\n        # Save the title\n        index_body = self.body\n        title = index_body.get_element(\"text:index-title\")  # type: ignore\n\n        # Clean the old index-body\n        self.body = None\n        index_body = self.body\n\n        # Restore the title\n        if title and str(title):\n            index_body.insert(title, position=0)  # type: ignore\n\n        # Insert default TOC style\n        if use_default_styles:\n            automatic_styles = body.get_element(\"//office:automatic-styles\")\n            if isinstance(automatic_styles, Element):\n                for level in range(1, 11):\n                    if (\n                        automatic_styles.get_style(\n                            \"paragraph\", _toc_entry_style_name(level)\n                        )\n                        is None\n                    ):\n                        level_style = default_toc_level_style(level)\n                        automatic_styles.append(level_style)\n\n        # Auto-fill the index\n        outline_level = self.outline_level or 10\n        level_indexes: dict[int, int] = {}\n        for header in body.headers:\n            level = header.get_attribute_integer(\"text:outline-level\") or 0\n            if level is None or level &gt; outline_level:\n                continue\n            number_str = self._header_numbering(level_indexes, level)\n            # Make the title with \"1.2.3. Title\" format\n            paragraph = Paragraph(f\"{number_str} {header}\")\n            if use_default_styles:\n                paragraph.style = _toc_entry_style_name(level)\n            index_body.append(paragraph)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.TOC.fill","title":"<code>fill(document=None, use_default_styles=True)</code>","text":"<p>Fill the TOC with the titles found in the document. A TOC is not contextual so it will catch all titles before and after its insertion. If the TOC is not attached to a document, attach it beforehand or provide one as argument.</p> <p>For having a pretty TOC, let use_default_styles by default.</p> <p>Arguments:</p> <pre><code>document -- Document\n\nuse_default_styles -- bool\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>def fill(\n    self,\n    document: Document | None = None,\n    use_default_styles: bool = True,\n) -&gt; None:\n    \"\"\"Fill the TOC with the titles found in the document. A TOC is not\n    contextual so it will catch all titles before and after its insertion.\n    If the TOC is not attached to a document, attach it beforehand or\n    provide one as argument.\n\n    For having a pretty TOC, let use_default_styles by default.\n\n    Arguments:\n\n        document -- Document\n\n        use_default_styles -- bool\n    \"\"\"\n    # Find the body\n    if document is not None:\n        body: Element | None = document.body\n    else:\n        body = self.document_body\n    if body is None:\n        raise ValueError(\"The TOC must be related to a document somehow\")\n\n    # Save the title\n    index_body = self.body\n    title = index_body.get_element(\"text:index-title\")  # type: ignore\n\n    # Clean the old index-body\n    self.body = None\n    index_body = self.body\n\n    # Restore the title\n    if title and str(title):\n        index_body.insert(title, position=0)  # type: ignore\n\n    # Insert default TOC style\n    if use_default_styles:\n        automatic_styles = body.get_element(\"//office:automatic-styles\")\n        if isinstance(automatic_styles, Element):\n            for level in range(1, 11):\n                if (\n                    automatic_styles.get_style(\n                        \"paragraph\", _toc_entry_style_name(level)\n                    )\n                    is None\n                ):\n                    level_style = default_toc_level_style(level)\n                    automatic_styles.append(level_style)\n\n    # Auto-fill the index\n    outline_level = self.outline_level or 10\n    level_indexes: dict[int, int] = {}\n    for header in body.headers:\n        level = header.get_attribute_integer(\"text:outline-level\") or 0\n        if level is None or level &gt; outline_level:\n            continue\n        number_str = self._header_numbering(level_indexes, level)\n        # Make the title with \"1.2.3. Title\" format\n        paragraph = Paragraph(f\"{number_str} {header}\")\n        if use_default_styles:\n            paragraph.style = _toc_entry_style_name(level)\n        index_body.append(paragraph)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Tab","title":"<code>Tab</code>","text":"<p>               Bases: <code>MDTab</code>, <code>Element</code></p> <p>This element represents the [UNICODE] tab character (HORIZONTAL TABULATION, U+0009).</p> <p>The position attribute contains the number of the tab-stop to which a tab character refers. The position 0 marks the start margin of a paragraph. Note: The position attribute is only a hint to help non-layout oriented consumers to determine the tab/tab-stop association. Layout oriented consumers should determine the tab positions based on the style information</p> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>class Tab(MDTab, Element):\n    \"\"\"This element represents the [UNICODE] tab character (HORIZONTAL\n    TABULATION, U+0009).\n\n    The position attribute contains the number of the tab-stop to which\n    a tab character refers. The position 0 marks the start margin of a\n    paragraph. Note: The position attribute is only a hint to help non-layout\n    oriented consumers to determine the tab/tab-stop association. Layout\n    oriented consumers should determine the tab positions based on the style\n    information\n    \"\"\"\n\n    _tag = \"text:tab\"\n    _properties: tuple[PropDef, ...] = (PropDef(\"position\", \"text:tab-ref\"),)\n\n    def __init__(self, position: int | None = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Arguments:\n\n            position -- int\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init and position is not None and position &gt;= 0:\n            self.position = str(position)\n\n    def __str__(self) -&gt; str:\n        return \"\\t\"\n\n    @property\n    def text(self) -&gt; str:\n        return \"\\t\"\n</code></pre>"},{"location":"reference.html#odfdo.Tab.__init__","title":"<code>__init__(position=None, **kwargs)</code>","text":"<p>Arguments:</p> <pre><code>position -- int\n</code></pre> Source code in <code>odfdo/paragraph_base.py</code> <pre><code>def __init__(self, position: int | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        position -- int\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init and position is not None and position &gt;= 0:\n        self.position = str(position)\n</code></pre>"},{"location":"reference.html#odfdo.TabStopStyle","title":"<code>TabStopStyle</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF \u201cstyle:tab-stop\u201d Base style for a TOC entryBase style for a TOC entry</p> Source code in <code>odfdo/toc.py</code> <pre><code>class TabStopStyle(Element):\n    \"\"\"ODF \"style:tab-stop\"\n    Base style for a TOC entryBase style for a TOC entry\n    \"\"\"\n\n    _tag = \"style:tab-stop\"\n    _properties = (\n        PropDef(\"style_char\", \"style:char\"),\n        PropDef(\"leader_color\", \"style:leader-color\"),\n        PropDef(\"leader_style\", \"style:leader-style\"),\n        PropDef(\"leader_text\", \"style:leader-text\"),\n        PropDef(\"leader_text_style\", \"style:leader-text-style\"),\n        PropDef(\"leader_type\", \"style:leader-type\"),\n        PropDef(\"leader_width\", \"style:leader-width\"),\n        PropDef(\"style_position\", \"style:position\"),\n        PropDef(\"style_type\", \"style:type\"),\n    )\n\n    def __init__(\n        self,\n        style_char: str | None = None,\n        leader_color: str | None = None,\n        leader_style: str | None = None,\n        leader_text: str | None = None,\n        leader_text_style: str | None = None,\n        leader_type: str | None = None,\n        leader_width: str | None = None,\n        style_position: str | None = None,\n        style_type: str | None = None,\n        **kwargs: Any,\n    ):\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style_char:\n                self.style_char = style_char\n            if leader_color:\n                self.leader_color = leader_color\n            if leader_style:\n                self.leader_style = leader_style\n            if leader_text:\n                self.leader_text = leader_text\n            if leader_text_style:\n                self.leader_text_style = leader_text_style\n            if leader_type:\n                self.leader_type = leader_type\n            if leader_width:\n                self.leader_width = leader_width\n            if style_position:\n                self.style_position = style_position\n            if style_type:\n                self.style_type = style_type\n</code></pre>"},{"location":"reference.html#odfdo.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>MDTable</code>, <code>CachedElement</code></p> <p>ODF table \u201ctable:table\u201d</p> Source code in <code>odfdo/table.py</code> <pre><code>class Table(MDTable, CachedElement):\n    \"\"\"ODF table \"table:table\" \"\"\"\n\n    _tag = \"table:table\"\n    _append = Element.append\n\n    def __init__(\n        self,\n        name: str | None = None,\n        width: int | str | None = None,\n        height: int | str | None = None,\n        protected: bool = False,\n        protection_key: str | None = None,\n        printable: bool = True,\n        print_ranges: list[str] | None = None,\n        style: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create a table element, optionally prefilled with \"height\" rows of\n        \"width\" cells each.\n\n        The \"name\" parameter is required and cannot contain []*?:/ or \\\\\n        characters, ' (apostrophe) cannot be the first or last character.\n\n        If the table is to be protected, a protection key must be provided,\n        i.e. a hash value of the password.\n\n        If the table must not be printed, set \"printable\" to False. The table\n        will not be printed when it is not displayed, whatever the value of\n        this argument.\n\n        Ranges of cells to print can be provided as a list of cell ranges,\n        e.g. ['E6:K12', 'P6:R12'] or directly as a raw string, e.g.\n        \"E6:K12 P6:R12\".\n\n        You can access and modify the XML tree manually, but you probably want\n        to use the API to access and alter cells. It will save you from\n        handling repetitions and the same number of cells for each row.\n\n        If you use both the table API and the XML API, you are on your own for\n        ensuiring model integrity.\n\n        Arguments:\n\n            name -- str\n\n            width -- int | str\n\n            height -- int | str\n\n            protected -- bool\n\n            protection_key -- str\n\n            printable -- bool\n\n            print_ranges -- list\n\n            style -- str\n        \"\"\"\n        super().__init__(**kwargs)\n        self._indexes = {}\n        self._indexes[\"_cmap\"] = {}\n        self._indexes[\"_tmap\"] = {}\n        if self._do_init:\n            self.name = name\n            if protected:\n                self.protected = protected\n                self.set_protection_key = protection_key\n            if not printable:\n                self.printable = printable\n            if print_ranges:\n                self.print_ranges = print_ranges\n            if style:\n                self.style = style\n            # Prefill the table\n            if width is not None or height is not None:\n                width = int(width or 1)\n                height = int(height or 1)\n                # Column groups for style information\n                columns = Column(repeated=width)\n                self._append(columns)\n                for _i in range(height):\n                    row = Row(width)\n                    self._append(row)\n        self._compute_table_cache()\n\n    def __str__(self) -&gt; str:\n        def write_content(csv_writer: object) -&gt; None:\n            for values in self.iter_values():\n                line = []\n                for value in values:\n                    if value is None:\n                        value = \"\"\n                    if isinstance(value, str):\n                        value = value.strip()\n                    line.append(value)\n                csv_writer.writerow(line)  # type: ignore\n\n        out = StringIO(newline=os.linesep)\n        csv_writer = csv.writer(\n            out,\n            delimiter=\" \",\n            doublequote=False,\n            escapechar=\"\\\\\",\n            lineterminator=os.linesep,\n            quotechar='\"',\n            quoting=csv.QUOTE_NONNUMERIC,\n        )\n        write_content(csv_writer)\n        return out.getvalue()\n\n    def _translate_y_from_any(self, y: str | int) -&gt; int:\n        # \"3\" (couting from 1) -&gt; 2 (couting from 0)\n        return translate_from_any(y, self.height, 1)\n\n    def _translate_table_coordinates_list(\n        self,\n        coord: tuple | list,\n    ) -&gt; tuple[int | None, ...]:\n        height = self.height\n        width = self.width\n        # assuming we got int values\n        if len(coord) == 1:\n            # It is a row\n            y = coord[0]\n            if y and y &lt; 0:\n                y = increment(y, height)\n            return (None, y, None, y)\n        if len(coord) == 2:\n            # It is a row range, not a cell, because context is table\n            y = coord[0]\n            if y and y &lt; 0:\n                y = increment(y, height)\n            t = coord[1]\n            if t and t &lt; 0:\n                t = increment(t, height)\n            return (None, y, None, t)\n        # should be 4 int\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_table_coordinates_str(\n        self,\n        coord_str: str,\n    ) -&gt; tuple[int | None, ...]:\n        height = self.height\n        width = self.width\n        coord = convert_coordinates(coord_str)\n        if len(coord) == 2:\n            x, y = coord\n            if x and x &lt; 0:\n                x = increment(x, width)\n            if y and y &lt; 0:\n                y = increment(y, height)\n            # extent to an area :\n            return (x, y, x, y)\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_table_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, ...]:\n        if isinstance(coord, str):\n            return self._translate_table_coordinates_str(coord)\n        return self._translate_table_coordinates_list(coord)\n\n    def _translate_column_coordinates_str(\n        self,\n        coord_str: str,\n    ) -&gt; tuple[int | None, ...]:\n        width = self.width\n        height = self.height\n        coord = convert_coordinates(coord_str)\n        if len(coord) == 2:\n            x, y = coord\n            if x and x &lt; 0:\n                x = increment(x, width)\n            if y and y &lt; 0:\n                y = increment(y, height)\n            # extent to an area :\n            return (x, y, x, y)\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_column_coordinates_list(\n        self,\n        coord: tuple | list,\n    ) -&gt; tuple[int | None, ...]:\n        width = self.width\n        height = self.height\n        # assuming we got int values\n        if len(coord) == 1:\n            # It is a column\n            x = coord[0]\n            if x and x &lt; 0:\n                x = increment(x, width)\n            return (x, None, x, None)\n        if len(coord) == 2:\n            # It is a column range, not a cell, because context is table\n            x = coord[0]\n            if x and x &lt; 0:\n                x = increment(x, width)\n            z = coord[1]\n            if z and z &lt; 0:\n                z = increment(z, width)\n            return (x, None, z, None)\n        # should be 4 int\n        x, y, z, t = coord\n        if x and x &lt; 0:\n            x = increment(x, width)\n        if y and y &lt; 0:\n            y = increment(y, height)\n        if z and z &lt; 0:\n            z = increment(z, width)\n        if t and t &lt; 0:\n            t = increment(t, height)\n        return (x, y, z, t)\n\n    def _translate_column_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, ...]:\n        if isinstance(coord, str):\n            return self._translate_column_coordinates_str(coord)\n        return self._translate_column_coordinates_list(coord)\n\n    def _translate_cell_coordinates(\n        self,\n        coord: tuple | list | str,\n    ) -&gt; tuple[int | None, int | None]:\n        # we want an x,y result\n        coord = convert_coordinates(coord)\n        if len(coord) == 2:\n            x, y = coord\n        # If we got an area, take the first cell\n        elif len(coord) == 4:\n            x, y, _z, _t = coord\n        else:\n            raise ValueError(str(coord))\n        if x and x &lt; 0:\n            x = increment(x, self.width)\n        if y and y &lt; 0:\n            y = increment(y, self.height)\n        return (x, y)\n\n    def _compute_table_cache(self) -&gt; None:\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_row, \"table:number-rows-repeated\"\n        )\n        self._tmap = make_cache_map(idx_repeated_seq)\n        idx_repeated_seq = self.elements_repeated_sequence(\n            _xpath_column, \"table:number-columns-repeated\"\n        )\n        self._cmap = make_cache_map(idx_repeated_seq)\n\n    def _update_width(self, row: Row) -&gt; None:\n        \"\"\"Synchronize the number of columns if the row is bigger.\n\n        Append, don't insert, not to disturb the current layout.\n        \"\"\"\n        diff = row.width - self.width\n        if diff &gt; 0:\n            self.append_column(Column(repeated=diff))\n\n    def _get_formatted_text_normal(self, context: dict | None) -&gt; str:\n        result = []\n        for row in self.traverse():\n            for cell in row.traverse():\n                value = cell.get_value(try_get_text=False)\n                # None ?\n                if value is None:\n                    # Try with get_formatted_text on the elements\n                    value = []\n                    for element in cell.children:\n                        value.append(element.get_formatted_text(context))\n                    value = \"\".join(value)\n                else:\n                    value = str(value)\n                result.append(value)\n                result.append(\"\\n\")\n            result.append(\"\\n\")\n        return \"\".join(result)\n\n    def _get_formatted_text_rst(self, context: dict) -&gt; str:\n        context[\"no_img_level\"] += 1\n        # Strip the table =&gt; We must clone\n        table = self.clone\n        table.rstrip(aggressive=True)  # type: ignore\n\n        # Fill the rows\n        rows = []\n        cols_nb = 0\n        cols_size: dict[int, int] = {}\n        for odf_row in table.traverse():  # type: ignore\n            row = []\n            for i, cell in enumerate(odf_row.traverse()):\n                value = cell.get_value(try_get_text=False)\n                # None ?\n                if value is None:\n                    # Try with get_formatted_text on the elements\n                    value = []\n                    for element in cell.children:\n                        value.append(element.get_formatted_text(context))\n                    value = \"\".join(value)\n                else:\n                    value = str(value)\n                value = value.strip()\n                # Strip the empty columns\n                if value:\n                    cols_nb = max(cols_nb, i + 1)\n                # Compute the size of each columns (at least 2)\n                cols_size[i] = max(cols_size.get(i, 2), len(value))\n                # Append\n                row.append(value)\n            rows.append(row)\n\n        # Nothing ?\n        if cols_nb == 0:\n            return \"\"\n\n        # Prevent a crash with empty columns (by example with images)\n        for col, size in cols_size.items():\n            if size == 0:\n                cols_size[col] = 1\n\n        # Update cols_size\n        LINE_MAX = 100\n        COL_MIN = 16\n\n        free_size = LINE_MAX - (cols_nb - 1) * 3 - 4\n        real_size = sum(cols_size[i] for i in range(cols_nb))\n        if real_size &gt; free_size:\n            factor = float(free_size) / real_size\n\n            for i in range(cols_nb):\n                old_size = cols_size[i]\n\n                # The cell is already small\n                if old_size &lt;= COL_MIN:\n                    continue\n\n                new_size = int(factor * old_size)\n\n                if new_size &lt; COL_MIN:\n                    new_size = COL_MIN\n                cols_size[i] = new_size\n\n        # Convert !\n        result: list[str] = [\"\"]\n        # Construct the first/last line\n        line: list[str] = []\n        for i in range(cols_nb):\n            line.append(\"=\" * cols_size[i])\n            line.append(\" \")\n        line_str = \"\".join(line)\n\n        # Add the lines\n        result.append(line_str)\n        for row in rows:\n            # Wrap the row\n            wrapped_row = []\n            for i, value in enumerate(row[:cols_nb]):\n                wrapped_value = []\n                for part in value.split(\"\\n\"):\n                    # Hack to handle correctly the lists or the directives\n                    subsequent_indent = \"\"\n                    part_lstripped = part.lstrip()\n                    if part_lstripped.startswith(\"-\") or part_lstripped.startswith(\n                        \"..\"\n                    ):\n                        subsequent_indent = \" \" * (len(part) - len(part.lstrip()) + 2)\n                    wrapped_part = wrap(\n                        part, width=cols_size[i], subsequent_indent=subsequent_indent\n                    )\n                    if wrapped_part:\n                        wrapped_value.extend(wrapped_part)\n                    else:\n                        wrapped_value.append(\"\")\n                wrapped_row.append(wrapped_value)\n\n            # Append!\n            for j in range(max([1] + [len(values) for values in wrapped_row])):\n                txt_row: list[str] = []\n                for i in range(cols_nb):\n                    values = wrapped_row[i] if i &lt; len(wrapped_row) else []\n\n                    # An empty cell ?\n                    if len(values) - 1 &lt; j or not values[j]:\n                        if i == 0 and j == 0:\n                            txt_row.append(\"..\")\n                            txt_row.append(\" \" * (cols_size[i] - 1))\n                        else:\n                            txt_row.append(\" \" * (cols_size[i] + 1))\n                        continue\n\n                    # Not empty\n                    value = values[j]\n                    txt_row.append(value)\n                    txt_row.append(\" \" * (cols_size[i] - len(value) + 1))\n                result.append(\"\".join(txt_row))\n\n        result.append(line_str)\n        result.append(\"\")\n        result.append(\"\")\n        result_str = \"\\n\".join(result)\n\n        context[\"no_img_level\"] -= 1\n        return result_str\n\n    def _translate_x_from_any(self, x: str | int) -&gt; int:\n        return translate_from_any(x, self.width, 0)\n\n    #\n    # Public API\n    #\n\n    def append(self, something: Element | str) -&gt; None:\n        \"\"\"Dispatch .append() call to append_row() or append_column().\"\"\"\n        if isinstance(something, Row):\n            self.append_row(something)\n        elif isinstance(something, Column):\n            self.append_column(something)\n        else:\n            # probably still an error\n            self._append(something)\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Get the current height of the table.\n\n        Return: int\n        \"\"\"\n        try:\n            height = self._tmap[-1] + 1\n        except Exception:\n            height = 0\n        return height\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Get the current width of the table, measured on columns.\n\n        Rows may have different widths, use the Table API to ensure width\n        consistency.\n\n        Return: int\n        \"\"\"\n        # Columns are our reference for user expected width\n\n        try:\n            width = self._cmap[-1] + 1\n        except Exception:\n            width = 0\n\n        # columns = self._get_columns()\n        # repeated = self.xpath(\n        #        'table:table-column/@table:number-columns-repeated')\n        # unrepeated = len(columns) - len(repeated)\n        # ws = sum(int(r) for r in repeated) + unrepeated\n        # if w != ws:\n        #    print \"WARNING   ws\", ws, \"w\", w\n\n        return width\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        \"\"\"Shortcut to get the current width and height of the table.\n\n        Return: (int, int)\n        \"\"\"\n        return self.width, self.height\n\n    @property\n    def name(self) -&gt; str | None:\n        \"\"\"Get / set the name of the table.\n\n        The \"name\" parameter is required and cannot contain []*?:/ or \\\\\n        characters, ' (apostrophe) cannot be the first or last character.\n        \"\"\"\n        return self.get_attribute_string(\"table:name\")\n\n    @name.setter\n    def name(self, name: str | None) -&gt; None:\n        name = _table_name_check(name)\n        # first, update named ranges\n        # fixme : delete name ranges when deleting table, too.\n        for named_range in self.get_named_ranges(table_name=self.name):\n            named_range.set_table_name(name)\n        self.set_attribute(\"table:name\", name)\n\n    @property\n    def protected(self) -&gt; bool:\n        return bool(self.get_attribute(\"table:protected\"))\n\n    @protected.setter\n    def protected(self, protect: bool) -&gt; None:\n        self.set_attribute(\"table:protected\", protect)\n\n    @property\n    def protection_key(self) -&gt; str | None:\n        return self.get_attribute_string(\"table:protection-key\")\n\n    @protection_key.setter\n    def protection_key(self, key: str) -&gt; None:\n        self.set_attribute(\"table:protection-key\", key)\n\n    @property\n    def printable(self) -&gt; bool:\n        printable = self.get_attribute(\"table:print\")\n        # Default value\n        if printable is None:\n            return True\n        return bool(printable)\n\n    @printable.setter\n    def printable(self, printable: bool) -&gt; None:\n        self.set_attribute(\"table:print\", printable)\n\n    @property\n    def print_ranges(self) -&gt; list[str]:\n        ranges = self.get_attribute_string(\"table:print-ranges\")\n        if isinstance(ranges, str):\n            return ranges.split()\n        return []\n\n    @print_ranges.setter\n    def print_ranges(self, ranges: list[str] | None) -&gt; None:\n        if isinstance(ranges, (list, tuple)):\n            self.set_attribute(\"table:print-ranges\", \" \".join(ranges))\n        else:\n            self.set_attribute(\"table:print-ranges\", ranges)\n\n    @property\n    def style(self) -&gt; str | None:\n        \"\"\"Get / set the style of the table\n\n        Return: str\n        \"\"\"\n        return self.get_attribute_string(\"table:style-name\")\n\n    @style.setter\n    def style(self, style: str | Element) -&gt; None:\n        self.set_style_attribute(\"table:style-name\", style)\n\n    def get_formatted_text(self, context: dict | None = None) -&gt; str:\n        if context and context[\"rst_mode\"]:\n            return self._get_formatted_text_rst(context)\n        return self._get_formatted_text_normal(context)\n\n    def get_values(\n        self,\n        coord: tuple | list | str | None = None,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n        flat: bool = False,\n    ) -&gt; list:\n        \"\"\"Get a matrix of values of the table.\n\n        Filter by coordinates will parse the area defined by the coordinates.\n\n        If 'cell_type' is used and 'complete' is True (default), missing values\n        are replaced by None.\n        Filter by ' cell_type = \"all\" ' will retrieve cells of any\n        type, aka non empty cells.\n\n        If 'cell_type' is None, complete is always True : with no cell type\n        queried, get_values() returns None for each empty cell, the length\n        each lists is equal to the width of the table.\n\n        If get_type is True, returns tuples (value, ODF type of value), or\n        (None, None) for empty cells with complete True.\n\n        If flat is True, the methods return a single list of all the values.\n        By default, flat is False.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of area\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of lists of Python types\n        \"\"\"\n        if coord:\n            x, y, z, t = self._translate_table_coordinates(coord)\n        else:\n            x = y = z = t = None\n        data = []\n        for row in self.traverse(start=y, end=t):\n            if z is None:\n                width = self.width\n            else:\n                width = min(z + 1, self.width)\n            if x is not None:\n                width -= x\n            values = row.get_values(\n                (x, z),\n                cell_type=cell_type,\n                complete=complete,\n                get_type=get_type,\n            )\n            # complete row to match request width\n            if complete:\n                if get_type:\n                    values.extend([(None, None)] * (width - len(values)))\n                else:\n                    values.extend([None] * (width - len(values)))\n            if flat:\n                data.extend(values)\n            else:\n                data.append(values)\n        return data\n\n    def iter_values(\n        self,\n        coord: tuple | list | str | None = None,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n    ) -&gt; Iterator[list]:\n        \"\"\"Iterate through lines of Python values of the table.\n\n        Filter by coordinates will parse the area defined by the coordinates.\n\n        cell_type, complete, grt_type : see get_values()\n\n\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of area\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: iterator of lists\n        \"\"\"\n        if coord:\n            x, y, z, t = self._translate_table_coordinates(coord)\n        else:\n            x = y = z = t = None\n        for row in self.traverse(start=y, end=t):\n            if z is None:\n                width = self.width\n            else:\n                width = min(z + 1, self.width)\n            if x is not None:\n                width -= x\n            values = row.get_values(\n                (x, z),\n                cell_type=cell_type,\n                complete=complete,\n                get_type=get_type,\n            )\n            # complete row to match column width\n            if complete:\n                if get_type:\n                    values.extend([(None, None)] * (width - len(values)))\n                else:\n                    values.extend([None] * (width - len(values)))\n            yield values\n\n    def set_values(\n        self,\n        values: list,\n        coord: tuple | list | str | None = None,\n        style: str | None = None,\n        cell_type: str | None = None,\n        currency: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set the value of cells in the table, from the 'coord' position\n        with values.\n\n        'coord' is the coordinate of the upper left cell to be modified by\n        values. If 'coord' is None, default to the position (0,0) (\"A1\").\n        If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n        area is used as coordinate.\n\n        The table is *not* cleared before the operation, to reset the table\n        before setting values, use table.clear().\n\n        A list of lists is expected, with as many lists as rows, and as many\n        items in each sublist as cells to be setted. None values in the list\n        will create empty cells with no cell type (but eventually a style).\n\n        Arguments:\n\n            coord -- tuple or str\n\n            values -- list of lists of python types\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n        \"\"\"\n        if coord:\n            x, y = self._translate_cell_coordinates(coord)\n        else:\n            x = y = 0\n        if y is None:\n            y = 0\n        if x is None:\n            x = 0\n        y -= 1\n        for row_values in values:\n            y += 1\n            if not row_values:\n                continue\n            row = self.get_row(y, clone=True)\n            repeated = row.repeated or 1\n            if repeated &gt;= 2:\n                row.repeated = None\n            row.set_values(\n                row_values,\n                start=x,\n                cell_type=cell_type,\n                currency=currency,\n                style=style,\n            )\n            self.set_row(y, row, clone=False)\n            self._update_width(row)\n\n    def rstrip(self, aggressive: bool = False) -&gt; None:\n        \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n        the table. Cells are empty if they contain no value or it evaluates\n        to False, and no style.\n\n        If aggressive is True, empty cells with style are removed too.\n\n        Argument:\n\n            aggressive -- bool\n        \"\"\"\n        # Step 1: remove empty rows below the table\n        for row in reversed(self._get_rows()):\n            if row.is_empty(aggressive=aggressive):\n                row.parent.delete(row)  # type: ignore\n            else:\n                break\n        # Step 2: rstrip remaining rows\n        max_width = 0\n        for row in self._get_rows():\n            row.rstrip(aggressive=aggressive)\n            # keep count of the biggest row\n            max_width = max(max_width, row.width)\n        # raz cache of rows\n        self._indexes[\"_tmap\"] = {}\n        # Step 3: trim columns to match max_width\n        columns = self._get_columns()\n        repeated_cols = self.xpath(\"table:table-column/@table:number-columns-repeated\")\n        if not isinstance(repeated_cols, list):\n            raise TypeError\n        unrepeated = len(columns) - len(repeated_cols)\n        column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore\n        diff = column_width - max_width\n        if diff &gt; 0:\n            for column in reversed(columns):\n                repeated = column.repeated or 1\n                repeated = repeated - diff\n                if repeated &gt; 0:\n                    column.repeated = repeated\n                    break\n                else:\n                    column.parent.delete(column)\n                    diff = -repeated\n                    if diff == 0:\n                        break\n        # raz cache of columns\n        self._indexes[\"_cmap\"] = {}\n        self._compute_table_cache()\n\n    def optimize_width(self) -&gt; None:\n        \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n        the table. Keep repeated styles of empty cells but minimize row width.\n        \"\"\"\n        self._optimize_width_trim_rows()\n        width = self._optimize_width_length()\n        self._optimize_width_rstrip_rows(width)\n        self._optimize_width_adapt_columns(width)\n\n    def _optimize_width_trim_rows(self) -&gt; None:\n        count = -1  # to keep one empty row\n        for row in reversed(self._get_rows()):\n            if row.is_empty(aggressive=False):\n                count += 1\n            else:\n                break\n        if count &gt; 0:\n            for row in reversed(self._get_rows()):\n                row.parent.delete(row)  # type: ignore\n                count -= 1\n                if count &lt;= 0:\n                    break\n        try:\n            last_row = self._get_rows()[-1]\n            last_row._set_repeated(None)\n        except IndexError:\n            pass\n        # raz cache of rows\n        self._indexes[\"_tmap\"] = {}\n\n    def _optimize_width_length(self) -&gt; int:\n        return max(row.minimized_width() for row in self._get_rows())\n\n    def _optimize_width_rstrip_rows(self, width: int) -&gt; None:\n        for row in self._get_rows():\n            row.force_width(width)\n\n    def _optimize_width_adapt_columns(self, width: int) -&gt; None:\n        # trim columns to match minimal_width\n        columns = self._get_columns()\n        repeated_cols = self.xpath(\"table:table-column/@table:number-columns-repeated\")\n        if not isinstance(repeated_cols, list):\n            raise TypeError\n        unrepeated = len(columns) - len(repeated_cols)\n        column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore\n        diff = column_width - width\n        if diff &gt; 0:\n            for column in reversed(columns):\n                repeated = column.repeated or 1\n                repeated = repeated - diff\n                if repeated &gt; 0:\n                    column.repeated = repeated\n                    break\n                else:\n                    column.parent.delete(column)\n                    diff = -repeated\n                    if diff == 0:\n                        break\n        # raz cache of columns\n        self._indexes[\"_cmap\"] = {}\n        self._compute_table_cache()\n\n    def transpose(self, coord: tuple | list | str | None = None) -&gt; None:\n        \"\"\"Swap *in-place* rows and columns of the table.\n\n        If 'coord' is not None, apply transpose only to the area defined by the\n        coordinates. Beware, if area is not square, some cells mays be over\n        written during the process.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of area\n\n            start -- int or str\n        \"\"\"\n        data = []\n        if coord is None:\n            for row in self.traverse():\n                data.append(list(row.traverse()))\n            transposed_data = zip_longest(*data)\n            self.clear()\n            # new_rows = []\n            for row_cells in transposed_data:\n                if not isiterable(row_cells):\n                    row_cells = (row_cells,)\n                row = Row()\n                row.extend_cells(row_cells)\n                self.append_row(row, clone=False)\n            self._compute_table_cache()\n        else:\n            x, y, z, t = self._translate_table_coordinates(coord)\n            if x is None:\n                x = 0\n            else:\n                x = min(x, self.width - 1)\n            if z is None:\n                z = self.width - 1\n            else:\n                z = min(z, self.width - 1)\n            if y is None:\n                y = 0\n            else:\n                y = min(y, self.height - 1)\n            if t is None:\n                t = self.height - 1\n            else:\n                t = min(t, self.height - 1)\n            for row in self.traverse(start=y, end=t):\n                data.append(list(row.traverse(start=x, end=z)))\n            transposed_data = zip_longest(*data)\n            # clear locally\n            w = z - x + 1\n            h = t - y + 1\n            if w != h:\n                nones = [[None] * w for i in range(h)]\n                self.set_values(nones, coord=(x, y, z, t))\n            # put transposed\n            filtered_data: list[tuple[Cell]] = []\n            for row_cells in transposed_data:\n                if isinstance(row_cells, (list, tuple)):\n                    filtered_data.append(row_cells)\n                else:\n                    filtered_data.append((row_cells,))\n            self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))\n            self._compute_table_cache()\n\n    def is_empty(self, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return whether every cell in the table has no value or the value\n        evaluates to False (empty string), and no style.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            aggressive -- bool\n        \"\"\"\n        return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())\n\n    #\n    # Rows\n    #\n\n    @property\n    def row_groups(self) -&gt; list[RowGroup]:\n        \"\"\"Get the list of all RowGroup.\n\n        Return: list of RowGroup\n        \"\"\"\n        return self.get_elements(_xpath_row_group)  # type: ignore\n\n    def _get_rows(self) -&gt; list[Row]:\n        return self.get_elements(_xpath_row)  # type: ignore\n\n    def traverse(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; Iterator[Row]:\n        \"\"\"Yield as many row elements as expected rows in the table, i.e.\n        expand repetitions by returning the same row as many times as\n        necessary.\n\n            Arguments:\n\n                start -- int\n\n                end -- int\n\n        Copies are returned, use set_row() to push them back.\n        \"\"\"\n        if start is None:\n            start = 0\n        start = max(0, start)\n        if end is None:\n            end = 2**32\n        if end &lt; start:\n            return\n        y = -1\n        for row in self._yield_odf_rows():\n            y += 1\n            if y &lt; start:\n                continue\n            if y &gt; end:\n                return\n            row.y = y\n            yield row\n\n    def get_rows(\n        self,\n        coord: tuple | list | str | None = None,\n        style: str | None = None,\n        content: str | None = None,\n    ) -&gt; list[Row]:\n        \"\"\"Get the list of rows matching the criteria.\n\n        Filter by coordinates will parse the area defined by the coordinates.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of rows\n\n            content -- str regex\n\n            style -- str\n\n        Return: list of rows\n        \"\"\"\n        if coord:\n            _x, y, _z, t = self._translate_table_coordinates(coord)\n        else:\n            y = t = None\n        # fixme : not clones ?\n        if not content and not style:\n            return list(self.traverse(start=y, end=t))\n        rows = []\n        for row in self.traverse(start=y, end=t):\n            if content and not row.match(content):\n                continue\n            if style and style != row.style:\n                continue\n            rows.append(row)\n        return rows\n\n    @property\n    def rows(self) -&gt; list[Row]:\n        \"\"\"Get the list of all rows.\n\n        Return: list of rows\n        \"\"\"\n        # fixme : not clones ?\n        return list(self.traverse())\n\n    def _yield_odf_rows(self):\n        for row in self._get_rows():\n            if row.repeated is None:\n                yield row\n            else:\n                for _ in range(row.repeated):\n                    row_copy = row.clone\n                    row_copy.repeated = None\n                    yield row_copy\n\n    def _get_row2(self, y: int, clone: bool = True, create: bool = True) -&gt; Row:\n        if y &gt;= self.height:\n            if create:\n                return Row()\n            raise ValueError(\"Row not found\")\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError(\"Row not found\")\n        if clone:\n            return row.clone\n        return row\n\n    def _get_row2_base(self, y: int) -&gt; Row | None:\n        idx = find_odf_idx(self._tmap, y)\n        if idx is not None:\n            if idx in self._indexes[\"_tmap\"]:\n                row = self._indexes[\"_tmap\"][idx]\n            else:\n                row = self._get_element_idx2(_xpath_row_idx, idx)\n                self._indexes[\"_tmap\"][idx] = row\n            return row\n        return None\n\n    def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:\n        \"\"\"Get the row at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        A copy is returned, use set_cell() to push it back.\n\n        Arguments:\n\n            y -- int or str\n\n        Return: Row\n        \"\"\"\n        # fixme : keep repeat ? maybe an option to functions : \"raw=False\"\n        y = self._translate_y_from_any(y)\n        row = self._get_row2(y, clone=clone, create=create)\n        if row is None:\n            raise ValueError(\"Row not found\")\n        row.y = y\n        return row\n\n    def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:\n        \"\"\"Replace the row at the given position with the new one. Repetions of\n        the old row will be adjusted.\n\n        If row is None, a new empty row is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n\n            row -- Row\n\n        returns the row, with updated row.y\n        \"\"\"\n        if row is None:\n            row = Row()\n            repeated = 1\n            clone = False\n        else:\n            repeated = row.repeated or 1\n        y = self._translate_y_from_any(y)\n        row.y = y\n        # Outside the defined table ?\n        diff = y - self.height\n        if diff == 0:\n            row_back = self.append_row(row, _repeated=repeated, clone=clone)\n        elif diff &gt; 0:\n            self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)\n            row_back = self.append_row(row, _repeated=repeated, clone=clone)\n        else:\n            # Inside the defined table\n            row_back = set_item_in_vault(  # type: ignore\n                y, row, self, _xpath_row_idx, \"_tmap\", clone=clone\n            )\n        # print self.serialize(True)\n        # Update width if necessary\n        self._update_width(row_back)\n        return row_back\n\n    def insert_row(\n        self, y: str | int, row: Row | None = None, clone: bool = True\n    ) -&gt; Row:\n        \"\"\"Insert the row before the given \"y\" position. If no row is given,\n        an empty one is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        If row is None, a new empty row is created.\n\n        Arguments:\n\n            y -- int or str\n\n            row -- Row\n\n        returns the row, with updated row.y\n        \"\"\"\n        if row is None:\n            row = Row()\n            clone = False\n        y = self._translate_y_from_any(y)\n        diff = y - self.height\n        if diff &lt; 0:\n            row_back = insert_item_in_vault(y, row, self, _xpath_row_idx, \"_tmap\")\n        elif diff == 0:\n            row_back = self.append_row(row, clone=clone)\n        else:\n            self.append_row(Row(repeated=diff), _repeated=diff, clone=False)\n            row_back = self.append_row(row, clone=clone)\n        row_back.y = y  # type: ignore\n        # Update width if necessary\n        self._update_width(row_back)  # type: ignore\n        return row_back  # type: ignore\n\n    def extend_rows(self, rows: list[Row] | None = None) -&gt; None:\n        \"\"\"Append a list of rows at the end of the table.\n\n        Arguments:\n\n            rows -- list of Row\n        \"\"\"\n        if rows is None:\n            rows = []\n        self.extend(rows)\n        self._compute_table_cache()\n        # Update width if necessary\n        width = self.width\n        for row in self.traverse():\n            if row.width &gt; width:\n                width = row.width\n        diff = width - self.width\n        if diff &gt; 0:\n            self.append_column(Column(repeated=diff))\n\n    def append_row(\n        self,\n        row: Row | None = None,\n        clone: bool = True,\n        _repeated: int | None = None,\n    ) -&gt; Row:\n        \"\"\"Append the row at the end of the table. If no row is given, an\n        empty one is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Note the columns are automatically created when the first row is\n        inserted in an empty table. So better insert a filled row.\n\n        Arguments:\n\n            row -- Row\n\n            _repeated -- (optional), repeated value of the row\n\n        returns the row, with updated row.y\n        \"\"\"\n        if row is None:\n            row = Row()\n            _repeated = 1\n        elif clone:\n            row = row.clone\n        # Appending a repeated row accepted\n        # Do not insert next to the last row because it could be in a group\n        self._append(row)\n        if _repeated is None:\n            _repeated = row.repeated or 1\n        self._tmap = insert_map_once(self._tmap, len(self._tmap), _repeated)\n        row.y = self.height - 1\n        # Initialize columns\n        if not self._get_columns():\n            repeated = row.width\n            self.insert(Column(repeated=repeated), position=0)\n            self._compute_table_cache()\n        # Update width if necessary\n        self._update_width(row)\n        return row\n\n    def delete_row(self, y: int | str) -&gt; None:\n        \"\"\"Delete the row at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n        \"\"\"\n        y = self._translate_y_from_any(y)\n        # Outside the defined table\n        if y &gt;= self.height:\n            return\n        # Inside the defined table\n        delete_item_in_vault(y, self, _xpath_row_idx, \"_tmap\")\n\n    def get_row_values(\n        self,\n        y: int | str,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n    ) -&gt; list:\n        \"\"\"Shortcut to get the list of Python values for the cells of the row\n        at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n        If cell_type and complete is True, replace missing values by None.\n\n        If get_type is True, returns a tuple (value, ODF type of value)\n\n        Arguments:\n\n            y -- int, str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of lists of Python types\n        \"\"\"\n        values = self.get_row(y, clone=False).get_values(\n            cell_type=cell_type, complete=complete, get_type=get_type\n        )\n        # complete row to match column width\n        if complete:\n            if get_type:\n                values.extend([(None, None)] * (self.width - len(values)))\n            else:\n                values.extend([None] * (self.width - len(values)))\n        return values\n\n    def get_row_sub_elements(self, y: int | str) -&gt; list[Any]:\n        \"\"\"Shortcut to get the list of Elements values for the cells of the row\n        at the given \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Missing values replaced by None.\n\n        Arguments:\n\n            y -- int, str\n\n        Return: list of lists of Elements\n        \"\"\"\n        values = self.get_row(y, clone=False).get_sub_elements()\n        values.extend([None] * (self.width - len(values)))\n        return values\n\n    def set_row_values(\n        self,\n        y: int | str,\n        values: list,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; Row:\n        \"\"\"Shortcut to set the values of *all* cells of the row at the given\n        \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n\n            values -- list of Python types\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n\n        returns the row, with updated row.y\n        \"\"\"\n        row = Row()  # needed if clones rows\n        row.set_values(values, style=style, cell_type=cell_type, currency=currency)\n        return self.set_row(y, row)  # needed if clones rows\n\n    def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:\n        \"\"\"Shortcut to set *all* the cells of the row at the given\n        \"y\" position.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Arguments:\n\n            y -- int or str\n\n            cells -- list of Python types\n\n            style -- str\n\n        returns the row, with updated row.y\n        \"\"\"\n        if cells is None:\n            cells = []\n        row = Row()  # needed if clones rows\n        row.extend_cells(cells)\n        return self.set_row(y, row)  # needed if clones rows\n\n    def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return wether every cell in the row at the given \"y\" position has\n        no value or the value evaluates to False (empty string), and no style.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Arguments:\n\n            y -- int or str\n\n            aggressive -- bool\n        \"\"\"\n        return self.get_row(y, clone=False).is_empty(aggressive=aggressive)\n\n    #\n    # Cells\n    #\n\n    def get_cells(\n        self,\n        coord: tuple | list | str | None = None,\n        cell_type: str | None = None,\n        style: str | None = None,\n        content: str | None = None,\n        flat: bool = False,\n    ) -&gt; list:\n        \"\"\"Get the cells matching the criteria. If 'coord' is None,\n        parse the whole table, else parse the area defined by 'coord'.\n\n        Filter by  cell_type = \"all\"  will retrieve cells of any\n        type, aka non empty cells.\n\n        If flat is True (default is False), the method return a single list\n        of all the values, else a list of lists of cells.\n\n        if cell_type, style and content are None, get_cells() will return\n        the exact number of cells of the area, including empty cells.\n\n        Arguments:\n\n            coordinates -- str or tuple of int : coordinates of area\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            content -- str regex\n\n            style -- str\n\n            flat -- boolean\n\n        Return: list of list of Cell\n        \"\"\"\n        if coord:\n            x, y, z, t = self._translate_table_coordinates(coord)\n        else:\n            x = y = z = t = None\n        if flat:\n            cells: list[Cell] = []\n            for row in self.traverse(start=y, end=t):\n                row_cells = row.get_cells(\n                    coord=(x, z),\n                    cell_type=cell_type,\n                    style=style,\n                    content=content,\n                )\n                cells.extend(row_cells)\n            return cells\n        else:\n            lcells: list[list[Cell]] = []\n            for row in self.traverse(start=y, end=t):\n                row_cells = row.get_cells(\n                    coord=(x, z),\n                    cell_type=cell_type,\n                    style=style,\n                    content=content,\n                )\n                lcells.append(row_cells)\n            return lcells\n\n    @property\n    def cells(self) -&gt; list:\n        \"\"\"Get all cells of the table.\n\n        Return: list of list of Cell\n        \"\"\"\n        lcells: list[list[Cell]] = []\n        for row in self.traverse():\n            lcells.append(row.cells)\n        return lcells\n\n    def get_cell(\n        self,\n        coord: tuple | list | str,\n        clone: bool = True,\n        keep_repeated: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Get the cell at the given coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        A copy is returned, use ``set_cell`` to push it back.\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n        Return: Cell\n        \"\"\"\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        # Outside the defined table\n        if y &gt;= self.height:\n            cell = Cell()\n        else:\n            # Inside the defined table\n            row = self._get_row2_base(y)\n            if row is None:\n                raise ValueError\n            read_cell = row.get_cell(x, clone=clone)\n            if read_cell is None:\n                raise ValueError\n            cell = read_cell\n            if not keep_repeated:\n                repeated = cell.repeated or 1\n                if repeated &gt;= 2:\n                    cell.repeated = None\n        cell.x = x\n        cell.y = y\n        return cell\n\n    def get_value(\n        self,\n        coord: tuple | list | str,\n        get_type: bool = False,\n    ) -&gt; Any:\n        \"\"\"Shortcut to get the Python value of the cell at the given\n        coordinates.\n\n        If get_type is True, returns the tuples (value, ODF type)\n\n        coord is either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\". If an Area is given, the upper\n        left position is used as coord.\n\n        Arguments:\n\n            coord -- (int, int) or str : coordinate\n\n        Return: Python type\n        \"\"\"\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        # Outside the defined table\n        if y &gt;= self.height:\n            if get_type:\n                return (None, None)\n            return None\n        else:\n            # Inside the defined table\n            row = self._get_row2_base(y)\n            if row is None:\n                raise ValueError\n            cell = row._get_cell2_base(x)\n            if cell is None:\n                if get_type:\n                    return (None, None)\n                return None\n            return cell.get_value(get_type=get_type)\n\n    def set_cell(\n        self,\n        coord: tuple | list | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Replace a cell of the table at the given coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Arguments:\n\n            coord -- (int, int) or str : coordinate\n\n            cell -- Cell\n\n        return the cell, with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        cell.x = x\n        cell.y = y\n        if y &gt;= self.height:\n            row = Row()\n            cell_back = row.set_cell(x, cell, clone=clone)\n            self.set_row(y, row, clone=False)\n        else:\n            row_read = self._get_row2_base(y)\n            if row_read is None:\n                raise ValueError\n            row = row_read\n            row.y = y\n            repeated = row.repeated or 1\n            if repeated &gt; 1:\n                row = row.clone\n                row.repeated = None\n                cell_back = row.set_cell(x, cell, clone=clone)\n                self.set_row(y, row, clone=False)\n            else:\n                cell_back = row.set_cell(x, cell, clone=clone)\n                # Update width if necessary, since we don't use set_row\n                self._update_width(row)\n        return cell_back\n\n    def set_cells(\n        self,\n        cells: list[list[Cell]] | list[tuple[Cell]],\n        coord: tuple | list | str | None = None,\n        clone: bool = True,\n    ) -&gt; None:\n        \"\"\"Set the cells in the table, from the 'coord' position.\n\n        'coord' is the coordinate of the upper left cell to be modified by\n        values. If 'coord' is None, default to the position (0,0) (\"A1\").\n        If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n        area is used as coordinate.\n\n        The table is *not* cleared before the operation, to reset the table\n        before setting cells, use table.clear().\n\n        A list of lists is expected, with as many lists as rows to be set, and\n        as many cell in each sublist as cells to be setted in the row.\n\n        Arguments:\n\n            cells -- list of list of cells\n\n            coord -- tuple or str\n\n            values -- list of lists of python types\n        \"\"\"\n        if coord:\n            x, y = self._translate_cell_coordinates(coord)\n        else:\n            x = y = 0\n        if y is None:\n            y = 0\n        if x is None:\n            x = 0\n        y -= 1\n        for row_cells in cells:\n            y += 1\n            if not row_cells:\n                continue\n            row = self.get_row(y, clone=True)\n            repeated = row.repeated or 1\n            if repeated &gt;= 2:\n                row.repeated = None\n            row.set_cells(row_cells, start=x, clone=clone)\n            self.set_row(y, row, clone=False)\n            self._update_width(row)\n\n    def set_value(\n        self,\n        coord: tuple | list | str,\n        value: Any,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set the Python value of the cell at the given coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n            value -- Python type\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n\n        \"\"\"\n        self.set_cell(\n            coord,\n            Cell(value, cell_type=cell_type, currency=currency, style=style),\n            clone=False,\n        )\n\n    def set_cell_image(\n        self,\n        coord: tuple | list | str,\n        image_frame: Frame,\n        doc_type: str | None = None,\n    ) -&gt; None:\n        \"\"\"Do all the magic to display an image in the cell at the given\n        coordinates.\n\n        They are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        The frame element must contain the expected image position and\n        dimensions.\n\n        DrawImage insertion depends on the document type, so the type must be\n        provided or the table element must be already attached to a document.\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n            image_frame -- Frame including an image\n\n            doc_type -- 'spreadsheet' or 'text'\n        \"\"\"\n        # Test document type\n        if doc_type is None:\n            body = self.document_body\n            if body is None:\n                raise ValueError(\"document type not found\")\n            doc_type = {\"office:spreadsheet\": \"spreadsheet\", \"office:text\": \"text\"}.get(\n                body.tag\n            )\n            if doc_type is None:\n                raise ValueError(\"document type not supported for images\")\n        # We need the end address of the image\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        cell = self.get_cell((x, y))\n        image_frame = image_frame.clone  # type: ignore\n        # Remove any previous paragraph, frame, etc.\n        for child in cell.children:\n            cell.delete(child)\n        # Now it all depends on the document type\n        if doc_type == \"spreadsheet\":\n            image_frame.anchor_type = \"char\"\n            # The frame needs end coordinates\n            width, height = image_frame.size\n            image_frame.set_attribute(\"table:end-x\", width)\n            image_frame.set_attribute(\"table:end-y\", height)\n            # FIXME what happens when the address changes?\n            address = f\"{self.name}.{digit_to_alpha(x)}{y + 1}\"\n            image_frame.set_attribute(\"table:end-cell-address\", address)\n            # The frame is directly in the cell\n            cell.append(image_frame)\n        elif doc_type == \"text\":\n            # The frame must be in a paragraph\n            cell.set_value(\"\")\n            paragraph = cell.get_element(\"text:p\")\n            if paragraph is None:\n                raise ValueError\n            paragraph.append(image_frame)\n        self.set_cell(coord, cell)\n\n    def insert_cell(\n        self,\n        coord: tuple | list | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Insert the given cell at the given coordinates. If no cell is\n        given, an empty one is created.\n\n        Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Cells on the right are shifted. Other rows remain untouched.\n\n        Arguments:\n\n            coord -- (int, int) or str\n\n            cell -- Cell\n\n        returns the cell with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        if clone:\n            cell = cell.clone\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        row = self._get_row2(y, clone=True)\n        row.y = y\n        row.repeated = None\n        cell_back = row.insert_cell(x, cell, clone=False)\n        self.set_row(y, row, clone=False)\n        # Update width if necessary\n        self._update_width(row)\n        return cell_back\n\n    def append_cell(\n        self,\n        y: int | str,\n        cell: Cell | None = None,\n        clone: bool = True,\n    ) -&gt; Cell:\n        \"\"\"Append the given cell at the \"y\" coordinate. Repeated cells are\n        accepted. If no cell is given, an empty one is created.\n\n        Position start at 0. So cell A4 is on row 3.\n\n        Other rows remain untouched.\n\n        Arguments:\n\n            y -- int or str\n\n            cell -- Cell\n\n        returns the cell with x and y updated\n        \"\"\"\n        if cell is None:\n            cell = Cell()\n            clone = False\n        if clone:\n            cell = cell.clone\n        y = self._translate_y_from_any(y)\n        row = self._get_row2(y)\n        row.y = y\n        cell_back = row.append_cell(cell, clone=False)\n        self.set_row(y, row)\n        # Update width if necessary\n        self._update_width(row)\n        return cell_back\n\n    def delete_cell(self, coord: tuple | list | str) -&gt; None:\n        \"\"\"Delete the cell at the given coordinates, so that next cells are\n        shifted to the left.\n\n        Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n        human-readable position like \"C4\".\n\n        Use set_value() for erasing value.\n\n        Arguments:\n\n            coord -- (int, int) or str\n        \"\"\"\n        x, y = self._translate_cell_coordinates(coord)\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        # Outside the defined table\n        if y &gt;= self.height:\n            return\n        # Inside the defined table\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError\n        row.delete_cell(x)\n        # self.set_row(y, row)\n\n    # Columns\n\n    def _get_columns(self) -&gt; list:\n        return self.get_elements(_xpath_column)\n\n    def traverse_columns(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; Iterator[Column]:\n        \"\"\"Yield as many column elements as expected columns in the table,\n        i.e. expand repetitions by returning the same column as many times as\n        necessary.\n\n            Arguments:\n\n                start -- int\n\n                end -- int\n\n        Copies are returned, use set_column() to push them back.\n        \"\"\"\n        idx = -1\n        before = -1\n        x = 0\n        if start is None and end is None:\n            for juska in self._cmap:\n                idx += 1\n                if idx in self._indexes[\"_cmap\"]:\n                    column = self._indexes[\"_cmap\"][idx]\n                else:\n                    column = self._get_element_idx2(_xpath_column_idx, idx)\n                    self._indexes[\"_cmap\"][idx] = column\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    # Return a copy without the now obsolete repetition\n                    column = column.clone\n                    column.x = x\n                    x += 1\n                    if repeated &gt; 1:\n                        column.repeated = None\n                    yield column\n        else:\n            if start is None:\n                start = 0\n            start = max(0, start)\n            if end is None:\n                try:\n                    end = self._cmap[-1]\n                except Exception:\n                    end = -1\n            start_map = find_odf_idx(self._cmap, start)\n            if start_map is None:\n                return\n            if start_map &gt; 0:\n                before = self._cmap[start_map - 1]\n            idx = start_map - 1\n            before = start - 1\n            x = start\n            for juska in self._cmap[start_map:]:\n                idx += 1\n                if idx in self._indexes[\"_cmap\"]:\n                    column = self._indexes[\"_cmap\"][idx]\n                else:\n                    column = self._get_element_idx2(_xpath_column_idx, idx)\n                    self._indexes[\"_cmap\"][idx] = column\n                repeated = juska - before\n                before = juska\n                for _i in range(repeated or 1):\n                    if x &lt;= end:\n                        column = column.clone\n                        column.x = x\n                        x += 1\n                        if repeated &gt; 1 or (x == start and start &gt; 0):\n                            column.repeated = None\n                        yield column\n\n    def get_columns(\n        self,\n        coord: tuple | list | str | None = None,\n        style: str | None = None,\n    ) -&gt; list[Column]:\n        \"\"\"Get the list of columns matching the criteria.\n\n        Copies are returned, use set_column() to push them back.\n\n        Arguments:\n\n            coord -- str or tuple of int : coordinates of columns\n\n            style -- str\n\n        Return: list of columns\n        \"\"\"\n        if coord:\n            x, _y, _z, t = self._translate_column_coordinates(coord)\n        else:\n            x = t = None\n        if not style:\n            return list(self.traverse_columns(start=x, end=t))\n        columns = []\n        for column in self.traverse_columns(start=x, end=t):\n            if style != column.style:\n                continue\n            columns.append(column)\n        return columns\n\n    def _get_column2(self, x: int) -&gt; Column | None:\n        # Outside the defined table\n        if x &gt;= self.width:\n            return Column()\n        # Inside the defined table\n        odf_idx = find_odf_idx(self._cmap, x)\n        if odf_idx is not None:\n            column = self._get_element_idx2(_xpath_column_idx, odf_idx)\n            if column is None:\n                return None\n            # fixme : no clone here =&gt; change doc and unit tests\n            return column.clone  # type: ignore\n            # return row\n        return None\n\n    @property\n    def columns(self) -&gt; list[Column]:\n        \"\"\"Get the list of all columns matching the criteria.\n\n        Copies are returned, use set_column() to push them back.\n\n        Return: list of columns\n        \"\"\"\n        return list(self.traverse_columns())\n\n    def get_column(self, x: int | str) -&gt; Column:\n        \"\"\"Get the column at the given \"x\" position.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        A copy is returned, use set_column() to push it back.\n\n        Arguments:\n\n            x -- int or str\n\n        Return: Column\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        column = self._get_column2(x)\n        if column is None:\n            raise ValueError\n        column.x = x\n        return column\n\n    def set_column(\n        self,\n        x: int | str,\n        column: Column | None = None,\n    ) -&gt; Column:\n        \"\"\"Replace the column at the given \"x\" position.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            x -- int or str\n\n            column -- Column\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        if column is None:\n            column = Column()\n            repeated = 1\n        else:\n            repeated = column.repeated or 1\n        column.x = x\n        # Outside the defined table ?\n        diff = x - self.width\n        if diff == 0:\n            column_back = self.append_column(column, _repeated=repeated)\n        elif diff &gt; 0:\n            self.append_column(Column(repeated=diff), _repeated=diff)\n            column_back = self.append_column(column, _repeated=repeated)\n        else:\n            # Inside the defined table\n            column_back = set_item_in_vault(  # type: ignore\n                x, column, self, _xpath_column_idx, \"_cmap\"\n            )\n        return column_back\n\n    def insert_column(\n        self,\n        x: int | str,\n        column: Column | None = None,\n    ) -&gt; Column:\n        \"\"\"Insert the column before the given \"x\" position. If no column is\n        given, an empty one is created.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            x -- int or str\n\n            column -- Column\n        \"\"\"\n        if column is None:\n            column = Column()\n        x = self._translate_x_from_any(x)\n        diff = x - self.width\n        if diff &lt; 0:\n            column_back = insert_item_in_vault(\n                x, column, self, _xpath_column_idx, \"_cmap\"\n            )\n        elif diff == 0:\n            column_back = self.append_column(column.clone)\n        else:\n            self.append_column(Column(repeated=diff), _repeated=diff)\n            column_back = self.append_column(column.clone)\n        column_back.x = x  # type: ignore\n        # Repetitions are accepted\n        repeated = column.repeated or 1\n        # Update width on every row\n        for row in self._get_rows():\n            if row.width &gt; x:\n                row.insert_cell(x, Cell(repeated=repeated))\n            # Shorter rows don't need insert\n            # Longer rows shouldn't exist!\n        return column_back  # type: ignore\n\n    def append_column(\n        self,\n        column: Column | None = None,\n        _repeated: int | None = None,\n    ) -&gt; Column:\n        \"\"\"Append the column at the end of the table. If no column is given,\n        an empty one is created.\n\n        ODF columns don't contain cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            column -- Column\n        \"\"\"\n        if column is None:\n            column = Column()\n        else:\n            column = column.clone\n        if not self._cmap:\n            position = 0\n        else:\n            odf_idx = len(self._cmap) - 1\n            last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)\n            if last_column is None:\n                raise ValueError\n            position = self.index(last_column) + 1\n        column.x = self.width\n        self.insert(column, position=position)\n        # Repetitions are accepted\n        if _repeated is None:\n            _repeated = column.repeated or 1\n        self._cmap = insert_map_once(self._cmap, len(self._cmap), _repeated)\n        # No need to update row widths\n        return column\n\n    def delete_column(self, x: int | str) -&gt; None:\n        \"\"\"Delete the column at the given position. ODF columns don't contain\n        cells, only style information.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Arguments:\n\n            x -- int or str\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        # Outside the defined table\n        if x &gt;= self.width:\n            return\n        # Inside the defined table\n        delete_item_in_vault(x, self, _xpath_column_idx, \"_cmap\")\n        # Update width\n        width = self.width\n        for row in self._get_rows():\n            if row.width &gt;= width:\n                row.delete_cell(x)\n\n    def get_column_cells(\n        self,\n        x: int | str,\n        style: str | None = None,\n        content: str | None = None,\n        cell_type: str | None = None,\n        complete: bool = False,\n    ) -&gt; list[Cell | None]:\n        \"\"\"Get the list of cells at the given position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n\n        If complete is True, replace missing values by None.\n\n        Arguments:\n\n            x -- int or str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            content -- str regex\n\n            style -- str\n\n            complete -- boolean\n\n        Return: list of Cell\n        \"\"\"\n        x = self._translate_x_from_any(x)\n        if cell_type:\n            cell_type = cell_type.lower().strip()\n        cells: list[Cell | None] = []\n        if not style and not content and not cell_type:\n            for row in self.traverse():\n                cells.append(row.get_cell(x, clone=True))\n            return cells\n        for row in self.traverse():\n            cell = row.get_cell(x, clone=True)\n            if cell is None:\n                raise ValueError\n            # Filter the cells by cell_type\n            if cell_type:\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    if complete:\n                        cells.append(None)\n                    continue\n            # Filter the cells with the regex\n            if content and not cell.match(content):\n                if complete:\n                    cells.append(None)\n                continue\n            # Filter the cells with the style\n            if style and style != cell.style:\n                if complete:\n                    cells.append(None)\n                continue\n            cells.append(cell)\n        return cells\n\n    def get_column_values(\n        self,\n        x: int | str,\n        cell_type: str | None = None,\n        complete: bool = True,\n        get_type: bool = False,\n    ) -&gt; list[Any]:\n        \"\"\"Shortcut to get the list of Python values for the cells at the\n        given position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        Filter by cell_type, with cell_type 'all' will retrieve cells of any\n        type, aka non empty cells.\n        If cell_type and complete is True, replace missing values by None.\n\n        If get_type is True, returns a tuple (value, ODF type of value)\n\n        Arguments:\n\n            x -- int or str\n\n            cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                         'currency', 'percentage' or 'all'\n\n            complete -- boolean\n\n            get_type -- boolean\n\n        Return: list of Python types\n        \"\"\"\n        cells = self.get_column_cells(\n            x, style=None, content=None, cell_type=cell_type, complete=complete\n        )\n        values: list[Any] = []\n        for cell in cells:\n            if cell is None:\n                if complete:\n                    if get_type:\n                        values.append((None, None))\n                    else:\n                        values.append(None)\n                continue\n            if cell_type:\n                ctype = cell.type\n                if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                    if complete:\n                        if get_type:\n                            values.append((None, None))\n                        else:\n                            values.append(None)\n                    continue\n            values.append(cell.get_value(get_type=get_type))\n        return values\n\n    def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:\n        \"\"\"Shortcut to set the list of cells at the given position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        The list must have the same length than the table height.\n\n        Arguments:\n\n            x -- int or str\n\n            cells -- list of Cell\n        \"\"\"\n        height = self.height\n        if len(cells) != height:\n            raise ValueError(f\"col mismatch: {height} cells expected\")\n        cells_iterator = iter(cells)\n        for y, row in enumerate(self.traverse()):\n            row.set_cell(x, next(cells_iterator))\n            self.set_row(y, row)\n\n    def set_column_values(\n        self,\n        x: int | str,\n        values: list,\n        cell_type: str | None = None,\n        currency: str | None = None,\n        style: str | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the list of Python values of cells at the given\n        position.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        The list must have the same length than the table height.\n\n        Arguments:\n\n            x -- int or str\n\n            values -- list of Python types\n\n            cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                         'string' or 'time'\n\n            currency -- three-letter str\n\n            style -- str\n        \"\"\"\n        cells = [\n            Cell(value, cell_type=cell_type, currency=currency, style=style)\n            for value in values\n        ]\n        self.set_column_cells(x, cells)\n\n    def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:\n        \"\"\"Return wether every cell in the column at \"x\" position has no value\n        or the value evaluates to False (empty string), and no style.\n\n        Position start at 0. So cell C4 is on column 2. Alphabetical position\n        like \"C\" is accepted.\n\n        If aggressive is True, empty cells with style are considered empty.\n\n        Return: bool\n        \"\"\"\n        for cell in self.get_column_cells(x):\n            if cell is None:\n                continue\n            if not cell.is_empty(aggressive=aggressive):\n                return False\n        return True\n\n    # Named Range\n\n    def get_named_ranges(  # type: ignore\n        self,\n        table_name: str | list[str] | None = None,\n    ) -&gt; list[NamedRange]:\n        \"\"\"Returns the list of available Name Ranges of the spreadsheet. If\n        table_name is provided, limits the search to these tables.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            table_names -- str or list of str, names of tables\n\n        Return : list of table_range\n        \"\"\"\n        body = self.document_body\n        if not body:\n            return []\n        all_named_ranges = body.get_named_ranges()\n        if not table_name:\n            return all_named_ranges  # type:ignore\n        filter_ = []\n        if isinstance(table_name, str):\n            filter_.append(table_name)\n        elif isiterable(table_name):\n            filter_.extend(table_name)\n        else:\n            raise ValueError(\n                f\"table_name must be string or Iterable, not {type(table_name)}\"\n            )\n        return [\n            nr\n            for nr in all_named_ranges\n            if nr.table_name in filter_  # type:ignore\n        ]\n\n    def get_named_range(self, name: str) -&gt; NamedRange:\n        \"\"\"Returns the Name Ranges of the specified name. If\n        table_name is provided, limits the search to these tables.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            name -- str, name of the named range object\n\n        Return : NamedRange\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document\")\n        return body.get_named_range(name)  # type: ignore\n\n    def set_named_range(\n        self,\n        name: str,\n        crange: str | tuple | list,\n        table_name: str | None = None,\n        usage: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create a Named Range element and insert it in the document.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            name -- str, name of the named range\n\n            crange -- str or tuple of int, cell or area coordinate\n\n            table_name -- str, name of the table\n\n            uage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n        \"\"\"\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document\")\n        if not name:\n            raise ValueError(\"Name required.\")\n        if table_name is None:\n            table_name = self.name\n        named_range = NamedRange(name, crange, table_name, usage)\n        body.append_named_range(named_range)\n\n    def delete_named_range(self, name: str) -&gt; None:\n        \"\"\"Delete the Named Range of specified name from the spreadsheet.\n        Beware : named ranges are stored at the body level, thus do not call\n        this method on a cloned table.\n\n        Arguments:\n\n            name -- str\n        \"\"\"\n        name = name.strip()\n        if not name:\n            raise ValueError(\"Name required.\")\n        body = self.document_body\n        if not body:\n            raise ValueError(\"Table is not inside a document.\")\n        body.delete_named_range(name)\n\n    #\n    # Cell span\n    #\n\n    def set_span(\n        self,\n        area: str | tuple | list,\n        merge: bool = False,\n    ) -&gt; bool:\n        \"\"\"Create a Cell Span : span the first cell of the area on several\n        columns and/or rows.\n        If merge is True, replace text of the cell by the concatenation of\n        existing text in covered cells.\n        Beware : if merge is True, old text is changed, if merge is False\n        (the default), old text in coverd cells is still present but not\n        displayed by most GUI.\n\n        If the area defines only one cell, the set span will do nothing.\n        It is not allowed to apply set span to an area whose one cell already\n        belongs to previous cell span.\n\n        Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n        be provided as an alpha numeric value like \"A1:B2' or a tuple like\n        (0, 0, 1, 1) or (0, 0).\n\n        Arguments:\n\n            area -- str or tuple of int, cell or area coordinate\n\n            merge -- boolean\n        \"\"\"\n        # get area\n        digits = convert_coordinates(area)\n        if len(digits) == 4:\n            x, y, z, t = digits\n        else:\n            x, y = digits\n            z, t = digits\n        start = x, y\n        end = z, t\n        if start == end:\n            # one cell : do nothing\n            return False\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        if z is None:\n            raise ValueError\n        if t is None:\n            raise ValueError\n        # check for previous span\n        good = True\n        # Check boundaries and empty cells : need to crate non existent cells\n        # so don't use get_cells directly, but get_cell\n        cells = []\n        for yy in range(y, t + 1):\n            row_cells = []\n            for xx in range(x, z + 1):\n                row_cells.append(\n                    self.get_cell((xx, yy), clone=True, keep_repeated=False)\n                )\n            cells.append(row_cells)\n        for row in cells:\n            for cell in row:\n                if cell.is_spanned():\n                    good = False\n                    break\n            if not good:\n                break\n        if not good:\n            return False\n        # Check boundaries\n        # if z &gt;= self.width or t &gt;= self.height:\n        #    self.set_cell(coord = end)\n        #    print area, z, t\n        #    cells = self.get_cells((x, y, z, t))\n        #    print cells\n        # do it:\n        if merge:\n            val_list = []\n            for row in cells:\n                for cell in row:\n                    if cell.is_empty(aggressive=True):\n                        continue\n                    val = cell.get_value()\n                    if val is not None:\n                        if isinstance(val, str):\n                            val.strip()\n                        if val != \"\":\n                            val_list.append(val)\n                        cell.clear()\n            if val_list:\n                if len(val_list) == 1:\n                    cells[0][0].set_value(val_list[0])\n                else:\n                    value = \" \".join([str(v) for v in val_list if v])\n                    cells[0][0].set_value(value)\n        cols = z - x + 1\n        cells[0][0].set_attribute(\"table:number-columns-spanned\", str(cols))\n        rows = t - y + 1\n        cells[0][0].set_attribute(\"table:number-rows-spanned\", str(rows))\n        for cell in cells[0][1:]:\n            cell.tag = \"table:covered-table-cell\"\n        for row in cells[1:]:\n            for cell in row:\n                cell.tag = \"table:covered-table-cell\"\n        # replace cells in table\n        self.set_cells(cells, coord=start, clone=False)\n        return True\n\n    def del_span(self, area: str | tuple | list) -&gt; bool:\n        \"\"\"Delete a Cell Span. 'area' is the cell coordiante of the upper left\n        cell of the spanned area.\n\n        Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n        be provided as an alpha numeric value like \"A1:B2' or a tuple like\n        (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell\n        is used.\n\n        Arguments:\n\n            area -- str or tuple of int, cell or area coordinate\n        \"\"\"\n        # get area\n        digits = convert_coordinates(area)\n        if len(digits) == 4:\n            x, y, _z, _t = digits\n        else:\n            x, y = digits\n        if x is None:\n            raise ValueError\n        if y is None:\n            raise ValueError\n        start = x, y\n        # check for previous span\n        cell0 = self.get_cell(start)\n        nb_cols = cell0.get_attribute_integer(\"table:number-columns-spanned\")\n        if nb_cols is None:\n            return False\n        nb_rows = cell0.get_attribute_integer(\"table:number-rows-spanned\")\n        if nb_rows is None:\n            return False\n        z = x + nb_cols - 1\n        t = y + nb_rows - 1\n        cells = self.get_cells((x, y, z, t))\n        cells[0][0].del_attribute(\"table:number-columns-spanned\")\n        cells[0][0].del_attribute(\"table:number-rows-spanned\")\n        for cell in cells[0][1:]:\n            cell.tag = \"table:table-cell\"\n        for row in cells[1:]:\n            for cell in row:\n                cell.tag = \"table:table-cell\"\n        # replace cells in table\n        self.set_cells(cells, coord=start, clone=False)\n        return True\n\n    # Utilities\n\n    def to_csv(\n        self,\n        path_or_file: str | Path | None = None,\n        dialect: str = \"excel\",\n    ) -&gt; Any:\n        \"\"\"Write the table as CSV in the file.\n\n        If the file is a string, it is opened as a local path. Else an\n        opened file-like is expected.\n\n        Arguments:\n\n            path_or_file -- str or file-like\n\n            dialect -- str, python csv.dialect, can be 'excel', 'unix'...\n        \"\"\"\n\n        def write_content(csv_writer: object) -&gt; None:\n            for values in self.iter_values():\n                line = []\n                for value in values:\n                    if value is None:\n                        value = \"\"\n                    if isinstance(value, str):\n                        value = value.strip()\n                    line.append(value)\n                csv_writer.writerow(line)  # type: ignore\n\n        out = StringIO(newline=\"\")\n        csv_writer = csv.writer(out, dialect=dialect)\n        write_content(csv_writer)\n        if path_or_file is None:\n            return out.getvalue()\n        path = Path(path_or_file)\n        path.write_text(out.getvalue())\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.Table.cells","title":"<code>cells</code>  <code>property</code>","text":"<p>Get all cells of the table.</p> <p>Return: list of list of Cell</p>"},{"location":"reference.html#odfdo.Table.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>Get the list of all columns matching the criteria.</p> <p>Copies are returned, use set_column() to push them back.</p> <p>Return: list of columns</p>"},{"location":"reference.html#odfdo.Table.height","title":"<code>height</code>  <code>property</code>","text":"<p>Get the current height of the table.</p> <p>Return: int</p>"},{"location":"reference.html#odfdo.Table.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the name of the table.</p> <p>The \u201cname\u201d parameter is required and cannot contain []*?:/ or \\ characters, \u2019 (apostrophe) cannot be the first or last character.</p>"},{"location":"reference.html#odfdo.Table.row_groups","title":"<code>row_groups</code>  <code>property</code>","text":"<p>Get the list of all RowGroup.</p> <p>Return: list of RowGroup</p>"},{"location":"reference.html#odfdo.Table.rows","title":"<code>rows</code>  <code>property</code>","text":"<p>Get the list of all rows.</p> <p>Return: list of rows</p>"},{"location":"reference.html#odfdo.Table.size","title":"<code>size</code>  <code>property</code>","text":"<p>Shortcut to get the current width and height of the table.</p> <p>Return: (int, int)</p>"},{"location":"reference.html#odfdo.Table.style","title":"<code>style</code>  <code>property</code> <code>writable</code>","text":"<p>Get / set the style of the table</p> <p>Return: str</p>"},{"location":"reference.html#odfdo.Table.width","title":"<code>width</code>  <code>property</code>","text":"<p>Get the current width of the table, measured on columns.</p> <p>Rows may have different widths, use the Table API to ensure width consistency.</p> <p>Return: int</p>"},{"location":"reference.html#odfdo.Table.__init__","title":"<code>__init__(name=None, width=None, height=None, protected=False, protection_key=None, printable=True, print_ranges=None, style=None, **kwargs)</code>","text":"<p>Create a table element, optionally prefilled with \u201cheight\u201d rows of \u201cwidth\u201d cells each.</p> <p>The \u201cname\u201d parameter is required and cannot contain []*?:/ or \\ characters, \u2019 (apostrophe) cannot be the first or last character.</p> <p>If the table is to be protected, a protection key must be provided, i.e. a hash value of the password.</p> <p>If the table must not be printed, set \u201cprintable\u201d to False. The table will not be printed when it is not displayed, whatever the value of this argument.</p> <p>Ranges of cells to print can be provided as a list of cell ranges, e.g. [\u2018E6:K12\u2019, \u2018P6:R12\u2019] or directly as a raw string, e.g. \u201cE6:K12 P6:R12\u201d.</p> <p>You can access and modify the XML tree manually, but you probably want to use the API to access and alter cells. It will save you from handling repetitions and the same number of cells for each row.</p> <p>If you use both the table API and the XML API, you are on your own for ensuiring model integrity.</p> <p>Arguments:</p> <pre><code>name -- str\n\nwidth -- int | str\n\nheight -- int | str\n\nprotected -- bool\n\nprotection_key -- str\n\nprintable -- bool\n\nprint_ranges -- list\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    width: int | str | None = None,\n    height: int | str | None = None,\n    protected: bool = False,\n    protection_key: str | None = None,\n    printable: bool = True,\n    print_ranges: list[str] | None = None,\n    style: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a table element, optionally prefilled with \"height\" rows of\n    \"width\" cells each.\n\n    The \"name\" parameter is required and cannot contain []*?:/ or \\\\\n    characters, ' (apostrophe) cannot be the first or last character.\n\n    If the table is to be protected, a protection key must be provided,\n    i.e. a hash value of the password.\n\n    If the table must not be printed, set \"printable\" to False. The table\n    will not be printed when it is not displayed, whatever the value of\n    this argument.\n\n    Ranges of cells to print can be provided as a list of cell ranges,\n    e.g. ['E6:K12', 'P6:R12'] or directly as a raw string, e.g.\n    \"E6:K12 P6:R12\".\n\n    You can access and modify the XML tree manually, but you probably want\n    to use the API to access and alter cells. It will save you from\n    handling repetitions and the same number of cells for each row.\n\n    If you use both the table API and the XML API, you are on your own for\n    ensuiring model integrity.\n\n    Arguments:\n\n        name -- str\n\n        width -- int | str\n\n        height -- int | str\n\n        protected -- bool\n\n        protection_key -- str\n\n        printable -- bool\n\n        print_ranges -- list\n\n        style -- str\n    \"\"\"\n    super().__init__(**kwargs)\n    self._indexes = {}\n    self._indexes[\"_cmap\"] = {}\n    self._indexes[\"_tmap\"] = {}\n    if self._do_init:\n        self.name = name\n        if protected:\n            self.protected = protected\n            self.set_protection_key = protection_key\n        if not printable:\n            self.printable = printable\n        if print_ranges:\n            self.print_ranges = print_ranges\n        if style:\n            self.style = style\n        # Prefill the table\n        if width is not None or height is not None:\n            width = int(width or 1)\n            height = int(height or 1)\n            # Column groups for style information\n            columns = Column(repeated=width)\n            self._append(columns)\n            for _i in range(height):\n                row = Row(width)\n                self._append(row)\n    self._compute_table_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Table.append","title":"<code>append(something)</code>","text":"<p>Dispatch .append() call to append_row() or append_column().</p> Source code in <code>odfdo/table.py</code> <pre><code>def append(self, something: Element | str) -&gt; None:\n    \"\"\"Dispatch .append() call to append_row() or append_column().\"\"\"\n    if isinstance(something, Row):\n        self.append_row(something)\n    elif isinstance(something, Column):\n        self.append_column(something)\n    else:\n        # probably still an error\n        self._append(something)\n</code></pre>"},{"location":"reference.html#odfdo.Table.append_cell","title":"<code>append_cell(y, cell=None, clone=True)</code>","text":"<p>Append the given cell at the \u201cy\u201d coordinate. Repeated cells are accepted. If no cell is given, an empty one is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Other rows remain untouched.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\ncell -- Cell\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/table.py</code> <pre><code>def append_cell(\n    self,\n    y: int | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Append the given cell at the \"y\" coordinate. Repeated cells are\n    accepted. If no cell is given, an empty one is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Other rows remain untouched.\n\n    Arguments:\n\n        y -- int or str\n\n        cell -- Cell\n\n    returns the cell with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    if clone:\n        cell = cell.clone\n    y = self._translate_y_from_any(y)\n    row = self._get_row2(y)\n    row.y = y\n    cell_back = row.append_cell(cell, clone=False)\n    self.set_row(y, row)\n    # Update width if necessary\n    self._update_width(row)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.append_column","title":"<code>append_column(column=None, _repeated=None)</code>","text":"<p>Append the column at the end of the table. If no column is given, an empty one is created.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>column -- Column\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def append_column(\n    self,\n    column: Column | None = None,\n    _repeated: int | None = None,\n) -&gt; Column:\n    \"\"\"Append the column at the end of the table. If no column is given,\n    an empty one is created.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        column -- Column\n    \"\"\"\n    if column is None:\n        column = Column()\n    else:\n        column = column.clone\n    if not self._cmap:\n        position = 0\n    else:\n        odf_idx = len(self._cmap) - 1\n        last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)\n        if last_column is None:\n            raise ValueError\n        position = self.index(last_column) + 1\n    column.x = self.width\n    self.insert(column, position=position)\n    # Repetitions are accepted\n    if _repeated is None:\n        _repeated = column.repeated or 1\n    self._cmap = insert_map_once(self._cmap, len(self._cmap), _repeated)\n    # No need to update row widths\n    return column\n</code></pre>"},{"location":"reference.html#odfdo.Table.append_row","title":"<code>append_row(row=None, clone=True, _repeated=None)</code>","text":"<p>Append the row at the end of the table. If no row is given, an empty one is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Note the columns are automatically created when the first row is inserted in an empty table. So better insert a filled row.</p> <p>Arguments:</p> <pre><code>row -- Row\n\n_repeated -- (optional), repeated value of the row\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def append_row(\n    self,\n    row: Row | None = None,\n    clone: bool = True,\n    _repeated: int | None = None,\n) -&gt; Row:\n    \"\"\"Append the row at the end of the table. If no row is given, an\n    empty one is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Note the columns are automatically created when the first row is\n    inserted in an empty table. So better insert a filled row.\n\n    Arguments:\n\n        row -- Row\n\n        _repeated -- (optional), repeated value of the row\n\n    returns the row, with updated row.y\n    \"\"\"\n    if row is None:\n        row = Row()\n        _repeated = 1\n    elif clone:\n        row = row.clone\n    # Appending a repeated row accepted\n    # Do not insert next to the last row because it could be in a group\n    self._append(row)\n    if _repeated is None:\n        _repeated = row.repeated or 1\n    self._tmap = insert_map_once(self._tmap, len(self._tmap), _repeated)\n    row.y = self.height - 1\n    # Initialize columns\n    if not self._get_columns():\n        repeated = row.width\n        self.insert(Column(repeated=repeated), position=0)\n        self._compute_table_cache()\n    # Update width if necessary\n    self._update_width(row)\n    return row\n</code></pre>"},{"location":"reference.html#odfdo.Table.del_span","title":"<code>del_span(area)</code>","text":"<p>Delete a Cell Span. \u2018area\u2019 is the cell coordiante of the upper left cell of the spanned area.</p> <p>Area can be either one cell (like \u2018A1\u2019) or an area (\u2018A1:B2\u2019). It can be provided as an alpha numeric value like \u201cA1:B2\u2019 or a tuple like (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell is used.</p> <p>Arguments:</p> <pre><code>area -- str or tuple of int, cell or area coordinate\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def del_span(self, area: str | tuple | list) -&gt; bool:\n    \"\"\"Delete a Cell Span. 'area' is the cell coordiante of the upper left\n    cell of the spanned area.\n\n    Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n    be provided as an alpha numeric value like \"A1:B2' or a tuple like\n    (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell\n    is used.\n\n    Arguments:\n\n        area -- str or tuple of int, cell or area coordinate\n    \"\"\"\n    # get area\n    digits = convert_coordinates(area)\n    if len(digits) == 4:\n        x, y, _z, _t = digits\n    else:\n        x, y = digits\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    start = x, y\n    # check for previous span\n    cell0 = self.get_cell(start)\n    nb_cols = cell0.get_attribute_integer(\"table:number-columns-spanned\")\n    if nb_cols is None:\n        return False\n    nb_rows = cell0.get_attribute_integer(\"table:number-rows-spanned\")\n    if nb_rows is None:\n        return False\n    z = x + nb_cols - 1\n    t = y + nb_rows - 1\n    cells = self.get_cells((x, y, z, t))\n    cells[0][0].del_attribute(\"table:number-columns-spanned\")\n    cells[0][0].del_attribute(\"table:number-rows-spanned\")\n    for cell in cells[0][1:]:\n        cell.tag = \"table:table-cell\"\n    for row in cells[1:]:\n        for cell in row:\n            cell.tag = \"table:table-cell\"\n    # replace cells in table\n    self.set_cells(cells, coord=start, clone=False)\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_cell","title":"<code>delete_cell(coord)</code>","text":"<p>Delete the cell at the given coordinates, so that next cells are shifted to the left.</p> <p>Coordinates are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Use set_value() for erasing value.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_cell(self, coord: tuple | list | str) -&gt; None:\n    \"\"\"Delete the cell at the given coordinates, so that next cells are\n    shifted to the left.\n\n    Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Use set_value() for erasing value.\n\n    Arguments:\n\n        coord -- (int, int) or str\n    \"\"\"\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    # Outside the defined table\n    if y &gt;= self.height:\n        return\n    # Inside the defined table\n    row = self._get_row2_base(y)\n    if row is None:\n        raise ValueError\n    row.delete_cell(x)\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_column","title":"<code>delete_column(x)</code>","text":"<p>Delete the column at the given position. ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_column(self, x: int | str) -&gt; None:\n    \"\"\"Delete the column at the given position. ODF columns don't contain\n    cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        x -- int or str\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    # Outside the defined table\n    if x &gt;= self.width:\n        return\n    # Inside the defined table\n    delete_item_in_vault(x, self, _xpath_column_idx, \"_cmap\")\n    # Update width\n    width = self.width\n    for row in self._get_rows():\n        if row.width &gt;= width:\n            row.delete_cell(x)\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_named_range","title":"<code>delete_named_range(name)</code>","text":"<p>Delete the Named Range of specified name from the spreadsheet. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>name -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_named_range(self, name: str) -&gt; None:\n    \"\"\"Delete the Named Range of specified name from the spreadsheet.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        name -- str\n    \"\"\"\n    name = name.strip()\n    if not name:\n        raise ValueError(\"Name required.\")\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document.\")\n    body.delete_named_range(name)\n</code></pre>"},{"location":"reference.html#odfdo.Table.delete_row","title":"<code>delete_row(y)</code>","text":"<p>Delete the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def delete_row(self, y: int | str) -&gt; None:\n    \"\"\"Delete the row at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n    \"\"\"\n    y = self._translate_y_from_any(y)\n    # Outside the defined table\n    if y &gt;= self.height:\n        return\n    # Inside the defined table\n    delete_item_in_vault(y, self, _xpath_row_idx, \"_tmap\")\n</code></pre>"},{"location":"reference.html#odfdo.Table.extend_rows","title":"<code>extend_rows(rows=None)</code>","text":"<p>Append a list of rows at the end of the table.</p> <p>Arguments:</p> <pre><code>rows -- list of Row\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def extend_rows(self, rows: list[Row] | None = None) -&gt; None:\n    \"\"\"Append a list of rows at the end of the table.\n\n    Arguments:\n\n        rows -- list of Row\n    \"\"\"\n    if rows is None:\n        rows = []\n    self.extend(rows)\n    self._compute_table_cache()\n    # Update width if necessary\n    width = self.width\n    for row in self.traverse():\n        if row.width &gt; width:\n            width = row.width\n    diff = width - self.width\n    if diff &gt; 0:\n        self.append_column(Column(repeated=diff))\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_cell","title":"<code>get_cell(coord, clone=True, keep_repeated=True)</code>","text":"<p>Get the cell at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>A copy is returned, use <code>set_cell</code> to push it back.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n</code></pre> <p>Return: Cell</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_cell(\n    self,\n    coord: tuple | list | str,\n    clone: bool = True,\n    keep_repeated: bool = True,\n) -&gt; Cell:\n    \"\"\"Get the cell at the given coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    A copy is returned, use ``set_cell`` to push it back.\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n    Return: Cell\n    \"\"\"\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    # Outside the defined table\n    if y &gt;= self.height:\n        cell = Cell()\n    else:\n        # Inside the defined table\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError\n        read_cell = row.get_cell(x, clone=clone)\n        if read_cell is None:\n            raise ValueError\n        cell = read_cell\n        if not keep_repeated:\n            repeated = cell.repeated or 1\n            if repeated &gt;= 2:\n                cell.repeated = None\n    cell.x = x\n    cell.y = y\n    return cell\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_cells","title":"<code>get_cells(coord=None, cell_type=None, style=None, content=None, flat=False)</code>","text":"<p>Get the cells matching the criteria. If \u2018coord\u2019 is None, parse the whole table, else parse the area defined by \u2018coord\u2019.</p> <p>Filter by  cell_type = \u201call\u201d  will retrieve cells of any type, aka non empty cells.</p> <p>If flat is True (default is False), the method return a single list of all the values, else a list of lists of cells.</p> <p>if cell_type, style and content are None, get_cells() will return the exact number of cells of the area, including empty cells.</p> <p>Arguments:</p> <pre><code>coordinates -- str or tuple of int : coordinates of area\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncontent -- str regex\n\nstyle -- str\n\nflat -- boolean\n</code></pre> <p>Return: list of list of Cell</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_cells(\n    self,\n    coord: tuple | list | str | None = None,\n    cell_type: str | None = None,\n    style: str | None = None,\n    content: str | None = None,\n    flat: bool = False,\n) -&gt; list:\n    \"\"\"Get the cells matching the criteria. If 'coord' is None,\n    parse the whole table, else parse the area defined by 'coord'.\n\n    Filter by  cell_type = \"all\"  will retrieve cells of any\n    type, aka non empty cells.\n\n    If flat is True (default is False), the method return a single list\n    of all the values, else a list of lists of cells.\n\n    if cell_type, style and content are None, get_cells() will return\n    the exact number of cells of the area, including empty cells.\n\n    Arguments:\n\n        coordinates -- str or tuple of int : coordinates of area\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        content -- str regex\n\n        style -- str\n\n        flat -- boolean\n\n    Return: list of list of Cell\n    \"\"\"\n    if coord:\n        x, y, z, t = self._translate_table_coordinates(coord)\n    else:\n        x = y = z = t = None\n    if flat:\n        cells: list[Cell] = []\n        for row in self.traverse(start=y, end=t):\n            row_cells = row.get_cells(\n                coord=(x, z),\n                cell_type=cell_type,\n                style=style,\n                content=content,\n            )\n            cells.extend(row_cells)\n        return cells\n    else:\n        lcells: list[list[Cell]] = []\n        for row in self.traverse(start=y, end=t):\n            row_cells = row.get_cells(\n                coord=(x, z),\n                cell_type=cell_type,\n                style=style,\n                content=content,\n            )\n            lcells.append(row_cells)\n        return lcells\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_column","title":"<code>get_column(x)</code>","text":"<p>Get the column at the given \u201cx\u201d position.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>A copy is returned, use set_column() to push it back.</p> <p>Arguments:</p> <pre><code>x -- int or str\n</code></pre> <p>Return: Column</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_column(self, x: int | str) -&gt; Column:\n    \"\"\"Get the column at the given \"x\" position.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    A copy is returned, use set_column() to push it back.\n\n    Arguments:\n\n        x -- int or str\n\n    Return: Column\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    column = self._get_column2(x)\n    if column is None:\n        raise ValueError\n    column.x = x\n    return column\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_column_cells","title":"<code>get_column_cells(x, style=None, content=None, cell_type=None, complete=False)</code>","text":"<p>Get the list of cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells.</p> <p>If complete is True, replace missing values by None.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncontent -- str regex\n\nstyle -- str\n\ncomplete -- boolean\n</code></pre> <p>Return: list of Cell</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_column_cells(\n    self,\n    x: int | str,\n    style: str | None = None,\n    content: str | None = None,\n    cell_type: str | None = None,\n    complete: bool = False,\n) -&gt; list[Cell | None]:\n    \"\"\"Get the list of cells at the given position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n\n    If complete is True, replace missing values by None.\n\n    Arguments:\n\n        x -- int or str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        content -- str regex\n\n        style -- str\n\n        complete -- boolean\n\n    Return: list of Cell\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    if cell_type:\n        cell_type = cell_type.lower().strip()\n    cells: list[Cell | None] = []\n    if not style and not content and not cell_type:\n        for row in self.traverse():\n            cells.append(row.get_cell(x, clone=True))\n        return cells\n    for row in self.traverse():\n        cell = row.get_cell(x, clone=True)\n        if cell is None:\n            raise ValueError\n        # Filter the cells by cell_type\n        if cell_type:\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                if complete:\n                    cells.append(None)\n                continue\n        # Filter the cells with the regex\n        if content and not cell.match(content):\n            if complete:\n                cells.append(None)\n            continue\n        # Filter the cells with the style\n        if style and style != cell.style:\n            if complete:\n                cells.append(None)\n            continue\n        cells.append(cell)\n    return cells\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_column_values","title":"<code>get_column_values(x, cell_type=None, complete=True, get_type=False)</code>","text":"<p>Shortcut to get the list of Python values for the cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells. If cell_type and complete is True, replace missing values by None.</p> <p>If get_type is True, returns a tuple (value, ODF type of value)</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of Python types</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_column_values(\n    self,\n    x: int | str,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n) -&gt; list[Any]:\n    \"\"\"Shortcut to get the list of Python values for the cells at the\n    given position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n    If cell_type and complete is True, replace missing values by None.\n\n    If get_type is True, returns a tuple (value, ODF type of value)\n\n    Arguments:\n\n        x -- int or str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of Python types\n    \"\"\"\n    cells = self.get_column_cells(\n        x, style=None, content=None, cell_type=cell_type, complete=complete\n    )\n    values: list[Any] = []\n    for cell in cells:\n        if cell is None:\n            if complete:\n                if get_type:\n                    values.append((None, None))\n                else:\n                    values.append(None)\n            continue\n        if cell_type:\n            ctype = cell.type\n            if not ctype or not (ctype == cell_type or cell_type == \"all\"):\n                if complete:\n                    if get_type:\n                        values.append((None, None))\n                    else:\n                        values.append(None)\n                continue\n        values.append(cell.get_value(get_type=get_type))\n    return values\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_columns","title":"<code>get_columns(coord=None, style=None)</code>","text":"<p>Get the list of columns matching the criteria.</p> <p>Copies are returned, use set_column() to push them back.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of columns\n\nstyle -- str\n</code></pre> <p>Return: list of columns</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_columns(\n    self,\n    coord: tuple | list | str | None = None,\n    style: str | None = None,\n) -&gt; list[Column]:\n    \"\"\"Get the list of columns matching the criteria.\n\n    Copies are returned, use set_column() to push them back.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of columns\n\n        style -- str\n\n    Return: list of columns\n    \"\"\"\n    if coord:\n        x, _y, _z, t = self._translate_column_coordinates(coord)\n    else:\n        x = t = None\n    if not style:\n        return list(self.traverse_columns(start=x, end=t))\n    columns = []\n    for column in self.traverse_columns(start=x, end=t):\n        if style != column.style:\n            continue\n        columns.append(column)\n    return columns\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_named_range","title":"<code>get_named_range(name)</code>","text":"<p>Returns the Name Ranges of the specified name. If table_name is provided, limits the search to these tables. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>name -- str, name of the named range object\n</code></pre> <p>Return : NamedRange</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_named_range(self, name: str) -&gt; NamedRange:\n    \"\"\"Returns the Name Ranges of the specified name. If\n    table_name is provided, limits the search to these tables.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        name -- str, name of the named range object\n\n    Return : NamedRange\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document\")\n    return body.get_named_range(name)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_named_ranges","title":"<code>get_named_ranges(table_name=None)</code>","text":"<p>Returns the list of available Name Ranges of the spreadsheet. If table_name is provided, limits the search to these tables. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>table_names -- str or list of str, names of tables\n</code></pre> <p>Return : list of table_range</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_named_ranges(  # type: ignore\n    self,\n    table_name: str | list[str] | None = None,\n) -&gt; list[NamedRange]:\n    \"\"\"Returns the list of available Name Ranges of the spreadsheet. If\n    table_name is provided, limits the search to these tables.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        table_names -- str or list of str, names of tables\n\n    Return : list of table_range\n    \"\"\"\n    body = self.document_body\n    if not body:\n        return []\n    all_named_ranges = body.get_named_ranges()\n    if not table_name:\n        return all_named_ranges  # type:ignore\n    filter_ = []\n    if isinstance(table_name, str):\n        filter_.append(table_name)\n    elif isiterable(table_name):\n        filter_.extend(table_name)\n    else:\n        raise ValueError(\n            f\"table_name must be string or Iterable, not {type(table_name)}\"\n        )\n    return [\n        nr\n        for nr in all_named_ranges\n        if nr.table_name in filter_  # type:ignore\n    ]\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_row","title":"<code>get_row(y, clone=True, create=True)</code>","text":"<p>Get the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>A copy is returned, use set_cell() to push it back.</p> <p>Arguments:</p> <pre><code>y -- int or str\n</code></pre> <p>Return: Row</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:\n    \"\"\"Get the row at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    A copy is returned, use set_cell() to push it back.\n\n    Arguments:\n\n        y -- int or str\n\n    Return: Row\n    \"\"\"\n    # fixme : keep repeat ? maybe an option to functions : \"raw=False\"\n    y = self._translate_y_from_any(y)\n    row = self._get_row2(y, clone=clone, create=create)\n    if row is None:\n        raise ValueError(\"Row not found\")\n    row.y = y\n    return row\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_row_sub_elements","title":"<code>get_row_sub_elements(y)</code>","text":"<p>Shortcut to get the list of Elements values for the cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Missing values replaced by None.</p> <p>Arguments:</p> <pre><code>y -- int, str\n</code></pre> <p>Return: list of lists of Elements</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_row_sub_elements(self, y: int | str) -&gt; list[Any]:\n    \"\"\"Shortcut to get the list of Elements values for the cells of the row\n    at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Missing values replaced by None.\n\n    Arguments:\n\n        y -- int, str\n\n    Return: list of lists of Elements\n    \"\"\"\n    values = self.get_row(y, clone=False).get_sub_elements()\n    values.extend([None] * (self.width - len(values)))\n    return values\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_row_values","title":"<code>get_row_values(y, cell_type=None, complete=True, get_type=False)</code>","text":"<p>Shortcut to get the list of Python values for the cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Filter by cell_type, with cell_type \u2018all\u2019 will retrieve cells of any type, aka non empty cells. If cell_type and complete is True, replace missing values by None.</p> <p>If get_type is True, returns a tuple (value, ODF type of value)</p> <p>Arguments:</p> <pre><code>y -- int, str\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of lists of Python types</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_row_values(\n    self,\n    y: int | str,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n) -&gt; list:\n    \"\"\"Shortcut to get the list of Python values for the cells of the row\n    at the given \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Filter by cell_type, with cell_type 'all' will retrieve cells of any\n    type, aka non empty cells.\n    If cell_type and complete is True, replace missing values by None.\n\n    If get_type is True, returns a tuple (value, ODF type of value)\n\n    Arguments:\n\n        y -- int, str\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of lists of Python types\n    \"\"\"\n    values = self.get_row(y, clone=False).get_values(\n        cell_type=cell_type, complete=complete, get_type=get_type\n    )\n    # complete row to match column width\n    if complete:\n        if get_type:\n            values.extend([(None, None)] * (self.width - len(values)))\n        else:\n            values.extend([None] * (self.width - len(values)))\n    return values\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_rows","title":"<code>get_rows(coord=None, style=None, content=None)</code>","text":"<p>Get the list of rows matching the criteria.</p> <p>Filter by coordinates will parse the area defined by the coordinates.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of rows\n\ncontent -- str regex\n\nstyle -- str\n</code></pre> <p>Return: list of rows</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_rows(\n    self,\n    coord: tuple | list | str | None = None,\n    style: str | None = None,\n    content: str | None = None,\n) -&gt; list[Row]:\n    \"\"\"Get the list of rows matching the criteria.\n\n    Filter by coordinates will parse the area defined by the coordinates.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of rows\n\n        content -- str regex\n\n        style -- str\n\n    Return: list of rows\n    \"\"\"\n    if coord:\n        _x, y, _z, t = self._translate_table_coordinates(coord)\n    else:\n        y = t = None\n    # fixme : not clones ?\n    if not content and not style:\n        return list(self.traverse(start=y, end=t))\n    rows = []\n    for row in self.traverse(start=y, end=t):\n        if content and not row.match(content):\n            continue\n        if style and style != row.style:\n            continue\n        rows.append(row)\n    return rows\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_value","title":"<code>get_value(coord, get_type=False)</code>","text":"<p>Shortcut to get the Python value of the cell at the given coordinates.</p> <p>If get_type is True, returns the tuples (value, ODF type)</p> <p>coord is either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d. If an Area is given, the upper left position is used as coord.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str : coordinate\n</code></pre> <p>Return: Python type</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_value(\n    self,\n    coord: tuple | list | str,\n    get_type: bool = False,\n) -&gt; Any:\n    \"\"\"Shortcut to get the Python value of the cell at the given\n    coordinates.\n\n    If get_type is True, returns the tuples (value, ODF type)\n\n    coord is either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\". If an Area is given, the upper\n    left position is used as coord.\n\n    Arguments:\n\n        coord -- (int, int) or str : coordinate\n\n    Return: Python type\n    \"\"\"\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    # Outside the defined table\n    if y &gt;= self.height:\n        if get_type:\n            return (None, None)\n        return None\n    else:\n        # Inside the defined table\n        row = self._get_row2_base(y)\n        if row is None:\n            raise ValueError\n        cell = row._get_cell2_base(x)\n        if cell is None:\n            if get_type:\n                return (None, None)\n            return None\n        return cell.get_value(get_type=get_type)\n</code></pre>"},{"location":"reference.html#odfdo.Table.get_values","title":"<code>get_values(coord=None, cell_type=None, complete=True, get_type=False, flat=False)</code>","text":"<p>Get a matrix of values of the table.</p> <p>Filter by coordinates will parse the area defined by the coordinates.</p> <p>If \u2018cell_type\u2019 is used and \u2018complete\u2019 is True (default), missing values are replaced by None. Filter by \u2019 cell_type = \u201call\u201d \u2019 will retrieve cells of any type, aka non empty cells.</p> <p>If \u2018cell_type\u2019 is None, complete is always True : with no cell type queried, get_values() returns None for each empty cell, the length each lists is equal to the width of the table.</p> <p>If get_type is True, returns tuples (value, ODF type of value), or (None, None) for empty cells with complete True.</p> <p>If flat is True, the methods return a single list of all the values. By default, flat is False.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of area\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: list of lists of Python types</p> Source code in <code>odfdo/table.py</code> <pre><code>def get_values(\n    self,\n    coord: tuple | list | str | None = None,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n    flat: bool = False,\n) -&gt; list:\n    \"\"\"Get a matrix of values of the table.\n\n    Filter by coordinates will parse the area defined by the coordinates.\n\n    If 'cell_type' is used and 'complete' is True (default), missing values\n    are replaced by None.\n    Filter by ' cell_type = \"all\" ' will retrieve cells of any\n    type, aka non empty cells.\n\n    If 'cell_type' is None, complete is always True : with no cell type\n    queried, get_values() returns None for each empty cell, the length\n    each lists is equal to the width of the table.\n\n    If get_type is True, returns tuples (value, ODF type of value), or\n    (None, None) for empty cells with complete True.\n\n    If flat is True, the methods return a single list of all the values.\n    By default, flat is False.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of area\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: list of lists of Python types\n    \"\"\"\n    if coord:\n        x, y, z, t = self._translate_table_coordinates(coord)\n    else:\n        x = y = z = t = None\n    data = []\n    for row in self.traverse(start=y, end=t):\n        if z is None:\n            width = self.width\n        else:\n            width = min(z + 1, self.width)\n        if x is not None:\n            width -= x\n        values = row.get_values(\n            (x, z),\n            cell_type=cell_type,\n            complete=complete,\n            get_type=get_type,\n        )\n        # complete row to match request width\n        if complete:\n            if get_type:\n                values.extend([(None, None)] * (width - len(values)))\n            else:\n                values.extend([None] * (width - len(values)))\n        if flat:\n            data.extend(values)\n        else:\n            data.append(values)\n    return data\n</code></pre>"},{"location":"reference.html#odfdo.Table.insert_cell","title":"<code>insert_cell(coord, cell=None, clone=True)</code>","text":"<p>Insert the given cell at the given coordinates. If no cell is given, an empty one is created.</p> <p>Coordinates are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Cells on the right are shifted. Other rows remain untouched.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n\ncell -- Cell\n</code></pre> <p>returns the cell with x and y updated</p> Source code in <code>odfdo/table.py</code> <pre><code>def insert_cell(\n    self,\n    coord: tuple | list | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Insert the given cell at the given coordinates. If no cell is\n    given, an empty one is created.\n\n    Coordinates are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Cells on the right are shifted. Other rows remain untouched.\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n        cell -- Cell\n\n    returns the cell with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    if clone:\n        cell = cell.clone\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    row = self._get_row2(y, clone=True)\n    row.y = y\n    row.repeated = None\n    cell_back = row.insert_cell(x, cell, clone=False)\n    self.set_row(y, row, clone=False)\n    # Update width if necessary\n    self._update_width(row)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.insert_column","title":"<code>insert_column(x, column=None)</code>","text":"<p>Insert the column before the given \u201cx\u201d position. If no column is given, an empty one is created.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncolumn -- Column\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def insert_column(\n    self,\n    x: int | str,\n    column: Column | None = None,\n) -&gt; Column:\n    \"\"\"Insert the column before the given \"x\" position. If no column is\n    given, an empty one is created.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        x -- int or str\n\n        column -- Column\n    \"\"\"\n    if column is None:\n        column = Column()\n    x = self._translate_x_from_any(x)\n    diff = x - self.width\n    if diff &lt; 0:\n        column_back = insert_item_in_vault(\n            x, column, self, _xpath_column_idx, \"_cmap\"\n        )\n    elif diff == 0:\n        column_back = self.append_column(column.clone)\n    else:\n        self.append_column(Column(repeated=diff), _repeated=diff)\n        column_back = self.append_column(column.clone)\n    column_back.x = x  # type: ignore\n    # Repetitions are accepted\n    repeated = column.repeated or 1\n    # Update width on every row\n    for row in self._get_rows():\n        if row.width &gt; x:\n            row.insert_cell(x, Cell(repeated=repeated))\n        # Shorter rows don't need insert\n        # Longer rows shouldn't exist!\n    return column_back  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Table.insert_row","title":"<code>insert_row(y, row=None, clone=True)</code>","text":"<p>Insert the row before the given \u201cy\u201d position. If no row is given, an empty one is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>If row is None, a new empty row is created.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\nrow -- Row\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def insert_row(\n    self, y: str | int, row: Row | None = None, clone: bool = True\n) -&gt; Row:\n    \"\"\"Insert the row before the given \"y\" position. If no row is given,\n    an empty one is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    If row is None, a new empty row is created.\n\n    Arguments:\n\n        y -- int or str\n\n        row -- Row\n\n    returns the row, with updated row.y\n    \"\"\"\n    if row is None:\n        row = Row()\n        clone = False\n    y = self._translate_y_from_any(y)\n    diff = y - self.height\n    if diff &lt; 0:\n        row_back = insert_item_in_vault(y, row, self, _xpath_row_idx, \"_tmap\")\n    elif diff == 0:\n        row_back = self.append_row(row, clone=clone)\n    else:\n        self.append_row(Row(repeated=diff), _repeated=diff, clone=False)\n        row_back = self.append_row(row, clone=clone)\n    row_back.y = y  # type: ignore\n    # Update width if necessary\n    self._update_width(row_back)  # type: ignore\n    return row_back  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.Table.is_column_empty","title":"<code>is_column_empty(x, aggressive=False)</code>","text":"<p>Return wether every cell in the column at \u201cx\u201d position has no value or the value evaluates to False (empty string), and no style.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Return: bool</p> Source code in <code>odfdo/table.py</code> <pre><code>def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return wether every cell in the column at \"x\" position has no value\n    or the value evaluates to False (empty string), and no style.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Return: bool\n    \"\"\"\n    for cell in self.get_column_cells(x):\n        if cell is None:\n            continue\n        if not cell.is_empty(aggressive=aggressive):\n            return False\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Table.is_empty","title":"<code>is_empty(aggressive=False)</code>","text":"<p>Return whether every cell in the table has no value or the value evaluates to False (empty string), and no style.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>aggressive -- bool\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def is_empty(self, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return whether every cell in the table has no value or the value\n    evaluates to False (empty string), and no style.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        aggressive -- bool\n    \"\"\"\n    return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())\n</code></pre>"},{"location":"reference.html#odfdo.Table.is_row_empty","title":"<code>is_row_empty(y, aggressive=False)</code>","text":"<p>Return wether every cell in the row at the given \u201cy\u201d position has no value or the value evaluates to False (empty string), and no style.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>If aggressive is True, empty cells with style are considered empty.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\naggressive -- bool\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:\n    \"\"\"Return wether every cell in the row at the given \"y\" position has\n    no value or the value evaluates to False (empty string), and no style.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    If aggressive is True, empty cells with style are considered empty.\n\n    Arguments:\n\n        y -- int or str\n\n        aggressive -- bool\n    \"\"\"\n    return self.get_row(y, clone=False).is_empty(aggressive=aggressive)\n</code></pre>"},{"location":"reference.html#odfdo.Table.iter_values","title":"<code>iter_values(coord=None, cell_type=None, complete=True, get_type=False)</code>","text":"<p>Iterate through lines of Python values of the table.</p> <p>Filter by coordinates will parse the area defined by the coordinates.</p> <p>cell_type, complete, grt_type : see get_values()</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of area\n\ncell_type -- 'boolean', 'float', 'date', 'string', 'time',\n             'currency', 'percentage' or 'all'\n\ncomplete -- boolean\n\nget_type -- boolean\n</code></pre> <p>Return: iterator of lists</p> Source code in <code>odfdo/table.py</code> <pre><code>def iter_values(\n    self,\n    coord: tuple | list | str | None = None,\n    cell_type: str | None = None,\n    complete: bool = True,\n    get_type: bool = False,\n) -&gt; Iterator[list]:\n    \"\"\"Iterate through lines of Python values of the table.\n\n    Filter by coordinates will parse the area defined by the coordinates.\n\n    cell_type, complete, grt_type : see get_values()\n\n\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of area\n\n        cell_type -- 'boolean', 'float', 'date', 'string', 'time',\n                     'currency', 'percentage' or 'all'\n\n        complete -- boolean\n\n        get_type -- boolean\n\n    Return: iterator of lists\n    \"\"\"\n    if coord:\n        x, y, z, t = self._translate_table_coordinates(coord)\n    else:\n        x = y = z = t = None\n    for row in self.traverse(start=y, end=t):\n        if z is None:\n            width = self.width\n        else:\n            width = min(z + 1, self.width)\n        if x is not None:\n            width -= x\n        values = row.get_values(\n            (x, z),\n            cell_type=cell_type,\n            complete=complete,\n            get_type=get_type,\n        )\n        # complete row to match column width\n        if complete:\n            if get_type:\n                values.extend([(None, None)] * (width - len(values)))\n            else:\n                values.extend([None] * (width - len(values)))\n        yield values\n</code></pre>"},{"location":"reference.html#odfdo.Table.optimize_width","title":"<code>optimize_width()</code>","text":"<p>Remove in-place empty rows below and empty cells at the right of the table. Keep repeated styles of empty cells but minimize row width.</p> Source code in <code>odfdo/table.py</code> <pre><code>def optimize_width(self) -&gt; None:\n    \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n    the table. Keep repeated styles of empty cells but minimize row width.\n    \"\"\"\n    self._optimize_width_trim_rows()\n    width = self._optimize_width_length()\n    self._optimize_width_rstrip_rows(width)\n    self._optimize_width_adapt_columns(width)\n</code></pre>"},{"location":"reference.html#odfdo.Table.rstrip","title":"<code>rstrip(aggressive=False)</code>","text":"<p>Remove in-place empty rows below and empty cells at the right of the table. Cells are empty if they contain no value or it evaluates to False, and no style.</p> <p>If aggressive is True, empty cells with style are removed too.</p> <p>Argument:</p> <pre><code>aggressive -- bool\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def rstrip(self, aggressive: bool = False) -&gt; None:\n    \"\"\"Remove *in-place* empty rows below and empty cells at the right of\n    the table. Cells are empty if they contain no value or it evaluates\n    to False, and no style.\n\n    If aggressive is True, empty cells with style are removed too.\n\n    Argument:\n\n        aggressive -- bool\n    \"\"\"\n    # Step 1: remove empty rows below the table\n    for row in reversed(self._get_rows()):\n        if row.is_empty(aggressive=aggressive):\n            row.parent.delete(row)  # type: ignore\n        else:\n            break\n    # Step 2: rstrip remaining rows\n    max_width = 0\n    for row in self._get_rows():\n        row.rstrip(aggressive=aggressive)\n        # keep count of the biggest row\n        max_width = max(max_width, row.width)\n    # raz cache of rows\n    self._indexes[\"_tmap\"] = {}\n    # Step 3: trim columns to match max_width\n    columns = self._get_columns()\n    repeated_cols = self.xpath(\"table:table-column/@table:number-columns-repeated\")\n    if not isinstance(repeated_cols, list):\n        raise TypeError\n    unrepeated = len(columns) - len(repeated_cols)\n    column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore\n    diff = column_width - max_width\n    if diff &gt; 0:\n        for column in reversed(columns):\n            repeated = column.repeated or 1\n            repeated = repeated - diff\n            if repeated &gt; 0:\n                column.repeated = repeated\n                break\n            else:\n                column.parent.delete(column)\n                diff = -repeated\n                if diff == 0:\n                    break\n    # raz cache of columns\n    self._indexes[\"_cmap\"] = {}\n    self._compute_table_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_cell","title":"<code>set_cell(coord, cell=None, clone=True)</code>","text":"<p>Replace a cell of the table at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str : coordinate\n\ncell -- Cell\n</code></pre> <p>return the cell, with x and y updated</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_cell(\n    self,\n    coord: tuple | list | str,\n    cell: Cell | None = None,\n    clone: bool = True,\n) -&gt; Cell:\n    \"\"\"Replace a cell of the table at the given coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Arguments:\n\n        coord -- (int, int) or str : coordinate\n\n        cell -- Cell\n\n    return the cell, with x and y updated\n    \"\"\"\n    if cell is None:\n        cell = Cell()\n        clone = False\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    cell.x = x\n    cell.y = y\n    if y &gt;= self.height:\n        row = Row()\n        cell_back = row.set_cell(x, cell, clone=clone)\n        self.set_row(y, row, clone=False)\n    else:\n        row_read = self._get_row2_base(y)\n        if row_read is None:\n            raise ValueError\n        row = row_read\n        row.y = y\n        repeated = row.repeated or 1\n        if repeated &gt; 1:\n            row = row.clone\n            row.repeated = None\n            cell_back = row.set_cell(x, cell, clone=clone)\n            self.set_row(y, row, clone=False)\n        else:\n            cell_back = row.set_cell(x, cell, clone=clone)\n            # Update width if necessary, since we don't use set_row\n            self._update_width(row)\n    return cell_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_cell_image","title":"<code>set_cell_image(coord, image_frame, doc_type=None)</code>","text":"<p>Do all the magic to display an image in the cell at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>The frame element must contain the expected image position and dimensions.</p> <p>DrawImage insertion depends on the document type, so the type must be provided or the table element must be already attached to a document.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n\nimage_frame -- Frame including an image\n\ndoc_type -- 'spreadsheet' or 'text'\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_cell_image(\n    self,\n    coord: tuple | list | str,\n    image_frame: Frame,\n    doc_type: str | None = None,\n) -&gt; None:\n    \"\"\"Do all the magic to display an image in the cell at the given\n    coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    The frame element must contain the expected image position and\n    dimensions.\n\n    DrawImage insertion depends on the document type, so the type must be\n    provided or the table element must be already attached to a document.\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n        image_frame -- Frame including an image\n\n        doc_type -- 'spreadsheet' or 'text'\n    \"\"\"\n    # Test document type\n    if doc_type is None:\n        body = self.document_body\n        if body is None:\n            raise ValueError(\"document type not found\")\n        doc_type = {\"office:spreadsheet\": \"spreadsheet\", \"office:text\": \"text\"}.get(\n            body.tag\n        )\n        if doc_type is None:\n            raise ValueError(\"document type not supported for images\")\n    # We need the end address of the image\n    x, y = self._translate_cell_coordinates(coord)\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    cell = self.get_cell((x, y))\n    image_frame = image_frame.clone  # type: ignore\n    # Remove any previous paragraph, frame, etc.\n    for child in cell.children:\n        cell.delete(child)\n    # Now it all depends on the document type\n    if doc_type == \"spreadsheet\":\n        image_frame.anchor_type = \"char\"\n        # The frame needs end coordinates\n        width, height = image_frame.size\n        image_frame.set_attribute(\"table:end-x\", width)\n        image_frame.set_attribute(\"table:end-y\", height)\n        # FIXME what happens when the address changes?\n        address = f\"{self.name}.{digit_to_alpha(x)}{y + 1}\"\n        image_frame.set_attribute(\"table:end-cell-address\", address)\n        # The frame is directly in the cell\n        cell.append(image_frame)\n    elif doc_type == \"text\":\n        # The frame must be in a paragraph\n        cell.set_value(\"\")\n        paragraph = cell.get_element(\"text:p\")\n        if paragraph is None:\n            raise ValueError\n        paragraph.append(image_frame)\n    self.set_cell(coord, cell)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_cells","title":"<code>set_cells(cells, coord=None, clone=True)</code>","text":"<p>Set the cells in the table, from the \u2018coord\u2019 position.</p> <p>\u2018coord\u2019 is the coordinate of the upper left cell to be modified by values. If \u2018coord\u2019 is None, default to the position (0,0) (\u201cA1\u201d). If \u2018coord\u2019 is an area (e.g. \u201cA2:B5\u201d), the upper left position of this area is used as coordinate.</p> <p>The table is not cleared before the operation, to reset the table before setting cells, use table.clear().</p> <p>A list of lists is expected, with as many lists as rows to be set, and as many cell in each sublist as cells to be setted in the row.</p> <p>Arguments:</p> <pre><code>cells -- list of list of cells\n\ncoord -- tuple or str\n\nvalues -- list of lists of python types\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_cells(\n    self,\n    cells: list[list[Cell]] | list[tuple[Cell]],\n    coord: tuple | list | str | None = None,\n    clone: bool = True,\n) -&gt; None:\n    \"\"\"Set the cells in the table, from the 'coord' position.\n\n    'coord' is the coordinate of the upper left cell to be modified by\n    values. If 'coord' is None, default to the position (0,0) (\"A1\").\n    If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n    area is used as coordinate.\n\n    The table is *not* cleared before the operation, to reset the table\n    before setting cells, use table.clear().\n\n    A list of lists is expected, with as many lists as rows to be set, and\n    as many cell in each sublist as cells to be setted in the row.\n\n    Arguments:\n\n        cells -- list of list of cells\n\n        coord -- tuple or str\n\n        values -- list of lists of python types\n    \"\"\"\n    if coord:\n        x, y = self._translate_cell_coordinates(coord)\n    else:\n        x = y = 0\n    if y is None:\n        y = 0\n    if x is None:\n        x = 0\n    y -= 1\n    for row_cells in cells:\n        y += 1\n        if not row_cells:\n            continue\n        row = self.get_row(y, clone=True)\n        repeated = row.repeated or 1\n        if repeated &gt;= 2:\n            row.repeated = None\n        row.set_cells(row_cells, start=x, clone=clone)\n        self.set_row(y, row, clone=False)\n        self._update_width(row)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_column","title":"<code>set_column(x, column=None)</code>","text":"<p>Replace the column at the given \u201cx\u201d position.</p> <p>ODF columns don\u2019t contain cells, only style information.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncolumn -- Column\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_column(\n    self,\n    x: int | str,\n    column: Column | None = None,\n) -&gt; Column:\n    \"\"\"Replace the column at the given \"x\" position.\n\n    ODF columns don't contain cells, only style information.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    Arguments:\n\n        x -- int or str\n\n        column -- Column\n    \"\"\"\n    x = self._translate_x_from_any(x)\n    if column is None:\n        column = Column()\n        repeated = 1\n    else:\n        repeated = column.repeated or 1\n    column.x = x\n    # Outside the defined table ?\n    diff = x - self.width\n    if diff == 0:\n        column_back = self.append_column(column, _repeated=repeated)\n    elif diff &gt; 0:\n        self.append_column(Column(repeated=diff), _repeated=diff)\n        column_back = self.append_column(column, _repeated=repeated)\n    else:\n        # Inside the defined table\n        column_back = set_item_in_vault(  # type: ignore\n            x, column, self, _xpath_column_idx, \"_cmap\"\n        )\n    return column_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_column_cells","title":"<code>set_column_cells(x, cells)</code>","text":"<p>Shortcut to set the list of cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>The list must have the same length than the table height.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\ncells -- list of Cell\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:\n    \"\"\"Shortcut to set the list of cells at the given position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    The list must have the same length than the table height.\n\n    Arguments:\n\n        x -- int or str\n\n        cells -- list of Cell\n    \"\"\"\n    height = self.height\n    if len(cells) != height:\n        raise ValueError(f\"col mismatch: {height} cells expected\")\n    cells_iterator = iter(cells)\n    for y, row in enumerate(self.traverse()):\n        row.set_cell(x, next(cells_iterator))\n        self.set_row(y, row)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_column_values","title":"<code>set_column_values(x, values, cell_type=None, currency=None, style=None)</code>","text":"<p>Shortcut to set the list of Python values of cells at the given position.</p> <p>Position start at 0. So cell C4 is on column 2. Alphabetical position like \u201cC\u201d is accepted.</p> <p>The list must have the same length than the table height.</p> <p>Arguments:</p> <pre><code>x -- int or str\n\nvalues -- list of Python types\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_column_values(\n    self,\n    x: int | str,\n    values: list,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the list of Python values of cells at the given\n    position.\n\n    Position start at 0. So cell C4 is on column 2. Alphabetical position\n    like \"C\" is accepted.\n\n    The list must have the same length than the table height.\n\n    Arguments:\n\n        x -- int or str\n\n        values -- list of Python types\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n    \"\"\"\n    cells = [\n        Cell(value, cell_type=cell_type, currency=currency, style=style)\n        for value in values\n    ]\n    self.set_column_cells(x, cells)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_named_range","title":"<code>set_named_range(name, crange, table_name=None, usage=None)</code>","text":"<p>Create a Named Range element and insert it in the document. Beware : named ranges are stored at the body level, thus do not call this method on a cloned table.</p> <p>Arguments:</p> <pre><code>name -- str, name of the named range\n\ncrange -- str or tuple of int, cell or area coordinate\n\ntable_name -- str, name of the table\n\nuage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_named_range(\n    self,\n    name: str,\n    crange: str | tuple | list,\n    table_name: str | None = None,\n    usage: str | None = None,\n) -&gt; None:\n    \"\"\"Create a Named Range element and insert it in the document.\n    Beware : named ranges are stored at the body level, thus do not call\n    this method on a cloned table.\n\n    Arguments:\n\n        name -- str, name of the named range\n\n        crange -- str or tuple of int, cell or area coordinate\n\n        table_name -- str, name of the table\n\n        uage -- None or 'print-range', 'filter', 'repeat-column', 'repeat-row'\n    \"\"\"\n    body = self.document_body\n    if not body:\n        raise ValueError(\"Table is not inside a document\")\n    if not name:\n        raise ValueError(\"Name required.\")\n    if table_name is None:\n        table_name = self.name\n    named_range = NamedRange(name, crange, table_name, usage)\n    body.append_named_range(named_range)\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_row","title":"<code>set_row(y, row=None, clone=True)</code>","text":"<p>Replace the row at the given position with the new one. Repetions of the old row will be adjusted.</p> <p>If row is None, a new empty row is created.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\nrow -- Row\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:\n    \"\"\"Replace the row at the given position with the new one. Repetions of\n    the old row will be adjusted.\n\n    If row is None, a new empty row is created.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n\n        row -- Row\n\n    returns the row, with updated row.y\n    \"\"\"\n    if row is None:\n        row = Row()\n        repeated = 1\n        clone = False\n    else:\n        repeated = row.repeated or 1\n    y = self._translate_y_from_any(y)\n    row.y = y\n    # Outside the defined table ?\n    diff = y - self.height\n    if diff == 0:\n        row_back = self.append_row(row, _repeated=repeated, clone=clone)\n    elif diff &gt; 0:\n        self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)\n        row_back = self.append_row(row, _repeated=repeated, clone=clone)\n    else:\n        # Inside the defined table\n        row_back = set_item_in_vault(  # type: ignore\n            y, row, self, _xpath_row_idx, \"_tmap\", clone=clone\n        )\n    # print self.serialize(True)\n    # Update width if necessary\n    self._update_width(row_back)\n    return row_back\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_row_cells","title":"<code>set_row_cells(y, cells=None)</code>","text":"<p>Shortcut to set all the cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\ncells -- list of Python types\n\nstyle -- str\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:\n    \"\"\"Shortcut to set *all* the cells of the row at the given\n    \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n\n        cells -- list of Python types\n\n        style -- str\n\n    returns the row, with updated row.y\n    \"\"\"\n    if cells is None:\n        cells = []\n    row = Row()  # needed if clones rows\n    row.extend_cells(cells)\n    return self.set_row(y, row)  # needed if clones rows\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_row_values","title":"<code>set_row_values(y, values, cell_type=None, currency=None, style=None)</code>","text":"<p>Shortcut to set the values of all cells of the row at the given \u201cy\u201d position.</p> <p>Position start at 0. So cell A4 is on row 3.</p> <p>Arguments:</p> <pre><code>y -- int or str\n\nvalues -- list of Python types\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> <p>returns the row, with updated row.y</p> Source code in <code>odfdo/table.py</code> <pre><code>def set_row_values(\n    self,\n    y: int | str,\n    values: list,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; Row:\n    \"\"\"Shortcut to set the values of *all* cells of the row at the given\n    \"y\" position.\n\n    Position start at 0. So cell A4 is on row 3.\n\n    Arguments:\n\n        y -- int or str\n\n        values -- list of Python types\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n\n    returns the row, with updated row.y\n    \"\"\"\n    row = Row()  # needed if clones rows\n    row.set_values(values, style=style, cell_type=cell_type, currency=currency)\n    return self.set_row(y, row)  # needed if clones rows\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_span","title":"<code>set_span(area, merge=False)</code>","text":"<p>Create a Cell Span : span the first cell of the area on several columns and/or rows. If merge is True, replace text of the cell by the concatenation of existing text in covered cells. Beware : if merge is True, old text is changed, if merge is False (the default), old text in coverd cells is still present but not displayed by most GUI.</p> <p>If the area defines only one cell, the set span will do nothing. It is not allowed to apply set span to an area whose one cell already belongs to previous cell span.</p> <p>Area can be either one cell (like \u2018A1\u2019) or an area (\u2018A1:B2\u2019). It can be provided as an alpha numeric value like \u201cA1:B2\u2019 or a tuple like (0, 0, 1, 1) or (0, 0).</p> <p>Arguments:</p> <pre><code>area -- str or tuple of int, cell or area coordinate\n\nmerge -- boolean\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_span(\n    self,\n    area: str | tuple | list,\n    merge: bool = False,\n) -&gt; bool:\n    \"\"\"Create a Cell Span : span the first cell of the area on several\n    columns and/or rows.\n    If merge is True, replace text of the cell by the concatenation of\n    existing text in covered cells.\n    Beware : if merge is True, old text is changed, if merge is False\n    (the default), old text in coverd cells is still present but not\n    displayed by most GUI.\n\n    If the area defines only one cell, the set span will do nothing.\n    It is not allowed to apply set span to an area whose one cell already\n    belongs to previous cell span.\n\n    Area can be either one cell (like 'A1') or an area ('A1:B2'). It can\n    be provided as an alpha numeric value like \"A1:B2' or a tuple like\n    (0, 0, 1, 1) or (0, 0).\n\n    Arguments:\n\n        area -- str or tuple of int, cell or area coordinate\n\n        merge -- boolean\n    \"\"\"\n    # get area\n    digits = convert_coordinates(area)\n    if len(digits) == 4:\n        x, y, z, t = digits\n    else:\n        x, y = digits\n        z, t = digits\n    start = x, y\n    end = z, t\n    if start == end:\n        # one cell : do nothing\n        return False\n    if x is None:\n        raise ValueError\n    if y is None:\n        raise ValueError\n    if z is None:\n        raise ValueError\n    if t is None:\n        raise ValueError\n    # check for previous span\n    good = True\n    # Check boundaries and empty cells : need to crate non existent cells\n    # so don't use get_cells directly, but get_cell\n    cells = []\n    for yy in range(y, t + 1):\n        row_cells = []\n        for xx in range(x, z + 1):\n            row_cells.append(\n                self.get_cell((xx, yy), clone=True, keep_repeated=False)\n            )\n        cells.append(row_cells)\n    for row in cells:\n        for cell in row:\n            if cell.is_spanned():\n                good = False\n                break\n        if not good:\n            break\n    if not good:\n        return False\n    # Check boundaries\n    # if z &gt;= self.width or t &gt;= self.height:\n    #    self.set_cell(coord = end)\n    #    print area, z, t\n    #    cells = self.get_cells((x, y, z, t))\n    #    print cells\n    # do it:\n    if merge:\n        val_list = []\n        for row in cells:\n            for cell in row:\n                if cell.is_empty(aggressive=True):\n                    continue\n                val = cell.get_value()\n                if val is not None:\n                    if isinstance(val, str):\n                        val.strip()\n                    if val != \"\":\n                        val_list.append(val)\n                    cell.clear()\n        if val_list:\n            if len(val_list) == 1:\n                cells[0][0].set_value(val_list[0])\n            else:\n                value = \" \".join([str(v) for v in val_list if v])\n                cells[0][0].set_value(value)\n    cols = z - x + 1\n    cells[0][0].set_attribute(\"table:number-columns-spanned\", str(cols))\n    rows = t - y + 1\n    cells[0][0].set_attribute(\"table:number-rows-spanned\", str(rows))\n    for cell in cells[0][1:]:\n        cell.tag = \"table:covered-table-cell\"\n    for row in cells[1:]:\n        for cell in row:\n            cell.tag = \"table:covered-table-cell\"\n    # replace cells in table\n    self.set_cells(cells, coord=start, clone=False)\n    return True\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_value","title":"<code>set_value(coord, value, cell_type=None, currency=None, style=None)</code>","text":"<p>Set the Python value of the cell at the given coordinates.</p> <p>They are either a 2-uplet of (x, y) starting from 0, or a human-readable position like \u201cC4\u201d.</p> <p>Arguments:</p> <pre><code>coord -- (int, int) or str\n\nvalue -- Python type\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n         'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_value(\n    self,\n    coord: tuple | list | str,\n    value: Any,\n    cell_type: str | None = None,\n    currency: str | None = None,\n    style: str | None = None,\n) -&gt; None:\n    \"\"\"Set the Python value of the cell at the given coordinates.\n\n    They are either a 2-uplet of (x, y) starting from 0, or a\n    human-readable position like \"C4\".\n\n    Arguments:\n\n        coord -- (int, int) or str\n\n        value -- Python type\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                 'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n\n    \"\"\"\n    self.set_cell(\n        coord,\n        Cell(value, cell_type=cell_type, currency=currency, style=style),\n        clone=False,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.Table.set_values","title":"<code>set_values(values, coord=None, style=None, cell_type=None, currency=None)</code>","text":"<p>Set the value of cells in the table, from the \u2018coord\u2019 position with values.</p> <p>\u2018coord\u2019 is the coordinate of the upper left cell to be modified by values. If \u2018coord\u2019 is None, default to the position (0,0) (\u201cA1\u201d). If \u2018coord\u2019 is an area (e.g. \u201cA2:B5\u201d), the upper left position of this area is used as coordinate.</p> <p>The table is not cleared before the operation, to reset the table before setting values, use table.clear().</p> <p>A list of lists is expected, with as many lists as rows, and as many items in each sublist as cells to be setted. None values in the list will create empty cells with no cell type (but eventually a style).</p> <p>Arguments:</p> <pre><code>coord -- tuple or str\n\nvalues -- list of lists of python types\n\ncell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n             'string' or 'time'\n\ncurrency -- three-letter str\n\nstyle -- str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def set_values(\n    self,\n    values: list,\n    coord: tuple | list | str | None = None,\n    style: str | None = None,\n    cell_type: str | None = None,\n    currency: str | None = None,\n) -&gt; None:\n    \"\"\"Set the value of cells in the table, from the 'coord' position\n    with values.\n\n    'coord' is the coordinate of the upper left cell to be modified by\n    values. If 'coord' is None, default to the position (0,0) (\"A1\").\n    If 'coord' is an area (e.g. \"A2:B5\"), the upper left position of this\n    area is used as coordinate.\n\n    The table is *not* cleared before the operation, to reset the table\n    before setting values, use table.clear().\n\n    A list of lists is expected, with as many lists as rows, and as many\n    items in each sublist as cells to be setted. None values in the list\n    will create empty cells with no cell type (but eventually a style).\n\n    Arguments:\n\n        coord -- tuple or str\n\n        values -- list of lists of python types\n\n        cell_type -- 'boolean', 'currency', 'date', 'float', 'percentage',\n                     'string' or 'time'\n\n        currency -- three-letter str\n\n        style -- str\n    \"\"\"\n    if coord:\n        x, y = self._translate_cell_coordinates(coord)\n    else:\n        x = y = 0\n    if y is None:\n        y = 0\n    if x is None:\n        x = 0\n    y -= 1\n    for row_values in values:\n        y += 1\n        if not row_values:\n            continue\n        row = self.get_row(y, clone=True)\n        repeated = row.repeated or 1\n        if repeated &gt;= 2:\n            row.repeated = None\n        row.set_values(\n            row_values,\n            start=x,\n            cell_type=cell_type,\n            currency=currency,\n            style=style,\n        )\n        self.set_row(y, row, clone=False)\n        self._update_width(row)\n</code></pre>"},{"location":"reference.html#odfdo.Table.to_csv","title":"<code>to_csv(path_or_file=None, dialect='excel')</code>","text":"<p>Write the table as CSV in the file.</p> <p>If the file is a string, it is opened as a local path. Else an opened file-like is expected.</p> <p>Arguments:</p> <pre><code>path_or_file -- str or file-like\n\ndialect -- str, python csv.dialect, can be 'excel', 'unix'...\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def to_csv(\n    self,\n    path_or_file: str | Path | None = None,\n    dialect: str = \"excel\",\n) -&gt; Any:\n    \"\"\"Write the table as CSV in the file.\n\n    If the file is a string, it is opened as a local path. Else an\n    opened file-like is expected.\n\n    Arguments:\n\n        path_or_file -- str or file-like\n\n        dialect -- str, python csv.dialect, can be 'excel', 'unix'...\n    \"\"\"\n\n    def write_content(csv_writer: object) -&gt; None:\n        for values in self.iter_values():\n            line = []\n            for value in values:\n                if value is None:\n                    value = \"\"\n                if isinstance(value, str):\n                    value = value.strip()\n                line.append(value)\n            csv_writer.writerow(line)  # type: ignore\n\n    out = StringIO(newline=\"\")\n    csv_writer = csv.writer(out, dialect=dialect)\n    write_content(csv_writer)\n    if path_or_file is None:\n        return out.getvalue()\n    path = Path(path_or_file)\n    path.write_text(out.getvalue())\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.Table.transpose","title":"<code>transpose(coord=None)</code>","text":"<p>Swap in-place rows and columns of the table.</p> <p>If \u2018coord\u2019 is not None, apply transpose only to the area defined by the coordinates. Beware, if area is not square, some cells mays be over written during the process.</p> <p>Arguments:</p> <pre><code>coord -- str or tuple of int : coordinates of area\n\nstart -- int or str\n</code></pre> Source code in <code>odfdo/table.py</code> <pre><code>def transpose(self, coord: tuple | list | str | None = None) -&gt; None:\n    \"\"\"Swap *in-place* rows and columns of the table.\n\n    If 'coord' is not None, apply transpose only to the area defined by the\n    coordinates. Beware, if area is not square, some cells mays be over\n    written during the process.\n\n    Arguments:\n\n        coord -- str or tuple of int : coordinates of area\n\n        start -- int or str\n    \"\"\"\n    data = []\n    if coord is None:\n        for row in self.traverse():\n            data.append(list(row.traverse()))\n        transposed_data = zip_longest(*data)\n        self.clear()\n        # new_rows = []\n        for row_cells in transposed_data:\n            if not isiterable(row_cells):\n                row_cells = (row_cells,)\n            row = Row()\n            row.extend_cells(row_cells)\n            self.append_row(row, clone=False)\n        self._compute_table_cache()\n    else:\n        x, y, z, t = self._translate_table_coordinates(coord)\n        if x is None:\n            x = 0\n        else:\n            x = min(x, self.width - 1)\n        if z is None:\n            z = self.width - 1\n        else:\n            z = min(z, self.width - 1)\n        if y is None:\n            y = 0\n        else:\n            y = min(y, self.height - 1)\n        if t is None:\n            t = self.height - 1\n        else:\n            t = min(t, self.height - 1)\n        for row in self.traverse(start=y, end=t):\n            data.append(list(row.traverse(start=x, end=z)))\n        transposed_data = zip_longest(*data)\n        # clear locally\n        w = z - x + 1\n        h = t - y + 1\n        if w != h:\n            nones = [[None] * w for i in range(h)]\n            self.set_values(nones, coord=(x, y, z, t))\n        # put transposed\n        filtered_data: list[tuple[Cell]] = []\n        for row_cells in transposed_data:\n            if isinstance(row_cells, (list, tuple)):\n                filtered_data.append(row_cells)\n            else:\n                filtered_data.append((row_cells,))\n        self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))\n        self._compute_table_cache()\n</code></pre>"},{"location":"reference.html#odfdo.Table.traverse","title":"<code>traverse(start=None, end=None)</code>","text":"<p>Yield as many row elements as expected rows in the table, i.e. expand repetitions by returning the same row as many times as necessary.</p> <pre><code>Arguments:\n\n    start -- int\n\n    end -- int\n</code></pre> <p>Copies are returned, use set_row() to push them back.</p> Source code in <code>odfdo/table.py</code> <pre><code>def traverse(\n    self,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; Iterator[Row]:\n    \"\"\"Yield as many row elements as expected rows in the table, i.e.\n    expand repetitions by returning the same row as many times as\n    necessary.\n\n        Arguments:\n\n            start -- int\n\n            end -- int\n\n    Copies are returned, use set_row() to push them back.\n    \"\"\"\n    if start is None:\n        start = 0\n    start = max(0, start)\n    if end is None:\n        end = 2**32\n    if end &lt; start:\n        return\n    y = -1\n    for row in self._yield_odf_rows():\n        y += 1\n        if y &lt; start:\n            continue\n        if y &gt; end:\n            return\n        row.y = y\n        yield row\n</code></pre>"},{"location":"reference.html#odfdo.Table.traverse_columns","title":"<code>traverse_columns(start=None, end=None)</code>","text":"<p>Yield as many column elements as expected columns in the table, i.e. expand repetitions by returning the same column as many times as necessary.</p> <pre><code>Arguments:\n\n    start -- int\n\n    end -- int\n</code></pre> <p>Copies are returned, use set_column() to push them back.</p> Source code in <code>odfdo/table.py</code> <pre><code>def traverse_columns(\n    self,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; Iterator[Column]:\n    \"\"\"Yield as many column elements as expected columns in the table,\n    i.e. expand repetitions by returning the same column as many times as\n    necessary.\n\n        Arguments:\n\n            start -- int\n\n            end -- int\n\n    Copies are returned, use set_column() to push them back.\n    \"\"\"\n    idx = -1\n    before = -1\n    x = 0\n    if start is None and end is None:\n        for juska in self._cmap:\n            idx += 1\n            if idx in self._indexes[\"_cmap\"]:\n                column = self._indexes[\"_cmap\"][idx]\n            else:\n                column = self._get_element_idx2(_xpath_column_idx, idx)\n                self._indexes[\"_cmap\"][idx] = column\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                # Return a copy without the now obsolete repetition\n                column = column.clone\n                column.x = x\n                x += 1\n                if repeated &gt; 1:\n                    column.repeated = None\n                yield column\n    else:\n        if start is None:\n            start = 0\n        start = max(0, start)\n        if end is None:\n            try:\n                end = self._cmap[-1]\n            except Exception:\n                end = -1\n        start_map = find_odf_idx(self._cmap, start)\n        if start_map is None:\n            return\n        if start_map &gt; 0:\n            before = self._cmap[start_map - 1]\n        idx = start_map - 1\n        before = start - 1\n        x = start\n        for juska in self._cmap[start_map:]:\n            idx += 1\n            if idx in self._indexes[\"_cmap\"]:\n                column = self._indexes[\"_cmap\"][idx]\n            else:\n                column = self._get_element_idx2(_xpath_column_idx, idx)\n                self._indexes[\"_cmap\"][idx] = column\n            repeated = juska - before\n            before = juska\n            for _i in range(repeated or 1):\n                if x &lt;= end:\n                    column = column.clone\n                    column.x = x\n                    x += 1\n                    if repeated &gt; 1 or (x == start and start &gt; 0):\n                        column.repeated = None\n                    yield column\n</code></pre>"},{"location":"reference.html#odfdo.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>Body</code></p> <p>Text, specialized class of Element in charge of actual content management.</p> Source code in <code>odfdo/body.py</code> <pre><code>class Text(Body):\n    \"\"\"Text, specialized class of Element in charge of actual content\n    management.\n    \"\"\"\n\n    _tag: str = \"office:text\"\n    _properties: tuple[PropDef, ...] = ()\n</code></pre>"},{"location":"reference.html#odfdo.TextChange","title":"<code>TextChange</code>","text":"<p>               Bases: <code>Element</code></p> <p>The TextChange \u201ctext:change\u201d element marks a position in an empty region where text has been deleted.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChange(Element):\n    \"\"\"The TextChange \"text:change\" element marks a position in an empty\n    region where text has been deleted.\n    \"\"\"\n\n    _tag = \"text:change\"\n\n    def get_id(self) -&gt; str | None:\n        return self.get_attribute_string(\"text:change-id\")\n\n    def set_id(self, idx: str) -&gt; None:\n        self.set_attribute(\"text:change-id\", idx)\n\n    def _get_tracked_changes(self) -&gt; Element | None:\n        body = self.document_body\n        if not body:\n            raise ValueError\n        return body.get_tracked_changes()\n\n    def get_changed_region(\n        self,\n        tracked_changes: Element | None = None,\n    ) -&gt; Element | None:\n        if not tracked_changes:\n            tracked_changes = self._get_tracked_changes()\n        idx = self.get_id()\n        return tracked_changes.get_changed_region(text_id=idx)  # type: ignore\n\n    def get_change_info(\n        self,\n        tracked_changes: Element | None = None,\n    ) -&gt; Element | None:\n        changed_region = self.get_changed_region(tracked_changes=tracked_changes)\n        if not changed_region:\n            return None\n        return changed_region.get_change_info()  # type: ignore\n\n    def get_change_element(\n        self,\n        tracked_changes: Element | None = None,\n    ) -&gt; Element | None:\n        changed_region = self.get_changed_region(tracked_changes=tracked_changes)\n        if not changed_region:\n            return None\n        return changed_region.get_change_element()  # type: ignore\n\n    def get_deleted(\n        self,\n        tracked_changes: Element | None = None,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; Element | None:\n        \"\"\"Shortcut to get the deleted informations stored in the\n        TextDeletion stored in the tracked changes.\n\n        Return: Paragraph (or None).\"\n        \"\"\"\n        changed = self.get_change_element(tracked_changes=tracked_changes)\n        if not changed:\n            return None\n        return changed.get_deleted(  # type: ignore\n            as_text=as_text,\n            no_header=no_header,\n            clean=clean,\n        )\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Return None.\"\"\"\n        return None\n\n    def get_start(self) -&gt; TextChangeStart | None:\n        \"\"\"Return None.\"\"\"\n        return None\n\n    def get_end(self) -&gt; TextChangeEnd | None:\n        \"\"\"Return None.\"\"\"\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_deleted","title":"<code>get_deleted(tracked_changes=None, as_text=False, no_header=False, clean=True)</code>","text":"<p>Shortcut to get the deleted informations stored in the TextDeletion stored in the tracked changes.</p> <p>Return: Paragraph (or None).\u201d</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(\n    self,\n    tracked_changes: Element | None = None,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; Element | None:\n    \"\"\"Shortcut to get the deleted informations stored in the\n    TextDeletion stored in the tracked changes.\n\n    Return: Paragraph (or None).\"\n    \"\"\"\n    changed = self.get_change_element(tracked_changes=tracked_changes)\n    if not changed:\n        return None\n    return changed.get_deleted(  # type: ignore\n        as_text=as_text,\n        no_header=no_header,\n        clean=clean,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_end","title":"<code>get_end()</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_end(self) -&gt; TextChangeEnd | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChange.get_start","title":"<code>get_start()</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_start(self) -&gt; TextChangeStart | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd","title":"<code>TextChangeEnd</code>","text":"<p>               Bases: <code>TextChange</code></p> <p>The TextChangeEnd \u201ctext:change-end\u201d element marks the end of a region with content where text has been inserted or the format has been changed.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChangeEnd(TextChange):\n    \"\"\"The TextChangeEnd \"text:change-end\" element marks the end of a region\n    with content where text has been inserted or the format has been\n    changed.\n    \"\"\"\n\n    _tag = \"text:change-end\"\n\n    def get_start(self) -&gt; TextChangeStart | None:\n        \"\"\"Return the corresponding annotation starting tag or None.\"\"\"\n        idx = self.get_id()\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can not find end tag: no parent available.\")\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_text_change_start(idx=idx)  # type: ignore\n\n    def get_end(self) -&gt; TextChangeEnd | None:\n        \"\"\"Return self.\"\"\"\n        return self\n\n    def get_deleted(self, *args: Any, **kwargs: Any) -&gt; Element | None:\n        \"\"\"Return None.\"\"\"\n        return None\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Return the content between text:change-start and text:change-end.\n\n        If no content exists (deletion tag), returns None (or '' if text flag\n        is True).\n        If as_text is True: returns the text content.\n        If clean is True: suppress unwanted tags (deletions marks, ...)\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of Element, cleaned and with headers\n\n        Arguments:\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list or Element or text\n        \"\"\"\n\n        # idx = self.get_id()\n        start = self.get_start()\n        end = self.get_end()\n        if end is None or start is None:\n            if as_text:\n                return \"\"\n            return None\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_between(\n            start, end, as_text=as_text, no_header=no_header, clean=clean\n        )\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_deleted","title":"<code>get_deleted(*args, **kwargs)</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(self, *args: Any, **kwargs: Any) -&gt; Element | None:\n    \"\"\"Return None.\"\"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_end","title":"<code>get_end()</code>","text":"<p>Return self.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_end(self) -&gt; TextChangeEnd | None:\n    \"\"\"Return self.\"\"\"\n    return self\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Return the content between text:change-start and text:change-end.</p> <p>If no content exists (deletion tag), returns None (or \u2018\u2019 if text flag is True). If as_text is True: returns the text content. If clean is True: suppress unwanted tags (deletions marks, \u2026) If no_header is True: existing text:h are changed in text:p By default: returns a list of Element, cleaned and with headers</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list or Element or text</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Return the content between text:change-start and text:change-end.\n\n    If no content exists (deletion tag), returns None (or '' if text flag\n    is True).\n    If as_text is True: returns the text content.\n    If clean is True: suppress unwanted tags (deletions marks, ...)\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of Element, cleaned and with headers\n\n    Arguments:\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list or Element or text\n    \"\"\"\n\n    # idx = self.get_id()\n    start = self.get_start()\n    end = self.get_end()\n    if end is None or start is None:\n        if as_text:\n            return \"\"\n        return None\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_between(\n        start, end, as_text=as_text, no_header=no_header, clean=clean\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeEnd.get_start","title":"<code>get_start()</code>","text":"<p>Return the corresponding annotation starting tag or None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_start(self) -&gt; TextChangeStart | None:\n    \"\"\"Return the corresponding annotation starting tag or None.\"\"\"\n    idx = self.get_id()\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Can not find end tag: no parent available.\")\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_text_change_start(idx=idx)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart","title":"<code>TextChangeStart</code>","text":"<p>               Bases: <code>TextChangeEnd</code></p> <p>The TextChangeStart \u201ctext:change-start\u201d element marks the start of a region with content where text has been inserted or the format has been changed.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChangeStart(TextChangeEnd):\n    \"\"\"The TextChangeStart \"text:change-start\" element marks the start of a\n    region with content where text has been inserted or the format has\n    been changed.\n    \"\"\"\n\n    _tag = \"text:change-start\"\n\n    def get_start(self) -&gt; TextChangeStart:\n        \"\"\"Return self.\"\"\"\n        return self\n\n    def get_end(self) -&gt; TextChangeEnd:\n        \"\"\"Return the corresponding change-end tag or None.\"\"\"\n        idx = self.get_id()\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"Can not find end tag: no parent available.\")\n        body = self.document_body\n        if not body:\n            body = self.root\n        return body.get_text_change_end(idx=idx)  # type: ignore\n\n    def delete(\n        self,\n        child: Element | None = None,\n        keep_tail: bool = True,\n    ) -&gt; None:\n        \"\"\"Delete the given element from the XML tree. If no element is given,\n        \"self\" is deleted. The XML library may allow to continue to use an\n        element now \"orphan\" as long as you have a reference to it.\n\n        For TextChangeStart : delete also the end tag if exists.\n\n        Arguments:\n\n            child -- Element\n\n            keep_tail -- boolean (default to True), True for most usages.\n        \"\"\"\n        if child is not None:  # act like normal delete\n            return super().delete(child, keep_tail)\n        idx = self.get_id()\n        parent = self.parent\n        if parent is None:\n            raise ValueError(\"cannot delete the root element\")\n        body = self.document_body\n        if not body:\n            body = parent\n        end = body.get_text_change_end(idx=idx)\n        if end:\n            end.delete()\n        # act like normal delete\n        super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart.delete","title":"<code>delete(child=None, keep_tail=True)</code>","text":"<p>Delete the given element from the XML tree. If no element is given, \u201cself\u201d is deleted. The XML library may allow to continue to use an element now \u201corphan\u201d as long as you have a reference to it.</p> <p>For TextChangeStart : delete also the end tag if exists.</p> <p>Arguments:</p> <pre><code>child -- Element\n\nkeep_tail -- boolean (default to True), True for most usages.\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def delete(\n    self,\n    child: Element | None = None,\n    keep_tail: bool = True,\n) -&gt; None:\n    \"\"\"Delete the given element from the XML tree. If no element is given,\n    \"self\" is deleted. The XML library may allow to continue to use an\n    element now \"orphan\" as long as you have a reference to it.\n\n    For TextChangeStart : delete also the end tag if exists.\n\n    Arguments:\n\n        child -- Element\n\n        keep_tail -- boolean (default to True), True for most usages.\n    \"\"\"\n    if child is not None:  # act like normal delete\n        return super().delete(child, keep_tail)\n    idx = self.get_id()\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"cannot delete the root element\")\n    body = self.document_body\n    if not body:\n        body = parent\n    end = body.get_text_change_end(idx=idx)\n    if end:\n        end.delete()\n    # act like normal delete\n    super().delete()\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart.get_end","title":"<code>get_end()</code>","text":"<p>Return the corresponding change-end tag or None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_end(self) -&gt; TextChangeEnd:\n    \"\"\"Return the corresponding change-end tag or None.\"\"\"\n    idx = self.get_id()\n    parent = self.parent\n    if parent is None:\n        raise ValueError(\"Can not find end tag: no parent available.\")\n    body = self.document_body\n    if not body:\n        body = self.root\n    return body.get_text_change_end(idx=idx)  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.TextChangeStart.get_start","title":"<code>get_start()</code>","text":"<p>Return self.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_start(self) -&gt; TextChangeStart:\n    \"\"\"Return self.\"\"\"\n    return self\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion","title":"<code>TextChangedRegion</code>","text":"<p>               Bases: <code>Element</code></p> <p>Each TextChangedRegion \u201ctext:changed-region\u201d element contains a single element, one of TextInsertion, TextDeletion or TextFormatChange that corresponds to a change being tracked within the scope of the \u201ctext:tracked-changes\u201d element that contains the \u201ctext:changed-region\u201d instance. The xml:id attribute of the TextChangedRegion is referenced from the \u201ctext:change\u201d, \u201ctext:change-start\u201d and \u201ctext:change-end\u201d elements that identify where the change applies to markup in the scope of the \u201ctext:tracked-changes\u201d element.</p> for this implementation, text:change should be referenced only <p>once in the scope, which is different from ODF 1.2 requirement:</p> <pre><code>     \" A \"text:changed-region\" can be referenced by more than one\n     change, but the corresponding referencing change mark elements\n     shall be of the same change type - insertion, format change or\n     deletion. \"\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextChangedRegion(Element):\n    \"\"\"Each TextChangedRegion \"text:changed-region\" element contains a single\n    element, one of TextInsertion, TextDeletion or TextFormatChange that\n    corresponds to a change being tracked within the scope of the\n    \"text:tracked-changes\" element that contains the \"text:changed-region\"\n    instance.\n    The xml:id attribute of the TextChangedRegion is referenced\n    from the \"text:change\", \"text:change-start\" and \"text:change-end\"\n    elements that identify where the change applies to markup in the scope of\n    the \"text:tracked-changes\" element.\n\n    Warning : for this implementation, text:change should be referenced only\n              once in the scope, which is different from ODF 1.2 requirement:\n             \" A \"text:changed-region\" can be referenced by more than one\n             change, but the corresponding referencing change mark elements\n             shall be of the same change type - insertion, format change or\n             deletion. \"\n    \"\"\"\n\n    _tag = \"text:changed-region\"\n\n    def get_change_info(self) -&gt; Element | None:\n        \"\"\"Shortcut to get the ChangeInfo element of the change\n        element child.\n\n        Return: ChangeInfo element.\n        \"\"\"\n        return self.get_element(\"descendant::office:change-info\")\n\n    def set_change_info(\n        self,\n        change_info: Element | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        comments: Element | list[Element] | None = None,\n    ) -&gt; None:\n        \"\"\"Shortcut to set the ChangeInfo element of the sub change element.\n        See TextInsertion.set_change_info() for details.\n\n        Arguments:\n\n             change_info -- ChangeInfo element (or None)\n\n             cretor -- str (or None)\n\n             date -- datetime (or None)\n\n             comments -- Paragraph or list of Paragraph elements (or None)\n        \"\"\"\n        child = self.get_change_element()\n        if not child:\n            raise ValueError\n        child.set_change_info(  # type: ignore\n            change_info=change_info, creator=creator, date=date, comments=comments\n        )\n\n    def get_change_element(self) -&gt; Element | None:\n        \"\"\"Get the change element child. It can be either: TextInsertion,\n        TextDeletion, or TextFormatChange as an Element object.\n\n        Return: Element.\n        \"\"\"\n        request = (\n            \"descendant::text:insertion \"\n            \"| descendant::text:deletion\"\n            \"| descendant::text:format-change\"\n        )\n        return self._filtered_element(request, 0)\n\n    def _get_text_id(self) -&gt; str | None:\n        return self.get_attribute_string(\"text:id\")\n\n    def _set_text_id(self, text_id: str) -&gt; None:\n        self.set_attribute(\"text:id\", text_id)\n\n    def _get_xml_id(self) -&gt; str | None:\n        return self.get_attribute_string(\"xml:id\")\n\n    def _set_xml_id(self, xml_id: str) -&gt; None:\n        self.set_attribute(\"xml:id\", xml_id)\n\n    def get_id(self) -&gt; str | None:\n        \"\"\"Get the \"text:id\" attribute.\n\n        Return: str\n        \"\"\"\n        return self._get_text_id()\n\n    def set_id(self, idx: str) -&gt; None:\n        \"\"\"Set both the \"text:id\" and \"xml:id\" attributes with same value.\"\"\"\n        self._set_text_id(idx)\n        self._set_xml_id(idx)\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.get_change_element","title":"<code>get_change_element()</code>","text":"<p>Get the change element child. It can be either: TextInsertion, TextDeletion, or TextFormatChange as an Element object.</p> <p>Return: Element.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_change_element(self) -&gt; Element | None:\n    \"\"\"Get the change element child. It can be either: TextInsertion,\n    TextDeletion, or TextFormatChange as an Element object.\n\n    Return: Element.\n    \"\"\"\n    request = (\n        \"descendant::text:insertion \"\n        \"| descendant::text:deletion\"\n        \"| descendant::text:format-change\"\n    )\n    return self._filtered_element(request, 0)\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.get_change_info","title":"<code>get_change_info()</code>","text":"<p>Shortcut to get the ChangeInfo element of the change element child.</p> <p>Return: ChangeInfo element.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_change_info(self) -&gt; Element | None:\n    \"\"\"Shortcut to get the ChangeInfo element of the change\n    element child.\n\n    Return: ChangeInfo element.\n    \"\"\"\n    return self.get_element(\"descendant::office:change-info\")\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.get_id","title":"<code>get_id()</code>","text":"<p>Get the \u201ctext:id\u201d attribute.</p> <p>Return: str</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_id(self) -&gt; str | None:\n    \"\"\"Get the \"text:id\" attribute.\n\n    Return: str\n    \"\"\"\n    return self._get_text_id()\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.set_change_info","title":"<code>set_change_info(change_info=None, creator=None, date=None, comments=None)</code>","text":"<p>Shortcut to set the ChangeInfo element of the sub change element. See TextInsertion.set_change_info() for details.</p> <p>Arguments:</p> <pre><code> change_info -- ChangeInfo element (or None)\n\n cretor -- str (or None)\n\n date -- datetime (or None)\n\n comments -- Paragraph or list of Paragraph elements (or None)\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_change_info(\n    self,\n    change_info: Element | None = None,\n    creator: str | None = None,\n    date: datetime | None = None,\n    comments: Element | list[Element] | None = None,\n) -&gt; None:\n    \"\"\"Shortcut to set the ChangeInfo element of the sub change element.\n    See TextInsertion.set_change_info() for details.\n\n    Arguments:\n\n         change_info -- ChangeInfo element (or None)\n\n         cretor -- str (or None)\n\n         date -- datetime (or None)\n\n         comments -- Paragraph or list of Paragraph elements (or None)\n    \"\"\"\n    child = self.get_change_element()\n    if not child:\n        raise ValueError\n    child.set_change_info(  # type: ignore\n        change_info=change_info, creator=creator, date=date, comments=comments\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextChangedRegion.set_id","title":"<code>set_id(idx)</code>","text":"<p>Set both the \u201ctext:id\u201d and \u201cxml:id\u201d attributes with same value.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_id(self, idx: str) -&gt; None:\n    \"\"\"Set both the \"text:id\" and \"xml:id\" attributes with same value.\"\"\"\n    self._set_text_id(idx)\n    self._set_xml_id(idx)\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion","title":"<code>TextDeletion</code>","text":"<p>               Bases: <code>TextInsertion</code></p> <p>The TextDeletion \u201ctext:deletion\u201d contains information that identifies the person responsible for a deletion and the date of that deletion. This information may also contain one or more Paragraph which contains a comment on the deletion. The TextDeletion element may also contain content that was deleted while change tracking was enabled. The position where the text was deleted is marked by a \u201ctext:change\u201d element. Deleted text is contained in a paragraph element. To reconstruct the original text, the paragraph containing the deleted text is merged with its surrounding paragraph or heading element. To reconstruct the text before a deletion took place:   - If the change mark is inside a paragraph, insert the content that was   deleted, but remove all leading start tags up to and including the   first \u201ctext:p\u201d element and all trailing end tags up to and including   the last \u201c/text:p\u201d or \u201c/text:h\u201d element. If the last trailing element   is a \u201c/text:h\u201d, change the end tag \u201c/text:p\u201d following this insertion   to a \u201c/text:h\u201d element.   - If the change mark is inside a heading, insert the content that was   deleted, but remove all leading start tags up to and including the   first \u201ctext:h\u201d element and all trailing end tags up to and including   the last \u201c/text:h\u201d or \u201c/text:p\u201d element. If the last trailing element   is a \u201c/text:p\u201d, change the end tag \u201c/text:h\u201d following this insertion   to a \u201c/text:p\u201d element.   - Otherwise, copy the text content of the \u201ctext:deletion\u201d element in   place of the change mark.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextDeletion(TextInsertion):\n    \"\"\"The TextDeletion \"text:deletion\" contains information that identifies\n    the person responsible for a deletion and the date of that deletion.\n    This information may also contain one or more Paragraph which contains\n    a comment on the deletion. The TextDeletion element may also contain\n    content that was deleted while change tracking was enabled. The position\n    where the text was deleted is marked by a \"text:change\" element. Deleted\n    text is contained in a paragraph element. To reconstruct the original\n    text, the paragraph containing the deleted text is merged with its\n    surrounding paragraph or heading element. To reconstruct the text before\n    a deletion took place:\n      - If the change mark is inside a paragraph, insert the content that was\n      deleted, but remove all leading start tags up to and including the\n      first \"text:p\" element and all trailing end tags up to and including\n      the last \"/text:p\" or \"/text:h\" element. If the last trailing element\n      is a \"/text:h\", change the end tag \"/text:p\" following this insertion\n      to a \"/text:h\" element.\n      - If the change mark is inside a heading, insert the content that was\n      deleted, but remove all leading start tags up to and including the\n      first \"text:h\" element and all trailing end tags up to and including\n      the last \"/text:h\" or \"/text:p\" element. If the last trailing element\n      is a \"/text:p\", change the end tag \"/text:h\" following this insertion\n      to a \"/text:p\" element.\n      - Otherwise, copy the text content of the \"text:deletion\" element in\n      place of the change mark.\n    \"\"\"\n\n    _tag = \"text:deletion\"\n\n    def get_deleted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n    ) -&gt; str | list[Element] | None:\n        \"\"\"Get the deleted informations stored in the TextDeletion.\n        If as_text is True: returns the text content.\n        If no_header is True: existing Heading are changed in Paragraph\n\n        Arguments:\n\n            as_text -- boolean\n\n            no_header -- boolean\n\n        Return: Paragraph and Header list\n        \"\"\"\n        children = self.children\n        inner = [elem for elem in children if elem.tag != \"office:change-info\"]\n        if no_header:  # crude replace t:h by t:p\n            new_inner = []\n            for element in inner:\n                if element.tag == \"text:h\":\n                    children = element.children\n                    text = element.text\n                    para = Element.from_tag(\"text:p\")\n                    para.text = text\n                    for child in children:\n                        para.append(child)\n                    new_inner.append(para)\n                else:\n                    new_inner.append(element)\n            inner = new_inner\n        if as_text:\n            return \"\\n\".join([elem.get_formatted_text(context=None) for elem in inner])\n        return inner\n\n    def set_deleted(self, paragraph_or_list: Element | list[Element]) -&gt; None:\n        \"\"\"Set the deleted informations stored in the TextDeletion. An\n        actual content that was deleted is expected, embeded in a Paragraph\n        element or Header.\n\n        Arguments:\n\n            paragraph_or_list -- Paragraph or Header element (or list)\n        \"\"\"\n        for element in self.get_deleted():  # type: ignore\n            self.delete(element)  # type: ignore\n        if isinstance(paragraph_or_list, Element):\n            paragraph_or_list = [paragraph_or_list]\n        for element in paragraph_or_list:\n            self.append(element)\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Return None.\"\"\"\n        if as_text:\n            return \"\"\n        return None\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion.get_deleted","title":"<code>get_deleted(as_text=False, no_header=False)</code>","text":"<p>Get the deleted informations stored in the TextDeletion. If as_text is True: returns the text content. If no_header is True: existing Heading are changed in Paragraph</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: Paragraph and Header list</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n) -&gt; str | list[Element] | None:\n    \"\"\"Get the deleted informations stored in the TextDeletion.\n    If as_text is True: returns the text content.\n    If no_header is True: existing Heading are changed in Paragraph\n\n    Arguments:\n\n        as_text -- boolean\n\n        no_header -- boolean\n\n    Return: Paragraph and Header list\n    \"\"\"\n    children = self.children\n    inner = [elem for elem in children if elem.tag != \"office:change-info\"]\n    if no_header:  # crude replace t:h by t:p\n        new_inner = []\n        for element in inner:\n            if element.tag == \"text:h\":\n                children = element.children\n                text = element.text\n                para = Element.from_tag(\"text:p\")\n                para.text = text\n                for child in children:\n                    para.append(child)\n                new_inner.append(para)\n            else:\n                new_inner.append(element)\n        inner = new_inner\n    if as_text:\n        return \"\\n\".join([elem.get_formatted_text(context=None) for elem in inner])\n    return inner\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Return None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Return None.\"\"\"\n    if as_text:\n        return \"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextDeletion.set_deleted","title":"<code>set_deleted(paragraph_or_list)</code>","text":"<p>Set the deleted informations stored in the TextDeletion. An actual content that was deleted is expected, embeded in a Paragraph element or Header.</p> <p>Arguments:</p> <pre><code>paragraph_or_list -- Paragraph or Header element (or list)\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_deleted(self, paragraph_or_list: Element | list[Element]) -&gt; None:\n    \"\"\"Set the deleted informations stored in the TextDeletion. An\n    actual content that was deleted is expected, embeded in a Paragraph\n    element or Header.\n\n    Arguments:\n\n        paragraph_or_list -- Paragraph or Header element (or list)\n    \"\"\"\n    for element in self.get_deleted():  # type: ignore\n        self.delete(element)  # type: ignore\n    if isinstance(paragraph_or_list, Element):\n        paragraph_or_list = [paragraph_or_list]\n    for element in paragraph_or_list:\n        self.append(element)\n</code></pre>"},{"location":"reference.html#odfdo.TextFormatChange","title":"<code>TextFormatChange</code>","text":"<p>               Bases: <code>TextInsertion</code></p> <p>The TextFormatChange \u201ctext:format-change\u201d element represents any change in formatting attributes. The region where the change took place is marked by \u201ctext:change-start\u201d, \u201ctext:change-end\u201d or \u201ctext:change\u201d elements.</p> <p>Note: This element does not contain formatting changes that have taken place.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextFormatChange(TextInsertion):\n    \"\"\"The TextFormatChange \"text:format-change\" element represents any change\n    in formatting attributes. The region where the change took place is\n    marked by \"text:change-start\", \"text:change-end\" or \"text:change\"\n    elements.\n\n    Note: This element does not contain formatting changes that have taken\n    place.\n    \"\"\"\n\n    _tag = \"text:format-change\"\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion","title":"<code>TextInsertion</code>","text":"<p>               Bases: <code>Element</code></p> <p>The TextInsertion \u201ctext:insertion\u201d element contains the information that identifies the person responsible for a change and the date of that change. This information may also contain one or more \u201ctext:p\u201d Paragraph which contain a comment on the insertion. The TextInsertion element\u2019s parent \u201ctext:changed-region\u201d element has an xml:id or text:id attribute, the value of which binds that parent element to the text:change-id attribute on the \u201ctext:change-start\u201d and \u201ctext:change-end\u201d elements.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TextInsertion(Element):\n    \"\"\"The TextInsertion \"text:insertion\" element contains the information\n    that identifies the person responsible for a change and the date of\n    that change. This information may also contain one or more \"text:p\"\n    Paragraph which contain a comment on the insertion. The\n    TextInsertion element's parent \"text:changed-region\" element has an\n    xml:id or text:id attribute, the value of which binds that parent\n    element to the text:change-id attribute on the \"text:change-start\"\n    and \"text:change-end\" elements.\n    \"\"\"\n\n    _tag = \"text:insertion\"\n\n    def get_deleted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n    ) -&gt; str | list[Element] | None:\n        \"\"\"Return: None.\"\"\"\n        if as_text:\n            return \"\"\n        return None\n\n    def get_inserted(\n        self,\n        as_text: bool = False,\n        no_header: bool = False,\n        clean: bool = True,\n    ) -&gt; str | Element | list[Element] | None:\n        \"\"\"Shortcut to text:change-start.get_inserted(). Return the content\n        between text:change-start and text:change-end.\n\n        If as_text is True: returns the text content.\n        If no_header is True: existing Heading are changed in Paragraph\n        If no_header is True: existing text:h are changed in text:p\n        By default: returns a list of Element, cleaned and with headers\n\n        Arguments:\n\n            as_text -- boolean\n\n            clean -- boolean\n\n            no_header -- boolean\n\n        Return: list or Element or text\n        \"\"\"\n        current = self.parent  # text:changed-region\n        if not current:\n            raise ValueError\n        idx = current.get_id()  # type: ignore\n        body = self.document_body\n        if not body:\n            body = self.root\n        text_change = body.get_text_change_start(idx=idx)\n        if not text_change:\n            raise ValueError\n        return text_change.get_inserted(  # type: ignore\n            as_text=as_text, no_header=no_header, clean=clean\n        )\n\n    def get_change_info(self) -&gt; Element | None:\n        \"\"\"Get the ChangeInfo child of the element.\n\n        Return: ChangeInfo element.\n        \"\"\"\n        return self.get_element(\"descendant::office:change-info\")\n\n    def set_change_info(\n        self,\n        change_info: Element | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        comments: Element | list[Element] | None = None,\n    ) -&gt; None:\n        \"\"\"Set the ChangeInfo element for the change element. If change_info\n        is not provided, creator, date and comments will be used to build a\n        suitable change info element. Default for creator is 'Unknown',\n        default for date is current time and default for comments is no\n        comment at all.\n        The new change info element will replace any existant ChangeInfo.\n\n        Arguments:\n\n             change_info -- ChangeInfo element (or None)\n\n             cretor -- str (or None)\n\n             date -- datetime (or None)\n\n             comments -- Paragraph or list of Paragraph elements (or None)\n        \"\"\"\n        if change_info is None:\n            new_change_info = ChangeInfo(creator, date)\n            if comments is not None:\n                if isinstance(comments, Element):\n                    # single pararagraph comment\n                    comments_list = [comments]\n                else:\n                    comments_list = comments\n                # assume iterable of Paragraph\n                for paragraph in comments_list:\n                    if not isinstance(paragraph, Paragraph):\n                        raise TypeError(f\"Not a Paragraph: '{paragraph!r}'\")\n                    new_change_info.insert(paragraph, xmlposition=LAST_CHILD)\n        else:\n            if not isinstance(change_info, ChangeInfo):\n                raise TypeError(f\"Not a ChangeInfo: '{change_info!r}'\")\n            new_change_info = change_info\n\n        old = self.get_change_info()\n        if old is not None:\n            self.replace_element(old, new_change_info)\n        else:\n            self.insert(new_change_info, xmlposition=FIRST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.get_change_info","title":"<code>get_change_info()</code>","text":"<p>Get the ChangeInfo child of the element.</p> <p>Return: ChangeInfo element.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_change_info(self) -&gt; Element | None:\n    \"\"\"Get the ChangeInfo child of the element.\n\n    Return: ChangeInfo element.\n    \"\"\"\n    return self.get_element(\"descendant::office:change-info\")\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.get_deleted","title":"<code>get_deleted(as_text=False, no_header=False)</code>","text":"<p>Return: None.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_deleted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n) -&gt; str | list[Element] | None:\n    \"\"\"Return: None.\"\"\"\n    if as_text:\n        return \"\"\n    return None\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.get_inserted","title":"<code>get_inserted(as_text=False, no_header=False, clean=True)</code>","text":"<p>Shortcut to text:change-start.get_inserted(). Return the content between text:change-start and text:change-end.</p> <p>If as_text is True: returns the text content. If no_header is True: existing Heading are changed in Paragraph If no_header is True: existing text:h are changed in text:p By default: returns a list of Element, cleaned and with headers</p> <p>Arguments:</p> <pre><code>as_text -- boolean\n\nclean -- boolean\n\nno_header -- boolean\n</code></pre> <p>Return: list or Element or text</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def get_inserted(\n    self,\n    as_text: bool = False,\n    no_header: bool = False,\n    clean: bool = True,\n) -&gt; str | Element | list[Element] | None:\n    \"\"\"Shortcut to text:change-start.get_inserted(). Return the content\n    between text:change-start and text:change-end.\n\n    If as_text is True: returns the text content.\n    If no_header is True: existing Heading are changed in Paragraph\n    If no_header is True: existing text:h are changed in text:p\n    By default: returns a list of Element, cleaned and with headers\n\n    Arguments:\n\n        as_text -- boolean\n\n        clean -- boolean\n\n        no_header -- boolean\n\n    Return: list or Element or text\n    \"\"\"\n    current = self.parent  # text:changed-region\n    if not current:\n        raise ValueError\n    idx = current.get_id()  # type: ignore\n    body = self.document_body\n    if not body:\n        body = self.root\n    text_change = body.get_text_change_start(idx=idx)\n    if not text_change:\n        raise ValueError\n    return text_change.get_inserted(  # type: ignore\n        as_text=as_text, no_header=no_header, clean=clean\n    )\n</code></pre>"},{"location":"reference.html#odfdo.TextInsertion.set_change_info","title":"<code>set_change_info(change_info=None, creator=None, date=None, comments=None)</code>","text":"<p>Set the ChangeInfo element for the change element. If change_info is not provided, creator, date and comments will be used to build a suitable change info element. Default for creator is \u2018Unknown\u2019, default for date is current time and default for comments is no comment at all. The new change info element will replace any existant ChangeInfo.</p> <p>Arguments:</p> <pre><code> change_info -- ChangeInfo element (or None)\n\n cretor -- str (or None)\n\n date -- datetime (or None)\n\n comments -- Paragraph or list of Paragraph elements (or None)\n</code></pre> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>def set_change_info(\n    self,\n    change_info: Element | None = None,\n    creator: str | None = None,\n    date: datetime | None = None,\n    comments: Element | list[Element] | None = None,\n) -&gt; None:\n    \"\"\"Set the ChangeInfo element for the change element. If change_info\n    is not provided, creator, date and comments will be used to build a\n    suitable change info element. Default for creator is 'Unknown',\n    default for date is current time and default for comments is no\n    comment at all.\n    The new change info element will replace any existant ChangeInfo.\n\n    Arguments:\n\n         change_info -- ChangeInfo element (or None)\n\n         cretor -- str (or None)\n\n         date -- datetime (or None)\n\n         comments -- Paragraph or list of Paragraph elements (or None)\n    \"\"\"\n    if change_info is None:\n        new_change_info = ChangeInfo(creator, date)\n        if comments is not None:\n            if isinstance(comments, Element):\n                # single pararagraph comment\n                comments_list = [comments]\n            else:\n                comments_list = comments\n            # assume iterable of Paragraph\n            for paragraph in comments_list:\n                if not isinstance(paragraph, Paragraph):\n                    raise TypeError(f\"Not a Paragraph: '{paragraph!r}'\")\n                new_change_info.insert(paragraph, xmlposition=LAST_CHILD)\n    else:\n        if not isinstance(change_info, ChangeInfo):\n            raise TypeError(f\"Not a ChangeInfo: '{change_info!r}'\")\n        new_change_info = change_info\n\n    old = self.get_change_info()\n    if old is not None:\n        self.replace_element(old, new_change_info)\n    else:\n        self.insert(new_change_info, xmlposition=FIRST_CHILD)\n</code></pre>"},{"location":"reference.html#odfdo.TocEntryTemplate","title":"<code>TocEntryTemplate</code>","text":"<p>               Bases: <code>Element</code></p> <p>ODF \u201ctext:table-of-content-entry-template\u201d</p> <p>Arguments:</p> <pre><code>style -- str\n</code></pre> Source code in <code>odfdo/toc.py</code> <pre><code>class TocEntryTemplate(Element):\n    \"\"\"ODF \"text:table-of-content-entry-template\"\n\n    Arguments:\n\n        style -- str\n    \"\"\"\n\n    _tag = \"text:table-of-content-entry-template\"\n    _properties = (PropDef(\"style\", \"text:style-name\"),)\n\n    def __init__(\n        self,\n        style: str | None = None,\n        outline_level: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if style:\n                self.style = style\n            if outline_level:\n                self.outline_level = outline_level\n\n    @property\n    def outline_level(self) -&gt; int | None:\n        return self.get_attribute_integer(\"text:outline-level\")\n\n    @outline_level.setter\n    def outline_level(self, level: int) -&gt; None:\n        self.set_attribute(\"text:outline-level\", str(level))\n\n    def complete_defaults(self) -&gt; None:\n        self.append(Element.from_tag(\"text:index-entry-chapter\"))\n        self.append(Element.from_tag(\"text:index-entry-text\"))\n        self.append(Element.from_tag(\"text:index-entry-text\"))\n        ts = Element.from_tag(\"text:index-entry-text\")\n        ts.set_style_attribute(\"style:type\", \"right\")\n        ts.set_style_attribute(\"style:leader-char\", \".\")\n        self.append(ts)\n        self.append(Element.from_tag(\"text:index-entry-page-number\"))\n</code></pre>"},{"location":"reference.html#odfdo.TrackedChanges","title":"<code>TrackedChanges</code>","text":"<p>               Bases: <code>MDZap</code>, <code>Element</code></p> <p>The TrackedChanges \u201ctext:tracked-changes\u201d element acts as a container for TextChangedRegion elements that represent changes in a certain scope of an OpenDocument document. This scope is the element in which the TrackedChanges element occurs. Changes in this scope shall be tracked by TextChangedRegion elements contained in the TrackedChanges element in this scope. If a TrackedChanges element is absent, there are no tracked changes in the corresponding scope. In this case, all change mark elements in this scope shall be ignored.</p> Source code in <code>odfdo/tracked_changes.py</code> <pre><code>class TrackedChanges(MDZap, Element):\n    \"\"\"The TrackedChanges \"text:tracked-changes\" element acts as a container\n    for TextChangedRegion elements that represent changes in a certain\n    scope of an OpenDocument document. This scope is the element in which\n    the TrackedChanges element occurs. Changes in this scope shall be\n    tracked by TextChangedRegion elements contained in the\n    TrackedChanges element in this scope. If a TrackedChanges\n    element is absent, there are no tracked changes in the corresponding\n    scope. In this case, all change mark elements in this scope shall be\n    ignored.\n    \"\"\"\n\n    _tag = \"text:tracked-changes\"\n\n    def get_changed_regions(\n        self,\n        creator: str | None = None,\n        date: datetime | None = None,\n        content: str | None = None,\n        role: str | None = None,\n    ) -&gt; list[Element]:\n        changed_regions = self._filtered_elements(\n            \"text:changed-region\",\n            dc_creator=creator,\n            dc_date=date,\n            content=content,\n        )\n        if role is None:\n            return changed_regions\n        result: list[Element] = []\n        for regien in changed_regions:\n            changed = regien.get_change_element()  # type: ignore\n            if not changed:\n                continue\n            if changed.tag.endswith(role):\n                result.append(regien)\n        return result\n\n    def get_changed_region(\n        self,\n        position: int = 0,\n        text_id: str | None = None,\n        creator: str | None = None,\n        date: datetime | None = None,\n        content: str | None = None,\n    ) -&gt; Element | None:\n        return self._filtered_element(\n            \"text:changed-region\",\n            position,\n            text_id=text_id,\n            dc_creator=creator,\n            dc_date=date,\n            content=content,\n        )\n</code></pre>"},{"location":"reference.html#odfdo.UserDefined","title":"<code>UserDefined</code>","text":"<p>               Bases: <code>ElementTyped</code></p> <p>Return a user defined field \u201ctext:user-defined\u201d. If the current document is provided, try to extract the content of the meta user defined field of same name.</p> <p>Arguments:</p> <pre><code>name -- str, name of the user defined field\n\nvalue -- python typed value, value of the field\n\nvalue_type -- str, office:value-type known type\n\ntext -- str\n\nstyle -- str\n\nfrom_document -- ODF document\n</code></pre> Source code in <code>odfdo/variable.py</code> <pre><code>class UserDefined(ElementTyped):\n    \"\"\"Return a user defined field \"text:user-defined\". If the current\n    document is provided, try to extract the content of the meta user defined\n    field of same name.\n\n    Arguments:\n\n        name -- str, name of the user defined field\n\n        value -- python typed value, value of the field\n\n        value_type -- str, office:value-type known type\n\n        text -- str\n\n        style -- str\n\n        from_document -- ODF document\n    \"\"\"\n\n    _tag = \"text:user-defined\"\n    _properties = (\n        PropDef(\"name\", \"text:name\"),\n        PropDef(\"style\", \"style:data-style-name\"),\n    )\n\n    def __init__(\n        self,\n        name: str = \"\",\n        value: Any = None,\n        value_type: str | None = None,\n        text: str | None = None,\n        style: str | None = None,\n        from_document: Document | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if name:\n                self.name = name\n            if style:\n                self.style = style\n            if from_document is not None:\n                meta_infos = from_document.meta\n                content = meta_infos.get_user_defined_metadata_of_name(name)\n                if content is not None:\n                    value = content.get(\"value\", None)\n                    value_type = content.get(\"value_type\", None)\n                    text = content.get(\"text\", None)\n            text = self.set_value_and_type(\n                value=value, value_type=value_type, text=text\n            )\n            self.text = text  # type: ignore\n</code></pre>"},{"location":"reference.html#odfdo.VarChapter","title":"<code>VarChapter</code>","text":"<p>               Bases: <code>Element</code></p> Source code in <code>odfdo/variable.py</code> <pre><code>class VarChapter(Element):\n    _tag = \"text:chapter\"\n    _properties = (\n        PropDef(\"display\", \"text:display\"),\n        PropDef(\"outline_level\", \"text:outline-level\"),\n    )\n    DISPLAY_VALUE_CHOICE = {  # noqa: RUF012\n        \"number\",\n        \"name\",\n        \"number-and-name\",\n        \"plain-number\",\n        \"plain-number-and-name\",\n    }\n\n    def __init__(\n        self,\n        display: str | None = \"name\",\n        outline_level: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"display can be: 'number', 'name', 'number-and-name', 'plain-number' or\n        'plain-number-and-name'\n        \"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if display not in VarChapter.DISPLAY_VALUE_CHOICE:\n                raise ValueError(f\"Unknown display value: '{display}'\")\n            self.display = display\n            if outline_level is not None:\n                self.outline_level = outline_level\n</code></pre>"},{"location":"reference.html#odfdo.VarChapter.__init__","title":"<code>__init__(display='name', outline_level=None, **kwargs)</code>","text":"<p>display can be: \u2018number\u2019, \u2018name\u2019, \u2018number-and-name\u2019, \u2018plain-number\u2019 or \u2018plain-number-and-name\u2019</p> Source code in <code>odfdo/variable.py</code> <pre><code>def __init__(\n    self,\n    display: str | None = \"name\",\n    outline_level: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"display can be: 'number', 'name', 'number-and-name', 'plain-number' or\n    'plain-number-and-name'\n    \"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if display not in VarChapter.DISPLAY_VALUE_CHOICE:\n            raise ValueError(f\"Unknown display value: '{display}'\")\n        self.display = display\n        if outline_level is not None:\n            self.outline_level = outline_level\n</code></pre>"},{"location":"reference.html#odfdo.VarFileName","title":"<code>VarFileName</code>","text":"<p>               Bases: <code>Element</code></p> Source code in <code>odfdo/variable.py</code> <pre><code>class VarFileName(Element):\n    _tag = \"text:file-name\"\n    _properties = (\n        PropDef(\"display\", \"text:display\"),\n        PropDef(\"fixed\", \"text:fixed\"),\n    )\n    DISPLAY_VALUE_CHOICE = {  # noqa: RUF012\n        \"full\",\n        \"path\",\n        \"name\",\n        \"name-and-extension\",\n    }\n\n    def __init__(\n        self,\n        display: str | None = \"full\",\n        fixed: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"display can be: 'full', 'path', 'name' or 'name-and-extension'\"\"\"\n        super().__init__(**kwargs)\n        if self._do_init:\n            if display not in VarFileName.DISPLAY_VALUE_CHOICE:\n                raise ValueError(f\"Unknown display value: '{display}'\")\n            self.display = display\n            if fixed:\n                self.fixed = True\n</code></pre>"},{"location":"reference.html#odfdo.VarFileName.__init__","title":"<code>__init__(display='full', fixed=False, **kwargs)</code>","text":"<p>display can be: \u2018full\u2019, \u2018path\u2019, \u2018name\u2019 or \u2018name-and-extension\u2019</p> Source code in <code>odfdo/variable.py</code> <pre><code>def __init__(\n    self,\n    display: str | None = \"full\",\n    fixed: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"display can be: 'full', 'path', 'name' or 'name-and-extension'\"\"\"\n    super().__init__(**kwargs)\n    if self._do_init:\n        if display not in VarFileName.DISPLAY_VALUE_CHOICE:\n            raise ValueError(f\"Unknown display value: '{display}'\")\n        self.display = display\n        if fixed:\n            self.fixed = True\n</code></pre>"},{"location":"reference.html#odfdo.VarPageNumber","title":"<code>VarPageNumber</code>","text":"<p>               Bases: <code>Element</code></p> <p>select_page \u2013 string in (\u2018previous\u2019, \u2018current\u2019, \u2018next\u2019)</p> <p>page_adjust \u2013 int (to add or subtract to the page number)</p> Source code in <code>odfdo/variable.py</code> <pre><code>class VarPageNumber(Element):\n    \"\"\"\n    select_page -- string in ('previous', 'current', 'next')\n\n    page_adjust -- int (to add or subtract to the page number)\n    \"\"\"\n\n    _tag = \"text:page-number\"\n    _properties = (\n        PropDef(\"select_page\", \"text:select-page\"),\n        PropDef(\"page_adjust\", \"text:page-adjust\"),\n    )\n\n    def __init__(\n        self,\n        select_page: str | None = None,\n        page_adjust: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        if self._do_init:\n            if select_page is None:\n                select_page = \"current\"\n            self.select_page = select_page\n            if page_adjust is not None:\n                self.page_adjust = page_adjust\n</code></pre>"},{"location":"reference.html#odfdo.XmlPart","title":"<code>XmlPart</code>","text":"<p>Representation of an XML part.</p> <p>Abstraction of the XML library behind.</p> Source code in <code>odfdo/xmlpart.py</code> <pre><code>class XmlPart:\n    \"\"\"Representation of an XML part.\n\n    Abstraction of the XML library behind.\n    \"\"\"\n\n    def __init__(self, part_name: str, container: Container) -&gt; None:\n        self.part_name = part_name\n        self.container = container\n\n        # Internal state\n        self.__tree: _ElementTree | None = None\n        self.__root: Element | None = None\n\n    def _get_tree(self) -&gt; _ElementTree:\n        if self.__tree is None:\n            part = self.container.get_part(self.part_name)\n            self.__tree = parse(BytesIO(part))  # type: ignore\n        return self.__tree\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} part_name={self.part_name}&gt;\"\n\n    # Public API\n\n    @property\n    def root(self) -&gt; Element:\n        if self.__root is None:\n            tree = self._get_tree()\n            self.__root = Element.from_tag(tree.getroot())\n        return self.__root\n\n    @property\n    def body(self) -&gt; Element:\n        \"\"\"Get or set the document body : 'office:body'\"\"\"\n        body = self.root.document_body\n        if not isinstance(body, Element):\n            raise TypeError(f\"No body found in {self.part_name!r}\")\n        return body\n\n    @body.setter\n    def body(self, new_body: Element) -&gt; None:\n        body = self.root.document_body\n        if not isinstance(body, Element):\n            raise TypeError(\"//office:body not found in document\")\n        tail = body.tail\n        body.clear()\n        for item in new_body.children:\n            body.append(item)\n        if tail:\n            body.tail = tail\n\n    def get_elements(self, xpath_query: str) -&gt; list[Element | EText]:\n        root = self.root\n        return root.xpath(xpath_query)\n\n    def get_element(self, xpath_query: str) -&gt; Any:\n        result = self.get_elements(xpath_query)\n        if not result:\n            return None\n        return result[0]\n\n    def delete_element(self, child: Element) -&gt; None:\n        child.delete()\n\n    def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n        \"\"\"Apply XPath query to the XML part. Return list of Element or\n        EText instances translated from the nodes found.\n        \"\"\"\n        root = self.root\n        return root.xpath(xpath_query)\n\n    @property\n    def clone(self) -&gt; XmlPart:\n        clone = object.__new__(self.__class__)\n        for name in self.__dict__:\n            if name == \"container\":\n                setattr(clone, name, self.container.clone)\n            elif name in (\"_XmlPart__tree\",):\n                setattr(clone, name, None)\n            else:\n                value = getattr(self, name)\n                value = deepcopy(value)\n                setattr(clone, name, value)\n        return clone\n\n    def serialize(self, pretty: bool = False) -&gt; bytes:\n        if pretty:\n            return self.pretty_serialize()\n        xml_header = b'&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n'\n        tree = self._get_tree()\n        bytes_tree = tostring(tree, encoding=\"unicode\").encode(\"utf8\")\n        return xml_header + bytes_tree\n\n    def pretty_serialize(self) -&gt; bytes:\n        xml_header = b'&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n'\n        bytes_tree = tostring(\n            self.custom_pretty_tree(),\n            encoding=\"unicode\",\n        ).encode(\"utf8\")\n        return xml_header + bytes_tree\n\n    def custom_pretty_tree(self) -&gt; _ElementTree | _Element:\n        tree = self._get_tree()\n        root = tree.getroot()\n        return pretty_indent(root)\n</code></pre>"},{"location":"reference.html#odfdo.XmlPart.body","title":"<code>body</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the document body : \u2018office:body\u2019</p>"},{"location":"reference.html#odfdo.XmlPart.xpath","title":"<code>xpath(xpath_query)</code>","text":"<p>Apply XPath query to the XML part. Return list of Element or EText instances translated from the nodes found.</p> Source code in <code>odfdo/xmlpart.py</code> <pre><code>def xpath(self, xpath_query: str) -&gt; list[Element | EText]:\n    \"\"\"Apply XPath query to the XML part. Return list of Element or\n    EText instances translated from the nodes found.\n    \"\"\"\n    root = self.root\n    return root.xpath(xpath_query)\n</code></pre>"},{"location":"reference.html#odfdo.PageBreak","title":"<code>PageBreak()</code>","text":"<p>Return an empty paragraph with a manual page break.</p> Using this function requires to register the page break style with <p>document.add_page_break_style()</p> Source code in <code>odfdo/paragraph.py</code> <pre><code>def PageBreak() -&gt; Paragraph:\n    \"\"\"Return an empty paragraph with a manual page break.\n\n    Using this function requires to register the page break style with:\n        document.add_page_break_style()\n    \"\"\"\n    return Paragraph(\"\", style=\"odfdopagebreak\")\n</code></pre>"},{"location":"reference.html#odfdo.create_table_cell_style","title":"<code>create_table_cell_style(border=None, border_top=None, border_bottom=None, border_left=None, border_right=None, padding=None, padding_top=None, padding_bottom=None, padding_left=None, padding_right=None, background_color=None, shadow=None, color=None)</code>","text":"<p>Return a cell style.</p> <p>The borders arguments must be some style attribute strings or None, see the method \u2018make_table_cell_border_string\u2019 to generate them. If the \u2018border\u2019 argument as the value \u2018default\u2019, the default style \u201c0.06pt solid #000000\u201d is used for the 4 borders. If any value is used for border, it is used for the 4 borders, else any of the 4 borders can be specified by it\u2019s own string. If all the border, border_top, border_bottom, \u2026 arguments are None, an empty border is used (ODF value is fo:border=\u201dnone\u201d).</p> <p>Padding arguments are string specifying a length (e.g. \u201c0.5mm\u201d)\u201d. If \u2018padding\u2019 is provided, it is used for the 4 sides, else any of the 4 sides padding can be specified by it\u2019s own string. Default padding is no padding.</p> <p>Arguments:</p> <pre><code>border -- str, style string for borders on four sides\n\nborder_top -- str, style string for top if no 'border' argument\n\nborder_bottom -- str, style string for bottom if no 'border' argument\n\nborder_left -- str, style string for left if no 'border' argument\n\nborder_right -- str, style string for right if no 'border' argument\n\npadding -- str, style string for padding on four sides\n\npadding_top -- str, style string for top if no 'padding' argument\n\npadding_bottom -- str, style string for bottom if no 'padding' argument\n\npadding_left -- str, style string for left if no 'padding' argument\n\npadding_right -- str, style string for right if no 'padding' argument\n\nbackground_color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\nshadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\ncolor -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n</code></pre> <p>Return : Style</p> Source code in <code>odfdo/style.py</code> <pre><code>def create_table_cell_style(\n    border: str | None = None,\n    border_top: str | None = None,\n    border_bottom: str | None = None,\n    border_left: str | None = None,\n    border_right: str | None = None,\n    padding: str | None = None,\n    padding_top: str | None = None,\n    padding_bottom: str | None = None,\n    padding_left: str | None = None,\n    padding_right: str | None = None,\n    background_color: str | tuple | None = None,\n    shadow: str | None = None,\n    color: str | tuple | None = None,\n) -&gt; Style:\n    \"\"\"Return a cell style.\n\n    The borders arguments must be some style attribute strings or None, see the\n    method 'make_table_cell_border_string' to generate them.\n    If the 'border' argument as the value 'default', the default style\n    \"0.06pt solid #000000\" is used for the 4 borders.\n    If any value is used for border, it is used for the 4 borders, else any of\n    the 4 borders can be specified by it's own string. If all the border,\n    border_top, border_bottom, ... arguments are None, an empty border is used\n    (ODF value is fo:border=\"none\").\n\n    Padding arguments are string specifying a length (e.g. \"0.5mm\")\". If\n    'padding' is provided, it is used for the 4 sides, else any of\n    the 4 sides padding can be specified by it's own string. Default padding is\n    no padding.\n\n    Arguments:\n\n        border -- str, style string for borders on four sides\n\n        border_top -- str, style string for top if no 'border' argument\n\n        border_bottom -- str, style string for bottom if no 'border' argument\n\n        border_left -- str, style string for left if no 'border' argument\n\n        border_right -- str, style string for right if no 'border' argument\n\n        padding -- str, style string for padding on four sides\n\n        padding_top -- str, style string for top if no 'padding' argument\n\n        padding_bottom -- str, style string for bottom if no 'padding' argument\n\n        padding_left -- str, style string for left if no 'padding' argument\n\n        padding_right -- str, style string for right if no 'padding' argument\n\n        background_color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\n        shadow -- str, e.g. \"#808080 0.176cm 0.176cm\"\n\n        color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\n    Return : Style\n    \"\"\"\n    if border == \"default\":\n        border = make_table_cell_border_string()  # default border\n    if border is not None:\n        # use the border value for 4 sides.\n        border_bottom = border_top = border_left = border_right = None\n    if (\n        border is None\n        and border_bottom is None\n        and border_top is None\n        and border_left is None\n        and border_right is None\n    ):\n        border = \"none\"\n    if padding is not None:\n        # use the padding value for 4 sides.\n        padding_bottom = padding_top = padding_left = padding_right = None\n    cell_style = Style(\n        \"table-cell\",\n        area=\"table-cell\",\n        border=border,\n        border_top=border_top,\n        border_bottom=border_bottom,\n        border_left=border_left,\n        border_right=border_right,\n        padding=padding,\n        padding_top=padding_top,\n        padding_bottom=padding_bottom,\n        padding_left=padding_left,\n        padding_right=padding_right,\n        background_color=background_color,\n        shadow=shadow,\n    )\n    if color:\n        cell_style.set_properties(area=\"text\", color=color)\n    return cell_style\n</code></pre>"},{"location":"reference.html#odfdo.default_frame_position_style","title":"<code>default_frame_position_style(name='FramePosition', horizontal_pos='from-left', vertical_pos='from-top', horizontal_rel='paragraph', vertical_rel='paragraph')</code>","text":"<p>Helper style for positioning frames in desktop applications that need it.</p> <p>Default arguments should be enough.</p> <p>Use the returned Style as the frame style or build a new graphic style with this style as the parent.</p> Source code in <code>odfdo/frame.py</code> <pre><code>def default_frame_position_style(\n    name: str = \"FramePosition\",\n    horizontal_pos: str = \"from-left\",\n    vertical_pos: str = \"from-top\",\n    horizontal_rel: str = \"paragraph\",\n    vertical_rel: str = \"paragraph\",\n) -&gt; Style:\n    \"\"\"Helper style for positioning frames in desktop applications that need\n    it.\n\n    Default arguments should be enough.\n\n    Use the returned Style as the frame style or build a new graphic style\n    with this style as the parent.\n    \"\"\"\n    return Style(\n        family=\"graphic\",\n        name=name,\n        horizontal_pos=horizontal_pos,\n        horizontal_rel=horizontal_rel,\n        vertical_pos=vertical_pos,\n        vertical_rel=vertical_rel,\n    )\n</code></pre>"},{"location":"reference.html#odfdo.default_toc_level_style","title":"<code>default_toc_level_style(level)</code>","text":"<p>Generate an automatic default style for the given TOC level.</p> Source code in <code>odfdo/toc.py</code> <pre><code>def default_toc_level_style(level: int) -&gt; Style:\n    \"\"\"Generate an automatic default style for the given TOC level.\"\"\"\n    tab_stop = TabStopStyle(style_type=\"right\", leader_style=\"dotted\", leader_text=\".\")\n    position = 17.5 - (0.5 * level)\n    tab_stop.style_position = f\"{position}cm\"\n    tab_stops = Element.from_tag(\"style:tab-stops\")\n    tab_stops.append(tab_stop)\n    properties = Element.from_tag(\"style:paragraph-properties\")\n    properties.append(tab_stops)\n    toc_style_level = Style(\n        family=\"paragraph\",\n        name=_toc_entry_style_name(level),\n        parent=f\"Contents_20_{level}\",\n    )\n    toc_style_level.append(properties)\n    return toc_style_level\n</code></pre>"},{"location":"reference.html#odfdo.hex2rgb","title":"<code>hex2rgb(color)</code>","text":"<p>Turns a \u201c#RRGGBB\u201d hexadecimal color representation into a (R, G, B) tuple.</p> <p>Arguments:</p> <pre><code>color -- str\n</code></pre> <p>Return: tuple</p> Source code in <code>odfdo/utils/color.py</code> <pre><code>def hex2rgb(color: str) -&gt; tuple[int, int, int]:\n    \"\"\"Turns a \"#RRGGBB\" hexadecimal color representation into a (R, G, B)\n    tuple.\n\n    Arguments:\n\n        color -- str\n\n    Return: tuple\n    \"\"\"\n    code = color[1:]\n    if not (len(color) == 7 and color[0] == \"#\" and code.isalnum()):\n        raise ValueError(f'\"{color}\" is not a valid color')\n    red = int(code[:2], 16)\n    green = int(code[2:4], 16)\n    blue = int(code[4:6], 16)\n    return (red, green, blue)\n</code></pre>"},{"location":"reference.html#odfdo.hexa_color","title":"<code>hexa_color(color=None)</code>","text":"<p>Convert a color definition of type tuple or string to hexadecimal representation.</p> <p>Empty string is converted to black. None is converted to None.</p> <p>Arguments:</p> <pre><code>color -- str or tuple or None\n</code></pre> <p>Return: str or None</p> Source code in <code>odfdo/utils/color.py</code> <pre><code>def hexa_color(color: str | tuple[int, int, int] | None = None) -&gt; str | None:\n    \"\"\"Convert a color definition of type tuple or string to hexadecimal\n    representation.\n\n    Empty string is converted to black.\n    None is converted to None.\n\n    Arguments:\n\n        color -- str or tuple or None\n\n    Return: str or None\n    \"\"\"\n    if color is None:\n        return None\n    if isinstance(color, tuple):\n        return rgb2hex(color)\n    if not isinstance(color, str):\n        raise TypeError(f'Invalid color argument \"{color!r}\"')\n    color = color.strip()\n    if not color:\n        return \"#000000\"\n    if color.startswith(\"#\"):\n        return color\n    return rgb2hex(color)\n</code></pre>"},{"location":"reference.html#odfdo.make_table_cell_border_string","title":"<code>make_table_cell_border_string(thick=None, line=None, color=None)</code>","text":"<p>Returns a string for style:table-cell-properties fo:border, with default : \u201c0.06pt solid #000000\u201d</p> <pre><code>thick -- str or float or int\nline -- str\ncolor -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n</code></pre> <p>Returns : str</p> Source code in <code>odfdo/style.py</code> <pre><code>def make_table_cell_border_string(\n    thick: str | float | int | None = None,\n    line: str | None = None,\n    color: str | tuple | None = None,\n) -&gt; str:\n    \"\"\"Returns a string for style:table-cell-properties fo:border,\n    with default : \"0.06pt solid #000000\"\n\n        thick -- str or float or int\n        line -- str\n        color -- str or rgb 3-tuple, str is 'black', 'grey', ... or '#012345'\n\n    Returns : str\n    \"\"\"\n    thick_string = _make_thick_string(thick)\n    line_string = _make_line_string(line)\n    color_string = hexa_color(color) or \"#000000\"\n    return \" \".join((thick_string, line_string, color_string))\n</code></pre>"},{"location":"reference.html#odfdo.rgb2hex","title":"<code>rgb2hex(color)</code>","text":"<p>Turns a color name or a (R, G, B) color tuple into a \u201c#RRGGBB\u201d hexadecimal representation.</p> <p>Arguments:</p> <pre><code>color -- str or tuple\n</code></pre> <p>Return: str</p> <p>Examples::</p> <pre><code>&gt;&gt;&gt; rgb2hex('yellow')\n'#FFFF00'\n&gt;&gt;&gt; rgb2hex((238, 130, 238))\n'#EE82EE'\n</code></pre> Source code in <code>odfdo/utils/color.py</code> <pre><code>def rgb2hex(color: str | tuple[int, int, int]) -&gt; str:\n    \"\"\"Turns a color name or a (R, G, B) color tuple into a \"#RRGGBB\"\n    hexadecimal representation.\n\n    Arguments:\n\n        color -- str or tuple\n\n    Return: str\n\n    Examples::\n\n        &gt;&gt;&gt; rgb2hex('yellow')\n        '#FFFF00'\n        &gt;&gt;&gt; rgb2hex((238, 130, 238))\n        '#EE82EE'\n    \"\"\"\n    if isinstance(color, str):\n        try:\n            code = CSS3_COLORMAP[color.lower()]\n        except KeyError as e:\n            raise KeyError(f'Color \"{color}\" is unknown in CSS color list') from e\n    elif isinstance(color, tuple):\n        if len(color) != 3:\n            raise ValueError(\"Color must be a 3-tuple\")\n        code = color\n    else:\n        raise TypeError(f'Invalid color \"{color}\"')\n    for channel in code:\n        if not 0 &lt;= channel &lt;= 255:\n            raise ValueError(\n                f'Invalid color \"{color}\", channel must be between 0 and 255'\n            )\n    return f\"#{code[0]:02X}{code[1]:02X}{code[2]:02X}\"\n</code></pre>"}]}