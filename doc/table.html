<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>odfdo.table API documentation</title>
<meta name="description" content="Table class for &#34;table:table&#34; and HeaderRows, Cell, Row, Column,
NamedRange related classes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>odfdo.table</code></h1>
</header>
<section id="section-intro">
<p>Table class for "table:table" and HeaderRows, Cell, Row, Column,
NamedRange related classes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2018-2024 Jérôme Dumonteil
# Copyright (c) 2009-2012 Ars Aperta, Itaapy, Pierlis, Talend.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Authors (odfdo project): jerome.dumonteil@gmail.com
# The odfdo project is a derivative work of the lpod-python project:
# https://github.com/lpod/lpod-python
# Authors: David Versmisse &lt;david.versmisse@itaapy.com&gt;
#          Hervé Cauwelier &lt;herve@itaapy.com&gt;
#          Romain Gauthier &lt;romain@itaapy.com&gt;
#          Jerome Dumonteil &lt;jerome.dumonteil@itaapy.com&gt;
&#34;&#34;&#34;Table class for &#34;table:table&#34; and HeaderRows, Cell, Row, Column,
NamedRange related classes.
&#34;&#34;&#34;
from __future__ import annotations

import contextlib
import csv
import os
import string
from bisect import bisect_left, insort
from collections.abc import Iterable, Iterator
from datetime import date, datetime, timedelta
from decimal import Decimal
from io import StringIO
from itertools import zip_longest
from pathlib import Path
from textwrap import wrap
from typing import Any

from lxml.etree import XPath

from .datatype import Boolean, Date, DateTime, Duration
from .element import (
    Element,
    _xpath_compile,
    register_element_class,
    register_element_class_list,
)
from .element_typed import ElementTyped
from .frame import Frame
from .utils import bytes_to_str, isiterable

_xpath_row = _xpath_compile(&#34;table:table-row&#34;)
_xpath_row_idx = _xpath_compile(&#34;(table:table-row)[$idx]&#34;)
_xpath_column = _xpath_compile(&#34;table:table-column&#34;)
_xpath_column_idx = _xpath_compile(&#34;(table:table-column)[$idx]&#34;)
_xpath_cell = _xpath_compile(&#34;(table:table-cell|table:covered-table-cell)&#34;)
_xpath_cell_idx = _xpath_compile(&#34;(table:table-cell|table:covered-table-cell)[$idx]&#34;)


def _table_name_check(name: Any) -&gt; str:
    if not isinstance(name, str):
        raise TypeError(&#34;String required.&#34;)
    name = name.strip()
    if not name:
        raise ValueError(&#34;Empty name not allowed.&#34;)
    for character in (&#34;\n&#34;, &#34;/&#34;, &#34;\\&#34;, &#34;&#39;&#34;):
        if character in name:
            raise ValueError(f&#34;Character {character} not allowed.&#34;)
    return name


_forbidden_in_named_range = {
    x
    for x in string.printable
    if x not in string.ascii_letters and x not in string.digits and x != &#34;_&#34;
}


def _alpha_to_digit(alpha: str) -&gt; int:
    &#34;&#34;&#34;Translates A to 0, B to 1, etc. So &#34;AB&#34; is value 27.&#34;&#34;&#34;
    if isinstance(alpha, int):
        return alpha
    if not alpha.isalpha():
        raise ValueError(f&#39;column name &#34;{alpha}&#34; is malformed&#39;)
    column = 0
    for c in alpha.lower():
        v = ord(c) - ord(&#34;a&#34;) + 1
        column = column * 26 + v
    return column - 1


def _digit_to_alpha(digit: int | str) -&gt; str:
    if isinstance(digit, str) and digit.isalpha():
        return digit
    if not isinstance(digit, int):
        raise TypeError(f&#39;column number &#34;{digit}&#34; is invalid&#39;)
    digit += 1
    column = &#34;&#34;
    while digit:
        column = chr(65 + ((digit - 1) % 26)) + column
        digit = (digit - 1) // 26
    return column


def _coordinates_to_alpha_area(coord: str | tuple | list) -&gt; tuple[str, str, str]:
    # assuming : either (x,y) or (x,y,z,t), with positive values
    if isinstance(coord, str):
        # either A1 or A1:B2, returns A1:A1 if needed
        parts = coord.strip().split(&#34;:&#34;)
        if len(parts) == 1:
            start = end = parts[0]
        else:
            start = parts[0]
            end = parts[1]
    elif isiterable(coord):
        if len(coord) == 2:
            x, y = coord
            z, t = coord
        else:
            # should be 4 int
            x, y, z, t = coord
        start = _digit_to_alpha(x) + str(y + 1)
        end = _digit_to_alpha(z) + str(t + 1)
    else:
        raise ValueError
    crange = start + &#34;:&#34; + end
    return (start, end, crange)


def _increment(value: int, step: int) -&gt; int:
    while value &lt; 0:
        if step == 0:
            return 0
        value += step
    return value


def _convert_coordinates(
    obj: tuple | list | str,
) -&gt; tuple[int | None, ...]:
    &#34;&#34;&#34;Translates &#34;D3&#34; to (3, 2) or return (1, 2) untouched.
    Translates &#34;A1:B3&#34; to (0,0,1,2)
    &#34;&#34;&#34;
    # By (1, 2) ?
    if isiterable(obj):
        return tuple(obj)  # type:ignore
    # Or by &#39;B3&#39; notation ?
    if not isinstance(obj, str):
        raise TypeError(f&#39;Bad coordinates type: &#34;{type(obj)}&#34;&#39;)
    coordinates = []
    for coord in [x.strip() for x in obj.split(&#34;:&#34;, 1)]:
        # First &#34;A&#34;
        alpha = &#34;&#34;
        for c in coord:
            if c.isalpha():
                alpha += c
            else:
                break
        try:
            column = _alpha_to_digit(alpha)
        except ValueError:
            # raise ValueError, &#39;coordinates &#34;%s&#34; malformed&#39; % obj
            # maybe &#39;1:4&#39; table row coordinates
            column = None
        coordinates.append(column)
        # Then &#34;1&#34;
        try:
            line = int(coord[len(alpha) :]) - 1
        except ValueError:
            # raise ValueError, &#39;coordinates &#34;%s&#34; malformed&#39; % obj
            # maybe &#39;A:C&#39; row coordinates
            line = None
        if line and line &lt;= 0:
            raise ValueError(f&#39;Coordinates &#34;{obj}&#34; malformed&#39;)
        coordinates.append(line)
    return tuple(coordinates)


def _translate_from_any(x: str | int, length: int, idx: int) -&gt; int:
    if isinstance(x, str):
        value_int = _convert_coordinates(x)[idx]
        if value_int is None:
            raise TypeError(f&#34;Wrong value: {x!r}&#34;)
    elif isinstance(x, int):
        value_int = x
    else:
        raise TypeError(f&#34;Wrong value: {x!r}&#34;)
    if value_int &lt; 0:
        return _increment(value_int, length)
    return value_int


def _get_python_value(data: Any, encoding: str) -&gt; Any:
    &#34;&#34;&#34;Try and guess the most appropriate Python type to load the data, with
    regard to ODF types.
    &#34;&#34;&#34;
    if isinstance(data, bytes):
        data = data.decode(encoding)
    # An int ?
    try:
        return int(data)
    except ValueError:
        pass
    # A float ?
    try:
        return float(data)
    except ValueError:
        pass
    # A Date ?
    try:
        return Date.decode(data)
    except ValueError:
        pass
    # A DateTime ?
    try:
        # Two tests: &#34;yyyy-mm-dd hh:mm:ss&#34; or &#34;yyyy-mm-ddThh:mm:ss&#34;
        return DateTime.decode(data.replace(&#34; &#34;, &#34;T&#34;))
    except ValueError:
        pass
    # A Duration ?
    try:
        return Duration.decode(data)
    except ValueError:
        pass
    # A Boolean ?
    try:
        # &#34;True&#34; or &#34;False&#34; with a .lower
        return Boolean.decode(data.lower())
    except ValueError:
        pass
    # TODO Try some other types ?
    # So a text
    return data


def _set_item_in_vault(  # noqa: C901
    position: int,
    item: Element,
    vault: Element,
    vault_scheme: XPath,
    vault_map_name: str,
    clone: bool = True,
) -&gt; Element:
    &#34;&#34;&#34;Set the item (cell, row) in its vault (row, table), updating the
    cache map.
    &#34;&#34;&#34;
    try:
        vault_map = getattr(vault, vault_map_name)
    except Exception as e:
        raise ValueError from e
    odf_idx = _find_odf_idx(vault_map, position)
    if odf_idx is None:
        raise ValueError
    repeated = item.repeated or 1  # type: ignore
    current_cache = vault_map[odf_idx]
    cache = vault._indexes[vault_map_name]
    if odf_idx in cache:
        current_item = cache[odf_idx]
    else:
        current_item = vault._get_element_idx2(vault_scheme, odf_idx)
    vault._indexes[vault_map_name] = {}
    target_idx = vault.index(current_item)
    if odf_idx &gt; 0:
        before_cache = vault_map[odf_idx - 1]
    else:
        before_cache = -1
    current_pos = before_cache + 1
    current_repeated = current_cache - before_cache
    repeated_before = position - current_pos
    repeated_after = current_repeated - repeated_before - repeated
    if repeated_before &gt;= 1:
        # Update repetition
        current_item._set_repeated(repeated_before)
        target_idx += 1
    else:
        # Replacing the first occurence
        vault.delete(current_item)
    # Insert new element
    if clone:
        new_item = item.clone
    else:
        new_item = item
    vault.insert(new_item, position=target_idx)
    # Insert the remaining repetitions
    if repeated_after &gt;= 1:
        after_item = current_item.clone
        after_item._set_repeated(repeated_after)
        vault.insert(after_item, position=target_idx + 1)
    # setting a repeated item !
    if repeated_after &lt; 0:
        # deleting some overlapped items
        deleting = repeated_after
        while deleting &lt; 0:
            delete_item = vault._get_element_idx2(vault_scheme, target_idx + 1)
            if delete_item is None:
                break
            is_repeated = delete_item.repeated or 1  # type: ignore
            is_repeated += deleting
            if is_repeated &gt; 1:
                delete_item._set_repeated(is_repeated)  # type: ignore
            else:
                vault.delete(delete_item)
            deleting = is_repeated
    # update cache
    # remove existing
    idx = odf_idx
    emap = _erase_map_once(vault_map, idx)
    # add before if any:
    if repeated_before &gt;= 1:
        emap = _insert_map_once(emap, idx, repeated_before)
        idx += 1
    # add our slot
    emap = _insert_map_once(emap, idx, repeated)
    # add after if any::
    if repeated_after &gt;= 1:
        idx += 1
        emap = _insert_map_once(emap, idx, repeated_after)
    if repeated_after &lt; 0:
        idx += 1
        while repeated_after &lt; 0:
            if idx &lt; len(emap):
                emap = _erase_map_once(emap, idx)
            repeated_after += 1
    setattr(vault, vault_map_name, emap)
    return new_item


def _insert_item_in_vault(
    position: int,
    item: Element,
    vault: Element,
    vault_scheme: XPath,
    vault_map_name: str,
) -&gt; Element:
    try:
        vault_map = getattr(vault, vault_map_name)
    except Exception as e:
        raise ValueError from e
    odf_idx = _find_odf_idx(vault_map, position)
    if odf_idx is None:
        raise ValueError
    repeated = item.repeated or 1  # type: ignore
    current_cache = vault_map[odf_idx]
    cache = vault._indexes[vault_map_name]
    if odf_idx in cache:
        current_item = cache[odf_idx]
    else:
        current_item = vault._get_element_idx2(vault_scheme, odf_idx)
    vault._indexes[vault_map_name] = {}
    target_idx = vault.index(current_item)
    if odf_idx &gt; 0:
        before_cache = vault_map[odf_idx - 1]
    else:
        before_cache = -1
    current_pos = before_cache + 1
    current_repeated = current_cache - before_cache
    repeated_before = position - current_pos
    repeated_after = current_repeated - repeated_before
    new_item = item.clone
    if repeated_before &gt;= 1:
        current_item._set_repeated(repeated_before)
        vault.insert(new_item, position=target_idx + 1)
        after_item = current_item.clone
        after_item._set_repeated(repeated_after)
        vault.insert(after_item, position=target_idx + 2)
    else:
        # only insert new cell
        vault.insert(new_item, position=target_idx)
    # update cache
    if repeated_before &gt;= 1:
        emap = _erase_map_once(vault_map, odf_idx)
        emap = _insert_map_once(emap, odf_idx, repeated_before)
        emap = _insert_map_once(emap, odf_idx + 1, repeated)
        setattr(
            vault, vault_map_name, _insert_map_once(emap, odf_idx + 2, repeated_after)
        )
    else:
        setattr(vault, vault_map_name, _insert_map_once(vault_map, odf_idx, repeated))
    return new_item


def _delete_item_in_vault(
    position: int,
    vault: Element,
    vault_scheme: XPath,
    vault_map_name: str,
) -&gt; None:
    try:
        vault_map = getattr(vault, vault_map_name)
    except Exception as e:
        raise ValueError from e
    odf_idx = _find_odf_idx(vault_map, position)
    if odf_idx is None:
        raise ValueError
    current_cache = vault_map[odf_idx]
    cache = vault._indexes[vault_map_name]
    if odf_idx in cache:
        current_item = cache[odf_idx]
    else:
        current_item = vault._get_element_idx2(vault_scheme, odf_idx)
    vault._indexes[vault_map_name] = {}
    if odf_idx &gt; 0:
        before_cache = vault_map[odf_idx - 1]
    else:
        before_cache = -1
    # current_pos = before_cache + 1
    current_repeated = current_cache - before_cache
    new_repeated = current_repeated - 1
    if new_repeated &gt;= 1:
        current_item._set_repeated(new_repeated)
        setattr(
            vault,
            vault_map_name,
            vault_map[:odf_idx] + [(x - 1) for x in vault_map[odf_idx:]],
        )
    else:
        # actual erase
        vault.delete(current_item)
        setattr(
            vault,
            vault_map_name,
            vault_map[:odf_idx] + [(x - 1) for x in vault_map[odf_idx + 1 :]],
        )


def _insert_map_once(orig_map: list, odf_idx: int, repeated: int) -&gt; list[int]:
    &#34;&#34;&#34;Add an item (cell or row) to the map

        map  --  cache map

        odf_idx  --  index in ODF XML

        repeated  --  repeated value of item, 1 or more

    odf_idx is NOT position (col or row), neither raw XML position, but ODF index
    &#34;&#34;&#34;
    repeated = repeated or 1
    if odf_idx &gt; len(orig_map):
        raise IndexError
    if odf_idx &gt; 0:
        before = orig_map[odf_idx - 1]
    else:
        before = -1
    juska = before + repeated  # aka max position value for item
    if odf_idx == len(orig_map):
        insort(orig_map, juska)
        return orig_map
    new_map = orig_map[:odf_idx]
    new_map.append(juska)
    new_map.extend([(x + repeated) for x in orig_map[odf_idx:]])
    return new_map


def _erase_map_once(orig_map: list, odf_idx: int) -&gt; list[int]:
    &#34;&#34;&#34;Remove an item (cell or row) from the map

    map  --  cache map

    odf_idx  --  index in ODF XML
    &#34;&#34;&#34;
    if odf_idx &gt;= len(orig_map):
        raise IndexError
    if odf_idx &gt; 0:
        before = orig_map[odf_idx - 1]
    else:
        before = -1
    current = orig_map[odf_idx]
    repeated = current - before
    orig_map = orig_map[:odf_idx] + [(x - repeated) for x in orig_map[odf_idx + 1 :]]
    return orig_map


def _make_cache_map(idx_repeated_seq: list[tuple[int, int]]) -&gt; list[int]:
    &#34;&#34;&#34;Build the initial cache map of the table.&#34;&#34;&#34;
    cache_amp: list[int] = []
    for odf_idx, repeated in idx_repeated_seq:
        cache_amp = _insert_map_once(cache_amp, odf_idx, repeated)
    return cache_amp


def _find_odf_idx(cache_map: list, position: int) -&gt; int | None:
    &#34;&#34;&#34;Find odf_idx in the map from the position (col or row).&#34;&#34;&#34;
    odf_idx = bisect_left(cache_map, position)
    if odf_idx &lt; len(cache_map):
        return odf_idx
    return None


class HeaderRows(Element):
    _tag = &#34;table:table-header-rows&#34;
    _caching = True


class Cell(ElementTyped):
    &#34;&#34;&#34; &#34;table:table-cell&#34; table cell element.&#34;&#34;&#34;

    _tag = &#34;table:table-cell&#34;
    _caching = True

    def __init__(
        self,
        value: Any = None,
        text: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
        formula: str | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a cell element containing the given value. The textual
        representation is automatically formatted but can be provided. Cell
        type can be deduced as well, unless the number is a percentage or
        currency. If cell type is &#34;currency&#34;, the currency must be given.
        The cell can be repeated on the given number of columns.

        Arguments:

            value -- bool, int, float, Decimal, date, datetime, str,
                     timedelta

            text -- str

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.x = None
        self.y = None
        if self._do_init:
            self.set_value(
                value,
                text=text,
                cell_type=cell_type,
                currency=currency,
                formula=formula,
            )
            if repeated and repeated &gt; 1:
                self.repeated = repeated
            if style is not None:
                self.style = style

    @property
    def clone(self) -&gt; Cell:
        clone = Element.clone.fget(self)  # type: ignore
        clone.y = self.y
        clone.x = self.x
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    @property
    def value(
        self,
    ) -&gt; str | bool | int | float | Decimal | date | datetime | timedelta | None:
        &#34;&#34;&#34;Set / get the value of the cell. The type is read from the
        &#39;office:value-type&#39; attribute of the cell. When setting the value,
        the type of the value will determine the new value_type of the cell.

        Warning: use this method for boolean, float or string only.
        &#34;&#34;&#34;
        value_type = self.get_attribute_string(&#34;office:value-type&#34;)
        if value_type == &#34;boolean&#34;:
            return self.get_attribute(&#34;office:boolean-value&#34;)
        if value_type in {&#34;float&#34;, &#34;percentage&#34;, &#34;currency&#34;}:
            value_decimal = Decimal(str(self.get_attribute_string(&#34;office:value&#34;)))
            # Return 3 instead of 3.0 if possible
            if int(value_decimal) == value_decimal:
                return int(value_decimal)
            return value_decimal
        if value_type == &#34;date&#34;:
            value_str = str(self.get_attribute_string(&#34;office:date-value&#34;))
            if &#34;T&#34; in value_str:
                return DateTime.decode(value_str)
            return Date.decode(value_str)
        if value_type == &#34;time&#34;:
            return Duration.decode(str(self.get_attribute_string(&#34;office:time-value&#34;)))
        if value_type == &#34;string&#34;:
            value = self.get_attribute_string(&#34;office:string-value&#34;)
            if value is not None:
                return value
            value_list = []
            for para in self.get_elements(&#34;text:p&#34;):
                value_list.append(para.text_recursive)
            return &#34;\n&#34;.join(value_list)
        return None

    @value.setter
    def value(self, value: str | bytes | bool | int | float | Decimal | None) -&gt; None:
        self.clear()
        if value is None:
            return
        if isinstance(value, (str, bytes)):
            if isinstance(value, bytes):
                value = bytes_to_str(value)
            self.set_attribute(&#34;office:value-type&#34;, &#34;string&#34;)
            self.set_attribute(&#34;office:string-value&#34;, value)
            self.text = value
            return
        if value is True or value is False:
            self.set_attribute(&#34;office:value-type&#34;, &#34;boolean&#34;)
            value_bool = Boolean.encode(value)
            self.set_attribute(&#34;office:boolean-value&#34;, value_bool)
            self.text = value_bool
            return
        if isinstance(value, (int, float, Decimal)):
            self.set_attribute(&#34;office:value-type&#34;, &#34;float&#34;)
            value_str = str(value)
            self.set_attribute(&#34;office:value&#34;, value_str)
            self.text = value_str
            return
        raise TypeError(f&#34;Unknown value type, try with set_value() : {value!r}&#34;)

    @property
    def float(self) -&gt; float:
        &#34;&#34;&#34;Set / get the value of the cell as a float (or 0.0).&#34;&#34;&#34;
        for tag in (&#34;office:value&#34;, &#34;office:string-value&#34;, &#34;office:boolean-value&#34;):
            read_attr = self.get_attribute(tag)
            if isinstance(read_attr, str):
                with contextlib.suppress(ValueError, TypeError):
                    return float(read_attr)
        return 0.0

    @float.setter
    def float(self, value: str | float | int | Decimal) -&gt; None:
        try:
            value_float = float(value)
        except (ValueError, TypeError):
            value_float = 0.0
        value_str = str(value_float)
        self.clear()
        self.set_attribute(&#34;office:value&#34;, value_str)
        self.set_attribute(&#34;office:value-type&#34;, &#34;float&#34;)
        self.text = value_str

    @property
    def string(self) -&gt; str:
        &#34;&#34;&#34;Set / get the value of the cell as a string (or &#39;&#39;).&#34;&#34;&#34;
        value = self.get_attribute_string(&#34;office:string-value&#34;)
        if isinstance(value, str):
            return value
        return &#34;&#34;

    @string.setter
    def string(
        self,
        value: str | bytes | int | float | Decimal | bool | None,  # type: ignore
    ) -&gt; None:
        self.clear()
        if value is None:
            value_str = &#34;&#34;
        else:
            value_str = str(value)
        self.set_attribute(&#34;office:value-type&#34;, &#34;string&#34;)
        self.set_attribute(&#34;office:string-value&#34;, value_str)
        self.text = value_str

    def set_value(
        self,
        value: (
            str  # type: ignore
            | bytes
            | float
            | int
            | Decimal
            | bool
            | datetime
            | date
            | timedelta
            | None
        ),
        text: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
        formula: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cell state from the Python value type.

        Text is how the cell is displayed. Cell type is guessed,
        unless provided.

        For monetary values, provide the name of the currency.

        Arguments:

            value -- Python type

            text -- str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                        &#39;currency&#39; or &#39;percentage&#39;

            currency -- str
        &#34;&#34;&#34;
        self.clear()
        text = self.set_value_and_type(
            value=value,
            text=text,
            value_type=cell_type,
            currency=currency,
        )
        if text is not None:
            self.text_content = text
        if formula is not None:
            self.formula = formula

    @property
    def type(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the type of the cell: boolean, float, date, string
        or time.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;office:value-type&#34;)

    @type.setter
    def type(self, cell_type: str) -&gt; None:
        self.set_attribute(&#34;office:value-type&#34;, cell_type)

    @property
    def currency(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the currency used for monetary values.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;office:currency&#34;)

    @currency.setter
    def currency(self, currency: str) -&gt; None:
        self.set_attribute(&#34;office:currency&#34;, currency)

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the numnber of times the cell is repeated, or
        None to delete. Without changing cache.
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-columns-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-columns-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get / set the number of times the cell is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-columns-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        child: Element = self
        while True:
            # look for Row, parent may be group of rows
            upper = child.parent
            if not upper:
                # lonely cell
                return
            # parent may be group of rows, not table
            if isinstance(upper, Row):
                break
            child = upper
        # fixme : need to optimize this
        if isinstance(upper, Row):
            upper._compute_row_cache()

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the style of the cell itself.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:style-name&#34;)

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    @property
    def formula(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the formula of the cell, or None if undefined.

        The formula is not interpreted in any way.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:formula&#34;)

    @formula.setter
    def formula(self, formula: str | None) -&gt; None:
        self.set_attribute(&#34;table:formula&#34;, formula)

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        if self.value is not None or self.children:
            return False
        if not aggressive and self.style is not None:
            return False
        return True

    def _is_spanned(self) -&gt; bool:
        if self.tag == &#34;table:covered-table-cell&#34;:
            return True
        if self.get_attribute(&#34;table:number-columns-spanned&#34;) is not None:
            return True
        if self.get_attribute(&#34;table:number-rows-spanned&#34;) is not None:
            return True
        return False


# class CellCovered(Cell):
#     _tag = &#39;table:covered-table-cell&#39;
#     _caching=True


class Row(Element):
    &#34;&#34;&#34;ODF table row &#34;table:table-row&#34; &#34;&#34;&#34;

    _tag = &#34;table:table-row&#34;
    _caching = True
    _append = Element.append

    def __init__(
        self,
        width: int | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;create a Row, optionally filled with &#34;width&#34; number of cells.

        Rows contain cells, their number determine the number of columns.

        You don&#39;t generally have to create rows by hand, use the Table API.

        Arguments:

            width -- int

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.y = None
        if not hasattr(self, &#34;_indexes&#34;):
            self._indexes = {}
            self._indexes[&#34;_rmap&#34;] = {}
        if not hasattr(self, &#34;_rmap&#34;):
            self._compute_row_cache()
            if not hasattr(self, &#34;_tmap&#34;):
                self._tmap = []
                self._cmap = []
        if self._do_init:
            if width is not None:
                for _i in range(width):
                    self.append(Cell())  # type:ignore
            if repeated:
                self.repeated = repeated
            if style is not None:
                self.style = style
            self._compute_row_cache()

    def _get_cells(self) -&gt; list[Element]:
        return self.get_elements(_xpath_cell)

    def _translate_row_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, int | None]:
        xyzt = _convert_coordinates(coord)
        if len(xyzt) == 2:
            x, z = xyzt
        else:
            x, _, z, __ = xyzt
        if x and x &lt; 0:
            x = _increment(x, self.width)
        if z and z &lt; 0:
            z = _increment(z, self.width)
        return (x, z)

    def _compute_row_cache(self) -&gt; None:
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_cell, &#34;table:number-columns-repeated&#34;
        )
        self._rmap = _make_cache_map(idx_repeated_seq)

    # Public API

    @property
    def clone(self) -&gt; Row:
        clone = Element.clone.fget(self)  # type: ignore
        clone.y = self.y
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the numnber of times the row is repeated, or
        None to delete it. Without changing cache.

        Arguments:

            repeated -- int
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-rows-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-rows-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get / set the number of times the row is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-rows-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        current: Element = self
        while True:
            # look for Table, parent may be group of rows
            upper = current.parent
            if not upper:
                # lonely row
                return
            # parent may be group of rows, not table
            if isinstance(upper, Table):
                break
            current = upper
        # fixme : need to optimize this
        if isinstance(upper, Table):
            upper._compute_table_cache()
            if hasattr(self, &#34;_tmap&#34;):
                del self._tmap[:]
                self._tmap.extend(upper._tmap)
            else:
                self._tmap = upper._tmap

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get /set the style of the row itself.

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute(&#34;table:style-name&#34;)  # type: ignore

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Get the number of expected cells in the row, i.e. addition
        repetitions.

        Return: int
        &#34;&#34;&#34;
        try:
            value = self._rmap[-1] + 1
        except Exception:
            value = 0
        return value

    def _translate_x_from_any(self, x: str | int) -&gt; int:
        return _translate_from_any(x, self.width, 0)

    def traverse(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Cell]:
        &#34;&#34;&#34;Yield as many cell elements as expected cells in the row, i.e.
        expand repetitions by returning the same cell as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_cell() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        x = 0
        cell: Cell
        if start is None and end is None:
            for juska in self._rmap:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    if cell is None:
                        cell = Cell()
                    else:
                        cell = cell.clone
                        if repeated &gt; 1:
                            cell.repeated = None
                    cell.y = self.y
                    cell.x = x
                    x += 1
                    yield cell
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._rmap[-1]
                except Exception:
                    end = -1
            start_map = _find_odf_idx(self._rmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._rmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            x = start
            for juska in self._rmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if x &lt;= end:
                        if cell is None:
                            cell = Cell()
                        else:
                            cell = cell.clone
                            if repeated &gt; 1 or (x == start and start &gt; 0):
                                cell.repeated = None
                        cell.y = self.y
                        cell.x = x
                        x += 1
                        yield cell

    def get_cells(
        self,
        coord: str | tuple | None = None,
        style: str | None = None,
        content: str | None = None,
        cell_type: str | None = None,
    ) -&gt; list[Cell]:
        &#34;&#34;&#34;Get the list of cells matching the criteria.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.

        Filter by coordinates will retrieve the amount of cells defined by
        &#39;coord&#39;, minus the other filters.

        Arguments:

            coord -- str or tuple of int : coordinates

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

        Return: list of Cell
        &#34;&#34;&#34;
        # fixme : not clones ?
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
        cells: list[Cell] = []
        for cell in self.traverse(start=x, end=z):
            # Filter the cells by cell_type
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    continue
            # Filter the cells with the regex
            if content and not cell.match(content):
                continue
            # Filter the cells with the style
            if style and style != cell.style:
                continue
            cells.append(cell)
        return cells

    def _get_cell2(self, x: int, clone: bool = True) -&gt; Cell | None:
        if x &gt;= self.width:
            return Cell()
        if clone:
            return self._get_cell2_base(x).clone  # type: ignore
        else:
            return self._get_cell2_base(x)

    def _get_cell2_base(self, x: int) -&gt; Cell | None:
        idx = _find_odf_idx(self._rmap, x)
        cell: Cell
        if idx is not None:
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                self._indexes[&#34;_rmap&#34;][idx] = cell
            return cell
        return None

    def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:
        &#34;&#34;&#34;Get the cell at position &#34;x&#34; starting from 0. Alphabetical
        positions like &#34;D&#34; are accepted.

        A  copy is returned, use set_cell() to push it back.

        Arguments:

            x -- int or str

        Return: Cell | None
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        cell = self._get_cell2(x, clone=clone)
        if not cell:
            return None
        cell.y = self.y
        cell.x = x
        return cell

    def get_value(
        self,
        x: int | str,
        get_type: bool = False,
    ) -&gt; Any | tuple[Any, str]:
        &#34;&#34;&#34;Shortcut to get the value of the cell at position &#34;x&#34;.
        If get_type is True, returns the tuples (value, ODF type).

        If the cell is empty, returns None or (None, None)

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        if get_type:
            x = self._translate_x_from_any(x)
            cell = self._get_cell2_base(x)
            if cell is None:
                return (None, None)
            return cell.get_value(get_type=get_type)
        x = self._translate_x_from_any(x)
        cell = self._get_cell2_base(x)
        if cell is None:
            return None
        return cell.get_value()

    def set_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Push the cell back in the row at position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Arguments:

            x -- int or str

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
            repeated = 1
            clone = False
        else:
            repeated = cell.repeated or 1
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff == 0:
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        elif diff &gt; 0:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        else:
            # Inside the defined row
            _set_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;, clone=clone)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        return cell_back

    def set_value(
        self,
        x: int | str,
        value: Any,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of the cell at position &#34;x&#34;.

        Arguments:

            x -- int or str

            value -- Python type

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        self.set_cell(
            x,
            Cell(value, style=style, cell_type=cell_type, currency=currency),
            clone=False,
        )

    def insert_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Insert the given cell at position &#34;x&#34; starting from 0. If no cell
        is given, an empty one is created.

        Alphabetical positions like &#34;D&#34; are accepted.

        Do not use when working on a table, use Table.insert_cell().

        Arguments:

            x -- int or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff &lt; 0:
            _insert_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        elif diff == 0:
            cell_back = self.append_cell(cell, clone=clone)
        else:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, clone=clone)
        return cell_back

    def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:
        if cells is None:
            cells = []
        self.extend(cells)
        self._compute_row_cache()

    def append_cell(
        self,
        cell: Cell | None = None,
        clone: bool = True,
        _repeated: int | None = None,
    ) -&gt; Cell:
        &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
        accepted. If no cell is given, an empty one is created.

        Do not use when working on a table, use Table.append_cell().

        Arguments:

            cell -- Cell

            _repeated -- (optional), repeated value of the row

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        self._append(cell)
        if _repeated is None:
            _repeated = cell.repeated or 1
        self._rmap = _insert_map_once(self._rmap, len(self._rmap), _repeated)
        cell.x = self.width - 1
        cell.y = self.y
        return cell

    # fix for unit test and typos
    append = append_cell  # type: ignore

    def delete_cell(self, x: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the cell at the given position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Cells on the right will be shifted to the left. In a table, other
        rows remain unaffected.

        Arguments:

            x -- int or str
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if x &gt;= self.width:
            return
        _delete_item_in_vault(x, self, _xpath_cell_idx, &#34;_rmap&#34;)

    def get_values(
        self,
        coord: str | tuple | None = None,
        cell_type: str | None = None,
        complete: bool = False,
        get_type: bool = False,
    ) -&gt; list[Any | tuple[Any, Any]]:
        &#34;&#34;&#34;Shortcut to get the cell values in this row.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type is used and complete is True, missing values are
        replaced by None.
        If cell_type is None, complete is always True : with no cell type
        queried, get_values() returns None for each empty cell, the length
        of the list is equal to the length of the row (depending on
        coordinates use).

        If get_type is True, returns a tuple (value, ODF type of value), or
        (None, None) for empty cells if complete is True.

        Filter by coordinates will retrieve the amount of cells defined by
        coordinates with None for empty cells, except when using cell_type.


        Arguments:

            coord -- str or tuple of int : coordinates in row

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of Python types, or list of tuples.
        &#34;&#34;&#34;
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
            values: list[Any | tuple[Any, Any]] = []
            for cell in self.traverse(start=x, end=z):
                # Filter the cells by cell_type
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        if get_type:
                            values.append((None, None))
                        else:
                            values.append(None)
                    continue
                values.append(cell.get_value(get_type=get_type))
            return values
        else:
            return [
                cell.get_value(get_type=get_type)
                for cell in self.traverse(start=x, end=z)
            ]

    def set_cells(
        self,
        cells: list[Cell] | tuple[Cell] | None = None,
        start: int | str = 0,
        clone: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cells in the row, from the &#39;start&#39; column.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            cells -- list of cells

            start -- int or str
        &#34;&#34;&#34;
        if cells is None:
            cells = []
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and clone is False and (len(cells) &gt;= self.width):
            self.clear()
            self.extend_cells(cells)
        else:
            x = start
            for cell in cells:
                self.set_cell(x, cell, clone=clone)
                if cell:
                    x += cell.repeated or 1
                else:
                    x += 1

    def set_values(
        self,
        values: list[Any],
        start: int | str = 0,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of cells in the row, from the &#39;start&#39;
        column vith values.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            values -- list of Python types

            start -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39; or &#39;percentage&#39;

            currency -- three-letter str

            style -- cell style
        &#34;&#34;&#34;
        # fixme : if values n, n+ are same, use repeat
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and (len(values) &gt;= self.width):
            self.clear()
            cells = [
                Cell(value, style=style, cell_type=cell_type, currency=currency)
                for value in values
            ]
            self.extend_cells(cells)
        else:
            x = start
            for value in values:
                self.set_cell(
                    x,
                    Cell(value, style=style, cell_type=cell_type, currency=currency),
                    clone=False,
                )
                x += 1

    def rstrip(self, aggressive: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove *in-place* empty cells at the right of the row. An empty
        cell has no value but can have style. If &#34;aggressive&#34; is True, style
        is ignored.

        Arguments:

            aggressive -- bool
        &#34;&#34;&#34;
        for cell in reversed(self._get_cells()):
            if not cell.is_empty(aggressive=aggressive):  # type: ignore
                break
            self.delete(cell)
        self._compute_row_cache()
        self._indexes[&#34;_rmap&#34;] = {}

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return whether every cell in the row has no value or the value
        evaluates to False (empty string), and no style.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            aggressive -- bool

        Return: bool
        &#34;&#34;&#34;
        return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore


class RowGroup(Element):
    &#34;&#34;&#34; &#34;table:table-row-group&#34; group rows with common properties.&#34;&#34;&#34;

    # TODO
    _tag = &#34;table:table-row-group&#34;
    _caching = True

    def __init__(
        self,
        height: int | None = None,
        width: int | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a group of rows, optionnaly filled with &#34;height&#34; number of
        rows, of &#34;width&#34; cells each.

        Row group bear style information applied to a series of rows.

        Arguments:

            height -- int

            width -- int
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        if self._do_init and height is not None:
            for _i in range(height):
                row = Row(width=width)
                self.append(row)


class Column(Element):
    &#34;&#34;&#34;ODF table column &#34;table:table-column&#34; &#34;&#34;&#34;

    _tag = &#34;table:table-column&#34;
    _caching = True

    def __init__(
        self,
        default_cell_style: str | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a column group element of the optionally given style. Cell
        style can be set for the whole column. If the properties apply to
        several columns, give the number of repeated columns.

        Columns don&#39;t contain cells, just style information.

        You don&#39;t generally have to create columns by hand, use the Table API.

        Arguments:

            default_cell_style -- str

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.x = None
        if self._do_init:
            if default_cell_style:
                self.set_default_cell_style(default_cell_style)
            if repeated and repeated &gt; 1:
                self.repeated = repeated
            if style:
                self.style = style

    @property
    def clone(self) -&gt; Column:
        clone = Element.clone.fget(self)  # type: ignore
        clone.x = self.x
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    def get_default_cell_style(self) -&gt; str | None:
        return self.get_attribute_string(&#34;table:default-cell-style-name&#34;)

    def set_default_cell_style(self, style: Element | str) -&gt; None:
        self.set_style_attribute(&#34;table:default-cell-style-name&#34;, style)

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the number of times the column is repeated, or
        None to delete it. Without changing cache.

        Arguments:

            repeated -- int or None
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-columns-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-columns-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get /set the number of times the column is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-columns-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        current: Element = self
        while True:
            # look for Table, parent may be group of rows
            upper = current.parent
            if not upper:
                # lonely column
                return
            # parent may be group of rows, not table
            if isinstance(upper, Table):
                break
            current = upper
        # fixme : need to optimize this
        if isinstance(upper, Table):
            upper._compute_table_cache()
            if hasattr(self, &#34;_cmap&#34;):
                del self._cmap[:]
                self._cmap.extend(upper._cmap)
            else:
                self._cmap = upper._cmap

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get /set the style of the column itself.

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:style-name&#34;)

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)


class Table(Element):
    &#34;&#34;&#34;ODF table &#34;table:table&#34; &#34;&#34;&#34;

    _tag = &#34;table:table&#34;
    _caching = True
    _append = Element.append

    def __init__(
        self,
        name: str | None = None,
        width: int | None = None,
        height: int | None = None,
        protected: bool = False,
        protection_key: str | None = None,
        display: bool = True,
        printable: bool = True,
        print_ranges: list[str] | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a table element, optionally prefilled with &#34;height&#34; rows of
        &#34;width&#34; cells each.

        If the table is to be protected, a protection key must be provided,
        i.e. a hash value of the password.

        If the table must not be displayed, set &#34;display&#34; to False.

        If the table must not be printed, set &#34;printable&#34; to False. The table
        will not be printed when it is not displayed, whatever the value of
        this argument.

        Ranges of cells to print can be provided as a list of cell ranges,
        e.g. [&#39;E6:K12&#39;, &#39;P6:R12&#39;] or directly as a raw string, e.g.
        &#34;E6:K12 P6:R12&#34;.

        You can access and modify the XML tree manually, but you probably want
        to use the API to access and alter cells. It will save you from
        handling repetitions and the same number of cells for each row.

        If you use both the table API and the XML API, you are on your own for
        ensuiring model integrity.

        Arguments:

            name -- str

            width -- int

            height -- int

            protected -- bool

            protection_key -- str

            display -- bool

            printable -- bool

            print_ranges -- list

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._indexes = {}
        self._indexes[&#34;_cmap&#34;] = {}
        self._indexes[&#34;_tmap&#34;] = {}
        if self._do_init:
            self.name = name
            if protected:
                self.protected = protected
                self.set_protection_key = protection_key
            if not display:
                self.displayed = display
            if not printable:
                self.printable = printable
            if print_ranges:
                self.print_ranges = print_ranges
            if style:
                self.style = style
            # Prefill the table
            if width is not None or height is not None:
                width = width or 1
                height = height or 1
                # Column groups for style information
                columns = Column(repeated=width)
                self._append(columns)
                for _i in range(height):
                    row = Row(width)
                    self._append(row)
        self._compute_table_cache()

    def __str__(self) -&gt; str:
        def write_content(csv_writer: object) -&gt; None:
            for values in self.iter_values():
                line = []
                for value in values:
                    if value is None:
                        value = &#34;&#34;
                    if isinstance(value, str):
                        value = value.strip()
                    line.append(value)
                csv_writer.writerow(line)  # type: ignore

        out = StringIO(newline=os.linesep)
        csv_writer = csv.writer(
            out,
            delimiter=&#34; &#34;,
            doublequote=False,
            escapechar=&#34;\\&#34;,
            lineterminator=os.linesep,
            quotechar=&#39;&#34;&#39;,
            quoting=csv.QUOTE_NONNUMERIC,
        )
        write_content(csv_writer)
        return out.getvalue()

    def _translate_y_from_any(self, y: str | int) -&gt; int:
        # &#34;3&#34; (couting from 1) -&gt; 2 (couting from 0)
        return _translate_from_any(y, self.height, 1)

    def _translate_table_coordinates_list(
        self,
        coord: tuple | list,
    ) -&gt; tuple[int | None, ...]:
        height = self.height
        width = self.width
        # assuming we got int values
        if len(coord) == 1:
            # It is a row
            y = coord[0]
            if y and y &lt; 0:
                y = _increment(y, height)
            return (None, y, None, y)
        if len(coord) == 2:
            # It is a row range, not a cell, because context is table
            y = coord[0]
            if y and y &lt; 0:
                y = _increment(y, height)
            t = coord[1]
            if t and t &lt; 0:
                t = _increment(t, height)
            return (None, y, None, t)
        # should be 4 int
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_table_coordinates_str(
        self,
        coord_str: str,
    ) -&gt; tuple[int | None, ...]:
        height = self.height
        width = self.width
        coord = _convert_coordinates(coord_str)
        if len(coord) == 2:
            x, y = coord
            if x and x &lt; 0:
                x = _increment(x, width)
            if y and y &lt; 0:
                y = _increment(y, height)
            # extent to an area :
            return (x, y, x, y)
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_table_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, ...]:
        if isinstance(coord, str):
            return self._translate_table_coordinates_str(coord)
        return self._translate_table_coordinates_list(coord)

    def _translate_column_coordinates_str(
        self,
        coord_str: str,
    ) -&gt; tuple[int | None, ...]:
        width = self.width
        height = self.height
        coord = _convert_coordinates(coord_str)
        if len(coord) == 2:
            x, y = coord
            if x and x &lt; 0:
                x = _increment(x, width)
            if y and y &lt; 0:
                y = _increment(y, height)
            # extent to an area :
            return (x, y, x, y)
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_column_coordinates_list(
        self,
        coord: tuple | list,
    ) -&gt; tuple[int | None, ...]:
        width = self.width
        height = self.height
        # assuming we got int values
        if len(coord) == 1:
            # It is a column
            x = coord[0]
            if x and x &lt; 0:
                x = _increment(x, width)
            return (x, None, x, None)
        if len(coord) == 2:
            # It is a column range, not a cell, because context is table
            x = coord[0]
            if x and x &lt; 0:
                x = _increment(x, width)
            z = coord[1]
            if z and z &lt; 0:
                z = _increment(z, width)
            return (x, None, z, None)
        # should be 4 int
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_column_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, ...]:
        if isinstance(coord, str):
            return self._translate_column_coordinates_str(coord)
        return self._translate_column_coordinates_list(coord)

    def _translate_cell_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, int | None]:
        # we want an x,y result
        coord = _convert_coordinates(coord)
        if len(coord) == 2:
            x, y = coord
        # If we got an area, take the first cell
        elif len(coord) == 4:
            x, y, z, t = coord
        else:
            raise ValueError(str(coord))
        if x and x &lt; 0:
            x = _increment(x, self.width)
        if y and y &lt; 0:
            y = _increment(y, self.height)
        return (x, y)

    def _compute_table_cache(self) -&gt; None:
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_row, &#34;table:number-rows-repeated&#34;
        )
        self._tmap = _make_cache_map(idx_repeated_seq)
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_column, &#34;table:number-columns-repeated&#34;
        )
        self._cmap = _make_cache_map(idx_repeated_seq)

    def _update_width(self, row: Row) -&gt; None:
        &#34;&#34;&#34;Synchronize the number of columns if the row is bigger.

        Append, don&#39;t insert, not to disturb the current layout.
        &#34;&#34;&#34;
        diff = row.width - self.width
        if diff &gt; 0:
            self.append_column(Column(repeated=diff))

    def _get_formatted_text_normal(self, context: dict | None) -&gt; str:
        result = []
        for row in self.traverse():
            for cell in row.traverse():
                value = cell.get_value(try_get_text=False)
                # None ?
                if value is None:
                    # Try with get_formatted_text on the elements
                    value = []
                    for element in cell.children:
                        value.append(element.get_formatted_text(context))
                    value = &#34;&#34;.join(value)
                else:
                    value = str(value)
                result.append(value)
                result.append(&#34;\n&#34;)
            result.append(&#34;\n&#34;)
        return &#34;&#34;.join(result)

    def _get_formatted_text_rst(self, context: dict) -&gt; str:  # noqa: C901
        context[&#34;no_img_level&#34;] += 1
        # Strip the table =&gt; We must clone
        table = self.clone
        table.rstrip(aggressive=True)  # type: ignore

        # Fill the rows
        rows = []
        cols_nb = 0
        cols_size: dict[int, int] = {}
        for odf_row in table.traverse():  # type: ignore
            row = []
            for i, cell in enumerate(odf_row.traverse()):
                value = cell.get_value(try_get_text=False)
                # None ?
                if value is None:
                    # Try with get_formatted_text on the elements
                    value = []
                    for element in cell.children:
                        value.append(element.get_formatted_text(context))
                    value = &#34;&#34;.join(value)
                else:
                    value = str(value)
                value = value.strip()
                # Strip the empty columns
                if value:
                    cols_nb = max(cols_nb, i + 1)
                # Compute the size of each columns (at least 2)
                cols_size[i] = max(cols_size.get(i, 2), len(value))
                # Append
                row.append(value)
            rows.append(row)

        # Nothing ?
        if cols_nb == 0:
            return &#34;&#34;

        # Prevent a crash with empty columns (by example with images)
        for col, size in cols_size.items():
            if size == 0:
                cols_size[col] = 1

        # Update cols_size
        LINE_MAX = 100
        COL_MIN = 16

        free_size = LINE_MAX - (cols_nb - 1) * 3 - 4
        real_size = sum([cols_size[i] for i in range(cols_nb)])
        if real_size &gt; free_size:
            factor = float(free_size) / real_size

            for i in range(cols_nb):
                old_size = cols_size[i]

                # The cell is already small
                if old_size &lt;= COL_MIN:
                    continue

                new_size = int(factor * old_size)

                if new_size &lt; COL_MIN:
                    new_size = COL_MIN
                cols_size[i] = new_size

        # Convert !
        result: list[str] = [&#34;&#34;]
        # Construct the first/last line
        line: list[str] = []
        for i in range(cols_nb):
            line.append(&#34;=&#34; * cols_size[i])
            line.append(&#34; &#34;)
        line_str = &#34;&#34;.join(line)

        # Add the lines
        result.append(line_str)
        for row in rows:
            # Wrap the row
            wrapped_row = []
            for i, value in enumerate(row[:cols_nb]):
                wrapped_value = []
                for part in value.split(&#34;\n&#34;):
                    # Hack to handle correctly the lists or the directives
                    subsequent_indent = &#34;&#34;
                    part_lstripped = part.lstrip()
                    if part_lstripped.startswith(&#34;-&#34;) or part_lstripped.startswith(
                        &#34;..&#34;
                    ):
                        subsequent_indent = &#34; &#34; * (len(part) - len(part.lstrip()) + 2)
                    wrapped_part = wrap(
                        part, width=cols_size[i], subsequent_indent=subsequent_indent
                    )
                    if wrapped_part:
                        wrapped_value.extend(wrapped_part)
                    else:
                        wrapped_value.append(&#34;&#34;)
                wrapped_row.append(wrapped_value)

            # Append!
            for j in range(max([1] + [len(values) for values in wrapped_row])):
                txt_row: list[str] = []
                for i in range(cols_nb):
                    values = wrapped_row[i] if i &lt; len(wrapped_row) else []

                    # An empty cell ?
                    if len(values) - 1 &lt; j or not values[j]:
                        if i == 0 and j == 0:
                            txt_row.append(&#34;..&#34;)
                            txt_row.append(&#34; &#34; * (cols_size[i] - 1))
                        else:
                            txt_row.append(&#34; &#34; * (cols_size[i] + 1))
                        continue

                    # Not empty
                    value = values[j]
                    txt_row.append(value)
                    txt_row.append(&#34; &#34; * (cols_size[i] - len(value) + 1))
                result.append(&#34;&#34;.join(txt_row))

        result.append(line_str)
        result.append(&#34;&#34;)
        result.append(&#34;&#34;)
        result_str = &#34;\n&#34;.join(result)

        context[&#34;no_img_level&#34;] -= 1
        return result_str

    def _translate_x_from_any(self, x: str | int) -&gt; int:
        return _translate_from_any(x, self.width, 0)

    #
    # Public API
    #

    def append(self, something: Element | str) -&gt; None:
        &#34;&#34;&#34;Dispatch .append() call to append_row() or append_column().&#34;&#34;&#34;
        if isinstance(something, Row):
            self.append_row(something)
        elif isinstance(something, Column):
            self.append_column(something)
        else:
            # probably still an error
            self._append(something)

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;Get the current height of the table.

        Return: int
        &#34;&#34;&#34;
        try:
            height = self._tmap[-1] + 1
        except Exception:
            height = 0
        return height

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Get the current width of the table, measured on columns.

        Rows may have different widths, use the Table API to ensure width
        consistency.

        Return: int
        &#34;&#34;&#34;
        # Columns are our reference for user expected width

        try:
            width = self._cmap[-1] + 1
        except Exception:
            width = 0

        # columns = self._get_columns()
        # repeated = self.xpath(
        #        &#39;table:table-column/@table:number-columns-repeated&#39;)
        # unrepeated = len(columns) - len(repeated)
        # ws = sum(int(r) for r in repeated) + unrepeated
        # if w != ws:
        #    print &#34;WARNING   ws&#34;, ws, &#34;w&#34;, w

        return width

    @property
    def size(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Shortcut to get the current width and height of the table.

        Return: (int, int)
        &#34;&#34;&#34;
        return self.width, self.height

    @property
    def name(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the name of the table.&#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:name&#34;)

    @name.setter
    def name(self, name: str) -&gt; None:
        name = _table_name_check(name)
        # first, update named ranges
        # fixme : delete name ranges when deleting table, too.
        for named_range in self.get_named_ranges(table_name=self.name):
            named_range.set_table_name(name)
        self.set_attribute(&#34;table:name&#34;, name)

    @property
    def protected(self) -&gt; bool:
        return bool(self.get_attribute(&#34;table:protected&#34;))

    @protected.setter
    def protected(self, protect: bool) -&gt; None:
        self.set_attribute(&#34;table:protected&#34;, protect)

    @property
    def protection_key(self) -&gt; str | None:
        return self.get_attribute_string(&#34;table:protection-key&#34;)

    @protection_key.setter
    def protection_key(self, key: str) -&gt; None:
        self.set_attribute(&#34;table:protection-key&#34;, key)

    @property
    def displayed(self) -&gt; bool:
        return bool(self.get_attribute(&#34;table:display&#34;))

    @displayed.setter
    def displayed(self, display: bool) -&gt; None:
        self.set_attribute(&#34;table:display&#34;, display)

    @property
    def printable(self) -&gt; bool:
        printable = self.get_attribute(&#34;table:print&#34;)
        # Default value
        if printable is None:
            return True
        return bool(printable)

    @printable.setter
    def printable(self, printable: bool) -&gt; None:
        self.set_attribute(&#34;table:print&#34;, printable)

    @property
    def print_ranges(self) -&gt; list[str]:
        ranges = self.get_attribute_string(&#34;table:print-ranges&#34;)
        if isinstance(ranges, str):
            return ranges.split()
        return []

    @print_ranges.setter
    def print_ranges(self, ranges: list[str] | None) -&gt; None:
        if isinstance(ranges, (list, tuple)):
            self.set_attribute(&#34;table:print-ranges&#34;, &#34; &#34;.join(ranges))
        else:
            self.set_attribute(&#34;table:print-ranges&#34;, ranges)

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the style of the table

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:style-name&#34;)

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    def get_formatted_text(self, context: dict | None = None) -&gt; str:
        if context and context[&#34;rst_mode&#34;]:
            return self._get_formatted_text_rst(context)
        return self._get_formatted_text_normal(context)

    def get_values(
        self,
        coord: tuple | list | str | None = None,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
        flat: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Get a matrix of values of the table.

        Filter by coordinates will parse the area defined by the coordinates.

        If &#39;cell_type&#39; is used and &#39;complete&#39; is True (default), missing values
        are replaced by None.
        Filter by &#39; cell_type = &#34;all&#34; &#39; will retrieve cells of any
        type, aka non empty cells.

        If &#39;cell_type&#39; is None, complete is always True : with no cell type
        queried, get_values() returns None for each empty cell, the length
        each lists is equal to the width of the table.

        If get_type is True, returns tuples (value, ODF type of value), or
        (None, None) for empty cells with complete True.

        If flat is True, the methods return a single list of all the values.
        By default, flat is False.

        Arguments:

            coord -- str or tuple of int : coordinates of area

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of lists of Python types
        &#34;&#34;&#34;
        if coord:
            x, y, z, t = self._translate_table_coordinates(coord)
        else:
            x = y = z = t = None
        data = []
        for row in self.traverse(start=y, end=t):
            if z is None:
                width = self.width
            else:
                width = min(z + 1, self.width)
            if x is not None:
                width -= x
            values = row.get_values(
                (x, z),
                cell_type=cell_type,
                complete=complete,
                get_type=get_type,
            )
            # complete row to match request width
            if complete:
                if get_type:
                    values.extend([(None, None)] * (width - len(values)))
                else:
                    values.extend([None] * (width - len(values)))
            if flat:
                data.extend(values)
            else:
                data.append(values)
        return data

    def iter_values(
        self,
        coord: tuple | list | str | None = None,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
    ) -&gt; Iterator[list]:
        &#34;&#34;&#34;Iterate through lines of Python values of the table.

        Filter by coordinates will parse the area defined by the coordinates.

        cell_type, complete, grt_type : see get_values()



        Arguments:

            coord -- str or tuple of int : coordinates of area

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: iterator of lists
        &#34;&#34;&#34;
        if coord:
            x, y, z, t = self._translate_table_coordinates(coord)
        else:
            x = y = z = t = None
        for row in self.traverse(start=y, end=t):
            if z is None:
                width = self.width
            else:
                width = min(z + 1, self.width)
            if x is not None:
                width -= x
            values = row.get_values(
                (x, z),
                cell_type=cell_type,
                complete=complete,
                get_type=get_type,
            )
            # complete row to match column width
            if complete:
                if get_type:
                    values.extend([(None, None)] * (width - len(values)))
                else:
                    values.extend([None] * (width - len(values)))
            yield values

    def set_values(
        self,
        values: list,
        coord: tuple | list | str | None = None,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Set the value of cells in the table, from the &#39;coord&#39; position
        with values.

        &#39;coord&#39; is the coordinate of the upper left cell to be modified by
        values. If &#39;coord&#39; is None, default to the position (0,0) (&#34;A1&#34;).
        If &#39;coord&#39; is an area (e.g. &#34;A2:B5&#34;), the upper left position of this
        area is used as coordinate.

        The table is *not* cleared before the operation, to reset the table
        before setting values, use table.clear().

        A list of lists is expected, with as many lists as rows, and as many
        items in each sublist as cells to be setted. None values in the list
        will create empty cells with no cell type (but eventually a style).

        Arguments:

            coord -- tuple or str

            values -- list of lists of python types

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str
        &#34;&#34;&#34;
        if coord:
            x, y = self._translate_cell_coordinates(coord)
        else:
            x = y = 0
        if y is None:
            y = 0
        if x is None:
            x = 0
        y -= 1
        for row_values in values:
            y += 1
            if not row_values:
                continue
            row = self.get_row(y, clone=True)
            repeated = row.repeated or 1
            if repeated &gt;= 2:
                row.repeated = None
            row.set_values(
                row_values,
                start=x,
                cell_type=cell_type,
                currency=currency,
                style=style,
            )
            self.set_row(y, row, clone=False)
            self._update_width(row)

    def rstrip(self, aggressive: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove *in-place* empty rows below and empty cells at the right of
        the table. Cells are empty if they contain no value or it evaluates
        to False, and no style.

        If aggressive is True, empty cells with style are removed too.

        Argument:

            aggressive -- bool
        &#34;&#34;&#34;
        # Step 1: remove empty rows below the table
        for row in reversed(self._get_rows()):
            if row.is_empty(aggressive=aggressive):
                row.parent.delete(row)  # type: ignore
            else:
                break
        # Step 2: rstrip remaining rows
        max_width = 0
        for row in self._get_rows():
            row.rstrip(aggressive=aggressive)
            # keep count of the biggest row
            max_width = max(max_width, row.width)
        # raz cache of rows
        self._indexes[&#34;_tmap&#34;] = {}
        # Step 3: trim columns to match max_width
        columns = self._get_columns()
        repeated_cols = self.xpath(&#34;table:table-column/@table:number-columns-repeated&#34;)
        if not isinstance(repeated_cols, list):
            raise TypeError
        unrepeated = len(columns) - len(repeated_cols)
        column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore
        diff = column_width - max_width
        if diff &gt; 0:
            for column in reversed(columns):
                repeated = column.repeated or 1
                repeated = repeated - diff
                if repeated &gt; 0:
                    column.repeated = repeated
                    break
                else:
                    column.parent.delete(column)
                    diff = -repeated
                    if diff == 0:
                        break
        # raz cache of columns
        self._indexes[&#34;_cmap&#34;] = {}
        self._compute_table_cache()

    def transpose(self, coord: tuple | list | str | None = None) -&gt; None:  # noqa: C901
        &#34;&#34;&#34;Swap *in-place* rows and columns of the table.

        If &#39;coord&#39; is not None, apply transpose only to the area defined by the
        coordinates. Beware, if area is not square, some cells mays be over
        written during the process.

        Arguments:

            coord -- str or tuple of int : coordinates of area

            start -- int or str
        &#34;&#34;&#34;
        data = []
        if coord is None:
            for row in self.traverse():
                data.append(list(row.traverse()))
            transposed_data = zip_longest(*data)
            self.clear()
            # new_rows = []
            for row_cells in transposed_data:
                if not isiterable(row_cells):
                    row_cells = (row_cells,)
                row = Row()
                row.extend_cells(row_cells)
                self.append_row(row, clone=False)
            self._compute_table_cache()
        else:
            x, y, z, t = self._translate_table_coordinates(coord)
            if x is None:
                x = 0
            else:
                x = min(x, self.width - 1)
            if z is None:
                z = self.width - 1
            else:
                z = min(z, self.width - 1)
            if y is None:
                y = 0
            else:
                y = min(y, self.height - 1)
            if t is None:
                t = self.height - 1
            else:
                t = min(t, self.height - 1)
            for row in self.traverse(start=y, end=t):
                data.append(list(row.traverse(start=x, end=z)))
            transposed_data = zip_longest(*data)
            # clear locally
            w = z - x + 1
            h = t - y + 1
            if w != h:
                nones = [[None] * w for i in range(h)]
                self.set_values(nones, coord=(x, y, z, t))
            # put transposed
            filtered_data: list[tuple[Cell]] = []
            for row_cells in transposed_data:
                if isinstance(row_cells, (list, tuple)):
                    filtered_data.append(row_cells)
                else:
                    filtered_data.append((row_cells,))
            self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))
            self._compute_table_cache()

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return whether every cell in the table has no value or the value
        evaluates to False (empty string), and no style.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            aggressive -- bool
        &#34;&#34;&#34;
        return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())

    #
    # Rows
    #

    def _get_rows(self) -&gt; list[Row]:
        return self.get_elements(_xpath_row)  # type: ignore

    def traverse(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Row]:
        &#34;&#34;&#34;Yield as many row elements as expected rows in the table, i.e.
        expand repetitions by returning the same row as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_row() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        y = 0
        if start is None and end is None:
            for juska in self._tmap:
                idx += 1
                if idx in self._indexes[&#34;_tmap&#34;]:
                    row = self._indexes[&#34;_tmap&#34;][idx]
                else:
                    row = self._get_element_idx2(_xpath_row_idx, idx)
                    self._indexes[&#34;_tmap&#34;][idx] = row
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    row = row.clone
                    row.y = y
                    y += 1
                    if repeated &gt; 1:
                        row.repeated = None
                    yield row
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._tmap[-1]
                except Exception:
                    end = -1
            start_map = _find_odf_idx(self._tmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._tmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            y = start
            for juska in self._tmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_tmap&#34;]:
                    row = self._indexes[&#34;_tmap&#34;][idx]
                else:
                    row = self._get_element_idx2(_xpath_row_idx, idx)
                    self._indexes[&#34;_tmap&#34;][idx] = row
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if y &lt;= end:
                        row = row.clone
                        row.y = y
                        y += 1
                        if repeated &gt; 1 or (y == start and start &gt; 0):
                            row.repeated = None
                        yield row

    def get_rows(
        self,
        coord: tuple | list | str | None = None,
        style: str | None = None,
        content: str | None = None,
    ) -&gt; list[Row]:
        &#34;&#34;&#34;Get the list of rows matching the criteria.

        Filter by coordinates will parse the area defined by the coordinates.

        Arguments:

            coord -- str or tuple of int : coordinates of rows

            content -- str regex

            style -- str

        Return: list of rows
        &#34;&#34;&#34;
        if coord:
            _x, y, _z, t = self._translate_table_coordinates(coord)
        else:
            y = t = None
        # fixme : not clones ?
        if not content and not style:
            return list(self.traverse(start=y, end=t))
        rows = []
        for row in self.traverse(start=y, end=t):
            if content and not row.match(content):
                continue
            if style and style != row.style:
                continue
            rows.append(row)
        return rows

    def _get_row2(self, y: int, clone: bool = True, create: bool = True) -&gt; Row:
        if y &gt;= self.height:
            if create:
                return Row()
            raise ValueError(&#34;Row not found&#34;)
        row = self._get_row2_base(y)
        if row is None:
            raise ValueError(&#34;Row not found&#34;)
        if clone:
            return row.clone
        return row

    def _get_row2_base(self, y: int) -&gt; Row | None:
        idx = _find_odf_idx(self._tmap, y)
        if idx is not None:
            if idx in self._indexes[&#34;_tmap&#34;]:
                row = self._indexes[&#34;_tmap&#34;][idx]
            else:
                row = self._get_element_idx2(_xpath_row_idx, idx)
                self._indexes[&#34;_tmap&#34;][idx] = row
            return row
        return None

    def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:
        &#34;&#34;&#34;Get the row at the given &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        A copy is returned, use set_cell() to push it back.

        Arguments:

            y -- int or str

        Return: Row
        &#34;&#34;&#34;
        # fixme : keep repeat ? maybe an option to functions : &#34;raw=False&#34;
        y = self._translate_y_from_any(y)
        row = self._get_row2(y, clone=clone, create=create)
        if row is None:
            raise ValueError(&#34;Row not found&#34;)
        row.y = y
        return row

    def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:
        &#34;&#34;&#34;Replace the row at the given position with the new one. Repetions of
        the old row will be adjusted.

        If row is None, a new empty row is created.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str

            row -- Row

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if row is None:
            row = Row()
            repeated = 1
            clone = False
        else:
            repeated = row.repeated or 1
        y = self._translate_y_from_any(y)
        row.y = y
        # Outside the defined table ?
        diff = y - self.height
        if diff == 0:
            row_back = self.append_row(row, _repeated=repeated, clone=clone)
        elif diff &gt; 0:
            self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)
            row_back = self.append_row(row, _repeated=repeated, clone=clone)
        else:
            # Inside the defined table
            row_back = _set_item_in_vault(  # type: ignore
                y, row, self, _xpath_row_idx, &#34;_tmap&#34;, clone=clone
            )
        # print self.serialize(True)
        # Update width if necessary
        self._update_width(row_back)
        return row_back

    def insert_row(
        self, y: str | int, row: Row | None = None, clone: bool = True
    ) -&gt; Row:
        &#34;&#34;&#34;Insert the row before the given &#34;y&#34; position. If no row is given,
        an empty one is created.

        Position start at 0. So cell A4 is on row 3.

        If row is None, a new empty row is created.

        Arguments:

            y -- int or str

            row -- Row

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if row is None:
            row = Row()
            clone = False
        y = self._translate_y_from_any(y)
        diff = y - self.height
        if diff &lt; 0:
            row_back = _insert_item_in_vault(y, row, self, _xpath_row_idx, &#34;_tmap&#34;)
        elif diff == 0:
            row_back = self.append_row(row, clone=clone)
        else:
            self.append_row(Row(repeated=diff), _repeated=diff, clone=False)
            row_back = self.append_row(row, clone=clone)
        row_back.y = y  # type: ignore
        # Update width if necessary
        self._update_width(row_back)  # type: ignore
        return row_back  # type: ignore

    def extend_rows(self, rows: list[Row] | None = None) -&gt; None:
        &#34;&#34;&#34;Append a list of rows at the end of the table.

        Arguments:

            rows -- list of Row
        &#34;&#34;&#34;
        if rows is None:
            rows = []
        self.extend(rows)
        self._compute_table_cache()
        # Update width if necessary
        width = self.width
        for row in self.traverse():
            if row.width &gt; width:
                width = row.width
        diff = width - self.width
        if diff &gt; 0:
            self.append_column(Column(repeated=diff))

    def append_row(
        self,
        row: Row | None = None,
        clone: bool = True,
        _repeated: int | None = None,
    ) -&gt; Row:
        &#34;&#34;&#34;Append the row at the end of the table. If no row is given, an
        empty one is created.

        Position start at 0. So cell A4 is on row 3.

        Note the columns are automatically created when the first row is
        inserted in an empty table. So better insert a filled row.

        Arguments:

            row -- Row

            _repeated -- (optional), repeated value of the row

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if row is None:
            row = Row()
            _repeated = 1
        elif clone:
            row = row.clone
        # Appending a repeated row accepted
        # Do not insert next to the last row because it could be in a group
        self._append(row)
        if _repeated is None:
            _repeated = row.repeated or 1
        self._tmap = _insert_map_once(self._tmap, len(self._tmap), _repeated)
        row.y = self.height - 1
        # Initialize columns
        if not self._get_columns():
            repeated = row.width
            self.insert(Column(repeated=repeated), position=0)
            self._compute_table_cache()
        # Update width if necessary
        self._update_width(row)
        return row

    def delete_row(self, y: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the row at the given &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str
        &#34;&#34;&#34;
        y = self._translate_y_from_any(y)
        # Outside the defined table
        if y &gt;= self.height:
            return
        # Inside the defined table
        _delete_item_in_vault(y, self, _xpath_row_idx, &#34;_tmap&#34;)

    def get_row_values(
        self,
        y: int | str,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Shortcut to get the list of Python values for the cells of the row
        at the given &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type and complete is True, replace missing values by None.

        If get_type is True, returns a tuple (value, ODF type of value)

        Arguments:

            y -- int, str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of lists of Python types
        &#34;&#34;&#34;
        values = self.get_row(y, clone=False).get_values(
            cell_type=cell_type, complete=complete, get_type=get_type
        )
        # complete row to match column width
        if complete:
            if get_type:
                values.extend([(None, None)] * (self.width - len(values)))
            else:
                values.extend([None] * (self.width - len(values)))
        return values

    def set_row_values(
        self,
        y: int | str,
        values: list,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; Row:
        &#34;&#34;&#34;Shortcut to set the values of *all* cells of the row at the given
        &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str

            values -- list of Python types

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        returns the row, with updated row.y
        &#34;&#34;&#34;
        row = Row()  # needed if clones rows
        row.set_values(values, style=style, cell_type=cell_type, currency=currency)
        return self.set_row(y, row)  # needed if clones rows

    def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:
        &#34;&#34;&#34;Shortcut to set *all* the cells of the row at the given
        &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str

            cells -- list of Python types

            style -- str

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if cells is None:
            cells = []
        row = Row()  # needed if clones rows
        row.extend_cells(cells)
        return self.set_row(y, row)  # needed if clones rows

    def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return wether every cell in the row at the given &#34;y&#34; position has
        no value or the value evaluates to False (empty string), and no style.

        Position start at 0. So cell A4 is on row 3.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            y -- int or str

            aggressive -- bool
        &#34;&#34;&#34;
        return self.get_row(y, clone=False).is_empty(aggressive=aggressive)

    #
    # Cells
    #

    def get_cells(
        self,
        coord: tuple | list | str | None = None,
        cell_type: str | None = None,
        style: str | None = None,
        content: str | None = None,
        flat: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Get the cells matching the criteria. If &#39;coord&#39; is None,
        parse the whole table, else parse the area defined by &#39;coord&#39;.

        Filter by  cell_type = &#34;all&#34;  will retrieve cells of any
        type, aka non empty cells.

        If flat is True (default is False), the method return a single list
        of all the values, else a list of lists of cells.

        if cell_type, style and content are None, get_cells() will return
        the exact number of cells of the area, including empty cells.

        Arguments:

            coordinates -- str or tuple of int : coordinates of area

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

            flat -- boolean

        Return: list of tuples
        &#34;&#34;&#34;
        if coord:
            x, y, z, t = self._translate_table_coordinates(coord)
        else:
            x = y = z = t = None
        if flat:
            cells: list[Cell] = []
            for row in self.traverse(start=y, end=t):
                row_cells = row.get_cells(
                    coord=(x, z),
                    cell_type=cell_type,
                    style=style,
                    content=content,
                )
                cells.extend(row_cells)
            return cells
        else:
            lcells: list[list[Cell]] = []
            for row in self.traverse(start=y, end=t):
                row_cells = row.get_cells(
                    coord=(x, z),
                    cell_type=cell_type,
                    style=style,
                    content=content,
                )
                lcells.append(row_cells)
            return lcells

    def get_cell(
        self,
        coord: tuple | list | str,
        clone: bool = True,
        keep_repeated: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Get the cell at the given coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        A copy is returned, use ``set_cell`` to push it back.

        Arguments:

            coord -- (int, int) or str

        Return: Cell
        &#34;&#34;&#34;
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        # Outside the defined table
        if y &gt;= self.height:
            cell = Cell()
        else:
            # Inside the defined table
            row = self._get_row2_base(y)
            if row is None:
                raise ValueError
            read_cell = row.get_cell(x, clone=clone)
            if read_cell is None:
                raise ValueError
            cell = read_cell
            if not keep_repeated:
                repeated = cell.repeated or 1
                if repeated &gt;= 2:
                    cell.repeated = None
        cell.x = x
        cell.y = y
        return cell

    def get_value(
        self,
        coord: tuple | list | str,
        get_type: bool = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Shortcut to get the Python value of the cell at the given
        coordinates.

        If get_type is True, returns the tuples (value, ODF type)

        coord is either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;. If an Area is given, the upper
        left position is used as coord.

        Arguments:

            coord -- (int, int) or str : coordinate

        Return: Python type
        &#34;&#34;&#34;
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        # Outside the defined table
        if y &gt;= self.height:
            if get_type:
                return (None, None)
            return None
        else:
            # Inside the defined table
            row = self._get_row2_base(y)
            if row is None:
                raise ValueError
            cell = row._get_cell2_base(x)
            if cell is None:
                if get_type:
                    return (None, None)
                return None
            return cell.get_value(get_type=get_type)

    def set_cell(
        self,
        coord: tuple | list | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Replace a cell of the table at the given coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Arguments:

            coord -- (int, int) or str : coordinate

            cell -- Cell

        return the cell, with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        cell.x = x
        cell.y = y
        if y &gt;= self.height:
            row = Row()
            cell_back = row.set_cell(x, cell, clone=clone)
            self.set_row(y, row, clone=False)
        else:
            row_read = self._get_row2_base(y)
            if row_read is None:
                raise ValueError
            row = row_read
            row.y = y
            repeated = row.repeated or 1
            if repeated &gt; 1:
                row = row.clone
                row.repeated = None
                cell_back = row.set_cell(x, cell, clone=clone)
                self.set_row(y, row, clone=False)
            else:
                cell_back = row.set_cell(x, cell, clone=clone)
                # Update width if necessary, since we don&#39;t use set_row
                self._update_width(row)
        return cell_back

    def set_cells(
        self,
        cells: list[list[Cell]] | list[tuple[Cell]],
        coord: tuple | list | str | None = None,
        clone: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cells in the table, from the &#39;coord&#39; position.

        &#39;coord&#39; is the coordinate of the upper left cell to be modified by
        values. If &#39;coord&#39; is None, default to the position (0,0) (&#34;A1&#34;).
        If &#39;coord&#39; is an area (e.g. &#34;A2:B5&#34;), the upper left position of this
        area is used as coordinate.

        The table is *not* cleared before the operation, to reset the table
        before setting cells, use table.clear().

        A list of lists is expected, with as many lists as rows to be set, and
        as many cell in each sublist as cells to be setted in the row.

        Arguments:

            cells -- list of list of cells

            coord -- tuple or str

            values -- list of lists of python types
        &#34;&#34;&#34;
        if coord:
            x, y = self._translate_cell_coordinates(coord)
        else:
            x = y = 0
        if y is None:
            y = 0
        if x is None:
            x = 0
        y -= 1
        for row_cells in cells:
            y += 1
            if not row_cells:
                continue
            row = self.get_row(y, clone=True)
            repeated = row.repeated or 1
            if repeated &gt;= 2:
                row.repeated = None
            row.set_cells(row_cells, start=x, clone=clone)
            self.set_row(y, row, clone=False)
            self._update_width(row)

    def set_value(
        self,
        coord: tuple | list | str,
        value: Any,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Set the Python value of the cell at the given coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Arguments:

            coord -- (int, int) or str

            value -- Python type

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        &#34;&#34;&#34;
        self.set_cell(
            coord,
            Cell(value, cell_type=cell_type, currency=currency, style=style),
            clone=False,
        )

    def set_cell_image(
        self,
        coord: tuple | list | str,
        image_frame: Frame,
        doc_type: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Do all the magic to display an image in the cell at the given
        coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        The frame element must contain the expected image position and
        dimensions.

        DrawImage insertion depends on the document type, so the type must be
        provided or the table element must be already attached to a document.

        Arguments:

            coord -- (int, int) or str

            image_frame -- Frame including an image

            doc_type -- &#39;spreadsheet&#39; or &#39;text&#39;
        &#34;&#34;&#34;
        # Test document type
        if doc_type is None:
            body = self.document_body
            if body is None:
                raise ValueError(&#34;document type not found&#34;)
            doc_type = {&#34;office:spreadsheet&#34;: &#34;spreadsheet&#34;, &#34;office:text&#34;: &#34;text&#34;}.get(
                body.tag
            )
            if doc_type is None:
                raise ValueError(&#34;document type not supported for images&#34;)
        # We need the end address of the image
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        cell = self.get_cell((x, y))
        image_frame = image_frame.clone  # type: ignore
        # Remove any previous paragraph, frame, etc.
        for child in cell.children:
            cell.delete(child)
        # Now it all depends on the document type
        if doc_type == &#34;spreadsheet&#34;:
            image_frame.anchor_type = &#34;char&#34;
            # The frame needs end coordinates
            width, height = image_frame.size
            image_frame.set_attribute(&#34;table:end-x&#34;, width)
            image_frame.set_attribute(&#34;table:end-y&#34;, height)
            # FIXME what happens when the address changes?
            address = f&#34;{self.name}.{_digit_to_alpha(x)}{y + 1}&#34;
            image_frame.set_attribute(&#34;table:end-cell-address&#34;, address)
            # The frame is directly in the cell
            cell.append(image_frame)
        elif doc_type == &#34;text&#34;:
            # The frame must be in a paragraph
            cell.set_value(&#34;&#34;)
            paragraph = cell.get_element(&#34;text:p&#34;)
            if paragraph is None:
                raise ValueError
            paragraph.append(image_frame)
        self.set_cell(coord, cell)

    def insert_cell(
        self,
        coord: tuple | list | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Insert the given cell at the given coordinates. If no cell is
        given, an empty one is created.

        Coordinates are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Cells on the right are shifted. Other rows remain untouched.

        Arguments:

            coord -- (int, int) or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        row = self._get_row2(y, clone=True)
        row.y = y
        row.repeated = None
        cell_back = row.insert_cell(x, cell, clone=False)
        self.set_row(y, row, clone=False)
        # Update width if necessary
        self._update_width(row)
        return cell_back

    def append_cell(
        self,
        y: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Append the given cell at the &#34;y&#34; coordinate. Repeated cells are
        accepted. If no cell is given, an empty one is created.

        Position start at 0. So cell A4 is on row 3.

        Other rows remain untouched.

        Arguments:

            y -- int or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        y = self._translate_y_from_any(y)
        row = self._get_row2(y)
        row.y = y
        cell_back = row.append_cell(cell, clone=False)
        self.set_row(y, row)
        # Update width if necessary
        self._update_width(row)
        return cell_back

    def delete_cell(self, coord: tuple | list | str) -&gt; None:
        &#34;&#34;&#34;Delete the cell at the given coordinates, so that next cells are
        shifted to the left.

        Coordinates are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Use set_value() for erasing value.

        Arguments:

            coord -- (int, int) or str
        &#34;&#34;&#34;
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        # Outside the defined table
        if y &gt;= self.height:
            return
        # Inside the defined table
        row = self._get_row2_base(y)
        if row is None:
            raise ValueError
        row.delete_cell(x)
        # self.set_row(y, row)

    # Columns

    def _get_columns(self) -&gt; list:
        return self.get_elements(_xpath_column)

    def traverse_columns(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Column]:
        &#34;&#34;&#34;Yield as many column elements as expected columns in the table,
        i.e. expand repetitions by returning the same column as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_column() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        x = 0
        if start is None and end is None:
            for juska in self._cmap:
                idx += 1
                if idx in self._indexes[&#34;_cmap&#34;]:
                    column = self._indexes[&#34;_cmap&#34;][idx]
                else:
                    column = self._get_element_idx2(_xpath_column_idx, idx)
                    self._indexes[&#34;_cmap&#34;][idx] = column
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    column = column.clone
                    column.x = x
                    x += 1
                    if repeated &gt; 1:
                        column.repeated = None
                    yield column
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._cmap[-1]
                except Exception:
                    end = -1
            start_map = _find_odf_idx(self._cmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._cmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            x = start
            for juska in self._cmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_cmap&#34;]:
                    column = self._indexes[&#34;_cmap&#34;][idx]
                else:
                    column = self._get_element_idx2(_xpath_column_idx, idx)
                    self._indexes[&#34;_cmap&#34;][idx] = column
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if x &lt;= end:
                        column = column.clone
                        column.x = x
                        x += 1
                        if repeated &gt; 1 or (x == start and start &gt; 0):
                            column.repeated = None
                        yield column

    def get_columns(
        self,
        coord: tuple | list | str | None = None,
        style: str | None = None,
    ) -&gt; list[Column]:
        &#34;&#34;&#34;Get the list of columns matching the criteria. Each result is a
        tuple of (x, column).

        Arguments:

            coord -- str or tuple of int : coordinates of columns

            style -- str

        Return: list of columns
        &#34;&#34;&#34;
        if coord:
            x, _y, _z, t = self._translate_column_coordinates(coord)
        else:
            x = t = None
        if not style:
            return list(self.traverse_columns(start=x, end=t))
        columns = []
        for column in self.traverse_columns(start=x, end=t):
            if style != column.style:
                continue
            columns.append(column)
        return columns

    def _get_column2(self, x: int) -&gt; Column | None:
        # Outside the defined table
        if x &gt;= self.width:
            return Column()
        # Inside the defined table
        odf_idx = _find_odf_idx(self._cmap, x)
        if odf_idx is not None:
            column = self._get_element_idx2(_xpath_column_idx, odf_idx)
            if column is None:
                return None
            # fixme : no clone here =&gt; change doc and unit tests
            return column.clone  # type: ignore
            # return row
        return None

    def get_column(self, x: int | str) -&gt; Column:
        &#34;&#34;&#34;Get the column at the given &#34;x&#34; position.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        A copy is returned, use set_column() to push it back.

        Arguments:

            x -- int or str

        Return: Column
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        column = self._get_column2(x)
        if column is None:
            raise ValueError
        column.x = x
        return column

    def set_column(
        self,
        x: int | str,
        column: Column | None = None,
    ) -&gt; Column:
        &#34;&#34;&#34;Replace the column at the given &#34;x&#34; position.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            x -- int or str

            column -- Column
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if column is None:
            column = Column()
            repeated = 1
        else:
            repeated = column.repeated or 1
        column.x = x
        # Outside the defined table ?
        diff = x - self.width
        if diff == 0:
            column_back = self.append_column(column, _repeated=repeated)
        elif diff &gt; 0:
            self.append_column(Column(repeated=diff), _repeated=diff)
            column_back = self.append_column(column, _repeated=repeated)
        else:
            # Inside the defined table
            column_back = _set_item_in_vault(  # type: ignore
                x, column, self, _xpath_column_idx, &#34;_cmap&#34;
            )
        return column_back

    def insert_column(
        self,
        x: int | str,
        column: Column | None = None,
    ) -&gt; Column:
        &#34;&#34;&#34;Insert the column before the given &#34;x&#34; position. If no column is
        given, an empty one is created.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            x -- int or str

            column -- Column
        &#34;&#34;&#34;
        if column is None:
            column = Column()
        x = self._translate_x_from_any(x)
        diff = x - self.width
        if diff &lt; 0:
            column_back = _insert_item_in_vault(
                x, column, self, _xpath_column_idx, &#34;_cmap&#34;
            )
        elif diff == 0:
            column_back = self.append_column(column.clone)
        else:
            self.append_column(Column(repeated=diff), _repeated=diff)
            column_back = self.append_column(column.clone)
        column_back.x = x  # type: ignore
        # Repetitions are accepted
        repeated = column.repeated or 1
        # Update width on every row
        for row in self._get_rows():
            if row.width &gt; x:
                row.insert_cell(x, Cell(repeated=repeated))
            # Shorter rows don&#39;t need insert
            # Longer rows shouldn&#39;t exist!
        return column_back  # type: ignore

    def append_column(
        self,
        column: Column | None = None,
        _repeated: int | None = None,
    ) -&gt; Column:
        &#34;&#34;&#34;Append the column at the end of the table. If no column is given,
        an empty one is created.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            column -- Column
        &#34;&#34;&#34;
        if column is None:
            column = Column()
        else:
            column = column.clone
        if not self._cmap:
            position = 0
        else:
            odf_idx = len(self._cmap) - 1
            last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)
            if last_column is None:
                raise ValueError
            position = self.index(last_column) + 1
        column.x = self.width
        self.insert(column, position=position)
        # Repetitions are accepted
        if _repeated is None:
            _repeated = column.repeated or 1
        self._cmap = _insert_map_once(self._cmap, len(self._cmap), _repeated)
        # No need to update row widths
        return column

    def delete_column(self, x: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the column at the given position. ODF columns don&#39;t contain
        cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            x -- int or str
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        # Outside the defined table
        if x &gt;= self.width:
            return
        # Inside the defined table
        _delete_item_in_vault(x, self, _xpath_column_idx, &#34;_cmap&#34;)
        # Update width
        width = self.width
        for row in self._get_rows():
            if row.width &gt;= width:
                row.delete_cell(x)

    def get_column_cells(  # noqa: C901
        self,
        x: int | str,
        style: str | None = None,
        content: str | None = None,
        cell_type: str | None = None,
        complete: bool = False,
    ) -&gt; list[Cell | None]:
        &#34;&#34;&#34;Get the list of cells at the given position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.

        If complete is True, replace missing values by None.

        Arguments:

            x -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

            complete -- boolean

        Return: list of Cell
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if cell_type:
            cell_type = cell_type.lower().strip()
        cells: list[Cell | None] = []
        if not style and not content and not cell_type:
            for row in self.traverse():
                cells.append(row.get_cell(x, clone=True))
            return cells
        for row in self.traverse():
            cell = row.get_cell(x, clone=True)
            if cell is None:
                raise ValueError
            # Filter the cells by cell_type
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        cells.append(None)
                    continue
            # Filter the cells with the regex
            if content and not cell.match(content):
                if complete:
                    cells.append(None)
                continue
            # Filter the cells with the style
            if style and style != cell.style:
                if complete:
                    cells.append(None)
                continue
            cells.append(cell)
        return cells

    def get_column_values(
        self,
        x: int | str,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
    ) -&gt; list[Any]:
        &#34;&#34;&#34;Shortcut to get the list of Python values for the cells at the
        given position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type and complete is True, replace missing values by None.

        If get_type is True, returns a tuple (value, ODF type of value)

        Arguments:

            x -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of Python types
        &#34;&#34;&#34;
        cells = self.get_column_cells(
            x, style=None, content=None, cell_type=cell_type, complete=complete
        )
        values: list[Any] = []
        for cell in cells:
            if cell is None:
                if complete:
                    if get_type:
                        values.append((None, None))
                    else:
                        values.append(None)
                continue
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        if get_type:
                            values.append((None, None))
                        else:
                            values.append(None)
                    continue
            values.append(cell.get_value(get_type=get_type))
        return values

    def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the list of cells at the given position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        The list must have the same length than the table height.

        Arguments:

            x -- int or str

            cells -- list of Cell
        &#34;&#34;&#34;
        height = self.height
        if len(cells) != height:
            raise ValueError(f&#34;col mismatch: {height} cells expected&#34;)
        cells_iterator = iter(cells)
        for y, row in enumerate(self.traverse()):
            row.set_cell(x, next(cells_iterator))
            self.set_row(y, row)

    def set_column_values(
        self,
        x: int | str,
        values: list,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the list of Python values of cells at the given
        position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        The list must have the same length than the table height.

        Arguments:

            x -- int or str

            values -- list of Python types

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str
        &#34;&#34;&#34;
        cells = [
            Cell(value, cell_type=cell_type, currency=currency, style=style)
            for value in values
        ]
        self.set_column_cells(x, cells)

    def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return wether every cell in the column at &#34;x&#34; position has no value
        or the value evaluates to False (empty string), and no style.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        If aggressive is True, empty cells with style are considered empty.

        Return: bool
        &#34;&#34;&#34;
        for cell in self.get_column_cells(x):
            if cell is None:
                continue
            if not cell.is_empty(aggressive=aggressive):
                return False
        return True

    # Named Range

    def get_named_ranges(  # type: ignore
        self,
        table_name: str | list[str] | None = None,
    ) -&gt; list[NamedRange]:
        &#34;&#34;&#34;Returns the list of available Name Ranges of the spreadsheet. If
        table_name is provided, limits the search to these tables.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            table_names -- str or list of str, names of tables

        Return : list of table_range
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            return []
        all_named_ranges = body.get_named_ranges()
        if not table_name:
            return all_named_ranges  # type:ignore
        filter_ = []
        if isinstance(table_name, str):
            filter_.append(table_name)
        elif isiterable(table_name):
            filter_.extend(table_name)
        else:
            raise ValueError(
                f&#34;table_name must be string or Iterable, not {type(table_name)}&#34;
            )
        return [
            nr for nr in all_named_ranges if nr.table_name in filter_  # type:ignore
        ]

    def get_named_range(self, name: str) -&gt; NamedRange:
        &#34;&#34;&#34;Returns the Name Ranges of the specified name. If
        table_name is provided, limits the search to these tables.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            name -- str, name of the named range object

        Return : NamedRange
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document&#34;)
        return body.get_named_range(name)  # type: ignore

    def set_named_range(
        self,
        name: str,
        crange: str | tuple | list,
        table_name: str | None = None,
        usage: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Create a Named Range element and insert it in the document.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            name -- str, name of the named range

            crange -- str or tuple of int, cell or area coordinate

            table_name -- str, name of the table

            uage -- None or &#39;print-range&#39;, &#39;filter&#39;, &#39;repeat-column&#39;, &#39;repeat-row&#39;
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document&#34;)
        if not name:
            raise ValueError(&#34;Name required.&#34;)
        if table_name is None:
            table_name = self.name
        named_range = NamedRange(name, crange, table_name, usage)
        body.append_named_range(named_range)

    def delete_named_range(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete the Named Range of specified name from the spreadsheet.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        name = name.strip()
        if not name:
            raise ValueError(&#34;Name required.&#34;)
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        body.delete_named_range(name)

    #
    # Cell span
    #

    def set_span(  # noqa: C901
        self,
        area: str | tuple | list,
        merge: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;Create a Cell Span : span the first cell of the area on several
        columns and/or rows.
        If merge is True, replace text of the cell by the concatenation of
        existing text in covered cells.
        Beware : if merge is True, old text is changed, if merge is False
        (the default), old text in coverd cells is still present but not
        displayed by most GUI.

        If the area defines only one cell, the set span will do nothing.
        It is not allowed to apply set span to an area whose one cell already
        belongs to previous cell span.

        Area can be either one cell (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can
        be provided as an alpha numeric value like &#34;A1:B2&#39; or a tuple like
        (0, 0, 1, 1) or (0, 0).

        Arguments:

            area -- str or tuple of int, cell or area coordinate

            merge -- boolean
        &#34;&#34;&#34;
        # get area
        digits = _convert_coordinates(area)
        if len(digits) == 4:
            x, y, z, t = digits
        else:
            x, y = digits
            z, t = digits
        start = x, y
        end = z, t
        if start == end:
            # one cell : do nothing
            return False
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        if z is None:
            raise ValueError
        if t is None:
            raise ValueError
        # check for previous span
        good = True
        # Check boundaries and empty cells : need to crate non existent cells
        # so don&#39;t use get_cells directly, but get_cell
        cells = []
        for yy in range(y, t + 1):
            row_cells = []
            for xx in range(x, z + 1):
                row_cells.append(
                    self.get_cell((xx, yy), clone=True, keep_repeated=False)
                )
            cells.append(row_cells)
        for row in cells:
            for cell in row:
                if cell._is_spanned():
                    good = False
                    break
            if not good:
                break
        if not good:
            return False
        # Check boundaries
        # if z &gt;= self.width or t &gt;= self.height:
        #    self.set_cell(coord = end)
        #    print area, z, t
        #    cells = self.get_cells((x, y, z, t))
        #    print cells
        # do it:
        if merge:
            val_list = []
            for row in cells:
                for cell in row:
                    if cell.is_empty(aggressive=True):
                        continue
                    val = cell.get_value()
                    if val is not None:
                        if isinstance(val, str):
                            val.strip()
                        if val != &#34;&#34;:
                            val_list.append(val)
                        cell.clear()
            if val_list:
                if len(val_list) == 1:
                    cells[0][0].set_value(val_list[0])
                else:
                    value = &#34; &#34;.join([str(v) for v in val_list if v])
                    cells[0][0].set_value(value)
        cols = z - x + 1
        cells[0][0].set_attribute(&#34;table:number-columns-spanned&#34;, str(cols))
        rows = t - y + 1
        cells[0][0].set_attribute(&#34;table:number-rows-spanned&#34;, str(rows))
        for cell in cells[0][1:]:
            cell.tag = &#34;table:covered-table-cell&#34;
        for row in cells[1:]:
            for cell in row:
                cell.tag = &#34;table:covered-table-cell&#34;
        # replace cells in table
        self.set_cells(cells, coord=start, clone=False)
        return True

    def del_span(self, area: str | tuple | list) -&gt; bool:
        &#34;&#34;&#34;Delete a Cell Span. &#39;area&#39; is the cell coordiante of the upper left
        cell of the spanned area.

        Area can be either one cell (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can
        be provided as an alpha numeric value like &#34;A1:B2&#39; or a tuple like
        (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell
        is used.

        Arguments:

            area -- str or tuple of int, cell or area coordinate
        &#34;&#34;&#34;
        # get area
        digits = _convert_coordinates(area)
        if len(digits) == 4:
            x, y, _z, _t = digits
        else:
            x, y = digits
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        start = x, y
        # check for previous span
        cell0 = self.get_cell(start)
        nb_cols = cell0.get_attribute_integer(&#34;table:number-columns-spanned&#34;)
        if nb_cols is None:
            return False
        nb_rows = cell0.get_attribute_integer(&#34;table:number-rows-spanned&#34;)
        if nb_rows is None:
            return False
        z = x + nb_cols - 1
        t = y + nb_rows - 1
        cells = self.get_cells((x, y, z, t))
        cells[0][0].del_attribute(&#34;table:number-columns-spanned&#34;)
        cells[0][0].del_attribute(&#34;table:number-rows-spanned&#34;)
        for cell in cells[0][1:]:
            cell.tag = &#34;table:table-cell&#34;
        for row in cells[1:]:
            for cell in row:
                cell.tag = &#34;table:table-cell&#34;
        # replace cells in table
        self.set_cells(cells, coord=start, clone=False)
        return True

    # Utilities

    def to_csv(
        self,
        path_or_file: str | Path | None = None,
        dialect: str = &#34;excel&#34;,
    ) -&gt; Any:
        &#34;&#34;&#34;Write the table as CSV in the file.

        If the file is a string, it is opened as a local path. Else an
        opened file-like is expected.

        Arguments:

            path_or_file -- str or file-like

            dialect -- str, python csv.dialect, can be &#39;excel&#39;, &#39;unix&#39;...
        &#34;&#34;&#34;

        def write_content(csv_writer: object) -&gt; None:
            for values in self.iter_values():
                line = []
                for value in values:
                    if value is None:
                        value = &#34;&#34;
                    if isinstance(value, str):
                        value = value.strip()
                    line.append(value)
                csv_writer.writerow(line)  # type: ignore

        out = StringIO(newline=&#34;&#34;)
        csv_writer = csv.writer(out, dialect=dialect)
        write_content(csv_writer)
        if path_or_file is None:
            return out.getvalue()
        path = Path(path_or_file)
        path.write_text(out.getvalue())
        return None


class NamedRange(Element):
    &#34;&#34;&#34;ODF Named Range &#34;table:named-range&#34;. Identifies inside the spreadsheet
    a range of cells of a table by a name and the name of the table.

    Name Ranges have the following attributes:

        name -- name of the named range

        table_name -- name of the table

        start -- first cell of the named range, tuple (x, y)

        end -- last cell of the named range, tuple (x, y)

        crange -- range of the named range, tuple (x, y, z, t)

        usage -- None or str, usage of the named range.
    &#34;&#34;&#34;

    _tag = &#34;table:named-range&#34;

    def __init__(
        self,
        name: str | None = None,
        crange: str | tuple | list | None = None,
        table_name: str | None = None,
        usage: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a Named Range element. &#39;name&#39; must contains only letters, digits
           and &#39;_&#39;, and must not be like a coordinate as &#39;A1&#39;. &#39;table_name&#39; must be
           a correct table name (no &#34;&#39;&#34; or &#34;/&#34; in it).

        Arguments:

             name -- str, name of the named range

             crange -- str or tuple of int, cell or area coordinate

             table_name -- str, name of the table

             usage -- None or &#39;print-range&#39;, &#39;filter&#39;, &#39;repeat-column&#39;, &#39;repeat-row&#39;
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.usage = None
        if self._do_init:
            self.name = name or &#34;&#34;
            self.table_name = _table_name_check(table_name)
            self.set_range(crange or &#34;&#34;)
            self.set_usage(usage)
        cell_range_address = self.get_attribute_string(&#34;table:cell-range-address&#34;) or &#34;&#34;
        if not cell_range_address:
            self.table_name = &#34;&#34;
            self.start = None
            self.end = None
            self.crange = None
            self.usage = None
            return
        self.usage = self.get_attribute(&#34;table:range-usable-as&#34;)
        name_range = cell_range_address.replace(&#34;$&#34;, &#34;&#34;)
        name, crange = name_range.split(&#34;.&#34;, 1)
        if name.startswith(&#34;&#39;&#34;) and name.endswith(&#34;&#39;&#34;):
            name = name[1:-1]
        self.table_name = name
        crange = crange.replace(&#34;.&#34;, &#34;&#34;)
        self._set_range(crange)

    def set_usage(self, usage: str | None = None) -&gt; None:
        &#34;&#34;&#34;Set the usage of the Named Range. Usage can be None (default) or one
        of :
            &#39;print-range&#39;
            &#39;filter&#39;
            &#39;repeat-column&#39;
            &#39;repeat-row&#39;

        Arguments:

            usage -- None or str
        &#34;&#34;&#34;
        if usage is not None:
            usage = usage.strip().lower()
            if usage not in (&#34;print-range&#34;, &#34;filter&#34;, &#34;repeat-column&#34;, &#34;repeat-row&#34;):
                usage = None
        if usage is None:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:range-usable-as&#34;)
            self.usage = None
        else:
            self.set_attribute(&#34;table:range-usable-as&#34;, usage)
            self.usage = usage

    @property
    def name(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the name of the table.&#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:name&#34;)

    @name.setter
    def name(self, name: str) -&gt; None:
        &#34;&#34;&#34;Set the name of the Named Range. The name is mandatory, if a Named
        Range of the same name exists, it will be replaced. Name must contains
        only alphanumerics characters and &#39;_&#39;, and can not be of a cell
        coordinates form like &#39;AB12&#39;.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        name = name.strip()
        if not name:
            raise ValueError(&#34;Name required.&#34;)
        for x in name:
            if x in _forbidden_in_named_range:
                raise ValueError(f&#34;Character forbidden &#39;{x}&#39; &#34;)
        step = &#34;&#34;
        for x in name:
            if x in string.ascii_letters and step in (&#34;&#34;, &#34;A&#34;):
                step = &#34;A&#34;
                continue
            elif step in (&#34;A&#34;, &#34;A1&#34;) and x in string.digits:
                step = &#34;A1&#34;
                continue
            else:
                step = &#34;&#34;
                break
        if step == &#34;A1&#34;:
            raise ValueError(&#34;Name of the type &#39;ABC123&#39; is not allowed.&#34;)
        with contextlib.suppress(Exception):
            # we are not on an inserted in a document.
            body = self.document_body
            named_range = body.get_named_range(name)  # type: ignore
            if named_range:
                named_range.delete()
        self.set_attribute(&#34;table:name&#34;, name)

    def set_table_name(self, name: str) -&gt; None:
        &#34;&#34;&#34;Set the name of the table of the Named Range. The name is mandatory.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        self.table_name = _table_name_check(name)
        self._update_attributes()

    def _set_range(self, coord: tuple | list | str) -&gt; None:
        digits = _convert_coordinates(coord)
        if len(digits) == 4:
            x, y, z, t = digits
        else:
            x, y = digits
            z, t = digits
        self.start = x, y  # type: ignore
        self.end = z, t  # type: ignore
        self.crange = x, y, z, t  # type: ignore

    def set_range(self, crange: str | tuple | list) -&gt; None:
        &#34;&#34;&#34;Set the range of the named range. Range can be either one cell
        (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can be provided as an alpha numeric
        value like &#34;A1:B2&#39; or a tuple like (0, 0, 1, 1) or (0, 0).

        Arguments:

            crange -- str or tuple of int, cell or area coordinate
        &#34;&#34;&#34;
        self._set_range(crange)
        self._update_attributes()

    def _update_attributes(self) -&gt; None:
        self.set_attribute(&#34;table:base-cell-address&#34;, self._make_base_cell_address())
        self.set_attribute(&#34;table:cell-range-address&#34;, self._make_cell_range_address())

    def _make_base_cell_address(self) -&gt; str:
        # assuming we got table_name and range
        if &#34; &#34; in self.table_name:
            name = f&#34;&#39;{self.table_name}&#39;&#34;
        else:
            name = self.table_name
        return f&#34;${name}.${_digit_to_alpha(self.start[0])}${self.start[1] + 1}&#34;  # type: ignore

    def _make_cell_range_address(self) -&gt; str:
        # assuming we got table_name and range
        if &#34; &#34; in self.table_name:
            name = f&#34;&#39;{self.table_name}&#39;&#34;
        else:
            name = self.table_name
        if self.start == self.end:
            return self._make_base_cell_address()
        return (
            f&#34;${name}.${_digit_to_alpha(self.start[0])}${self.start[1] + 1}:&#34;  # type: ignore
            f&#34;.${_digit_to_alpha(self.end[0])}${self.end[1] + 1}&#34;  # type: ignore
        )

    def get_values(
        self,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
        flat: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Shortcut to retrieve the values of the cells of the named range. See
        table.get_values() for the arguments description and return format.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore

    def get_value(self, get_type: bool = False) -&gt; Any:
        &#34;&#34;&#34;Shortcut to retrieve the value of the first cell of the named range.
        See table.get_value() for the arguments description and return format.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        return table.get_value(self.start, get_type)  # type: ignore

    def set_values(
        self,
        values: list,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the values of the cells of the named range.
        See table.set_values() for the arguments description.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        table.set_values(  # type: ignore
            values,
            coord=self.crange,
            style=style,
            cell_type=cell_type,
            currency=currency,
        )

    def set_value(
        self,
        value: Any,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of the first cell of the named range.
        See table.set_value() for the arguments description.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        table.set_value(  # type: ignore
            coord=self.start,
            value=value,
            cell_type=cell_type,
            currency=currency,
            style=style,
        )


def import_from_csv(
    path_or_file: str | Path | object,
    name: str,
    style: str | None = None,
    delimiter: str | None = None,
    quotechar: str | None = None,
    lineterminator: str | None = None,
    encoding: str = &#34;utf-8&#34;,
) -&gt; Table:
    &#34;&#34;&#34;Convert the CSV file to an Table. If the file is a string, it is
    opened as a local path. Else a open file-like is expected; it will not be
    closed afterwards.

    CSV format can be autodetected to a certain limit, but encoding is
    important.

    Arguments:

      path_or_file -- str or file-like

      name -- str

      style -- str

      delimiter -- str

      quotechar -- str

      lineterminator -- str

      encoding -- str
    &#34;&#34;&#34;

    # Load the data
    # XXX Load the entire file in memory
    # Alternative: a file-wrapper returning the sample then the rest
    if isinstance(path_or_file, (str, Path)):
        Path(path_or_file)
        content_b = Path(path_or_file).read_bytes()
    else:
        # Leave the file we were given open
        content_b = path_or_file.read()  # type: ignore
    if isinstance(content_b, bytes):
        content = content_b.decode()
    else:
        content = content_b
    data = content.splitlines(True)
    # Sniff the dialect
    sample = &#34;&#34;.join(data[:100])
    dialect = csv.Sniffer().sniff(sample)
    # We can overload the result
    if delimiter is not None:
        dialect.delimiter = delimiter
    if quotechar is not None:
        dialect.quotechar = quotechar
    if lineterminator is not None:
        dialect.lineterminator = lineterminator
    # Make the rows
    reader = csv.reader(data, dialect)
    table = Table(name, style=style)
    for line in reader:
        row = Row()
        # rstrip line
        while line and not line[-1].strip():
            line.pop()
        for value in line:
            cell = Cell(_get_python_value(value, encoding))
            row.append_cell(cell, clone=False)
        table.append_row(row, clone=False)
    return table


register_element_class_list(Cell, (Cell._tag, &#34;table:covered-table-cell&#34;))
# register_element_class(CellCovered)
register_element_class(HeaderRows)
register_element_class(Row)
register_element_class(Column)
register_element_class(RowGroup)
register_element_class(Table)
register_element_class(NamedRange)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="odfdo.table.import_from_csv"><code class="name flex">
<span>def <span class="ident">import_from_csv</span></span>(<span>path_or_file: str | Path | object, name: str, style: str | None = None, delimiter: str | None = None, quotechar: str | None = None, lineterminator: str | None = None, encoding: str = 'utf-8') ‑> <a title="odfdo.table.Table" href="#odfdo.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the CSV file to an Table. If the file is a string, it is
opened as a local path. Else a open file-like is expected; it will not be
closed afterwards.</p>
<p>CSV format can be autodetected to a certain limit, but encoding is
important.</p>
<h2 id="arguments">Arguments</h2>
<p>path_or_file &ndash; str or file-like</p>
<p>name &ndash; str</p>
<p>style &ndash; str</p>
<p>delimiter &ndash; str</p>
<p>quotechar &ndash; str</p>
<p>lineterminator &ndash; str</p>
<p>encoding &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_from_csv(
    path_or_file: str | Path | object,
    name: str,
    style: str | None = None,
    delimiter: str | None = None,
    quotechar: str | None = None,
    lineterminator: str | None = None,
    encoding: str = &#34;utf-8&#34;,
) -&gt; Table:
    &#34;&#34;&#34;Convert the CSV file to an Table. If the file is a string, it is
    opened as a local path. Else a open file-like is expected; it will not be
    closed afterwards.

    CSV format can be autodetected to a certain limit, but encoding is
    important.

    Arguments:

      path_or_file -- str or file-like

      name -- str

      style -- str

      delimiter -- str

      quotechar -- str

      lineterminator -- str

      encoding -- str
    &#34;&#34;&#34;

    # Load the data
    # XXX Load the entire file in memory
    # Alternative: a file-wrapper returning the sample then the rest
    if isinstance(path_or_file, (str, Path)):
        Path(path_or_file)
        content_b = Path(path_or_file).read_bytes()
    else:
        # Leave the file we were given open
        content_b = path_or_file.read()  # type: ignore
    if isinstance(content_b, bytes):
        content = content_b.decode()
    else:
        content = content_b
    data = content.splitlines(True)
    # Sniff the dialect
    sample = &#34;&#34;.join(data[:100])
    dialect = csv.Sniffer().sniff(sample)
    # We can overload the result
    if delimiter is not None:
        dialect.delimiter = delimiter
    if quotechar is not None:
        dialect.quotechar = quotechar
    if lineterminator is not None:
        dialect.lineterminator = lineterminator
    # Make the rows
    reader = csv.reader(data, dialect)
    table = Table(name, style=style)
    for line in reader:
        row = Row()
        # rstrip line
        while line and not line[-1].strip():
            line.pop()
        for value in line:
            cell = Cell(_get_python_value(value, encoding))
            row.append_cell(cell, clone=False)
        table.append_row(row, clone=False)
    return table</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="odfdo.table.Cell"><code class="flex name class">
<span>class <span class="ident">Cell</span></span>
<span>(</span><span>value: Any = None, text: str | None = None, cell_type: str | None = None, currency: str | None = None, formula: str | None = None, repeated: int | None = None, style: str | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>"table:table-cell" table cell element.</p>
<p>Create a cell element containing the given value. The textual
representation is automatically formatted but can be provided. Cell
type can be deduced as well, unless the number is a percentage or
currency. If cell type is "currency", the currency must be given.
The cell can be repeated on the given number of columns.</p>
<h2 id="arguments">Arguments</h2>
<p>value &ndash; bool, int, float, Decimal, date, datetime, str,
timedelta</p>
<p>text &ndash; str</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>repeated &ndash; int</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cell(ElementTyped):
    &#34;&#34;&#34; &#34;table:table-cell&#34; table cell element.&#34;&#34;&#34;

    _tag = &#34;table:table-cell&#34;
    _caching = True

    def __init__(
        self,
        value: Any = None,
        text: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
        formula: str | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a cell element containing the given value. The textual
        representation is automatically formatted but can be provided. Cell
        type can be deduced as well, unless the number is a percentage or
        currency. If cell type is &#34;currency&#34;, the currency must be given.
        The cell can be repeated on the given number of columns.

        Arguments:

            value -- bool, int, float, Decimal, date, datetime, str,
                     timedelta

            text -- str

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.x = None
        self.y = None
        if self._do_init:
            self.set_value(
                value,
                text=text,
                cell_type=cell_type,
                currency=currency,
                formula=formula,
            )
            if repeated and repeated &gt; 1:
                self.repeated = repeated
            if style is not None:
                self.style = style

    @property
    def clone(self) -&gt; Cell:
        clone = Element.clone.fget(self)  # type: ignore
        clone.y = self.y
        clone.x = self.x
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    @property
    def value(
        self,
    ) -&gt; str | bool | int | float | Decimal | date | datetime | timedelta | None:
        &#34;&#34;&#34;Set / get the value of the cell. The type is read from the
        &#39;office:value-type&#39; attribute of the cell. When setting the value,
        the type of the value will determine the new value_type of the cell.

        Warning: use this method for boolean, float or string only.
        &#34;&#34;&#34;
        value_type = self.get_attribute_string(&#34;office:value-type&#34;)
        if value_type == &#34;boolean&#34;:
            return self.get_attribute(&#34;office:boolean-value&#34;)
        if value_type in {&#34;float&#34;, &#34;percentage&#34;, &#34;currency&#34;}:
            value_decimal = Decimal(str(self.get_attribute_string(&#34;office:value&#34;)))
            # Return 3 instead of 3.0 if possible
            if int(value_decimal) == value_decimal:
                return int(value_decimal)
            return value_decimal
        if value_type == &#34;date&#34;:
            value_str = str(self.get_attribute_string(&#34;office:date-value&#34;))
            if &#34;T&#34; in value_str:
                return DateTime.decode(value_str)
            return Date.decode(value_str)
        if value_type == &#34;time&#34;:
            return Duration.decode(str(self.get_attribute_string(&#34;office:time-value&#34;)))
        if value_type == &#34;string&#34;:
            value = self.get_attribute_string(&#34;office:string-value&#34;)
            if value is not None:
                return value
            value_list = []
            for para in self.get_elements(&#34;text:p&#34;):
                value_list.append(para.text_recursive)
            return &#34;\n&#34;.join(value_list)
        return None

    @value.setter
    def value(self, value: str | bytes | bool | int | float | Decimal | None) -&gt; None:
        self.clear()
        if value is None:
            return
        if isinstance(value, (str, bytes)):
            if isinstance(value, bytes):
                value = bytes_to_str(value)
            self.set_attribute(&#34;office:value-type&#34;, &#34;string&#34;)
            self.set_attribute(&#34;office:string-value&#34;, value)
            self.text = value
            return
        if value is True or value is False:
            self.set_attribute(&#34;office:value-type&#34;, &#34;boolean&#34;)
            value_bool = Boolean.encode(value)
            self.set_attribute(&#34;office:boolean-value&#34;, value_bool)
            self.text = value_bool
            return
        if isinstance(value, (int, float, Decimal)):
            self.set_attribute(&#34;office:value-type&#34;, &#34;float&#34;)
            value_str = str(value)
            self.set_attribute(&#34;office:value&#34;, value_str)
            self.text = value_str
            return
        raise TypeError(f&#34;Unknown value type, try with set_value() : {value!r}&#34;)

    @property
    def float(self) -&gt; float:
        &#34;&#34;&#34;Set / get the value of the cell as a float (or 0.0).&#34;&#34;&#34;
        for tag in (&#34;office:value&#34;, &#34;office:string-value&#34;, &#34;office:boolean-value&#34;):
            read_attr = self.get_attribute(tag)
            if isinstance(read_attr, str):
                with contextlib.suppress(ValueError, TypeError):
                    return float(read_attr)
        return 0.0

    @float.setter
    def float(self, value: str | float | int | Decimal) -&gt; None:
        try:
            value_float = float(value)
        except (ValueError, TypeError):
            value_float = 0.0
        value_str = str(value_float)
        self.clear()
        self.set_attribute(&#34;office:value&#34;, value_str)
        self.set_attribute(&#34;office:value-type&#34;, &#34;float&#34;)
        self.text = value_str

    @property
    def string(self) -&gt; str:
        &#34;&#34;&#34;Set / get the value of the cell as a string (or &#39;&#39;).&#34;&#34;&#34;
        value = self.get_attribute_string(&#34;office:string-value&#34;)
        if isinstance(value, str):
            return value
        return &#34;&#34;

    @string.setter
    def string(
        self,
        value: str | bytes | int | float | Decimal | bool | None,  # type: ignore
    ) -&gt; None:
        self.clear()
        if value is None:
            value_str = &#34;&#34;
        else:
            value_str = str(value)
        self.set_attribute(&#34;office:value-type&#34;, &#34;string&#34;)
        self.set_attribute(&#34;office:string-value&#34;, value_str)
        self.text = value_str

    def set_value(
        self,
        value: (
            str  # type: ignore
            | bytes
            | float
            | int
            | Decimal
            | bool
            | datetime
            | date
            | timedelta
            | None
        ),
        text: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
        formula: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cell state from the Python value type.

        Text is how the cell is displayed. Cell type is guessed,
        unless provided.

        For monetary values, provide the name of the currency.

        Arguments:

            value -- Python type

            text -- str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                        &#39;currency&#39; or &#39;percentage&#39;

            currency -- str
        &#34;&#34;&#34;
        self.clear()
        text = self.set_value_and_type(
            value=value,
            text=text,
            value_type=cell_type,
            currency=currency,
        )
        if text is not None:
            self.text_content = text
        if formula is not None:
            self.formula = formula

    @property
    def type(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the type of the cell: boolean, float, date, string
        or time.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;office:value-type&#34;)

    @type.setter
    def type(self, cell_type: str) -&gt; None:
        self.set_attribute(&#34;office:value-type&#34;, cell_type)

    @property
    def currency(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the currency used for monetary values.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;office:currency&#34;)

    @currency.setter
    def currency(self, currency: str) -&gt; None:
        self.set_attribute(&#34;office:currency&#34;, currency)

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the numnber of times the cell is repeated, or
        None to delete. Without changing cache.
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-columns-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-columns-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get / set the number of times the cell is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-columns-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        child: Element = self
        while True:
            # look for Row, parent may be group of rows
            upper = child.parent
            if not upper:
                # lonely cell
                return
            # parent may be group of rows, not table
            if isinstance(upper, Row):
                break
            child = upper
        # fixme : need to optimize this
        if isinstance(upper, Row):
            upper._compute_row_cache()

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the style of the cell itself.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:style-name&#34;)

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    @property
    def formula(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the formula of the cell, or None if undefined.

        The formula is not interpreted in any way.

        Return: str | None
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:formula&#34;)

    @formula.setter
    def formula(self, formula: str | None) -&gt; None:
        self.set_attribute(&#34;table:formula&#34;, formula)

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        if self.value is not None or self.children:
            return False
        if not aggressive and self.style is not None:
            return False
        return True

    def _is_spanned(self) -&gt; bool:
        if self.tag == &#34;table:covered-table-cell&#34;:
            return True
        if self.get_attribute(&#34;table:number-columns-spanned&#34;) is not None:
            return True
        if self.get_attribute(&#34;table:number-rows-spanned&#34;) is not None:
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element_typed.ElementTyped" href="element_typed.html#odfdo.element_typed.ElementTyped">ElementTyped</a></li>
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.table.Cell.clone"><code class="name">var <span class="ident">clone</span> : <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clone(self) -&gt; Cell:
    clone = Element.clone.fget(self)  # type: ignore
    clone.y = self.y
    clone.x = self.x
    if hasattr(self, &#34;_tmap&#34;):
        if hasattr(self, &#34;_rmap&#34;):
            clone._rmap = self._rmap[:]
        clone._tmap = self._tmap[:]
        clone._cmap = self._cmap[:]
    return clone</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.currency"><code class="name">var <span class="ident">currency</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the currency used for monetary values.</p>
<p>Return: str | None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def currency(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the currency used for monetary values.

    Return: str | None
    &#34;&#34;&#34;
    return self.get_attribute_string(&#34;office:currency&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.float"><code class="name">var <span class="ident">float</span> : float</code></dt>
<dd>
<div class="desc"><p>Set / get the value of the cell as a float (or 0.0).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def float(self) -&gt; float:
    &#34;&#34;&#34;Set / get the value of the cell as a float (or 0.0).&#34;&#34;&#34;
    for tag in (&#34;office:value&#34;, &#34;office:string-value&#34;, &#34;office:boolean-value&#34;):
        read_attr = self.get_attribute(tag)
        if isinstance(read_attr, str):
            with contextlib.suppress(ValueError, TypeError):
                return float(read_attr)
    return 0.0</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.formula"><code class="name">var <span class="ident">formula</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the formula of the cell, or None if undefined.</p>
<p>The formula is not interpreted in any way.</p>
<p>Return: str | None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def formula(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the formula of the cell, or None if undefined.

    The formula is not interpreted in any way.

    Return: str | None
    &#34;&#34;&#34;
    return self.get_attribute_string(&#34;table:formula&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.repeated"><code class="name">var <span class="ident">repeated</span> : int | None</code></dt>
<dd>
<div class="desc"><p>Get / set the number of times the cell is repeated.</p>
<p>Always None when using the table API.</p>
<p>Return: int or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def repeated(self) -&gt; int | None:
    &#34;&#34;&#34;Get / set the number of times the cell is repeated.

    Always None when using the table API.

    Return: int or None
    &#34;&#34;&#34;
    repeated = self.get_attribute(&#34;table:number-columns-repeated&#34;)
    if repeated is None:
        return None
    return int(repeated)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.string"><code class="name">var <span class="ident">string</span> : str</code></dt>
<dd>
<div class="desc"><p>Set / get the value of the cell as a string (or '').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def string(self) -&gt; str:
    &#34;&#34;&#34;Set / get the value of the cell as a string (or &#39;&#39;).&#34;&#34;&#34;
    value = self.get_attribute_string(&#34;office:string-value&#34;)
    if isinstance(value, str):
        return value
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.style"><code class="name">var <span class="ident">style</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the style of the cell itself.</p>
<p>Return: str | None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def style(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the style of the cell itself.

    Return: str | None
    &#34;&#34;&#34;
    return self.get_attribute_string(&#34;table:style-name&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.type"><code class="name">var <span class="ident">type</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the type of the cell: boolean, float, date, string
or time.</p>
<p>Return: str | None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the type of the cell: boolean, float, date, string
    or time.

    Return: str | None
    &#34;&#34;&#34;
    return self.get_attribute_string(&#34;office:value-type&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Cell.value"><code class="name">var <span class="ident">value</span> : str | bool | int | float | decimal.Decimal | datetime.date | datetime.datetime | datetime.timedelta | None</code></dt>
<dd>
<div class="desc"><p>Set / get the value of the cell. The type is read from the
'office:value-type' attribute of the cell. When setting the value,
the type of the value will determine the new value_type of the cell.</p>
<p>Warning: use this method for boolean, float or string only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(
    self,
) -&gt; str | bool | int | float | Decimal | date | datetime | timedelta | None:
    &#34;&#34;&#34;Set / get the value of the cell. The type is read from the
    &#39;office:value-type&#39; attribute of the cell. When setting the value,
    the type of the value will determine the new value_type of the cell.

    Warning: use this method for boolean, float or string only.
    &#34;&#34;&#34;
    value_type = self.get_attribute_string(&#34;office:value-type&#34;)
    if value_type == &#34;boolean&#34;:
        return self.get_attribute(&#34;office:boolean-value&#34;)
    if value_type in {&#34;float&#34;, &#34;percentage&#34;, &#34;currency&#34;}:
        value_decimal = Decimal(str(self.get_attribute_string(&#34;office:value&#34;)))
        # Return 3 instead of 3.0 if possible
        if int(value_decimal) == value_decimal:
            return int(value_decimal)
        return value_decimal
    if value_type == &#34;date&#34;:
        value_str = str(self.get_attribute_string(&#34;office:date-value&#34;))
        if &#34;T&#34; in value_str:
            return DateTime.decode(value_str)
        return Date.decode(value_str)
    if value_type == &#34;time&#34;:
        return Duration.decode(str(self.get_attribute_string(&#34;office:time-value&#34;)))
    if value_type == &#34;string&#34;:
        value = self.get_attribute_string(&#34;office:string-value&#34;)
        if value is not None:
            return value
        value_list = []
        for para in self.get_elements(&#34;text:p&#34;):
            value_list.append(para.text_recursive)
        return &#34;\n&#34;.join(value_list)
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.table.Cell.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, value: str | bytes | float | int | Decimal | bool | datetime | date | timedelta | None, text: str | None = None, cell_type: str | None = None, currency: str | None = None, formula: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the cell state from the Python value type.</p>
<p>Text is how the cell is displayed. Cell type is guessed,
unless provided.</p>
<p>For monetary values, provide the name of the currency.</p>
<h2 id="arguments">Arguments</h2>
<p>value &ndash; Python type</p>
<p>text &ndash; str</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency' or 'percentage'</p>
<p>currency &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(
    self,
    value: (
        str  # type: ignore
        | bytes
        | float
        | int
        | Decimal
        | bool
        | datetime
        | date
        | timedelta
        | None
    ),
    text: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
    formula: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Set the cell state from the Python value type.

    Text is how the cell is displayed. Cell type is guessed,
    unless provided.

    For monetary values, provide the name of the currency.

    Arguments:

        value -- Python type

        text -- str

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                    &#39;currency&#39; or &#39;percentage&#39;

        currency -- str
    &#34;&#34;&#34;
    self.clear()
    text = self.set_value_and_type(
        value=value,
        text=text,
        value_type=cell_type,
        currency=currency,
    )
    if text is not None:
        self.text_content = text
    if formula is not None:
        self.formula = formula</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element_typed.ElementTyped" href="element_typed.html#odfdo.element_typed.ElementTyped">ElementTyped</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element_typed.ElementTyped.append" href="element.html#odfdo.element.Element.append">append</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_value" href="element_typed.html#odfdo.element_typed.ElementTyped.get_value">get_value</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.is_empty" href="element.html#odfdo.element.Element.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element_typed.ElementTyped.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odfdo.table.Column"><code class="flex name class">
<span>class <span class="ident">Column</span></span>
<span>(</span><span>default_cell_style: str | None = None, repeated: int | None = None, style: str | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>ODF table column "table:table-column" </p>
<p>Create a column group element of the optionally given style. Cell
style can be set for the whole column. If the properties apply to
several columns, give the number of repeated columns.</p>
<p>Columns don't contain cells, just style information.</p>
<p>You don't generally have to create columns by hand, use the Table API.</p>
<h2 id="arguments">Arguments</h2>
<p>default_cell_style &ndash; str</p>
<p>repeated &ndash; int</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Column(Element):
    &#34;&#34;&#34;ODF table column &#34;table:table-column&#34; &#34;&#34;&#34;

    _tag = &#34;table:table-column&#34;
    _caching = True

    def __init__(
        self,
        default_cell_style: str | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a column group element of the optionally given style. Cell
        style can be set for the whole column. If the properties apply to
        several columns, give the number of repeated columns.

        Columns don&#39;t contain cells, just style information.

        You don&#39;t generally have to create columns by hand, use the Table API.

        Arguments:

            default_cell_style -- str

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.x = None
        if self._do_init:
            if default_cell_style:
                self.set_default_cell_style(default_cell_style)
            if repeated and repeated &gt; 1:
                self.repeated = repeated
            if style:
                self.style = style

    @property
    def clone(self) -&gt; Column:
        clone = Element.clone.fget(self)  # type: ignore
        clone.x = self.x
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    def get_default_cell_style(self) -&gt; str | None:
        return self.get_attribute_string(&#34;table:default-cell-style-name&#34;)

    def set_default_cell_style(self, style: Element | str) -&gt; None:
        self.set_style_attribute(&#34;table:default-cell-style-name&#34;, style)

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the number of times the column is repeated, or
        None to delete it. Without changing cache.

        Arguments:

            repeated -- int or None
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-columns-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-columns-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get /set the number of times the column is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-columns-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        current: Element = self
        while True:
            # look for Table, parent may be group of rows
            upper = current.parent
            if not upper:
                # lonely column
                return
            # parent may be group of rows, not table
            if isinstance(upper, Table):
                break
            current = upper
        # fixme : need to optimize this
        if isinstance(upper, Table):
            upper._compute_table_cache()
            if hasattr(self, &#34;_cmap&#34;):
                del self._cmap[:]
                self._cmap.extend(upper._cmap)
            else:
                self._cmap = upper._cmap

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get /set the style of the column itself.

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:style-name&#34;)

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.table.Column.clone"><code class="name">var <span class="ident">clone</span> : <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clone(self) -&gt; Column:
    clone = Element.clone.fget(self)  # type: ignore
    clone.x = self.x
    if hasattr(self, &#34;_tmap&#34;):
        if hasattr(self, &#34;_rmap&#34;):
            clone._rmap = self._rmap[:]
        clone._tmap = self._tmap[:]
        clone._cmap = self._cmap[:]
    return clone</code></pre>
</details>
</dd>
<dt id="odfdo.table.Column.repeated"><code class="name">var <span class="ident">repeated</span> : int | None</code></dt>
<dd>
<div class="desc"><p>Get /set the number of times the column is repeated.</p>
<p>Always None when using the table API.</p>
<p>Return: int or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def repeated(self) -&gt; int | None:
    &#34;&#34;&#34;Get /set the number of times the column is repeated.

    Always None when using the table API.

    Return: int or None
    &#34;&#34;&#34;
    repeated = self.get_attribute(&#34;table:number-columns-repeated&#34;)
    if repeated is None:
        return None
    return int(repeated)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Column.style"><code class="name">var <span class="ident">style</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get /set the style of the column itself.</p>
<p>Return: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def style(self) -&gt; str | None:
    &#34;&#34;&#34;Get /set the style of the column itself.

    Return: str
    &#34;&#34;&#34;
    return self.get_attribute_string(&#34;table:style-name&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.table.Column.get_default_cell_style"><code class="name flex">
<span>def <span class="ident">get_default_cell_style</span></span>(<span>self) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_cell_style(self) -&gt; str | None:
    return self.get_attribute_string(&#34;table:default-cell-style-name&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Column.set_default_cell_style"><code class="name flex">
<span>def <span class="ident">set_default_cell_style</span></span>(<span>self, style: Element | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_cell_style(self, style: Element | str) -&gt; None:
    self.set_style_attribute(&#34;table:default-cell-style-name&#34;, style)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append" href="element.html#odfdo.element.Element.append">append</a></code></li>
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.is_empty" href="element.html#odfdo.element.Element.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odfdo.table.HeaderRows"><code class="flex name class">
<span>class <span class="ident">HeaderRows</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of all ODF classes.</p>
<p>Representation of an XML element. Abstraction of the XML library behind.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderRows(Element):
    _tag = &#34;table:table-header-rows&#34;
    _caching = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append" href="element.html#odfdo.element.Element.append">append</a></code></li>
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.is_empty" href="element.html#odfdo.element.Element.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odfdo.table.NamedRange"><code class="flex name class">
<span>class <span class="ident">NamedRange</span></span>
<span>(</span><span>name: str | None = None, crange: str | tuple | list | None = None, table_name: str | None = None, usage: str | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>ODF Named Range "table:named-range". Identifies inside the spreadsheet
a range of cells of a table by a name and the name of the table.</p>
<p>Name Ranges have the following attributes:</p>
<pre><code>name -- name of the named range

table_name -- name of the table

start -- first cell of the named range, tuple (x, y)

end -- last cell of the named range, tuple (x, y)

crange -- range of the named range, tuple (x, y, z, t)

usage -- None or str, usage of the named range.
</code></pre>
<p>Create a Named Range element. 'name' must contains only letters, digits
and '_', and must not be like a coordinate as 'A1'. 'table_name' must be
a correct table name (no "'" or "/" in it).</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str, name of the named range</p>
<p>crange &ndash; str or tuple of int, cell or area coordinate</p>
<p>table_name &ndash; str, name of the table</p>
<p>usage &ndash; None or 'print-range', 'filter', 'repeat-column', 'repeat-row'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NamedRange(Element):
    &#34;&#34;&#34;ODF Named Range &#34;table:named-range&#34;. Identifies inside the spreadsheet
    a range of cells of a table by a name and the name of the table.

    Name Ranges have the following attributes:

        name -- name of the named range

        table_name -- name of the table

        start -- first cell of the named range, tuple (x, y)

        end -- last cell of the named range, tuple (x, y)

        crange -- range of the named range, tuple (x, y, z, t)

        usage -- None or str, usage of the named range.
    &#34;&#34;&#34;

    _tag = &#34;table:named-range&#34;

    def __init__(
        self,
        name: str | None = None,
        crange: str | tuple | list | None = None,
        table_name: str | None = None,
        usage: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a Named Range element. &#39;name&#39; must contains only letters, digits
           and &#39;_&#39;, and must not be like a coordinate as &#39;A1&#39;. &#39;table_name&#39; must be
           a correct table name (no &#34;&#39;&#34; or &#34;/&#34; in it).

        Arguments:

             name -- str, name of the named range

             crange -- str or tuple of int, cell or area coordinate

             table_name -- str, name of the table

             usage -- None or &#39;print-range&#39;, &#39;filter&#39;, &#39;repeat-column&#39;, &#39;repeat-row&#39;
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.usage = None
        if self._do_init:
            self.name = name or &#34;&#34;
            self.table_name = _table_name_check(table_name)
            self.set_range(crange or &#34;&#34;)
            self.set_usage(usage)
        cell_range_address = self.get_attribute_string(&#34;table:cell-range-address&#34;) or &#34;&#34;
        if not cell_range_address:
            self.table_name = &#34;&#34;
            self.start = None
            self.end = None
            self.crange = None
            self.usage = None
            return
        self.usage = self.get_attribute(&#34;table:range-usable-as&#34;)
        name_range = cell_range_address.replace(&#34;$&#34;, &#34;&#34;)
        name, crange = name_range.split(&#34;.&#34;, 1)
        if name.startswith(&#34;&#39;&#34;) and name.endswith(&#34;&#39;&#34;):
            name = name[1:-1]
        self.table_name = name
        crange = crange.replace(&#34;.&#34;, &#34;&#34;)
        self._set_range(crange)

    def set_usage(self, usage: str | None = None) -&gt; None:
        &#34;&#34;&#34;Set the usage of the Named Range. Usage can be None (default) or one
        of :
            &#39;print-range&#39;
            &#39;filter&#39;
            &#39;repeat-column&#39;
            &#39;repeat-row&#39;

        Arguments:

            usage -- None or str
        &#34;&#34;&#34;
        if usage is not None:
            usage = usage.strip().lower()
            if usage not in (&#34;print-range&#34;, &#34;filter&#34;, &#34;repeat-column&#34;, &#34;repeat-row&#34;):
                usage = None
        if usage is None:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:range-usable-as&#34;)
            self.usage = None
        else:
            self.set_attribute(&#34;table:range-usable-as&#34;, usage)
            self.usage = usage

    @property
    def name(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the name of the table.&#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:name&#34;)

    @name.setter
    def name(self, name: str) -&gt; None:
        &#34;&#34;&#34;Set the name of the Named Range. The name is mandatory, if a Named
        Range of the same name exists, it will be replaced. Name must contains
        only alphanumerics characters and &#39;_&#39;, and can not be of a cell
        coordinates form like &#39;AB12&#39;.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        name = name.strip()
        if not name:
            raise ValueError(&#34;Name required.&#34;)
        for x in name:
            if x in _forbidden_in_named_range:
                raise ValueError(f&#34;Character forbidden &#39;{x}&#39; &#34;)
        step = &#34;&#34;
        for x in name:
            if x in string.ascii_letters and step in (&#34;&#34;, &#34;A&#34;):
                step = &#34;A&#34;
                continue
            elif step in (&#34;A&#34;, &#34;A1&#34;) and x in string.digits:
                step = &#34;A1&#34;
                continue
            else:
                step = &#34;&#34;
                break
        if step == &#34;A1&#34;:
            raise ValueError(&#34;Name of the type &#39;ABC123&#39; is not allowed.&#34;)
        with contextlib.suppress(Exception):
            # we are not on an inserted in a document.
            body = self.document_body
            named_range = body.get_named_range(name)  # type: ignore
            if named_range:
                named_range.delete()
        self.set_attribute(&#34;table:name&#34;, name)

    def set_table_name(self, name: str) -&gt; None:
        &#34;&#34;&#34;Set the name of the table of the Named Range. The name is mandatory.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        self.table_name = _table_name_check(name)
        self._update_attributes()

    def _set_range(self, coord: tuple | list | str) -&gt; None:
        digits = _convert_coordinates(coord)
        if len(digits) == 4:
            x, y, z, t = digits
        else:
            x, y = digits
            z, t = digits
        self.start = x, y  # type: ignore
        self.end = z, t  # type: ignore
        self.crange = x, y, z, t  # type: ignore

    def set_range(self, crange: str | tuple | list) -&gt; None:
        &#34;&#34;&#34;Set the range of the named range. Range can be either one cell
        (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can be provided as an alpha numeric
        value like &#34;A1:B2&#39; or a tuple like (0, 0, 1, 1) or (0, 0).

        Arguments:

            crange -- str or tuple of int, cell or area coordinate
        &#34;&#34;&#34;
        self._set_range(crange)
        self._update_attributes()

    def _update_attributes(self) -&gt; None:
        self.set_attribute(&#34;table:base-cell-address&#34;, self._make_base_cell_address())
        self.set_attribute(&#34;table:cell-range-address&#34;, self._make_cell_range_address())

    def _make_base_cell_address(self) -&gt; str:
        # assuming we got table_name and range
        if &#34; &#34; in self.table_name:
            name = f&#34;&#39;{self.table_name}&#39;&#34;
        else:
            name = self.table_name
        return f&#34;${name}.${_digit_to_alpha(self.start[0])}${self.start[1] + 1}&#34;  # type: ignore

    def _make_cell_range_address(self) -&gt; str:
        # assuming we got table_name and range
        if &#34; &#34; in self.table_name:
            name = f&#34;&#39;{self.table_name}&#39;&#34;
        else:
            name = self.table_name
        if self.start == self.end:
            return self._make_base_cell_address()
        return (
            f&#34;${name}.${_digit_to_alpha(self.start[0])}${self.start[1] + 1}:&#34;  # type: ignore
            f&#34;.${_digit_to_alpha(self.end[0])}${self.end[1] + 1}&#34;  # type: ignore
        )

    def get_values(
        self,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
        flat: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Shortcut to retrieve the values of the cells of the named range. See
        table.get_values() for the arguments description and return format.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore

    def get_value(self, get_type: bool = False) -&gt; Any:
        &#34;&#34;&#34;Shortcut to retrieve the value of the first cell of the named range.
        See table.get_value() for the arguments description and return format.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        return table.get_value(self.start, get_type)  # type: ignore

    def set_values(
        self,
        values: list,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the values of the cells of the named range.
        See table.set_values() for the arguments description.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        table.set_values(  # type: ignore
            values,
            coord=self.crange,
            style=style,
            cell_type=cell_type,
            currency=currency,
        )

    def set_value(
        self,
        value: Any,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of the first cell of the named range.
        See table.set_value() for the arguments description.
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        table = body.get_table(name=self.table_name)
        if table is None:
            raise ValueError
        table.set_value(  # type: ignore
            coord=self.start,
            value=value,
            cell_type=cell_type,
            currency=currency,
            style=style,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.table.NamedRange.name"><code class="name">var <span class="ident">name</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the name of the table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the name of the table.&#34;&#34;&#34;
    return self.get_attribute_string(&#34;table:name&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.table.NamedRange.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, get_type: bool = False) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to retrieve the value of the first cell of the named range.
See table.get_value() for the arguments description and return format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, get_type: bool = False) -&gt; Any:
    &#34;&#34;&#34;Shortcut to retrieve the value of the first cell of the named range.
    See table.get_value() for the arguments description and return format.
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document.&#34;)
    table = body.get_table(name=self.table_name)
    if table is None:
        raise ValueError
    return table.get_value(self.start, get_type)  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.NamedRange.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self, cell_type: str | None = None, complete: bool = True, get_type: bool = False, flat: bool = False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to retrieve the values of the cells of the named range. See
table.get_values() for the arguments description and return format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(
    self,
    cell_type: str | None = None,
    complete: bool = True,
    get_type: bool = False,
    flat: bool = False,
) -&gt; list:
    &#34;&#34;&#34;Shortcut to retrieve the values of the cells of the named range. See
    table.get_values() for the arguments description and return format.
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document.&#34;)
    table = body.get_table(name=self.table_name)
    if table is None:
        raise ValueError
    return table.get_values(self.crange, cell_type, complete, get_type, flat)  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.NamedRange.set_range"><code class="name flex">
<span>def <span class="ident">set_range</span></span>(<span>self, crange: str | tuple | list) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the range of the named range. Range can be either one cell
(like 'A1') or an area ('A1:B2'). It can be provided as an alpha numeric
value like "A1:B2' or a tuple like (0, 0, 1, 1) or (0, 0).</p>
<h2 id="arguments">Arguments</h2>
<p>crange &ndash; str or tuple of int, cell or area coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_range(self, crange: str | tuple | list) -&gt; None:
    &#34;&#34;&#34;Set the range of the named range. Range can be either one cell
    (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can be provided as an alpha numeric
    value like &#34;A1:B2&#39; or a tuple like (0, 0, 1, 1) or (0, 0).

    Arguments:

        crange -- str or tuple of int, cell or area coordinate
    &#34;&#34;&#34;
    self._set_range(crange)
    self._update_attributes()</code></pre>
</details>
</dd>
<dt id="odfdo.table.NamedRange.set_table_name"><code class="name flex">
<span>def <span class="ident">set_table_name</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the name of the table of the Named Range. The name is mandatory.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_table_name(self, name: str) -&gt; None:
    &#34;&#34;&#34;Set the name of the table of the Named Range. The name is mandatory.

    Arguments:

        name -- str
    &#34;&#34;&#34;
    self.table_name = _table_name_check(name)
    self._update_attributes()</code></pre>
</details>
</dd>
<dt id="odfdo.table.NamedRange.set_usage"><code class="name flex">
<span>def <span class="ident">set_usage</span></span>(<span>self, usage: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the usage of the Named Range. Usage can be None (default) or one
of :
'print-range'
'filter'
'repeat-column'
'repeat-row'</p>
<h2 id="arguments">Arguments</h2>
<p>usage &ndash; None or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_usage(self, usage: str | None = None) -&gt; None:
    &#34;&#34;&#34;Set the usage of the Named Range. Usage can be None (default) or one
    of :
        &#39;print-range&#39;
        &#39;filter&#39;
        &#39;repeat-column&#39;
        &#39;repeat-row&#39;

    Arguments:

        usage -- None or str
    &#34;&#34;&#34;
    if usage is not None:
        usage = usage.strip().lower()
        if usage not in (&#34;print-range&#34;, &#34;filter&#34;, &#34;repeat-column&#34;, &#34;repeat-row&#34;):
            usage = None
    if usage is None:
        with contextlib.suppress(KeyError):
            self.del_attribute(&#34;table:range-usable-as&#34;)
        self.usage = None
    else:
        self.set_attribute(&#34;table:range-usable-as&#34;, usage)
        self.usage = usage</code></pre>
</details>
</dd>
<dt id="odfdo.table.NamedRange.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, value: Any, cell_type: str | None = None, currency: str | None = None, style: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the value of the first cell of the named range.
See table.set_value() for the arguments description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(
    self,
    value: Any,
    cell_type: str | None = None,
    currency: str | None = None,
    style: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the value of the first cell of the named range.
    See table.set_value() for the arguments description.
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document.&#34;)
    table = body.get_table(name=self.table_name)
    if table is None:
        raise ValueError
    table.set_value(  # type: ignore
        coord=self.start,
        value=value,
        cell_type=cell_type,
        currency=currency,
        style=style,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.table.NamedRange.set_values"><code class="name flex">
<span>def <span class="ident">set_values</span></span>(<span>self, values: list, style: str | None = None, cell_type: str | None = None, currency: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the values of the cells of the named range.
See table.set_values() for the arguments description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values(
    self,
    values: list,
    style: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the values of the cells of the named range.
    See table.set_values() for the arguments description.
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document.&#34;)
    table = body.get_table(name=self.table_name)
    if table is None:
        raise ValueError
    table.set_values(  # type: ignore
        values,
        coord=self.crange,
        style=style,
        cell_type=cell_type,
        currency=currency,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append" href="element.html#odfdo.element.Element.append">append</a></code></li>
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.is_empty" href="element.html#odfdo.element.Element.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odfdo.table.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>width: int | None = None, repeated: int | None = None, style: str | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>ODF table row "table:table-row" </p>
<p>create a Row, optionally filled with "width" number of cells.</p>
<p>Rows contain cells, their number determine the number of columns.</p>
<p>You don't generally have to create rows by hand, use the Table API.</p>
<h2 id="arguments">Arguments</h2>
<p>width &ndash; int</p>
<p>repeated &ndash; int</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Row(Element):
    &#34;&#34;&#34;ODF table row &#34;table:table-row&#34; &#34;&#34;&#34;

    _tag = &#34;table:table-row&#34;
    _caching = True
    _append = Element.append

    def __init__(
        self,
        width: int | None = None,
        repeated: int | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;create a Row, optionally filled with &#34;width&#34; number of cells.

        Rows contain cells, their number determine the number of columns.

        You don&#39;t generally have to create rows by hand, use the Table API.

        Arguments:

            width -- int

            repeated -- int

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.y = None
        if not hasattr(self, &#34;_indexes&#34;):
            self._indexes = {}
            self._indexes[&#34;_rmap&#34;] = {}
        if not hasattr(self, &#34;_rmap&#34;):
            self._compute_row_cache()
            if not hasattr(self, &#34;_tmap&#34;):
                self._tmap = []
                self._cmap = []
        if self._do_init:
            if width is not None:
                for _i in range(width):
                    self.append(Cell())  # type:ignore
            if repeated:
                self.repeated = repeated
            if style is not None:
                self.style = style
            self._compute_row_cache()

    def _get_cells(self) -&gt; list[Element]:
        return self.get_elements(_xpath_cell)

    def _translate_row_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, int | None]:
        xyzt = _convert_coordinates(coord)
        if len(xyzt) == 2:
            x, z = xyzt
        else:
            x, _, z, __ = xyzt
        if x and x &lt; 0:
            x = _increment(x, self.width)
        if z and z &lt; 0:
            z = _increment(z, self.width)
        return (x, z)

    def _compute_row_cache(self) -&gt; None:
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_cell, &#34;table:number-columns-repeated&#34;
        )
        self._rmap = _make_cache_map(idx_repeated_seq)

    # Public API

    @property
    def clone(self) -&gt; Row:
        clone = Element.clone.fget(self)  # type: ignore
        clone.y = self.y
        if hasattr(self, &#34;_tmap&#34;):
            if hasattr(self, &#34;_rmap&#34;):
                clone._rmap = self._rmap[:]
            clone._tmap = self._tmap[:]
            clone._cmap = self._cmap[:]
        return clone

    def _set_repeated(self, repeated: int | None) -&gt; None:
        &#34;&#34;&#34;Internal only. Set the numnber of times the row is repeated, or
        None to delete it. Without changing cache.

        Arguments:

            repeated -- int
        &#34;&#34;&#34;
        if repeated is None or repeated &lt; 2:
            with contextlib.suppress(KeyError):
                self.del_attribute(&#34;table:number-rows-repeated&#34;)
            return
        self.set_attribute(&#34;table:number-rows-repeated&#34;, str(repeated))

    @property
    def repeated(self) -&gt; int | None:
        &#34;&#34;&#34;Get / set the number of times the row is repeated.

        Always None when using the table API.

        Return: int or None
        &#34;&#34;&#34;
        repeated = self.get_attribute(&#34;table:number-rows-repeated&#34;)
        if repeated is None:
            return None
        return int(repeated)

    @repeated.setter
    def repeated(self, repeated: int | None) -&gt; None:
        self._set_repeated(repeated)
        # update cache
        current: Element = self
        while True:
            # look for Table, parent may be group of rows
            upper = current.parent
            if not upper:
                # lonely row
                return
            # parent may be group of rows, not table
            if isinstance(upper, Table):
                break
            current = upper
        # fixme : need to optimize this
        if isinstance(upper, Table):
            upper._compute_table_cache()
            if hasattr(self, &#34;_tmap&#34;):
                del self._tmap[:]
                self._tmap.extend(upper._tmap)
            else:
                self._tmap = upper._tmap

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get /set the style of the row itself.

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute(&#34;table:style-name&#34;)  # type: ignore

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Get the number of expected cells in the row, i.e. addition
        repetitions.

        Return: int
        &#34;&#34;&#34;
        try:
            value = self._rmap[-1] + 1
        except Exception:
            value = 0
        return value

    def _translate_x_from_any(self, x: str | int) -&gt; int:
        return _translate_from_any(x, self.width, 0)

    def traverse(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Cell]:
        &#34;&#34;&#34;Yield as many cell elements as expected cells in the row, i.e.
        expand repetitions by returning the same cell as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_cell() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        x = 0
        cell: Cell
        if start is None and end is None:
            for juska in self._rmap:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    if cell is None:
                        cell = Cell()
                    else:
                        cell = cell.clone
                        if repeated &gt; 1:
                            cell.repeated = None
                    cell.y = self.y
                    cell.x = x
                    x += 1
                    yield cell
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._rmap[-1]
                except Exception:
                    end = -1
            start_map = _find_odf_idx(self._rmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._rmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            x = start
            for juska in self._rmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_rmap&#34;]:
                    cell = self._indexes[&#34;_rmap&#34;][idx]
                else:
                    cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                    if not isinstance(cell, Cell):
                        raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                    self._indexes[&#34;_rmap&#34;][idx] = cell
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if x &lt;= end:
                        if cell is None:
                            cell = Cell()
                        else:
                            cell = cell.clone
                            if repeated &gt; 1 or (x == start and start &gt; 0):
                                cell.repeated = None
                        cell.y = self.y
                        cell.x = x
                        x += 1
                        yield cell

    def get_cells(
        self,
        coord: str | tuple | None = None,
        style: str | None = None,
        content: str | None = None,
        cell_type: str | None = None,
    ) -&gt; list[Cell]:
        &#34;&#34;&#34;Get the list of cells matching the criteria.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.

        Filter by coordinates will retrieve the amount of cells defined by
        &#39;coord&#39;, minus the other filters.

        Arguments:

            coord -- str or tuple of int : coordinates

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

        Return: list of Cell
        &#34;&#34;&#34;
        # fixme : not clones ?
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
        cells: list[Cell] = []
        for cell in self.traverse(start=x, end=z):
            # Filter the cells by cell_type
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    continue
            # Filter the cells with the regex
            if content and not cell.match(content):
                continue
            # Filter the cells with the style
            if style and style != cell.style:
                continue
            cells.append(cell)
        return cells

    def _get_cell2(self, x: int, clone: bool = True) -&gt; Cell | None:
        if x &gt;= self.width:
            return Cell()
        if clone:
            return self._get_cell2_base(x).clone  # type: ignore
        else:
            return self._get_cell2_base(x)

    def _get_cell2_base(self, x: int) -&gt; Cell | None:
        idx = _find_odf_idx(self._rmap, x)
        cell: Cell
        if idx is not None:
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                self._indexes[&#34;_rmap&#34;][idx] = cell
            return cell
        return None

    def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:
        &#34;&#34;&#34;Get the cell at position &#34;x&#34; starting from 0. Alphabetical
        positions like &#34;D&#34; are accepted.

        A  copy is returned, use set_cell() to push it back.

        Arguments:

            x -- int or str

        Return: Cell | None
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        cell = self._get_cell2(x, clone=clone)
        if not cell:
            return None
        cell.y = self.y
        cell.x = x
        return cell

    def get_value(
        self,
        x: int | str,
        get_type: bool = False,
    ) -&gt; Any | tuple[Any, str]:
        &#34;&#34;&#34;Shortcut to get the value of the cell at position &#34;x&#34;.
        If get_type is True, returns the tuples (value, ODF type).

        If the cell is empty, returns None or (None, None)

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        if get_type:
            x = self._translate_x_from_any(x)
            cell = self._get_cell2_base(x)
            if cell is None:
                return (None, None)
            return cell.get_value(get_type=get_type)
        x = self._translate_x_from_any(x)
        cell = self._get_cell2_base(x)
        if cell is None:
            return None
        return cell.get_value()

    def set_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Push the cell back in the row at position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Arguments:

            x -- int or str

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
            repeated = 1
            clone = False
        else:
            repeated = cell.repeated or 1
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff == 0:
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        elif diff &gt; 0:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
        else:
            # Inside the defined row
            _set_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;, clone=clone)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        return cell_back

    def set_value(
        self,
        x: int | str,
        value: Any,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of the cell at position &#34;x&#34;.

        Arguments:

            x -- int or str

            value -- Python type

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        See get_cell() and Cell.get_value().
        &#34;&#34;&#34;
        self.set_cell(
            x,
            Cell(value, style=style, cell_type=cell_type, currency=currency),
            clone=False,
        )

    def insert_cell(
        self,
        x: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Insert the given cell at position &#34;x&#34; starting from 0. If no cell
        is given, an empty one is created.

        Alphabetical positions like &#34;D&#34; are accepted.

        Do not use when working on a table, use Table.insert_cell().

        Arguments:

            x -- int or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        cell_back: Cell
        if cell is None:
            cell = Cell()
        x = self._translate_x_from_any(x)
        # Outside the defined row
        diff = x - self.width
        if diff &lt; 0:
            _insert_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;)
            cell.x = x
            cell.y = self.y
            cell_back = cell
        elif diff == 0:
            cell_back = self.append_cell(cell, clone=clone)
        else:
            self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
            cell_back = self.append_cell(cell, clone=clone)
        return cell_back

    def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:
        if cells is None:
            cells = []
        self.extend(cells)
        self._compute_row_cache()

    def append_cell(
        self,
        cell: Cell | None = None,
        clone: bool = True,
        _repeated: int | None = None,
    ) -&gt; Cell:
        &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
        accepted. If no cell is given, an empty one is created.

        Do not use when working on a table, use Table.append_cell().

        Arguments:

            cell -- Cell

            _repeated -- (optional), repeated value of the row

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        self._append(cell)
        if _repeated is None:
            _repeated = cell.repeated or 1
        self._rmap = _insert_map_once(self._rmap, len(self._rmap), _repeated)
        cell.x = self.width - 1
        cell.y = self.y
        return cell

    # fix for unit test and typos
    append = append_cell  # type: ignore

    def delete_cell(self, x: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the cell at the given position &#34;x&#34; starting from 0.
        Alphabetical positions like &#34;D&#34; are accepted.

        Cells on the right will be shifted to the left. In a table, other
        rows remain unaffected.

        Arguments:

            x -- int or str
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if x &gt;= self.width:
            return
        _delete_item_in_vault(x, self, _xpath_cell_idx, &#34;_rmap&#34;)

    def get_values(
        self,
        coord: str | tuple | None = None,
        cell_type: str | None = None,
        complete: bool = False,
        get_type: bool = False,
    ) -&gt; list[Any | tuple[Any, Any]]:
        &#34;&#34;&#34;Shortcut to get the cell values in this row.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type is used and complete is True, missing values are
        replaced by None.
        If cell_type is None, complete is always True : with no cell type
        queried, get_values() returns None for each empty cell, the length
        of the list is equal to the length of the row (depending on
        coordinates use).

        If get_type is True, returns a tuple (value, ODF type of value), or
        (None, None) for empty cells if complete is True.

        Filter by coordinates will retrieve the amount of cells defined by
        coordinates with None for empty cells, except when using cell_type.


        Arguments:

            coord -- str or tuple of int : coordinates in row

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of Python types, or list of tuples.
        &#34;&#34;&#34;
        if coord:
            x, z = self._translate_row_coordinates(coord)
        else:
            x = None
            z = None
        if cell_type:
            cell_type = cell_type.lower().strip()
            values: list[Any | tuple[Any, Any]] = []
            for cell in self.traverse(start=x, end=z):
                # Filter the cells by cell_type
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        if get_type:
                            values.append((None, None))
                        else:
                            values.append(None)
                    continue
                values.append(cell.get_value(get_type=get_type))
            return values
        else:
            return [
                cell.get_value(get_type=get_type)
                for cell in self.traverse(start=x, end=z)
            ]

    def set_cells(
        self,
        cells: list[Cell] | tuple[Cell] | None = None,
        start: int | str = 0,
        clone: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cells in the row, from the &#39;start&#39; column.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            cells -- list of cells

            start -- int or str
        &#34;&#34;&#34;
        if cells is None:
            cells = []
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and clone is False and (len(cells) &gt;= self.width):
            self.clear()
            self.extend_cells(cells)
        else:
            x = start
            for cell in cells:
                self.set_cell(x, cell, clone=clone)
                if cell:
                    x += cell.repeated or 1
                else:
                    x += 1

    def set_values(
        self,
        values: list[Any],
        start: int | str = 0,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the value of cells in the row, from the &#39;start&#39;
        column vith values.
        This method does not clear the row, use row.clear() before to start
        with an empty row.

        Arguments:

            values -- list of Python types

            start -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39; or &#39;percentage&#39;

            currency -- three-letter str

            style -- cell style
        &#34;&#34;&#34;
        # fixme : if values n, n+ are same, use repeat
        if start is None:
            start = 0
        else:
            start = self._translate_x_from_any(start)
        if start == 0 and (len(values) &gt;= self.width):
            self.clear()
            cells = [
                Cell(value, style=style, cell_type=cell_type, currency=currency)
                for value in values
            ]
            self.extend_cells(cells)
        else:
            x = start
            for value in values:
                self.set_cell(
                    x,
                    Cell(value, style=style, cell_type=cell_type, currency=currency),
                    clone=False,
                )
                x += 1

    def rstrip(self, aggressive: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove *in-place* empty cells at the right of the row. An empty
        cell has no value but can have style. If &#34;aggressive&#34; is True, style
        is ignored.

        Arguments:

            aggressive -- bool
        &#34;&#34;&#34;
        for cell in reversed(self._get_cells()):
            if not cell.is_empty(aggressive=aggressive):  # type: ignore
                break
            self.delete(cell)
        self._compute_row_cache()
        self._indexes[&#34;_rmap&#34;] = {}

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return whether every cell in the row has no value or the value
        evaluates to False (empty string), and no style.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            aggressive -- bool

        Return: bool
        &#34;&#34;&#34;
        return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.table.Row.clone"><code class="name">var <span class="ident">clone</span> : <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clone(self) -&gt; Row:
    clone = Element.clone.fget(self)  # type: ignore
    clone.y = self.y
    if hasattr(self, &#34;_tmap&#34;):
        if hasattr(self, &#34;_rmap&#34;):
            clone._rmap = self._rmap[:]
        clone._tmap = self._tmap[:]
        clone._cmap = self._cmap[:]
    return clone</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.repeated"><code class="name">var <span class="ident">repeated</span> : int | None</code></dt>
<dd>
<div class="desc"><p>Get / set the number of times the row is repeated.</p>
<p>Always None when using the table API.</p>
<p>Return: int or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def repeated(self) -&gt; int | None:
    &#34;&#34;&#34;Get / set the number of times the row is repeated.

    Always None when using the table API.

    Return: int or None
    &#34;&#34;&#34;
    repeated = self.get_attribute(&#34;table:number-rows-repeated&#34;)
    if repeated is None:
        return None
    return int(repeated)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.style"><code class="name">var <span class="ident">style</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get /set the style of the row itself.</p>
<p>Return: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def style(self) -&gt; str | None:
    &#34;&#34;&#34;Get /set the style of the row itself.

    Return: str
    &#34;&#34;&#34;
    return self.get_attribute(&#34;table:style-name&#34;)  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the number of expected cells in the row, i.e. addition
repetitions.</p>
<p>Return: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;Get the number of expected cells in the row, i.e. addition
    repetitions.

    Return: int
    &#34;&#34;&#34;
    try:
        value = self._rmap[-1] + 1
    except Exception:
        value = 0
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.table.Row.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the given cell at the end of the row. Repeated cells are
accepted. If no cell is given, an empty one is created.</p>
<p>Do not use when working on a table, use Table.append_cell().</p>
<h2 id="arguments">Arguments</h2>
<p>cell &ndash; Cell</p>
<p>_repeated &ndash; (optional), repeated value of the row</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_cell(
    self,
    cell: Cell | None = None,
    clone: bool = True,
    _repeated: int | None = None,
) -&gt; Cell:
    &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
    accepted. If no cell is given, an empty one is created.

    Do not use when working on a table, use Table.append_cell().

    Arguments:

        cell -- Cell

        _repeated -- (optional), repeated value of the row

    returns the cell with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    if clone:
        cell = cell.clone
    self._append(cell)
    if _repeated is None:
        _repeated = cell.repeated or 1
    self._rmap = _insert_map_once(self._rmap, len(self._rmap), _repeated)
    cell.x = self.width - 1
    cell.y = self.y
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.append_cell"><code class="name flex">
<span>def <span class="ident">append_cell</span></span>(<span>self, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the given cell at the end of the row. Repeated cells are
accepted. If no cell is given, an empty one is created.</p>
<p>Do not use when working on a table, use Table.append_cell().</p>
<h2 id="arguments">Arguments</h2>
<p>cell &ndash; Cell</p>
<p>_repeated &ndash; (optional), repeated value of the row</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_cell(
    self,
    cell: Cell | None = None,
    clone: bool = True,
    _repeated: int | None = None,
) -&gt; Cell:
    &#34;&#34;&#34;Append the given cell at the end of the row. Repeated cells are
    accepted. If no cell is given, an empty one is created.

    Do not use when working on a table, use Table.append_cell().

    Arguments:

        cell -- Cell

        _repeated -- (optional), repeated value of the row

    returns the cell with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    if clone:
        cell = cell.clone
    self._append(cell)
    if _repeated is None:
        _repeated = cell.repeated or 1
    self._rmap = _insert_map_once(self._rmap, len(self._rmap), _repeated)
    cell.x = self.width - 1
    cell.y = self.y
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.delete_cell"><code class="name flex">
<span>def <span class="ident">delete_cell</span></span>(<span>self, x: int | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the cell at the given position "x" starting from 0.
Alphabetical positions like "D" are accepted.</p>
<p>Cells on the right will be shifted to the left. In a table, other
rows remain unaffected.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_cell(self, x: int | str) -&gt; None:
    &#34;&#34;&#34;Delete the cell at the given position &#34;x&#34; starting from 0.
    Alphabetical positions like &#34;D&#34; are accepted.

    Cells on the right will be shifted to the left. In a table, other
    rows remain unaffected.

    Arguments:

        x -- int or str
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    if x &gt;= self.width:
        return
    _delete_item_in_vault(x, self, _xpath_cell_idx, &#34;_rmap&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.extend_cells"><code class="name flex">
<span>def <span class="ident">extend_cells</span></span>(<span>self, cells: Iterable[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>] | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_cells(self, cells: Iterable[Cell] | None = None) -&gt; None:
    if cells is None:
        cells = []
    self.extend(cells)
    self._compute_row_cache()</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.get_cell"><code class="name flex">
<span>def <span class="ident">get_cell</span></span>(<span>self, x: int, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None</span>
</code></dt>
<dd>
<div class="desc"><p>Get the cell at position "x" starting from 0. Alphabetical
positions like "D" are accepted.</p>
<p>A
copy is returned, use set_cell() to push it back.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>Return: Cell | None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell(self, x: int, clone: bool = True) -&gt; Cell | None:
    &#34;&#34;&#34;Get the cell at position &#34;x&#34; starting from 0. Alphabetical
    positions like &#34;D&#34; are accepted.

    A  copy is returned, use set_cell() to push it back.

    Arguments:

        x -- int or str

    Return: Cell | None
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    cell = self._get_cell2(x, clone=clone)
    if not cell:
        return None
    cell.y = self.y
    cell.x = x
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.get_cells"><code class="name flex">
<span>def <span class="ident">get_cells</span></span>(<span>self, coord: str | tuple | None = None, style: str | None = None, content: str | None = None, cell_type: str | None = None) ‑> list[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of cells matching the criteria.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.</p>
<p>Filter by coordinates will retrieve the amount of cells defined by
'coord', minus the other filters.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>content &ndash; str regex</p>
<p>style &ndash; str</p>
<p>Return: list of Cell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells(
    self,
    coord: str | tuple | None = None,
    style: str | None = None,
    content: str | None = None,
    cell_type: str | None = None,
) -&gt; list[Cell]:
    &#34;&#34;&#34;Get the list of cells matching the criteria.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.

    Filter by coordinates will retrieve the amount of cells defined by
    &#39;coord&#39;, minus the other filters.

    Arguments:

        coord -- str or tuple of int : coordinates

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        content -- str regex

        style -- str

    Return: list of Cell
    &#34;&#34;&#34;
    # fixme : not clones ?
    if coord:
        x, z = self._translate_row_coordinates(coord)
    else:
        x = None
        z = None
    if cell_type:
        cell_type = cell_type.lower().strip()
    cells: list[Cell] = []
    for cell in self.traverse(start=x, end=z):
        # Filter the cells by cell_type
        if cell_type:
            ctype = cell.type
            if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                continue
        # Filter the cells with the regex
        if content and not cell.match(content):
            continue
        # Filter the cells with the style
        if style and style != cell.style:
            continue
        cells.append(cell)
    return cells</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, x: int | str, get_type: bool = False) ‑> typing.Any | tuple[typing.Any, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the value of the cell at position "x".
If get_type is True, returns the tuples (value, ODF type).</p>
<p>If the cell is empty, returns None or (None, None)</p>
<p>See get_cell() and Cell.get_value().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(
    self,
    x: int | str,
    get_type: bool = False,
) -&gt; Any | tuple[Any, str]:
    &#34;&#34;&#34;Shortcut to get the value of the cell at position &#34;x&#34;.
    If get_type is True, returns the tuples (value, ODF type).

    If the cell is empty, returns None or (None, None)

    See get_cell() and Cell.get_value().
    &#34;&#34;&#34;
    if get_type:
        x = self._translate_x_from_any(x)
        cell = self._get_cell2_base(x)
        if cell is None:
            return (None, None)
        return cell.get_value(get_type=get_type)
    x = self._translate_x_from_any(x)
    cell = self._get_cell2_base(x)
    if cell is None:
        return None
    return cell.get_value()</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self, coord: str | tuple | None = None, cell_type: str | None = None, complete: bool = False, get_type: bool = False) ‑> list[typing.Any | tuple[typing.Any, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the cell values in this row.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.
If cell_type is used and complete is True, missing values are
replaced by None.
If cell_type is None, complete is always True : with no cell type
queried, get_values() returns None for each empty cell, the length
of the list is equal to the length of the row (depending on
coordinates use).</p>
<p>If get_type is True, returns a tuple (value, ODF type of value), or
(None, None) for empty cells if complete is True.</p>
<p>Filter by coordinates will retrieve the amount of cells defined by
coordinates with None for empty cells, except when using cell_type.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates in row</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>complete &ndash; boolean</p>
<p>get_type &ndash; boolean</p>
<p>Return: list of Python types, or list of tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(
    self,
    coord: str | tuple | None = None,
    cell_type: str | None = None,
    complete: bool = False,
    get_type: bool = False,
) -&gt; list[Any | tuple[Any, Any]]:
    &#34;&#34;&#34;Shortcut to get the cell values in this row.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.
    If cell_type is used and complete is True, missing values are
    replaced by None.
    If cell_type is None, complete is always True : with no cell type
    queried, get_values() returns None for each empty cell, the length
    of the list is equal to the length of the row (depending on
    coordinates use).

    If get_type is True, returns a tuple (value, ODF type of value), or
    (None, None) for empty cells if complete is True.

    Filter by coordinates will retrieve the amount of cells defined by
    coordinates with None for empty cells, except when using cell_type.


    Arguments:

        coord -- str or tuple of int : coordinates in row

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        complete -- boolean

        get_type -- boolean

    Return: list of Python types, or list of tuples.
    &#34;&#34;&#34;
    if coord:
        x, z = self._translate_row_coordinates(coord)
    else:
        x = None
        z = None
    if cell_type:
        cell_type = cell_type.lower().strip()
        values: list[Any | tuple[Any, Any]] = []
        for cell in self.traverse(start=x, end=z):
            # Filter the cells by cell_type
            ctype = cell.type
            if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                if complete:
                    if get_type:
                        values.append((None, None))
                    else:
                        values.append(None)
                continue
            values.append(cell.get_value(get_type=get_type))
        return values
    else:
        return [
            cell.get_value(get_type=get_type)
            for cell in self.traverse(start=x, end=z)
        ]</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.insert_cell"><code class="name flex">
<span>def <span class="ident">insert_cell</span></span>(<span>self, x: int | str, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert the given cell at position "x" starting from 0. If no cell
is given, an empty one is created.</p>
<p>Alphabetical positions like "D" are accepted.</p>
<p>Do not use when working on a table, use Table.insert_cell().</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>cell &ndash; Cell</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_cell(
    self,
    x: int | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Insert the given cell at position &#34;x&#34; starting from 0. If no cell
    is given, an empty one is created.

    Alphabetical positions like &#34;D&#34; are accepted.

    Do not use when working on a table, use Table.insert_cell().

    Arguments:

        x -- int or str

        cell -- Cell

    returns the cell with x and y updated
    &#34;&#34;&#34;
    cell_back: Cell
    if cell is None:
        cell = Cell()
    x = self._translate_x_from_any(x)
    # Outside the defined row
    diff = x - self.width
    if diff &lt; 0:
        _insert_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;)
        cell.x = x
        cell.y = self.y
        cell_back = cell
    elif diff == 0:
        cell_back = self.append_cell(cell, clone=clone)
    else:
        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
        cell_back = self.append_cell(cell, clone=clone)
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self, aggressive: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether every cell in the row has no value or the value
evaluates to False (empty string), and no style.</p>
<p>If aggressive is True, empty cells with style are considered empty.</p>
<h2 id="arguments">Arguments</h2>
<p>aggressive &ndash; bool</p>
<p>Return: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self, aggressive: bool = False) -&gt; bool:
    &#34;&#34;&#34;Return whether every cell in the row has no value or the value
    evaluates to False (empty string), and no style.

    If aggressive is True, empty cells with style are considered empty.

    Arguments:

        aggressive -- bool

    Return: bool
    &#34;&#34;&#34;
    return all(cell.is_empty(aggressive=aggressive) for cell in self._get_cells())  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.rstrip"><code class="name flex">
<span>def <span class="ident">rstrip</span></span>(<span>self, aggressive: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove <em>in-place</em> empty cells at the right of the row. An empty
cell has no value but can have style. If "aggressive" is True, style
is ignored.</p>
<h2 id="arguments">Arguments</h2>
<p>aggressive &ndash; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rstrip(self, aggressive: bool = False) -&gt; None:
    &#34;&#34;&#34;Remove *in-place* empty cells at the right of the row. An empty
    cell has no value but can have style. If &#34;aggressive&#34; is True, style
    is ignored.

    Arguments:

        aggressive -- bool
    &#34;&#34;&#34;
    for cell in reversed(self._get_cells()):
        if not cell.is_empty(aggressive=aggressive):  # type: ignore
            break
        self.delete(cell)
    self._compute_row_cache()
    self._indexes[&#34;_rmap&#34;] = {}</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.set_cell"><code class="name flex">
<span>def <span class="ident">set_cell</span></span>(<span>self, x: int | str, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Push the cell back in the row at position "x" starting from 0.
Alphabetical positions like "D" are accepted.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell(
    self,
    x: int | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Push the cell back in the row at position &#34;x&#34; starting from 0.
    Alphabetical positions like &#34;D&#34; are accepted.

    Arguments:

        x -- int or str

    returns the cell with x and y updated
    &#34;&#34;&#34;
    cell_back: Cell
    if cell is None:
        cell = Cell()
        repeated = 1
        clone = False
    else:
        repeated = cell.repeated or 1
    x = self._translate_x_from_any(x)
    # Outside the defined row
    diff = x - self.width
    if diff == 0:
        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
    elif diff &gt; 0:
        self.append_cell(Cell(repeated=diff), _repeated=diff, clone=False)
        cell_back = self.append_cell(cell, _repeated=repeated, clone=clone)
    else:
        # Inside the defined row
        _set_item_in_vault(x, cell, self, _xpath_cell_idx, &#34;_rmap&#34;, clone=clone)
        cell.x = x
        cell.y = self.y
        cell_back = cell
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.set_cells"><code class="name flex">
<span>def <span class="ident">set_cells</span></span>(<span>self, cells: list[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>] | tuple[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>] | None = None, start: int | str = 0, clone: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the cells in the row, from the 'start' column.
This method does not clear the row, use row.clear() before to start
with an empty row.</p>
<h2 id="arguments">Arguments</h2>
<p>cells &ndash; list of cells</p>
<p>start &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cells(
    self,
    cells: list[Cell] | tuple[Cell] | None = None,
    start: int | str = 0,
    clone: bool = True,
) -&gt; None:
    &#34;&#34;&#34;Set the cells in the row, from the &#39;start&#39; column.
    This method does not clear the row, use row.clear() before to start
    with an empty row.

    Arguments:

        cells -- list of cells

        start -- int or str
    &#34;&#34;&#34;
    if cells is None:
        cells = []
    if start is None:
        start = 0
    else:
        start = self._translate_x_from_any(start)
    if start == 0 and clone is False and (len(cells) &gt;= self.width):
        self.clear()
        self.extend_cells(cells)
    else:
        x = start
        for cell in cells:
            self.set_cell(x, cell, clone=clone)
            if cell:
                x += cell.repeated or 1
            else:
                x += 1</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, x: int | str, value: Any, style: str | None = None, cell_type: str | None = None, currency: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the value of the cell at position "x".</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>value &ndash; Python type</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; str</p>
<p>See get_cell() and Cell.get_value().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(
    self,
    x: int | str,
    value: Any,
    style: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the value of the cell at position &#34;x&#34;.

    Arguments:

        x -- int or str

        value -- Python type

        cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                 &#39;string&#39; or &#39;time&#39;

        currency -- three-letter str

        style -- str

    See get_cell() and Cell.get_value().
    &#34;&#34;&#34;
    self.set_cell(
        x,
        Cell(value, style=style, cell_type=cell_type, currency=currency),
        clone=False,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.set_values"><code class="name flex">
<span>def <span class="ident">set_values</span></span>(<span>self, values: list[Any], start: int | str = 0, style: str | None = None, cell_type: str | None = None, currency: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the value of cells in the row, from the 'start'
column vith values.
This method does not clear the row, use row.clear() before to start
with an empty row.</p>
<h2 id="arguments">Arguments</h2>
<p>values &ndash; list of Python types</p>
<p>start &ndash; int or str</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency' or 'percentage'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; cell style</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values(
    self,
    values: list[Any],
    start: int | str = 0,
    style: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the value of cells in the row, from the &#39;start&#39;
    column vith values.
    This method does not clear the row, use row.clear() before to start
    with an empty row.

    Arguments:

        values -- list of Python types

        start -- int or str

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39; or &#39;percentage&#39;

        currency -- three-letter str

        style -- cell style
    &#34;&#34;&#34;
    # fixme : if values n, n+ are same, use repeat
    if start is None:
        start = 0
    else:
        start = self._translate_x_from_any(start)
    if start == 0 and (len(values) &gt;= self.width):
        self.clear()
        cells = [
            Cell(value, style=style, cell_type=cell_type, currency=currency)
            for value in values
        ]
        self.extend_cells(cells)
    else:
        x = start
        for value in values:
            self.set_cell(
                x,
                Cell(value, style=style, cell_type=cell_type, currency=currency),
                clone=False,
            )
            x += 1</code></pre>
</details>
</dd>
<dt id="odfdo.table.Row.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, start: int | None = None, end: int | None = None) ‑> collections.abc.Iterator[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Yield as many cell elements as expected cells in the row, i.e.
expand repetitions by returning the same cell as many times as
necessary.</p>
<pre><code>Arguments:

    start -- int

    end -- int
</code></pre>
<p>Copies are returned, use set_cell() to push them back.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse(  # noqa: C901
    self,
    start: int | None = None,
    end: int | None = None,
) -&gt; Iterator[Cell]:
    &#34;&#34;&#34;Yield as many cell elements as expected cells in the row, i.e.
    expand repetitions by returning the same cell as many times as
    necessary.

        Arguments:

            start -- int

            end -- int

    Copies are returned, use set_cell() to push them back.
    &#34;&#34;&#34;
    idx = -1
    before = -1
    x = 0
    cell: Cell
    if start is None and end is None:
        for juska in self._rmap:
            idx += 1
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                if not isinstance(cell, Cell):
                    raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                self._indexes[&#34;_rmap&#34;][idx] = cell
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                # Return a copy without the now obsolete repetition
                if cell is None:
                    cell = Cell()
                else:
                    cell = cell.clone
                    if repeated &gt; 1:
                        cell.repeated = None
                cell.y = self.y
                cell.x = x
                x += 1
                yield cell
    else:
        if start is None:
            start = 0
        start = max(0, start)
        if end is None:
            try:
                end = self._rmap[-1]
            except Exception:
                end = -1
        start_map = _find_odf_idx(self._rmap, start)
        if start_map is None:
            return
        if start_map &gt; 0:
            before = self._rmap[start_map - 1]
        idx = start_map - 1
        before = start - 1
        x = start
        for juska in self._rmap[start_map:]:
            idx += 1
            if idx in self._indexes[&#34;_rmap&#34;]:
                cell = self._indexes[&#34;_rmap&#34;][idx]
            else:
                cell = self._get_element_idx2(_xpath_cell_idx, idx)  # type: ignore
                if not isinstance(cell, Cell):
                    raise TypeError(f&#34;Not a cell: {cell!r}&#34;)
                self._indexes[&#34;_rmap&#34;][idx] = cell
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                if x &lt;= end:
                    if cell is None:
                        cell = Cell()
                    else:
                        cell = cell.clone
                        if repeated &gt; 1 or (x == start and start &gt; 0):
                            cell.repeated = None
                    cell.y = self.y
                    cell.x = x
                    x += 1
                    yield cell</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odfdo.table.RowGroup"><code class="flex name class">
<span>class <span class="ident">RowGroup</span></span>
<span>(</span><span>height: int | None = None, width: int | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>"table:table-row-group" group rows with common properties.</p>
<p>Create a group of rows, optionnaly filled with "height" number of
rows, of "width" cells each.</p>
<p>Row group bear style information applied to a series of rows.</p>
<h2 id="arguments">Arguments</h2>
<p>height &ndash; int</p>
<p>width &ndash; int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RowGroup(Element):
    &#34;&#34;&#34; &#34;table:table-row-group&#34; group rows with common properties.&#34;&#34;&#34;

    # TODO
    _tag = &#34;table:table-row-group&#34;
    _caching = True

    def __init__(
        self,
        height: int | None = None,
        width: int | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a group of rows, optionnaly filled with &#34;height&#34; number of
        rows, of &#34;width&#34; cells each.

        Row group bear style information applied to a series of rows.

        Arguments:

            height -- int

            width -- int
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        if self._do_init and height is not None:
            for _i in range(height):
                row = Row(width=width)
                self.append(row)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append" href="element.html#odfdo.element.Element.append">append</a></code></li>
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.delete_named_range" href="element.html#odfdo.element.Element.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_range" href="element.html#odfdo.element.Element.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.get_named_ranges" href="element.html#odfdo.element.Element.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.is_empty" href="element.html#odfdo.element.Element.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odfdo.table.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>name: str | None = None, width: int | None = None, height: int | None = None, protected: bool = False, protection_key: str | None = None, display: bool = True, printable: bool = True, print_ranges: list[str] | None = None, style: str | None = None, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>ODF table "table:table" </p>
<p>Create a table element, optionally prefilled with "height" rows of
"width" cells each.</p>
<p>If the table is to be protected, a protection key must be provided,
i.e. a hash value of the password.</p>
<p>If the table must not be displayed, set "display" to False.</p>
<p>If the table must not be printed, set "printable" to False. The table
will not be printed when it is not displayed, whatever the value of
this argument.</p>
<p>Ranges of cells to print can be provided as a list of cell ranges,
e.g. ['E6:K12', 'P6:R12'] or directly as a raw string, e.g.
"E6:K12 P6:R12".</p>
<p>You can access and modify the XML tree manually, but you probably want
to use the API to access and alter cells. It will save you from
handling repetitions and the same number of cells for each row.</p>
<p>If you use both the table API and the XML API, you are on your own for
ensuiring model integrity.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p>
<p>width &ndash; int</p>
<p>height &ndash; int</p>
<p>protected &ndash; bool</p>
<p>protection_key &ndash; str</p>
<p>display &ndash; bool</p>
<p>printable &ndash; bool</p>
<p>print_ranges &ndash; list</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table(Element):
    &#34;&#34;&#34;ODF table &#34;table:table&#34; &#34;&#34;&#34;

    _tag = &#34;table:table&#34;
    _caching = True
    _append = Element.append

    def __init__(
        self,
        name: str | None = None,
        width: int | None = None,
        height: int | None = None,
        protected: bool = False,
        protection_key: str | None = None,
        display: bool = True,
        printable: bool = True,
        print_ranges: list[str] | None = None,
        style: str | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create a table element, optionally prefilled with &#34;height&#34; rows of
        &#34;width&#34; cells each.

        If the table is to be protected, a protection key must be provided,
        i.e. a hash value of the password.

        If the table must not be displayed, set &#34;display&#34; to False.

        If the table must not be printed, set &#34;printable&#34; to False. The table
        will not be printed when it is not displayed, whatever the value of
        this argument.

        Ranges of cells to print can be provided as a list of cell ranges,
        e.g. [&#39;E6:K12&#39;, &#39;P6:R12&#39;] or directly as a raw string, e.g.
        &#34;E6:K12 P6:R12&#34;.

        You can access and modify the XML tree manually, but you probably want
        to use the API to access and alter cells. It will save you from
        handling repetitions and the same number of cells for each row.

        If you use both the table API and the XML API, you are on your own for
        ensuiring model integrity.

        Arguments:

            name -- str

            width -- int

            height -- int

            protected -- bool

            protection_key -- str

            display -- bool

            printable -- bool

            print_ranges -- list

            style -- str
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._indexes = {}
        self._indexes[&#34;_cmap&#34;] = {}
        self._indexes[&#34;_tmap&#34;] = {}
        if self._do_init:
            self.name = name
            if protected:
                self.protected = protected
                self.set_protection_key = protection_key
            if not display:
                self.displayed = display
            if not printable:
                self.printable = printable
            if print_ranges:
                self.print_ranges = print_ranges
            if style:
                self.style = style
            # Prefill the table
            if width is not None or height is not None:
                width = width or 1
                height = height or 1
                # Column groups for style information
                columns = Column(repeated=width)
                self._append(columns)
                for _i in range(height):
                    row = Row(width)
                    self._append(row)
        self._compute_table_cache()

    def __str__(self) -&gt; str:
        def write_content(csv_writer: object) -&gt; None:
            for values in self.iter_values():
                line = []
                for value in values:
                    if value is None:
                        value = &#34;&#34;
                    if isinstance(value, str):
                        value = value.strip()
                    line.append(value)
                csv_writer.writerow(line)  # type: ignore

        out = StringIO(newline=os.linesep)
        csv_writer = csv.writer(
            out,
            delimiter=&#34; &#34;,
            doublequote=False,
            escapechar=&#34;\\&#34;,
            lineterminator=os.linesep,
            quotechar=&#39;&#34;&#39;,
            quoting=csv.QUOTE_NONNUMERIC,
        )
        write_content(csv_writer)
        return out.getvalue()

    def _translate_y_from_any(self, y: str | int) -&gt; int:
        # &#34;3&#34; (couting from 1) -&gt; 2 (couting from 0)
        return _translate_from_any(y, self.height, 1)

    def _translate_table_coordinates_list(
        self,
        coord: tuple | list,
    ) -&gt; tuple[int | None, ...]:
        height = self.height
        width = self.width
        # assuming we got int values
        if len(coord) == 1:
            # It is a row
            y = coord[0]
            if y and y &lt; 0:
                y = _increment(y, height)
            return (None, y, None, y)
        if len(coord) == 2:
            # It is a row range, not a cell, because context is table
            y = coord[0]
            if y and y &lt; 0:
                y = _increment(y, height)
            t = coord[1]
            if t and t &lt; 0:
                t = _increment(t, height)
            return (None, y, None, t)
        # should be 4 int
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_table_coordinates_str(
        self,
        coord_str: str,
    ) -&gt; tuple[int | None, ...]:
        height = self.height
        width = self.width
        coord = _convert_coordinates(coord_str)
        if len(coord) == 2:
            x, y = coord
            if x and x &lt; 0:
                x = _increment(x, width)
            if y and y &lt; 0:
                y = _increment(y, height)
            # extent to an area :
            return (x, y, x, y)
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_table_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, ...]:
        if isinstance(coord, str):
            return self._translate_table_coordinates_str(coord)
        return self._translate_table_coordinates_list(coord)

    def _translate_column_coordinates_str(
        self,
        coord_str: str,
    ) -&gt; tuple[int | None, ...]:
        width = self.width
        height = self.height
        coord = _convert_coordinates(coord_str)
        if len(coord) == 2:
            x, y = coord
            if x and x &lt; 0:
                x = _increment(x, width)
            if y and y &lt; 0:
                y = _increment(y, height)
            # extent to an area :
            return (x, y, x, y)
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_column_coordinates_list(
        self,
        coord: tuple | list,
    ) -&gt; tuple[int | None, ...]:
        width = self.width
        height = self.height
        # assuming we got int values
        if len(coord) == 1:
            # It is a column
            x = coord[0]
            if x and x &lt; 0:
                x = _increment(x, width)
            return (x, None, x, None)
        if len(coord) == 2:
            # It is a column range, not a cell, because context is table
            x = coord[0]
            if x and x &lt; 0:
                x = _increment(x, width)
            z = coord[1]
            if z and z &lt; 0:
                z = _increment(z, width)
            return (x, None, z, None)
        # should be 4 int
        x, y, z, t = coord
        if x and x &lt; 0:
            x = _increment(x, width)
        if y and y &lt; 0:
            y = _increment(y, height)
        if z and z &lt; 0:
            z = _increment(z, width)
        if t and t &lt; 0:
            t = _increment(t, height)
        return (x, y, z, t)

    def _translate_column_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, ...]:
        if isinstance(coord, str):
            return self._translate_column_coordinates_str(coord)
        return self._translate_column_coordinates_list(coord)

    def _translate_cell_coordinates(
        self,
        coord: tuple | list | str,
    ) -&gt; tuple[int | None, int | None]:
        # we want an x,y result
        coord = _convert_coordinates(coord)
        if len(coord) == 2:
            x, y = coord
        # If we got an area, take the first cell
        elif len(coord) == 4:
            x, y, z, t = coord
        else:
            raise ValueError(str(coord))
        if x and x &lt; 0:
            x = _increment(x, self.width)
        if y and y &lt; 0:
            y = _increment(y, self.height)
        return (x, y)

    def _compute_table_cache(self) -&gt; None:
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_row, &#34;table:number-rows-repeated&#34;
        )
        self._tmap = _make_cache_map(idx_repeated_seq)
        idx_repeated_seq = self.elements_repeated_sequence(
            _xpath_column, &#34;table:number-columns-repeated&#34;
        )
        self._cmap = _make_cache_map(idx_repeated_seq)

    def _update_width(self, row: Row) -&gt; None:
        &#34;&#34;&#34;Synchronize the number of columns if the row is bigger.

        Append, don&#39;t insert, not to disturb the current layout.
        &#34;&#34;&#34;
        diff = row.width - self.width
        if diff &gt; 0:
            self.append_column(Column(repeated=diff))

    def _get_formatted_text_normal(self, context: dict | None) -&gt; str:
        result = []
        for row in self.traverse():
            for cell in row.traverse():
                value = cell.get_value(try_get_text=False)
                # None ?
                if value is None:
                    # Try with get_formatted_text on the elements
                    value = []
                    for element in cell.children:
                        value.append(element.get_formatted_text(context))
                    value = &#34;&#34;.join(value)
                else:
                    value = str(value)
                result.append(value)
                result.append(&#34;\n&#34;)
            result.append(&#34;\n&#34;)
        return &#34;&#34;.join(result)

    def _get_formatted_text_rst(self, context: dict) -&gt; str:  # noqa: C901
        context[&#34;no_img_level&#34;] += 1
        # Strip the table =&gt; We must clone
        table = self.clone
        table.rstrip(aggressive=True)  # type: ignore

        # Fill the rows
        rows = []
        cols_nb = 0
        cols_size: dict[int, int] = {}
        for odf_row in table.traverse():  # type: ignore
            row = []
            for i, cell in enumerate(odf_row.traverse()):
                value = cell.get_value(try_get_text=False)
                # None ?
                if value is None:
                    # Try with get_formatted_text on the elements
                    value = []
                    for element in cell.children:
                        value.append(element.get_formatted_text(context))
                    value = &#34;&#34;.join(value)
                else:
                    value = str(value)
                value = value.strip()
                # Strip the empty columns
                if value:
                    cols_nb = max(cols_nb, i + 1)
                # Compute the size of each columns (at least 2)
                cols_size[i] = max(cols_size.get(i, 2), len(value))
                # Append
                row.append(value)
            rows.append(row)

        # Nothing ?
        if cols_nb == 0:
            return &#34;&#34;

        # Prevent a crash with empty columns (by example with images)
        for col, size in cols_size.items():
            if size == 0:
                cols_size[col] = 1

        # Update cols_size
        LINE_MAX = 100
        COL_MIN = 16

        free_size = LINE_MAX - (cols_nb - 1) * 3 - 4
        real_size = sum([cols_size[i] for i in range(cols_nb)])
        if real_size &gt; free_size:
            factor = float(free_size) / real_size

            for i in range(cols_nb):
                old_size = cols_size[i]

                # The cell is already small
                if old_size &lt;= COL_MIN:
                    continue

                new_size = int(factor * old_size)

                if new_size &lt; COL_MIN:
                    new_size = COL_MIN
                cols_size[i] = new_size

        # Convert !
        result: list[str] = [&#34;&#34;]
        # Construct the first/last line
        line: list[str] = []
        for i in range(cols_nb):
            line.append(&#34;=&#34; * cols_size[i])
            line.append(&#34; &#34;)
        line_str = &#34;&#34;.join(line)

        # Add the lines
        result.append(line_str)
        for row in rows:
            # Wrap the row
            wrapped_row = []
            for i, value in enumerate(row[:cols_nb]):
                wrapped_value = []
                for part in value.split(&#34;\n&#34;):
                    # Hack to handle correctly the lists or the directives
                    subsequent_indent = &#34;&#34;
                    part_lstripped = part.lstrip()
                    if part_lstripped.startswith(&#34;-&#34;) or part_lstripped.startswith(
                        &#34;..&#34;
                    ):
                        subsequent_indent = &#34; &#34; * (len(part) - len(part.lstrip()) + 2)
                    wrapped_part = wrap(
                        part, width=cols_size[i], subsequent_indent=subsequent_indent
                    )
                    if wrapped_part:
                        wrapped_value.extend(wrapped_part)
                    else:
                        wrapped_value.append(&#34;&#34;)
                wrapped_row.append(wrapped_value)

            # Append!
            for j in range(max([1] + [len(values) for values in wrapped_row])):
                txt_row: list[str] = []
                for i in range(cols_nb):
                    values = wrapped_row[i] if i &lt; len(wrapped_row) else []

                    # An empty cell ?
                    if len(values) - 1 &lt; j or not values[j]:
                        if i == 0 and j == 0:
                            txt_row.append(&#34;..&#34;)
                            txt_row.append(&#34; &#34; * (cols_size[i] - 1))
                        else:
                            txt_row.append(&#34; &#34; * (cols_size[i] + 1))
                        continue

                    # Not empty
                    value = values[j]
                    txt_row.append(value)
                    txt_row.append(&#34; &#34; * (cols_size[i] - len(value) + 1))
                result.append(&#34;&#34;.join(txt_row))

        result.append(line_str)
        result.append(&#34;&#34;)
        result.append(&#34;&#34;)
        result_str = &#34;\n&#34;.join(result)

        context[&#34;no_img_level&#34;] -= 1
        return result_str

    def _translate_x_from_any(self, x: str | int) -&gt; int:
        return _translate_from_any(x, self.width, 0)

    #
    # Public API
    #

    def append(self, something: Element | str) -&gt; None:
        &#34;&#34;&#34;Dispatch .append() call to append_row() or append_column().&#34;&#34;&#34;
        if isinstance(something, Row):
            self.append_row(something)
        elif isinstance(something, Column):
            self.append_column(something)
        else:
            # probably still an error
            self._append(something)

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;Get the current height of the table.

        Return: int
        &#34;&#34;&#34;
        try:
            height = self._tmap[-1] + 1
        except Exception:
            height = 0
        return height

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Get the current width of the table, measured on columns.

        Rows may have different widths, use the Table API to ensure width
        consistency.

        Return: int
        &#34;&#34;&#34;
        # Columns are our reference for user expected width

        try:
            width = self._cmap[-1] + 1
        except Exception:
            width = 0

        # columns = self._get_columns()
        # repeated = self.xpath(
        #        &#39;table:table-column/@table:number-columns-repeated&#39;)
        # unrepeated = len(columns) - len(repeated)
        # ws = sum(int(r) for r in repeated) + unrepeated
        # if w != ws:
        #    print &#34;WARNING   ws&#34;, ws, &#34;w&#34;, w

        return width

    @property
    def size(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Shortcut to get the current width and height of the table.

        Return: (int, int)
        &#34;&#34;&#34;
        return self.width, self.height

    @property
    def name(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the name of the table.&#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:name&#34;)

    @name.setter
    def name(self, name: str) -&gt; None:
        name = _table_name_check(name)
        # first, update named ranges
        # fixme : delete name ranges when deleting table, too.
        for named_range in self.get_named_ranges(table_name=self.name):
            named_range.set_table_name(name)
        self.set_attribute(&#34;table:name&#34;, name)

    @property
    def protected(self) -&gt; bool:
        return bool(self.get_attribute(&#34;table:protected&#34;))

    @protected.setter
    def protected(self, protect: bool) -&gt; None:
        self.set_attribute(&#34;table:protected&#34;, protect)

    @property
    def protection_key(self) -&gt; str | None:
        return self.get_attribute_string(&#34;table:protection-key&#34;)

    @protection_key.setter
    def protection_key(self, key: str) -&gt; None:
        self.set_attribute(&#34;table:protection-key&#34;, key)

    @property
    def displayed(self) -&gt; bool:
        return bool(self.get_attribute(&#34;table:display&#34;))

    @displayed.setter
    def displayed(self, display: bool) -&gt; None:
        self.set_attribute(&#34;table:display&#34;, display)

    @property
    def printable(self) -&gt; bool:
        printable = self.get_attribute(&#34;table:print&#34;)
        # Default value
        if printable is None:
            return True
        return bool(printable)

    @printable.setter
    def printable(self, printable: bool) -&gt; None:
        self.set_attribute(&#34;table:print&#34;, printable)

    @property
    def print_ranges(self) -&gt; list[str]:
        ranges = self.get_attribute_string(&#34;table:print-ranges&#34;)
        if isinstance(ranges, str):
            return ranges.split()
        return []

    @print_ranges.setter
    def print_ranges(self, ranges: list[str] | None) -&gt; None:
        if isinstance(ranges, (list, tuple)):
            self.set_attribute(&#34;table:print-ranges&#34;, &#34; &#34;.join(ranges))
        else:
            self.set_attribute(&#34;table:print-ranges&#34;, ranges)

    @property
    def style(self) -&gt; str | None:
        &#34;&#34;&#34;Get / set the style of the table

        Return: str
        &#34;&#34;&#34;
        return self.get_attribute_string(&#34;table:style-name&#34;)

    @style.setter
    def style(self, style: str | Element) -&gt; None:
        self.set_style_attribute(&#34;table:style-name&#34;, style)

    def get_formatted_text(self, context: dict | None = None) -&gt; str:
        if context and context[&#34;rst_mode&#34;]:
            return self._get_formatted_text_rst(context)
        return self._get_formatted_text_normal(context)

    def get_values(
        self,
        coord: tuple | list | str | None = None,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
        flat: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Get a matrix of values of the table.

        Filter by coordinates will parse the area defined by the coordinates.

        If &#39;cell_type&#39; is used and &#39;complete&#39; is True (default), missing values
        are replaced by None.
        Filter by &#39; cell_type = &#34;all&#34; &#39; will retrieve cells of any
        type, aka non empty cells.

        If &#39;cell_type&#39; is None, complete is always True : with no cell type
        queried, get_values() returns None for each empty cell, the length
        each lists is equal to the width of the table.

        If get_type is True, returns tuples (value, ODF type of value), or
        (None, None) for empty cells with complete True.

        If flat is True, the methods return a single list of all the values.
        By default, flat is False.

        Arguments:

            coord -- str or tuple of int : coordinates of area

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of lists of Python types
        &#34;&#34;&#34;
        if coord:
            x, y, z, t = self._translate_table_coordinates(coord)
        else:
            x = y = z = t = None
        data = []
        for row in self.traverse(start=y, end=t):
            if z is None:
                width = self.width
            else:
                width = min(z + 1, self.width)
            if x is not None:
                width -= x
            values = row.get_values(
                (x, z),
                cell_type=cell_type,
                complete=complete,
                get_type=get_type,
            )
            # complete row to match request width
            if complete:
                if get_type:
                    values.extend([(None, None)] * (width - len(values)))
                else:
                    values.extend([None] * (width - len(values)))
            if flat:
                data.extend(values)
            else:
                data.append(values)
        return data

    def iter_values(
        self,
        coord: tuple | list | str | None = None,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
    ) -&gt; Iterator[list]:
        &#34;&#34;&#34;Iterate through lines of Python values of the table.

        Filter by coordinates will parse the area defined by the coordinates.

        cell_type, complete, grt_type : see get_values()



        Arguments:

            coord -- str or tuple of int : coordinates of area

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: iterator of lists
        &#34;&#34;&#34;
        if coord:
            x, y, z, t = self._translate_table_coordinates(coord)
        else:
            x = y = z = t = None
        for row in self.traverse(start=y, end=t):
            if z is None:
                width = self.width
            else:
                width = min(z + 1, self.width)
            if x is not None:
                width -= x
            values = row.get_values(
                (x, z),
                cell_type=cell_type,
                complete=complete,
                get_type=get_type,
            )
            # complete row to match column width
            if complete:
                if get_type:
                    values.extend([(None, None)] * (width - len(values)))
                else:
                    values.extend([None] * (width - len(values)))
            yield values

    def set_values(
        self,
        values: list,
        coord: tuple | list | str | None = None,
        style: str | None = None,
        cell_type: str | None = None,
        currency: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Set the value of cells in the table, from the &#39;coord&#39; position
        with values.

        &#39;coord&#39; is the coordinate of the upper left cell to be modified by
        values. If &#39;coord&#39; is None, default to the position (0,0) (&#34;A1&#34;).
        If &#39;coord&#39; is an area (e.g. &#34;A2:B5&#34;), the upper left position of this
        area is used as coordinate.

        The table is *not* cleared before the operation, to reset the table
        before setting values, use table.clear().

        A list of lists is expected, with as many lists as rows, and as many
        items in each sublist as cells to be setted. None values in the list
        will create empty cells with no cell type (but eventually a style).

        Arguments:

            coord -- tuple or str

            values -- list of lists of python types

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str
        &#34;&#34;&#34;
        if coord:
            x, y = self._translate_cell_coordinates(coord)
        else:
            x = y = 0
        if y is None:
            y = 0
        if x is None:
            x = 0
        y -= 1
        for row_values in values:
            y += 1
            if not row_values:
                continue
            row = self.get_row(y, clone=True)
            repeated = row.repeated or 1
            if repeated &gt;= 2:
                row.repeated = None
            row.set_values(
                row_values,
                start=x,
                cell_type=cell_type,
                currency=currency,
                style=style,
            )
            self.set_row(y, row, clone=False)
            self._update_width(row)

    def rstrip(self, aggressive: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove *in-place* empty rows below and empty cells at the right of
        the table. Cells are empty if they contain no value or it evaluates
        to False, and no style.

        If aggressive is True, empty cells with style are removed too.

        Argument:

            aggressive -- bool
        &#34;&#34;&#34;
        # Step 1: remove empty rows below the table
        for row in reversed(self._get_rows()):
            if row.is_empty(aggressive=aggressive):
                row.parent.delete(row)  # type: ignore
            else:
                break
        # Step 2: rstrip remaining rows
        max_width = 0
        for row in self._get_rows():
            row.rstrip(aggressive=aggressive)
            # keep count of the biggest row
            max_width = max(max_width, row.width)
        # raz cache of rows
        self._indexes[&#34;_tmap&#34;] = {}
        # Step 3: trim columns to match max_width
        columns = self._get_columns()
        repeated_cols = self.xpath(&#34;table:table-column/@table:number-columns-repeated&#34;)
        if not isinstance(repeated_cols, list):
            raise TypeError
        unrepeated = len(columns) - len(repeated_cols)
        column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore
        diff = column_width - max_width
        if diff &gt; 0:
            for column in reversed(columns):
                repeated = column.repeated or 1
                repeated = repeated - diff
                if repeated &gt; 0:
                    column.repeated = repeated
                    break
                else:
                    column.parent.delete(column)
                    diff = -repeated
                    if diff == 0:
                        break
        # raz cache of columns
        self._indexes[&#34;_cmap&#34;] = {}
        self._compute_table_cache()

    def transpose(self, coord: tuple | list | str | None = None) -&gt; None:  # noqa: C901
        &#34;&#34;&#34;Swap *in-place* rows and columns of the table.

        If &#39;coord&#39; is not None, apply transpose only to the area defined by the
        coordinates. Beware, if area is not square, some cells mays be over
        written during the process.

        Arguments:

            coord -- str or tuple of int : coordinates of area

            start -- int or str
        &#34;&#34;&#34;
        data = []
        if coord is None:
            for row in self.traverse():
                data.append(list(row.traverse()))
            transposed_data = zip_longest(*data)
            self.clear()
            # new_rows = []
            for row_cells in transposed_data:
                if not isiterable(row_cells):
                    row_cells = (row_cells,)
                row = Row()
                row.extend_cells(row_cells)
                self.append_row(row, clone=False)
            self._compute_table_cache()
        else:
            x, y, z, t = self._translate_table_coordinates(coord)
            if x is None:
                x = 0
            else:
                x = min(x, self.width - 1)
            if z is None:
                z = self.width - 1
            else:
                z = min(z, self.width - 1)
            if y is None:
                y = 0
            else:
                y = min(y, self.height - 1)
            if t is None:
                t = self.height - 1
            else:
                t = min(t, self.height - 1)
            for row in self.traverse(start=y, end=t):
                data.append(list(row.traverse(start=x, end=z)))
            transposed_data = zip_longest(*data)
            # clear locally
            w = z - x + 1
            h = t - y + 1
            if w != h:
                nones = [[None] * w for i in range(h)]
                self.set_values(nones, coord=(x, y, z, t))
            # put transposed
            filtered_data: list[tuple[Cell]] = []
            for row_cells in transposed_data:
                if isinstance(row_cells, (list, tuple)):
                    filtered_data.append(row_cells)
                else:
                    filtered_data.append((row_cells,))
            self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))
            self._compute_table_cache()

    def is_empty(self, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return whether every cell in the table has no value or the value
        evaluates to False (empty string), and no style.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            aggressive -- bool
        &#34;&#34;&#34;
        return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())

    #
    # Rows
    #

    def _get_rows(self) -&gt; list[Row]:
        return self.get_elements(_xpath_row)  # type: ignore

    def traverse(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Row]:
        &#34;&#34;&#34;Yield as many row elements as expected rows in the table, i.e.
        expand repetitions by returning the same row as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_row() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        y = 0
        if start is None and end is None:
            for juska in self._tmap:
                idx += 1
                if idx in self._indexes[&#34;_tmap&#34;]:
                    row = self._indexes[&#34;_tmap&#34;][idx]
                else:
                    row = self._get_element_idx2(_xpath_row_idx, idx)
                    self._indexes[&#34;_tmap&#34;][idx] = row
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    row = row.clone
                    row.y = y
                    y += 1
                    if repeated &gt; 1:
                        row.repeated = None
                    yield row
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._tmap[-1]
                except Exception:
                    end = -1
            start_map = _find_odf_idx(self._tmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._tmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            y = start
            for juska in self._tmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_tmap&#34;]:
                    row = self._indexes[&#34;_tmap&#34;][idx]
                else:
                    row = self._get_element_idx2(_xpath_row_idx, idx)
                    self._indexes[&#34;_tmap&#34;][idx] = row
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if y &lt;= end:
                        row = row.clone
                        row.y = y
                        y += 1
                        if repeated &gt; 1 or (y == start and start &gt; 0):
                            row.repeated = None
                        yield row

    def get_rows(
        self,
        coord: tuple | list | str | None = None,
        style: str | None = None,
        content: str | None = None,
    ) -&gt; list[Row]:
        &#34;&#34;&#34;Get the list of rows matching the criteria.

        Filter by coordinates will parse the area defined by the coordinates.

        Arguments:

            coord -- str or tuple of int : coordinates of rows

            content -- str regex

            style -- str

        Return: list of rows
        &#34;&#34;&#34;
        if coord:
            _x, y, _z, t = self._translate_table_coordinates(coord)
        else:
            y = t = None
        # fixme : not clones ?
        if not content and not style:
            return list(self.traverse(start=y, end=t))
        rows = []
        for row in self.traverse(start=y, end=t):
            if content and not row.match(content):
                continue
            if style and style != row.style:
                continue
            rows.append(row)
        return rows

    def _get_row2(self, y: int, clone: bool = True, create: bool = True) -&gt; Row:
        if y &gt;= self.height:
            if create:
                return Row()
            raise ValueError(&#34;Row not found&#34;)
        row = self._get_row2_base(y)
        if row is None:
            raise ValueError(&#34;Row not found&#34;)
        if clone:
            return row.clone
        return row

    def _get_row2_base(self, y: int) -&gt; Row | None:
        idx = _find_odf_idx(self._tmap, y)
        if idx is not None:
            if idx in self._indexes[&#34;_tmap&#34;]:
                row = self._indexes[&#34;_tmap&#34;][idx]
            else:
                row = self._get_element_idx2(_xpath_row_idx, idx)
                self._indexes[&#34;_tmap&#34;][idx] = row
            return row
        return None

    def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:
        &#34;&#34;&#34;Get the row at the given &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        A copy is returned, use set_cell() to push it back.

        Arguments:

            y -- int or str

        Return: Row
        &#34;&#34;&#34;
        # fixme : keep repeat ? maybe an option to functions : &#34;raw=False&#34;
        y = self._translate_y_from_any(y)
        row = self._get_row2(y, clone=clone, create=create)
        if row is None:
            raise ValueError(&#34;Row not found&#34;)
        row.y = y
        return row

    def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:
        &#34;&#34;&#34;Replace the row at the given position with the new one. Repetions of
        the old row will be adjusted.

        If row is None, a new empty row is created.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str

            row -- Row

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if row is None:
            row = Row()
            repeated = 1
            clone = False
        else:
            repeated = row.repeated or 1
        y = self._translate_y_from_any(y)
        row.y = y
        # Outside the defined table ?
        diff = y - self.height
        if diff == 0:
            row_back = self.append_row(row, _repeated=repeated, clone=clone)
        elif diff &gt; 0:
            self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)
            row_back = self.append_row(row, _repeated=repeated, clone=clone)
        else:
            # Inside the defined table
            row_back = _set_item_in_vault(  # type: ignore
                y, row, self, _xpath_row_idx, &#34;_tmap&#34;, clone=clone
            )
        # print self.serialize(True)
        # Update width if necessary
        self._update_width(row_back)
        return row_back

    def insert_row(
        self, y: str | int, row: Row | None = None, clone: bool = True
    ) -&gt; Row:
        &#34;&#34;&#34;Insert the row before the given &#34;y&#34; position. If no row is given,
        an empty one is created.

        Position start at 0. So cell A4 is on row 3.

        If row is None, a new empty row is created.

        Arguments:

            y -- int or str

            row -- Row

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if row is None:
            row = Row()
            clone = False
        y = self._translate_y_from_any(y)
        diff = y - self.height
        if diff &lt; 0:
            row_back = _insert_item_in_vault(y, row, self, _xpath_row_idx, &#34;_tmap&#34;)
        elif diff == 0:
            row_back = self.append_row(row, clone=clone)
        else:
            self.append_row(Row(repeated=diff), _repeated=diff, clone=False)
            row_back = self.append_row(row, clone=clone)
        row_back.y = y  # type: ignore
        # Update width if necessary
        self._update_width(row_back)  # type: ignore
        return row_back  # type: ignore

    def extend_rows(self, rows: list[Row] | None = None) -&gt; None:
        &#34;&#34;&#34;Append a list of rows at the end of the table.

        Arguments:

            rows -- list of Row
        &#34;&#34;&#34;
        if rows is None:
            rows = []
        self.extend(rows)
        self._compute_table_cache()
        # Update width if necessary
        width = self.width
        for row in self.traverse():
            if row.width &gt; width:
                width = row.width
        diff = width - self.width
        if diff &gt; 0:
            self.append_column(Column(repeated=diff))

    def append_row(
        self,
        row: Row | None = None,
        clone: bool = True,
        _repeated: int | None = None,
    ) -&gt; Row:
        &#34;&#34;&#34;Append the row at the end of the table. If no row is given, an
        empty one is created.

        Position start at 0. So cell A4 is on row 3.

        Note the columns are automatically created when the first row is
        inserted in an empty table. So better insert a filled row.

        Arguments:

            row -- Row

            _repeated -- (optional), repeated value of the row

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if row is None:
            row = Row()
            _repeated = 1
        elif clone:
            row = row.clone
        # Appending a repeated row accepted
        # Do not insert next to the last row because it could be in a group
        self._append(row)
        if _repeated is None:
            _repeated = row.repeated or 1
        self._tmap = _insert_map_once(self._tmap, len(self._tmap), _repeated)
        row.y = self.height - 1
        # Initialize columns
        if not self._get_columns():
            repeated = row.width
            self.insert(Column(repeated=repeated), position=0)
            self._compute_table_cache()
        # Update width if necessary
        self._update_width(row)
        return row

    def delete_row(self, y: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the row at the given &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str
        &#34;&#34;&#34;
        y = self._translate_y_from_any(y)
        # Outside the defined table
        if y &gt;= self.height:
            return
        # Inside the defined table
        _delete_item_in_vault(y, self, _xpath_row_idx, &#34;_tmap&#34;)

    def get_row_values(
        self,
        y: int | str,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Shortcut to get the list of Python values for the cells of the row
        at the given &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type and complete is True, replace missing values by None.

        If get_type is True, returns a tuple (value, ODF type of value)

        Arguments:

            y -- int, str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of lists of Python types
        &#34;&#34;&#34;
        values = self.get_row(y, clone=False).get_values(
            cell_type=cell_type, complete=complete, get_type=get_type
        )
        # complete row to match column width
        if complete:
            if get_type:
                values.extend([(None, None)] * (self.width - len(values)))
            else:
                values.extend([None] * (self.width - len(values)))
        return values

    def set_row_values(
        self,
        y: int | str,
        values: list,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; Row:
        &#34;&#34;&#34;Shortcut to set the values of *all* cells of the row at the given
        &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str

            values -- list of Python types

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        returns the row, with updated row.y
        &#34;&#34;&#34;
        row = Row()  # needed if clones rows
        row.set_values(values, style=style, cell_type=cell_type, currency=currency)
        return self.set_row(y, row)  # needed if clones rows

    def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:
        &#34;&#34;&#34;Shortcut to set *all* the cells of the row at the given
        &#34;y&#34; position.

        Position start at 0. So cell A4 is on row 3.

        Arguments:

            y -- int or str

            cells -- list of Python types

            style -- str

        returns the row, with updated row.y
        &#34;&#34;&#34;
        if cells is None:
            cells = []
        row = Row()  # needed if clones rows
        row.extend_cells(cells)
        return self.set_row(y, row)  # needed if clones rows

    def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return wether every cell in the row at the given &#34;y&#34; position has
        no value or the value evaluates to False (empty string), and no style.

        Position start at 0. So cell A4 is on row 3.

        If aggressive is True, empty cells with style are considered empty.

        Arguments:

            y -- int or str

            aggressive -- bool
        &#34;&#34;&#34;
        return self.get_row(y, clone=False).is_empty(aggressive=aggressive)

    #
    # Cells
    #

    def get_cells(
        self,
        coord: tuple | list | str | None = None,
        cell_type: str | None = None,
        style: str | None = None,
        content: str | None = None,
        flat: bool = False,
    ) -&gt; list:
        &#34;&#34;&#34;Get the cells matching the criteria. If &#39;coord&#39; is None,
        parse the whole table, else parse the area defined by &#39;coord&#39;.

        Filter by  cell_type = &#34;all&#34;  will retrieve cells of any
        type, aka non empty cells.

        If flat is True (default is False), the method return a single list
        of all the values, else a list of lists of cells.

        if cell_type, style and content are None, get_cells() will return
        the exact number of cells of the area, including empty cells.

        Arguments:

            coordinates -- str or tuple of int : coordinates of area

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

            flat -- boolean

        Return: list of tuples
        &#34;&#34;&#34;
        if coord:
            x, y, z, t = self._translate_table_coordinates(coord)
        else:
            x = y = z = t = None
        if flat:
            cells: list[Cell] = []
            for row in self.traverse(start=y, end=t):
                row_cells = row.get_cells(
                    coord=(x, z),
                    cell_type=cell_type,
                    style=style,
                    content=content,
                )
                cells.extend(row_cells)
            return cells
        else:
            lcells: list[list[Cell]] = []
            for row in self.traverse(start=y, end=t):
                row_cells = row.get_cells(
                    coord=(x, z),
                    cell_type=cell_type,
                    style=style,
                    content=content,
                )
                lcells.append(row_cells)
            return lcells

    def get_cell(
        self,
        coord: tuple | list | str,
        clone: bool = True,
        keep_repeated: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Get the cell at the given coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        A copy is returned, use ``set_cell`` to push it back.

        Arguments:

            coord -- (int, int) or str

        Return: Cell
        &#34;&#34;&#34;
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        # Outside the defined table
        if y &gt;= self.height:
            cell = Cell()
        else:
            # Inside the defined table
            row = self._get_row2_base(y)
            if row is None:
                raise ValueError
            read_cell = row.get_cell(x, clone=clone)
            if read_cell is None:
                raise ValueError
            cell = read_cell
            if not keep_repeated:
                repeated = cell.repeated or 1
                if repeated &gt;= 2:
                    cell.repeated = None
        cell.x = x
        cell.y = y
        return cell

    def get_value(
        self,
        coord: tuple | list | str,
        get_type: bool = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Shortcut to get the Python value of the cell at the given
        coordinates.

        If get_type is True, returns the tuples (value, ODF type)

        coord is either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;. If an Area is given, the upper
        left position is used as coord.

        Arguments:

            coord -- (int, int) or str : coordinate

        Return: Python type
        &#34;&#34;&#34;
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        # Outside the defined table
        if y &gt;= self.height:
            if get_type:
                return (None, None)
            return None
        else:
            # Inside the defined table
            row = self._get_row2_base(y)
            if row is None:
                raise ValueError
            cell = row._get_cell2_base(x)
            if cell is None:
                if get_type:
                    return (None, None)
                return None
            return cell.get_value(get_type=get_type)

    def set_cell(
        self,
        coord: tuple | list | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Replace a cell of the table at the given coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Arguments:

            coord -- (int, int) or str : coordinate

            cell -- Cell

        return the cell, with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        cell.x = x
        cell.y = y
        if y &gt;= self.height:
            row = Row()
            cell_back = row.set_cell(x, cell, clone=clone)
            self.set_row(y, row, clone=False)
        else:
            row_read = self._get_row2_base(y)
            if row_read is None:
                raise ValueError
            row = row_read
            row.y = y
            repeated = row.repeated or 1
            if repeated &gt; 1:
                row = row.clone
                row.repeated = None
                cell_back = row.set_cell(x, cell, clone=clone)
                self.set_row(y, row, clone=False)
            else:
                cell_back = row.set_cell(x, cell, clone=clone)
                # Update width if necessary, since we don&#39;t use set_row
                self._update_width(row)
        return cell_back

    def set_cells(
        self,
        cells: list[list[Cell]] | list[tuple[Cell]],
        coord: tuple | list | str | None = None,
        clone: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Set the cells in the table, from the &#39;coord&#39; position.

        &#39;coord&#39; is the coordinate of the upper left cell to be modified by
        values. If &#39;coord&#39; is None, default to the position (0,0) (&#34;A1&#34;).
        If &#39;coord&#39; is an area (e.g. &#34;A2:B5&#34;), the upper left position of this
        area is used as coordinate.

        The table is *not* cleared before the operation, to reset the table
        before setting cells, use table.clear().

        A list of lists is expected, with as many lists as rows to be set, and
        as many cell in each sublist as cells to be setted in the row.

        Arguments:

            cells -- list of list of cells

            coord -- tuple or str

            values -- list of lists of python types
        &#34;&#34;&#34;
        if coord:
            x, y = self._translate_cell_coordinates(coord)
        else:
            x = y = 0
        if y is None:
            y = 0
        if x is None:
            x = 0
        y -= 1
        for row_cells in cells:
            y += 1
            if not row_cells:
                continue
            row = self.get_row(y, clone=True)
            repeated = row.repeated or 1
            if repeated &gt;= 2:
                row.repeated = None
            row.set_cells(row_cells, start=x, clone=clone)
            self.set_row(y, row, clone=False)
            self._update_width(row)

    def set_value(
        self,
        coord: tuple | list | str,
        value: Any,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Set the Python value of the cell at the given coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Arguments:

            coord -- (int, int) or str

            value -- Python type

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str

        &#34;&#34;&#34;
        self.set_cell(
            coord,
            Cell(value, cell_type=cell_type, currency=currency, style=style),
            clone=False,
        )

    def set_cell_image(
        self,
        coord: tuple | list | str,
        image_frame: Frame,
        doc_type: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Do all the magic to display an image in the cell at the given
        coordinates.

        They are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        The frame element must contain the expected image position and
        dimensions.

        DrawImage insertion depends on the document type, so the type must be
        provided or the table element must be already attached to a document.

        Arguments:

            coord -- (int, int) or str

            image_frame -- Frame including an image

            doc_type -- &#39;spreadsheet&#39; or &#39;text&#39;
        &#34;&#34;&#34;
        # Test document type
        if doc_type is None:
            body = self.document_body
            if body is None:
                raise ValueError(&#34;document type not found&#34;)
            doc_type = {&#34;office:spreadsheet&#34;: &#34;spreadsheet&#34;, &#34;office:text&#34;: &#34;text&#34;}.get(
                body.tag
            )
            if doc_type is None:
                raise ValueError(&#34;document type not supported for images&#34;)
        # We need the end address of the image
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        cell = self.get_cell((x, y))
        image_frame = image_frame.clone  # type: ignore
        # Remove any previous paragraph, frame, etc.
        for child in cell.children:
            cell.delete(child)
        # Now it all depends on the document type
        if doc_type == &#34;spreadsheet&#34;:
            image_frame.anchor_type = &#34;char&#34;
            # The frame needs end coordinates
            width, height = image_frame.size
            image_frame.set_attribute(&#34;table:end-x&#34;, width)
            image_frame.set_attribute(&#34;table:end-y&#34;, height)
            # FIXME what happens when the address changes?
            address = f&#34;{self.name}.{_digit_to_alpha(x)}{y + 1}&#34;
            image_frame.set_attribute(&#34;table:end-cell-address&#34;, address)
            # The frame is directly in the cell
            cell.append(image_frame)
        elif doc_type == &#34;text&#34;:
            # The frame must be in a paragraph
            cell.set_value(&#34;&#34;)
            paragraph = cell.get_element(&#34;text:p&#34;)
            if paragraph is None:
                raise ValueError
            paragraph.append(image_frame)
        self.set_cell(coord, cell)

    def insert_cell(
        self,
        coord: tuple | list | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Insert the given cell at the given coordinates. If no cell is
        given, an empty one is created.

        Coordinates are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Cells on the right are shifted. Other rows remain untouched.

        Arguments:

            coord -- (int, int) or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        row = self._get_row2(y, clone=True)
        row.y = y
        row.repeated = None
        cell_back = row.insert_cell(x, cell, clone=False)
        self.set_row(y, row, clone=False)
        # Update width if necessary
        self._update_width(row)
        return cell_back

    def append_cell(
        self,
        y: int | str,
        cell: Cell | None = None,
        clone: bool = True,
    ) -&gt; Cell:
        &#34;&#34;&#34;Append the given cell at the &#34;y&#34; coordinate. Repeated cells are
        accepted. If no cell is given, an empty one is created.

        Position start at 0. So cell A4 is on row 3.

        Other rows remain untouched.

        Arguments:

            y -- int or str

            cell -- Cell

        returns the cell with x and y updated
        &#34;&#34;&#34;
        if cell is None:
            cell = Cell()
            clone = False
        if clone:
            cell = cell.clone
        y = self._translate_y_from_any(y)
        row = self._get_row2(y)
        row.y = y
        cell_back = row.append_cell(cell, clone=False)
        self.set_row(y, row)
        # Update width if necessary
        self._update_width(row)
        return cell_back

    def delete_cell(self, coord: tuple | list | str) -&gt; None:
        &#34;&#34;&#34;Delete the cell at the given coordinates, so that next cells are
        shifted to the left.

        Coordinates are either a 2-uplet of (x, y) starting from 0, or a
        human-readable position like &#34;C4&#34;.

        Use set_value() for erasing value.

        Arguments:

            coord -- (int, int) or str
        &#34;&#34;&#34;
        x, y = self._translate_cell_coordinates(coord)
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        # Outside the defined table
        if y &gt;= self.height:
            return
        # Inside the defined table
        row = self._get_row2_base(y)
        if row is None:
            raise ValueError
        row.delete_cell(x)
        # self.set_row(y, row)

    # Columns

    def _get_columns(self) -&gt; list:
        return self.get_elements(_xpath_column)

    def traverse_columns(  # noqa: C901
        self,
        start: int | None = None,
        end: int | None = None,
    ) -&gt; Iterator[Column]:
        &#34;&#34;&#34;Yield as many column elements as expected columns in the table,
        i.e. expand repetitions by returning the same column as many times as
        necessary.

            Arguments:

                start -- int

                end -- int

        Copies are returned, use set_column() to push them back.
        &#34;&#34;&#34;
        idx = -1
        before = -1
        x = 0
        if start is None and end is None:
            for juska in self._cmap:
                idx += 1
                if idx in self._indexes[&#34;_cmap&#34;]:
                    column = self._indexes[&#34;_cmap&#34;][idx]
                else:
                    column = self._get_element_idx2(_xpath_column_idx, idx)
                    self._indexes[&#34;_cmap&#34;][idx] = column
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    # Return a copy without the now obsolete repetition
                    column = column.clone
                    column.x = x
                    x += 1
                    if repeated &gt; 1:
                        column.repeated = None
                    yield column
        else:
            if start is None:
                start = 0
            start = max(0, start)
            if end is None:
                try:
                    end = self._cmap[-1]
                except Exception:
                    end = -1
            start_map = _find_odf_idx(self._cmap, start)
            if start_map is None:
                return
            if start_map &gt; 0:
                before = self._cmap[start_map - 1]
            idx = start_map - 1
            before = start - 1
            x = start
            for juska in self._cmap[start_map:]:
                idx += 1
                if idx in self._indexes[&#34;_cmap&#34;]:
                    column = self._indexes[&#34;_cmap&#34;][idx]
                else:
                    column = self._get_element_idx2(_xpath_column_idx, idx)
                    self._indexes[&#34;_cmap&#34;][idx] = column
                repeated = juska - before
                before = juska
                for _i in range(repeated or 1):
                    if x &lt;= end:
                        column = column.clone
                        column.x = x
                        x += 1
                        if repeated &gt; 1 or (x == start and start &gt; 0):
                            column.repeated = None
                        yield column

    def get_columns(
        self,
        coord: tuple | list | str | None = None,
        style: str | None = None,
    ) -&gt; list[Column]:
        &#34;&#34;&#34;Get the list of columns matching the criteria. Each result is a
        tuple of (x, column).

        Arguments:

            coord -- str or tuple of int : coordinates of columns

            style -- str

        Return: list of columns
        &#34;&#34;&#34;
        if coord:
            x, _y, _z, t = self._translate_column_coordinates(coord)
        else:
            x = t = None
        if not style:
            return list(self.traverse_columns(start=x, end=t))
        columns = []
        for column in self.traverse_columns(start=x, end=t):
            if style != column.style:
                continue
            columns.append(column)
        return columns

    def _get_column2(self, x: int) -&gt; Column | None:
        # Outside the defined table
        if x &gt;= self.width:
            return Column()
        # Inside the defined table
        odf_idx = _find_odf_idx(self._cmap, x)
        if odf_idx is not None:
            column = self._get_element_idx2(_xpath_column_idx, odf_idx)
            if column is None:
                return None
            # fixme : no clone here =&gt; change doc and unit tests
            return column.clone  # type: ignore
            # return row
        return None

    def get_column(self, x: int | str) -&gt; Column:
        &#34;&#34;&#34;Get the column at the given &#34;x&#34; position.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        A copy is returned, use set_column() to push it back.

        Arguments:

            x -- int or str

        Return: Column
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        column = self._get_column2(x)
        if column is None:
            raise ValueError
        column.x = x
        return column

    def set_column(
        self,
        x: int | str,
        column: Column | None = None,
    ) -&gt; Column:
        &#34;&#34;&#34;Replace the column at the given &#34;x&#34; position.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            x -- int or str

            column -- Column
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if column is None:
            column = Column()
            repeated = 1
        else:
            repeated = column.repeated or 1
        column.x = x
        # Outside the defined table ?
        diff = x - self.width
        if diff == 0:
            column_back = self.append_column(column, _repeated=repeated)
        elif diff &gt; 0:
            self.append_column(Column(repeated=diff), _repeated=diff)
            column_back = self.append_column(column, _repeated=repeated)
        else:
            # Inside the defined table
            column_back = _set_item_in_vault(  # type: ignore
                x, column, self, _xpath_column_idx, &#34;_cmap&#34;
            )
        return column_back

    def insert_column(
        self,
        x: int | str,
        column: Column | None = None,
    ) -&gt; Column:
        &#34;&#34;&#34;Insert the column before the given &#34;x&#34; position. If no column is
        given, an empty one is created.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            x -- int or str

            column -- Column
        &#34;&#34;&#34;
        if column is None:
            column = Column()
        x = self._translate_x_from_any(x)
        diff = x - self.width
        if diff &lt; 0:
            column_back = _insert_item_in_vault(
                x, column, self, _xpath_column_idx, &#34;_cmap&#34;
            )
        elif diff == 0:
            column_back = self.append_column(column.clone)
        else:
            self.append_column(Column(repeated=diff), _repeated=diff)
            column_back = self.append_column(column.clone)
        column_back.x = x  # type: ignore
        # Repetitions are accepted
        repeated = column.repeated or 1
        # Update width on every row
        for row in self._get_rows():
            if row.width &gt; x:
                row.insert_cell(x, Cell(repeated=repeated))
            # Shorter rows don&#39;t need insert
            # Longer rows shouldn&#39;t exist!
        return column_back  # type: ignore

    def append_column(
        self,
        column: Column | None = None,
        _repeated: int | None = None,
    ) -&gt; Column:
        &#34;&#34;&#34;Append the column at the end of the table. If no column is given,
        an empty one is created.

        ODF columns don&#39;t contain cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            column -- Column
        &#34;&#34;&#34;
        if column is None:
            column = Column()
        else:
            column = column.clone
        if not self._cmap:
            position = 0
        else:
            odf_idx = len(self._cmap) - 1
            last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)
            if last_column is None:
                raise ValueError
            position = self.index(last_column) + 1
        column.x = self.width
        self.insert(column, position=position)
        # Repetitions are accepted
        if _repeated is None:
            _repeated = column.repeated or 1
        self._cmap = _insert_map_once(self._cmap, len(self._cmap), _repeated)
        # No need to update row widths
        return column

    def delete_column(self, x: int | str) -&gt; None:
        &#34;&#34;&#34;Delete the column at the given position. ODF columns don&#39;t contain
        cells, only style information.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Arguments:

            x -- int or str
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        # Outside the defined table
        if x &gt;= self.width:
            return
        # Inside the defined table
        _delete_item_in_vault(x, self, _xpath_column_idx, &#34;_cmap&#34;)
        # Update width
        width = self.width
        for row in self._get_rows():
            if row.width &gt;= width:
                row.delete_cell(x)

    def get_column_cells(  # noqa: C901
        self,
        x: int | str,
        style: str | None = None,
        content: str | None = None,
        cell_type: str | None = None,
        complete: bool = False,
    ) -&gt; list[Cell | None]:
        &#34;&#34;&#34;Get the list of cells at the given position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.

        If complete is True, replace missing values by None.

        Arguments:

            x -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            content -- str regex

            style -- str

            complete -- boolean

        Return: list of Cell
        &#34;&#34;&#34;
        x = self._translate_x_from_any(x)
        if cell_type:
            cell_type = cell_type.lower().strip()
        cells: list[Cell | None] = []
        if not style and not content and not cell_type:
            for row in self.traverse():
                cells.append(row.get_cell(x, clone=True))
            return cells
        for row in self.traverse():
            cell = row.get_cell(x, clone=True)
            if cell is None:
                raise ValueError
            # Filter the cells by cell_type
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        cells.append(None)
                    continue
            # Filter the cells with the regex
            if content and not cell.match(content):
                if complete:
                    cells.append(None)
                continue
            # Filter the cells with the style
            if style and style != cell.style:
                if complete:
                    cells.append(None)
                continue
            cells.append(cell)
        return cells

    def get_column_values(
        self,
        x: int | str,
        cell_type: str | None = None,
        complete: bool = True,
        get_type: bool = False,
    ) -&gt; list[Any]:
        &#34;&#34;&#34;Shortcut to get the list of Python values for the cells at the
        given position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
        type, aka non empty cells.
        If cell_type and complete is True, replace missing values by None.

        If get_type is True, returns a tuple (value, ODF type of value)

        Arguments:

            x -- int or str

            cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                         &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

            complete -- boolean

            get_type -- boolean

        Return: list of Python types
        &#34;&#34;&#34;
        cells = self.get_column_cells(
            x, style=None, content=None, cell_type=cell_type, complete=complete
        )
        values: list[Any] = []
        for cell in cells:
            if cell is None:
                if complete:
                    if get_type:
                        values.append((None, None))
                    else:
                        values.append(None)
                continue
            if cell_type:
                ctype = cell.type
                if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                    if complete:
                        if get_type:
                            values.append((None, None))
                        else:
                            values.append(None)
                    continue
            values.append(cell.get_value(get_type=get_type))
        return values

    def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the list of cells at the given position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        The list must have the same length than the table height.

        Arguments:

            x -- int or str

            cells -- list of Cell
        &#34;&#34;&#34;
        height = self.height
        if len(cells) != height:
            raise ValueError(f&#34;col mismatch: {height} cells expected&#34;)
        cells_iterator = iter(cells)
        for y, row in enumerate(self.traverse()):
            row.set_cell(x, next(cells_iterator))
            self.set_row(y, row)

    def set_column_values(
        self,
        x: int | str,
        values: list,
        cell_type: str | None = None,
        currency: str | None = None,
        style: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Shortcut to set the list of Python values of cells at the given
        position.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        The list must have the same length than the table height.

        Arguments:

            x -- int or str

            values -- list of Python types

            cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                         &#39;string&#39; or &#39;time&#39;

            currency -- three-letter str

            style -- str
        &#34;&#34;&#34;
        cells = [
            Cell(value, cell_type=cell_type, currency=currency, style=style)
            for value in values
        ]
        self.set_column_cells(x, cells)

    def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:
        &#34;&#34;&#34;Return wether every cell in the column at &#34;x&#34; position has no value
        or the value evaluates to False (empty string), and no style.

        Position start at 0. So cell C4 is on column 2. Alphabetical position
        like &#34;C&#34; is accepted.

        If aggressive is True, empty cells with style are considered empty.

        Return: bool
        &#34;&#34;&#34;
        for cell in self.get_column_cells(x):
            if cell is None:
                continue
            if not cell.is_empty(aggressive=aggressive):
                return False
        return True

    # Named Range

    def get_named_ranges(  # type: ignore
        self,
        table_name: str | list[str] | None = None,
    ) -&gt; list[NamedRange]:
        &#34;&#34;&#34;Returns the list of available Name Ranges of the spreadsheet. If
        table_name is provided, limits the search to these tables.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            table_names -- str or list of str, names of tables

        Return : list of table_range
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            return []
        all_named_ranges = body.get_named_ranges()
        if not table_name:
            return all_named_ranges  # type:ignore
        filter_ = []
        if isinstance(table_name, str):
            filter_.append(table_name)
        elif isiterable(table_name):
            filter_.extend(table_name)
        else:
            raise ValueError(
                f&#34;table_name must be string or Iterable, not {type(table_name)}&#34;
            )
        return [
            nr for nr in all_named_ranges if nr.table_name in filter_  # type:ignore
        ]

    def get_named_range(self, name: str) -&gt; NamedRange:
        &#34;&#34;&#34;Returns the Name Ranges of the specified name. If
        table_name is provided, limits the search to these tables.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            name -- str, name of the named range object

        Return : NamedRange
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document&#34;)
        return body.get_named_range(name)  # type: ignore

    def set_named_range(
        self,
        name: str,
        crange: str | tuple | list,
        table_name: str | None = None,
        usage: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Create a Named Range element and insert it in the document.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            name -- str, name of the named range

            crange -- str or tuple of int, cell or area coordinate

            table_name -- str, name of the table

            uage -- None or &#39;print-range&#39;, &#39;filter&#39;, &#39;repeat-column&#39;, &#39;repeat-row&#39;
        &#34;&#34;&#34;
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document&#34;)
        if not name:
            raise ValueError(&#34;Name required.&#34;)
        if table_name is None:
            table_name = self.name
        named_range = NamedRange(name, crange, table_name, usage)
        body.append_named_range(named_range)

    def delete_named_range(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete the Named Range of specified name from the spreadsheet.
        Beware : named ranges are stored at the body level, thus do not call
        this method on a cloned table.

        Arguments:

            name -- str
        &#34;&#34;&#34;
        name = name.strip()
        if not name:
            raise ValueError(&#34;Name required.&#34;)
        body = self.document_body
        if not body:
            raise ValueError(&#34;Table is not inside a document.&#34;)
        body.delete_named_range(name)

    #
    # Cell span
    #

    def set_span(  # noqa: C901
        self,
        area: str | tuple | list,
        merge: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;Create a Cell Span : span the first cell of the area on several
        columns and/or rows.
        If merge is True, replace text of the cell by the concatenation of
        existing text in covered cells.
        Beware : if merge is True, old text is changed, if merge is False
        (the default), old text in coverd cells is still present but not
        displayed by most GUI.

        If the area defines only one cell, the set span will do nothing.
        It is not allowed to apply set span to an area whose one cell already
        belongs to previous cell span.

        Area can be either one cell (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can
        be provided as an alpha numeric value like &#34;A1:B2&#39; or a tuple like
        (0, 0, 1, 1) or (0, 0).

        Arguments:

            area -- str or tuple of int, cell or area coordinate

            merge -- boolean
        &#34;&#34;&#34;
        # get area
        digits = _convert_coordinates(area)
        if len(digits) == 4:
            x, y, z, t = digits
        else:
            x, y = digits
            z, t = digits
        start = x, y
        end = z, t
        if start == end:
            # one cell : do nothing
            return False
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        if z is None:
            raise ValueError
        if t is None:
            raise ValueError
        # check for previous span
        good = True
        # Check boundaries and empty cells : need to crate non existent cells
        # so don&#39;t use get_cells directly, but get_cell
        cells = []
        for yy in range(y, t + 1):
            row_cells = []
            for xx in range(x, z + 1):
                row_cells.append(
                    self.get_cell((xx, yy), clone=True, keep_repeated=False)
                )
            cells.append(row_cells)
        for row in cells:
            for cell in row:
                if cell._is_spanned():
                    good = False
                    break
            if not good:
                break
        if not good:
            return False
        # Check boundaries
        # if z &gt;= self.width or t &gt;= self.height:
        #    self.set_cell(coord = end)
        #    print area, z, t
        #    cells = self.get_cells((x, y, z, t))
        #    print cells
        # do it:
        if merge:
            val_list = []
            for row in cells:
                for cell in row:
                    if cell.is_empty(aggressive=True):
                        continue
                    val = cell.get_value()
                    if val is not None:
                        if isinstance(val, str):
                            val.strip()
                        if val != &#34;&#34;:
                            val_list.append(val)
                        cell.clear()
            if val_list:
                if len(val_list) == 1:
                    cells[0][0].set_value(val_list[0])
                else:
                    value = &#34; &#34;.join([str(v) for v in val_list if v])
                    cells[0][0].set_value(value)
        cols = z - x + 1
        cells[0][0].set_attribute(&#34;table:number-columns-spanned&#34;, str(cols))
        rows = t - y + 1
        cells[0][0].set_attribute(&#34;table:number-rows-spanned&#34;, str(rows))
        for cell in cells[0][1:]:
            cell.tag = &#34;table:covered-table-cell&#34;
        for row in cells[1:]:
            for cell in row:
                cell.tag = &#34;table:covered-table-cell&#34;
        # replace cells in table
        self.set_cells(cells, coord=start, clone=False)
        return True

    def del_span(self, area: str | tuple | list) -&gt; bool:
        &#34;&#34;&#34;Delete a Cell Span. &#39;area&#39; is the cell coordiante of the upper left
        cell of the spanned area.

        Area can be either one cell (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can
        be provided as an alpha numeric value like &#34;A1:B2&#39; or a tuple like
        (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell
        is used.

        Arguments:

            area -- str or tuple of int, cell or area coordinate
        &#34;&#34;&#34;
        # get area
        digits = _convert_coordinates(area)
        if len(digits) == 4:
            x, y, _z, _t = digits
        else:
            x, y = digits
        if x is None:
            raise ValueError
        if y is None:
            raise ValueError
        start = x, y
        # check for previous span
        cell0 = self.get_cell(start)
        nb_cols = cell0.get_attribute_integer(&#34;table:number-columns-spanned&#34;)
        if nb_cols is None:
            return False
        nb_rows = cell0.get_attribute_integer(&#34;table:number-rows-spanned&#34;)
        if nb_rows is None:
            return False
        z = x + nb_cols - 1
        t = y + nb_rows - 1
        cells = self.get_cells((x, y, z, t))
        cells[0][0].del_attribute(&#34;table:number-columns-spanned&#34;)
        cells[0][0].del_attribute(&#34;table:number-rows-spanned&#34;)
        for cell in cells[0][1:]:
            cell.tag = &#34;table:table-cell&#34;
        for row in cells[1:]:
            for cell in row:
                cell.tag = &#34;table:table-cell&#34;
        # replace cells in table
        self.set_cells(cells, coord=start, clone=False)
        return True

    # Utilities

    def to_csv(
        self,
        path_or_file: str | Path | None = None,
        dialect: str = &#34;excel&#34;,
    ) -&gt; Any:
        &#34;&#34;&#34;Write the table as CSV in the file.

        If the file is a string, it is opened as a local path. Else an
        opened file-like is expected.

        Arguments:

            path_or_file -- str or file-like

            dialect -- str, python csv.dialect, can be &#39;excel&#39;, &#39;unix&#39;...
        &#34;&#34;&#34;

        def write_content(csv_writer: object) -&gt; None:
            for values in self.iter_values():
                line = []
                for value in values:
                    if value is None:
                        value = &#34;&#34;
                    if isinstance(value, str):
                        value = value.strip()
                    line.append(value)
                csv_writer.writerow(line)  # type: ignore

        out = StringIO(newline=&#34;&#34;)
        csv_writer = csv.writer(out, dialect=dialect)
        write_content(csv_writer)
        if path_or_file is None:
            return out.getvalue()
        path = Path(path_or_file)
        path.write_text(out.getvalue())
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="odfdo.table.Table.displayed"><code class="name">var <span class="ident">displayed</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def displayed(self) -&gt; bool:
    return bool(self.get_attribute(&#34;table:display&#34;))</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the current height of the table.</p>
<p>Return: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self) -&gt; int:
    &#34;&#34;&#34;Get the current height of the table.

    Return: int
    &#34;&#34;&#34;
    try:
        height = self._tmap[-1] + 1
    except Exception:
        height = 0
    return height</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.name"><code class="name">var <span class="ident">name</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the name of the table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the name of the table.&#34;&#34;&#34;
    return self.get_attribute_string(&#34;table:name&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.print_ranges"><code class="name">var <span class="ident">print_ranges</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def print_ranges(self) -&gt; list[str]:
    ranges = self.get_attribute_string(&#34;table:print-ranges&#34;)
    if isinstance(ranges, str):
        return ranges.split()
    return []</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.printable"><code class="name">var <span class="ident">printable</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def printable(self) -&gt; bool:
    printable = self.get_attribute(&#34;table:print&#34;)
    # Default value
    if printable is None:
        return True
    return bool(printable)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.protected"><code class="name">var <span class="ident">protected</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def protected(self) -&gt; bool:
    return bool(self.get_attribute(&#34;table:protected&#34;))</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.protection_key"><code class="name">var <span class="ident">protection_key</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def protection_key(self) -&gt; str | None:
    return self.get_attribute_string(&#34;table:protection-key&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.size"><code class="name">var <span class="ident">size</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the current width and height of the table.</p>
<p>Return: (int, int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Shortcut to get the current width and height of the table.

    Return: (int, int)
    &#34;&#34;&#34;
    return self.width, self.height</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.style"><code class="name">var <span class="ident">style</span> : str | None</code></dt>
<dd>
<div class="desc"><p>Get / set the style of the table</p>
<p>Return: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def style(self) -&gt; str | None:
    &#34;&#34;&#34;Get / set the style of the table

    Return: str
    &#34;&#34;&#34;
    return self.get_attribute_string(&#34;table:style-name&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the current width of the table, measured on columns.</p>
<p>Rows may have different widths, use the Table API to ensure width
consistency.</p>
<p>Return: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;Get the current width of the table, measured on columns.

    Rows may have different widths, use the Table API to ensure width
    consistency.

    Return: int
    &#34;&#34;&#34;
    # Columns are our reference for user expected width

    try:
        width = self._cmap[-1] + 1
    except Exception:
        width = 0

    # columns = self._get_columns()
    # repeated = self.xpath(
    #        &#39;table:table-column/@table:number-columns-repeated&#39;)
    # unrepeated = len(columns) - len(repeated)
    # ws = sum(int(r) for r in repeated) + unrepeated
    # if w != ws:
    #    print &#34;WARNING   ws&#34;, ws, &#34;w&#34;, w

    return width</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="odfdo.table.Table.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, something: Element | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dispatch .append() call to append_row() or append_column().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, something: Element | str) -&gt; None:
    &#34;&#34;&#34;Dispatch .append() call to append_row() or append_column().&#34;&#34;&#34;
    if isinstance(something, Row):
        self.append_row(something)
    elif isinstance(something, Column):
        self.append_column(something)
    else:
        # probably still an error
        self._append(something)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.append_cell"><code class="name flex">
<span>def <span class="ident">append_cell</span></span>(<span>self, y: int | str, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the given cell at the "y" coordinate. Repeated cells are
accepted. If no cell is given, an empty one is created.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<p>Other rows remain untouched.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>cell &ndash; Cell</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_cell(
    self,
    y: int | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Append the given cell at the &#34;y&#34; coordinate. Repeated cells are
    accepted. If no cell is given, an empty one is created.

    Position start at 0. So cell A4 is on row 3.

    Other rows remain untouched.

    Arguments:

        y -- int or str

        cell -- Cell

    returns the cell with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    if clone:
        cell = cell.clone
    y = self._translate_y_from_any(y)
    row = self._get_row2(y)
    row.y = y
    cell_back = row.append_cell(cell, clone=False)
    self.set_row(y, row)
    # Update width if necessary
    self._update_width(row)
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.append_column"><code class="name flex">
<span>def <span class="ident">append_column</span></span>(<span>self, column: <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a> | None = None) ‑> <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the column at the end of the table. If no column is given,
an empty one is created.</p>
<p>ODF columns don't contain cells, only style information.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<h2 id="arguments">Arguments</h2>
<p>column &ndash; Column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_column(
    self,
    column: Column | None = None,
    _repeated: int | None = None,
) -&gt; Column:
    &#34;&#34;&#34;Append the column at the end of the table. If no column is given,
    an empty one is created.

    ODF columns don&#39;t contain cells, only style information.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    Arguments:

        column -- Column
    &#34;&#34;&#34;
    if column is None:
        column = Column()
    else:
        column = column.clone
    if not self._cmap:
        position = 0
    else:
        odf_idx = len(self._cmap) - 1
        last_column = self._get_element_idx2(_xpath_column_idx, odf_idx)
        if last_column is None:
            raise ValueError
        position = self.index(last_column) + 1
    column.x = self.width
    self.insert(column, position=position)
    # Repetitions are accepted
    if _repeated is None:
        _repeated = column.repeated or 1
    self._cmap = _insert_map_once(self._cmap, len(self._cmap), _repeated)
    # No need to update row widths
    return column</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.append_row"><code class="name flex">
<span>def <span class="ident">append_row</span></span>(<span>self, row: <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append the row at the end of the table. If no row is given, an
empty one is created.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<p>Note the columns are automatically created when the first row is
inserted in an empty table. So better insert a filled row.</p>
<h2 id="arguments">Arguments</h2>
<p>row &ndash; Row</p>
<p>_repeated &ndash; (optional), repeated value of the row</p>
<p>returns the row, with updated row.y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_row(
    self,
    row: Row | None = None,
    clone: bool = True,
    _repeated: int | None = None,
) -&gt; Row:
    &#34;&#34;&#34;Append the row at the end of the table. If no row is given, an
    empty one is created.

    Position start at 0. So cell A4 is on row 3.

    Note the columns are automatically created when the first row is
    inserted in an empty table. So better insert a filled row.

    Arguments:

        row -- Row

        _repeated -- (optional), repeated value of the row

    returns the row, with updated row.y
    &#34;&#34;&#34;
    if row is None:
        row = Row()
        _repeated = 1
    elif clone:
        row = row.clone
    # Appending a repeated row accepted
    # Do not insert next to the last row because it could be in a group
    self._append(row)
    if _repeated is None:
        _repeated = row.repeated or 1
    self._tmap = _insert_map_once(self._tmap, len(self._tmap), _repeated)
    row.y = self.height - 1
    # Initialize columns
    if not self._get_columns():
        repeated = row.width
        self.insert(Column(repeated=repeated), position=0)
        self._compute_table_cache()
    # Update width if necessary
    self._update_width(row)
    return row</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.del_span"><code class="name flex">
<span>def <span class="ident">del_span</span></span>(<span>self, area: str | tuple | list) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a Cell Span. 'area' is the cell coordiante of the upper left
cell of the spanned area.</p>
<p>Area can be either one cell (like 'A1') or an area ('A1:B2'). It can
be provided as an alpha numeric value like "A1:B2' or a tuple like
(0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell
is used.</p>
<h2 id="arguments">Arguments</h2>
<p>area &ndash; str or tuple of int, cell or area coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_span(self, area: str | tuple | list) -&gt; bool:
    &#34;&#34;&#34;Delete a Cell Span. &#39;area&#39; is the cell coordiante of the upper left
    cell of the spanned area.

    Area can be either one cell (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can
    be provided as an alpha numeric value like &#34;A1:B2&#39; or a tuple like
    (0, 0, 1, 1) or (0, 0). If an area is provided, the upper left cell
    is used.

    Arguments:

        area -- str or tuple of int, cell or area coordinate
    &#34;&#34;&#34;
    # get area
    digits = _convert_coordinates(area)
    if len(digits) == 4:
        x, y, _z, _t = digits
    else:
        x, y = digits
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    start = x, y
    # check for previous span
    cell0 = self.get_cell(start)
    nb_cols = cell0.get_attribute_integer(&#34;table:number-columns-spanned&#34;)
    if nb_cols is None:
        return False
    nb_rows = cell0.get_attribute_integer(&#34;table:number-rows-spanned&#34;)
    if nb_rows is None:
        return False
    z = x + nb_cols - 1
    t = y + nb_rows - 1
    cells = self.get_cells((x, y, z, t))
    cells[0][0].del_attribute(&#34;table:number-columns-spanned&#34;)
    cells[0][0].del_attribute(&#34;table:number-rows-spanned&#34;)
    for cell in cells[0][1:]:
        cell.tag = &#34;table:table-cell&#34;
    for row in cells[1:]:
        for cell in row:
            cell.tag = &#34;table:table-cell&#34;
    # replace cells in table
    self.set_cells(cells, coord=start, clone=False)
    return True</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.delete_cell"><code class="name flex">
<span>def <span class="ident">delete_cell</span></span>(<span>self, coord: tuple | list | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the cell at the given coordinates, so that next cells are
shifted to the left.</p>
<p>Coordinates are either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4".</p>
<p>Use set_value() for erasing value.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_cell(self, coord: tuple | list | str) -&gt; None:
    &#34;&#34;&#34;Delete the cell at the given coordinates, so that next cells are
    shifted to the left.

    Coordinates are either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;.

    Use set_value() for erasing value.

    Arguments:

        coord -- (int, int) or str
    &#34;&#34;&#34;
    x, y = self._translate_cell_coordinates(coord)
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    # Outside the defined table
    if y &gt;= self.height:
        return
    # Inside the defined table
    row = self._get_row2_base(y)
    if row is None:
        raise ValueError
    row.delete_cell(x)
    # self.set_row(y, row)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.delete_column"><code class="name flex">
<span>def <span class="ident">delete_column</span></span>(<span>self, x: int | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the column at the given position. ODF columns don't contain
cells, only style information.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_column(self, x: int | str) -&gt; None:
    &#34;&#34;&#34;Delete the column at the given position. ODF columns don&#39;t contain
    cells, only style information.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    Arguments:

        x -- int or str
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    # Outside the defined table
    if x &gt;= self.width:
        return
    # Inside the defined table
    _delete_item_in_vault(x, self, _xpath_column_idx, &#34;_cmap&#34;)
    # Update width
    width = self.width
    for row in self._get_rows():
        if row.width &gt;= width:
            row.delete_cell(x)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.delete_named_range"><code class="name flex">
<span>def <span class="ident">delete_named_range</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the Named Range of specified name from the spreadsheet.
Beware : named ranges are stored at the body level, thus do not call
this method on a cloned table.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_named_range(self, name: str) -&gt; None:
    &#34;&#34;&#34;Delete the Named Range of specified name from the spreadsheet.
    Beware : named ranges are stored at the body level, thus do not call
    this method on a cloned table.

    Arguments:

        name -- str
    &#34;&#34;&#34;
    name = name.strip()
    if not name:
        raise ValueError(&#34;Name required.&#34;)
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document.&#34;)
    body.delete_named_range(name)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.delete_row"><code class="name flex">
<span>def <span class="ident">delete_row</span></span>(<span>self, y: int | str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the row at the given "y" position.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_row(self, y: int | str) -&gt; None:
    &#34;&#34;&#34;Delete the row at the given &#34;y&#34; position.

    Position start at 0. So cell A4 is on row 3.

    Arguments:

        y -- int or str
    &#34;&#34;&#34;
    y = self._translate_y_from_any(y)
    # Outside the defined table
    if y &gt;= self.height:
        return
    # Inside the defined table
    _delete_item_in_vault(y, self, _xpath_row_idx, &#34;_tmap&#34;)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.extend_rows"><code class="name flex">
<span>def <span class="ident">extend_rows</span></span>(<span>self, rows: list[<a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a>] | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Append a list of rows at the end of the table.</p>
<h2 id="arguments">Arguments</h2>
<p>rows &ndash; list of Row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_rows(self, rows: list[Row] | None = None) -&gt; None:
    &#34;&#34;&#34;Append a list of rows at the end of the table.

    Arguments:

        rows -- list of Row
    &#34;&#34;&#34;
    if rows is None:
        rows = []
    self.extend(rows)
    self._compute_table_cache()
    # Update width if necessary
    width = self.width
    for row in self.traverse():
        if row.width &gt; width:
            width = row.width
    diff = width - self.width
    if diff &gt; 0:
        self.append_column(Column(repeated=diff))</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_cell"><code class="name flex">
<span>def <span class="ident">get_cell</span></span>(<span>self, coord: tuple | list | str, clone: bool = True, keep_repeated: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the cell at the given coordinates.</p>
<p>They are either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4".</p>
<p>A copy is returned, use <code>set_cell</code> to push it back.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str</p>
<p>Return: Cell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell(
    self,
    coord: tuple | list | str,
    clone: bool = True,
    keep_repeated: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Get the cell at the given coordinates.

    They are either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;.

    A copy is returned, use ``set_cell`` to push it back.

    Arguments:

        coord -- (int, int) or str

    Return: Cell
    &#34;&#34;&#34;
    x, y = self._translate_cell_coordinates(coord)
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    # Outside the defined table
    if y &gt;= self.height:
        cell = Cell()
    else:
        # Inside the defined table
        row = self._get_row2_base(y)
        if row is None:
            raise ValueError
        read_cell = row.get_cell(x, clone=clone)
        if read_cell is None:
            raise ValueError
        cell = read_cell
        if not keep_repeated:
            repeated = cell.repeated or 1
            if repeated &gt;= 2:
                cell.repeated = None
    cell.x = x
    cell.y = y
    return cell</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_cells"><code class="name flex">
<span>def <span class="ident">get_cells</span></span>(<span>self, coord: tuple | list | str | None = None, cell_type: str | None = None, style: str | None = None, content: str | None = None, flat: bool = False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Get the cells matching the criteria. If 'coord' is None,
parse the whole table, else parse the area defined by 'coord'.</p>
<p>Filter by
cell_type = "all"
will retrieve cells of any
type, aka non empty cells.</p>
<p>If flat is True (default is False), the method return a single list
of all the values, else a list of lists of cells.</p>
<p>if cell_type, style and content are None, get_cells() will return
the exact number of cells of the area, including empty cells.</p>
<h2 id="arguments">Arguments</h2>
<p>coordinates &ndash; str or tuple of int : coordinates of area</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>content &ndash; str regex</p>
<p>style &ndash; str</p>
<p>flat &ndash; boolean</p>
<p>Return: list of tuples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells(
    self,
    coord: tuple | list | str | None = None,
    cell_type: str | None = None,
    style: str | None = None,
    content: str | None = None,
    flat: bool = False,
) -&gt; list:
    &#34;&#34;&#34;Get the cells matching the criteria. If &#39;coord&#39; is None,
    parse the whole table, else parse the area defined by &#39;coord&#39;.

    Filter by  cell_type = &#34;all&#34;  will retrieve cells of any
    type, aka non empty cells.

    If flat is True (default is False), the method return a single list
    of all the values, else a list of lists of cells.

    if cell_type, style and content are None, get_cells() will return
    the exact number of cells of the area, including empty cells.

    Arguments:

        coordinates -- str or tuple of int : coordinates of area

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        content -- str regex

        style -- str

        flat -- boolean

    Return: list of tuples
    &#34;&#34;&#34;
    if coord:
        x, y, z, t = self._translate_table_coordinates(coord)
    else:
        x = y = z = t = None
    if flat:
        cells: list[Cell] = []
        for row in self.traverse(start=y, end=t):
            row_cells = row.get_cells(
                coord=(x, z),
                cell_type=cell_type,
                style=style,
                content=content,
            )
            cells.extend(row_cells)
        return cells
    else:
        lcells: list[list[Cell]] = []
        for row in self.traverse(start=y, end=t):
            row_cells = row.get_cells(
                coord=(x, z),
                cell_type=cell_type,
                style=style,
                content=content,
            )
            lcells.append(row_cells)
        return lcells</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_column"><code class="name flex">
<span>def <span class="ident">get_column</span></span>(<span>self, x: int | str) ‑> <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the column at the given "x" position.</p>
<p>ODF columns don't contain cells, only style information.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<p>A copy is returned, use set_column() to push it back.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>Return: Column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column(self, x: int | str) -&gt; Column:
    &#34;&#34;&#34;Get the column at the given &#34;x&#34; position.

    ODF columns don&#39;t contain cells, only style information.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    A copy is returned, use set_column() to push it back.

    Arguments:

        x -- int or str

    Return: Column
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    column = self._get_column2(x)
    if column is None:
        raise ValueError
    column.x = x
    return column</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_column_cells"><code class="name flex">
<span>def <span class="ident">get_column_cells</span></span>(<span>self, x: int | str, style: str | None = None, content: str | None = None, cell_type: str | None = None, complete: bool = False) ‑> list[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of cells at the given position.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.</p>
<p>If complete is True, replace missing values by None.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>content &ndash; str regex</p>
<p>style &ndash; str</p>
<p>complete &ndash; boolean</p>
<p>Return: list of Cell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_cells(  # noqa: C901
    self,
    x: int | str,
    style: str | None = None,
    content: str | None = None,
    cell_type: str | None = None,
    complete: bool = False,
) -&gt; list[Cell | None]:
    &#34;&#34;&#34;Get the list of cells at the given position.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.

    If complete is True, replace missing values by None.

    Arguments:

        x -- int or str

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        content -- str regex

        style -- str

        complete -- boolean

    Return: list of Cell
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    if cell_type:
        cell_type = cell_type.lower().strip()
    cells: list[Cell | None] = []
    if not style and not content and not cell_type:
        for row in self.traverse():
            cells.append(row.get_cell(x, clone=True))
        return cells
    for row in self.traverse():
        cell = row.get_cell(x, clone=True)
        if cell is None:
            raise ValueError
        # Filter the cells by cell_type
        if cell_type:
            ctype = cell.type
            if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                if complete:
                    cells.append(None)
                continue
        # Filter the cells with the regex
        if content and not cell.match(content):
            if complete:
                cells.append(None)
            continue
        # Filter the cells with the style
        if style and style != cell.style:
            if complete:
                cells.append(None)
            continue
        cells.append(cell)
    return cells</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_column_values"><code class="name flex">
<span>def <span class="ident">get_column_values</span></span>(<span>self, x: int | str, cell_type: str | None = None, complete: bool = True, get_type: bool = False) ‑> list[typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the list of Python values for the cells at the
given position.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.
If cell_type and complete is True, replace missing values by None.</p>
<p>If get_type is True, returns a tuple (value, ODF type of value)</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>complete &ndash; boolean</p>
<p>get_type &ndash; boolean</p>
<p>Return: list of Python types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_values(
    self,
    x: int | str,
    cell_type: str | None = None,
    complete: bool = True,
    get_type: bool = False,
) -&gt; list[Any]:
    &#34;&#34;&#34;Shortcut to get the list of Python values for the cells at the
    given position.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.
    If cell_type and complete is True, replace missing values by None.

    If get_type is True, returns a tuple (value, ODF type of value)

    Arguments:

        x -- int or str

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        complete -- boolean

        get_type -- boolean

    Return: list of Python types
    &#34;&#34;&#34;
    cells = self.get_column_cells(
        x, style=None, content=None, cell_type=cell_type, complete=complete
    )
    values: list[Any] = []
    for cell in cells:
        if cell is None:
            if complete:
                if get_type:
                    values.append((None, None))
                else:
                    values.append(None)
            continue
        if cell_type:
            ctype = cell.type
            if not ctype or not (ctype == cell_type or cell_type == &#34;all&#34;):
                if complete:
                    if get_type:
                        values.append((None, None))
                    else:
                        values.append(None)
                continue
        values.append(cell.get_value(get_type=get_type))
    return values</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_columns"><code class="name flex">
<span>def <span class="ident">get_columns</span></span>(<span>self, coord: tuple | list | str | None = None, style: str | None = None) ‑> list[<a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of columns matching the criteria. Each result is a
tuple of (x, column).</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates of columns</p>
<p>style &ndash; str</p>
<p>Return: list of columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_columns(
    self,
    coord: tuple | list | str | None = None,
    style: str | None = None,
) -&gt; list[Column]:
    &#34;&#34;&#34;Get the list of columns matching the criteria. Each result is a
    tuple of (x, column).

    Arguments:

        coord -- str or tuple of int : coordinates of columns

        style -- str

    Return: list of columns
    &#34;&#34;&#34;
    if coord:
        x, _y, _z, t = self._translate_column_coordinates(coord)
    else:
        x = t = None
    if not style:
        return list(self.traverse_columns(start=x, end=t))
    columns = []
    for column in self.traverse_columns(start=x, end=t):
        if style != column.style:
            continue
        columns.append(column)
    return columns</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_named_range"><code class="name flex">
<span>def <span class="ident">get_named_range</span></span>(<span>self, name: str) ‑> <a title="odfdo.table.NamedRange" href="#odfdo.table.NamedRange">NamedRange</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Name Ranges of the specified name. If
table_name is provided, limits the search to these tables.
Beware : named ranges are stored at the body level, thus do not call
this method on a cloned table.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str, name of the named range object</p>
<p>Return : NamedRange</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_named_range(self, name: str) -&gt; NamedRange:
    &#34;&#34;&#34;Returns the Name Ranges of the specified name. If
    table_name is provided, limits the search to these tables.
    Beware : named ranges are stored at the body level, thus do not call
    this method on a cloned table.

    Arguments:

        name -- str, name of the named range object

    Return : NamedRange
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document&#34;)
    return body.get_named_range(name)  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_named_ranges"><code class="name flex">
<span>def <span class="ident">get_named_ranges</span></span>(<span>self, table_name: str | list[str] | None = None) ‑> list[<a title="odfdo.table.NamedRange" href="#odfdo.table.NamedRange">NamedRange</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of available Name Ranges of the spreadsheet. If
table_name is provided, limits the search to these tables.
Beware : named ranges are stored at the body level, thus do not call
this method on a cloned table.</p>
<h2 id="arguments">Arguments</h2>
<p>table_names &ndash; str or list of str, names of tables</p>
<p>Return : list of table_range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_named_ranges(  # type: ignore
    self,
    table_name: str | list[str] | None = None,
) -&gt; list[NamedRange]:
    &#34;&#34;&#34;Returns the list of available Name Ranges of the spreadsheet. If
    table_name is provided, limits the search to these tables.
    Beware : named ranges are stored at the body level, thus do not call
    this method on a cloned table.

    Arguments:

        table_names -- str or list of str, names of tables

    Return : list of table_range
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        return []
    all_named_ranges = body.get_named_ranges()
    if not table_name:
        return all_named_ranges  # type:ignore
    filter_ = []
    if isinstance(table_name, str):
        filter_.append(table_name)
    elif isiterable(table_name):
        filter_.extend(table_name)
    else:
        raise ValueError(
            f&#34;table_name must be string or Iterable, not {type(table_name)}&#34;
        )
    return [
        nr for nr in all_named_ranges if nr.table_name in filter_  # type:ignore
    ]</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_row"><code class="name flex">
<span>def <span class="ident">get_row</span></span>(<span>self, y: int | str, clone: bool = True, create: bool = True) ‑> <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the row at the given "y" position.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<p>A copy is returned, use set_cell() to push it back.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>Return: Row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_row(self, y: int | str, clone: bool = True, create: bool = True) -&gt; Row:
    &#34;&#34;&#34;Get the row at the given &#34;y&#34; position.

    Position start at 0. So cell A4 is on row 3.

    A copy is returned, use set_cell() to push it back.

    Arguments:

        y -- int or str

    Return: Row
    &#34;&#34;&#34;
    # fixme : keep repeat ? maybe an option to functions : &#34;raw=False&#34;
    y = self._translate_y_from_any(y)
    row = self._get_row2(y, clone=clone, create=create)
    if row is None:
        raise ValueError(&#34;Row not found&#34;)
    row.y = y
    return row</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_row_values"><code class="name flex">
<span>def <span class="ident">get_row_values</span></span>(<span>self, y: int | str, cell_type: str | None = None, complete: bool = True, get_type: bool = False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the list of Python values for the cells of the row
at the given "y" position.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<p>Filter by cell_type, with cell_type 'all' will retrieve cells of any
type, aka non empty cells.
If cell_type and complete is True, replace missing values by None.</p>
<p>If get_type is True, returns a tuple (value, ODF type of value)</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int, str</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>complete &ndash; boolean</p>
<p>get_type &ndash; boolean</p>
<p>Return: list of lists of Python types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_row_values(
    self,
    y: int | str,
    cell_type: str | None = None,
    complete: bool = True,
    get_type: bool = False,
) -&gt; list:
    &#34;&#34;&#34;Shortcut to get the list of Python values for the cells of the row
    at the given &#34;y&#34; position.

    Position start at 0. So cell A4 is on row 3.

    Filter by cell_type, with cell_type &#39;all&#39; will retrieve cells of any
    type, aka non empty cells.
    If cell_type and complete is True, replace missing values by None.

    If get_type is True, returns a tuple (value, ODF type of value)

    Arguments:

        y -- int, str

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        complete -- boolean

        get_type -- boolean

    Return: list of lists of Python types
    &#34;&#34;&#34;
    values = self.get_row(y, clone=False).get_values(
        cell_type=cell_type, complete=complete, get_type=get_type
    )
    # complete row to match column width
    if complete:
        if get_type:
            values.extend([(None, None)] * (self.width - len(values)))
        else:
            values.extend([None] * (self.width - len(values)))
    return values</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_rows"><code class="name flex">
<span>def <span class="ident">get_rows</span></span>(<span>self, coord: tuple | list | str | None = None, style: str | None = None, content: str | None = None) ‑> list[<a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of rows matching the criteria.</p>
<p>Filter by coordinates will parse the area defined by the coordinates.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates of rows</p>
<p>content &ndash; str regex</p>
<p>style &ndash; str</p>
<p>Return: list of rows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rows(
    self,
    coord: tuple | list | str | None = None,
    style: str | None = None,
    content: str | None = None,
) -&gt; list[Row]:
    &#34;&#34;&#34;Get the list of rows matching the criteria.

    Filter by coordinates will parse the area defined by the coordinates.

    Arguments:

        coord -- str or tuple of int : coordinates of rows

        content -- str regex

        style -- str

    Return: list of rows
    &#34;&#34;&#34;
    if coord:
        _x, y, _z, t = self._translate_table_coordinates(coord)
    else:
        y = t = None
    # fixme : not clones ?
    if not content and not style:
        return list(self.traverse(start=y, end=t))
    rows = []
    for row in self.traverse(start=y, end=t):
        if content and not row.match(content):
            continue
        if style and style != row.style:
            continue
        rows.append(row)
    return rows</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, coord: tuple | list | str, get_type: bool = False) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to get the Python value of the cell at the given
coordinates.</p>
<p>If get_type is True, returns the tuples (value, ODF type)</p>
<p>coord is either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4". If an Area is given, the upper
left position is used as coord.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str : coordinate</p>
<p>Return: Python type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(
    self,
    coord: tuple | list | str,
    get_type: bool = False,
) -&gt; Any:
    &#34;&#34;&#34;Shortcut to get the Python value of the cell at the given
    coordinates.

    If get_type is True, returns the tuples (value, ODF type)

    coord is either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;. If an Area is given, the upper
    left position is used as coord.

    Arguments:

        coord -- (int, int) or str : coordinate

    Return: Python type
    &#34;&#34;&#34;
    x, y = self._translate_cell_coordinates(coord)
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    # Outside the defined table
    if y &gt;= self.height:
        if get_type:
            return (None, None)
        return None
    else:
        # Inside the defined table
        row = self._get_row2_base(y)
        if row is None:
            raise ValueError
        cell = row._get_cell2_base(x)
        if cell is None:
            if get_type:
                return (None, None)
            return None
        return cell.get_value(get_type=get_type)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self, coord: tuple | list | str | None = None, cell_type: str | None = None, complete: bool = True, get_type: bool = False, flat: bool = False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Get a matrix of values of the table.</p>
<p>Filter by coordinates will parse the area defined by the coordinates.</p>
<p>If 'cell_type' is used and 'complete' is True (default), missing values
are replaced by None.
Filter by ' cell_type = "all" ' will retrieve cells of any
type, aka non empty cells.</p>
<p>If 'cell_type' is None, complete is always True : with no cell type
queried, get_values() returns None for each empty cell, the length
each lists is equal to the width of the table.</p>
<p>If get_type is True, returns tuples (value, ODF type of value), or
(None, None) for empty cells with complete True.</p>
<p>If flat is True, the methods return a single list of all the values.
By default, flat is False.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates of area</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>complete &ndash; boolean</p>
<p>get_type &ndash; boolean</p>
<p>Return: list of lists of Python types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(
    self,
    coord: tuple | list | str | None = None,
    cell_type: str | None = None,
    complete: bool = True,
    get_type: bool = False,
    flat: bool = False,
) -&gt; list:
    &#34;&#34;&#34;Get a matrix of values of the table.

    Filter by coordinates will parse the area defined by the coordinates.

    If &#39;cell_type&#39; is used and &#39;complete&#39; is True (default), missing values
    are replaced by None.
    Filter by &#39; cell_type = &#34;all&#34; &#39; will retrieve cells of any
    type, aka non empty cells.

    If &#39;cell_type&#39; is None, complete is always True : with no cell type
    queried, get_values() returns None for each empty cell, the length
    each lists is equal to the width of the table.

    If get_type is True, returns tuples (value, ODF type of value), or
    (None, None) for empty cells with complete True.

    If flat is True, the methods return a single list of all the values.
    By default, flat is False.

    Arguments:

        coord -- str or tuple of int : coordinates of area

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        complete -- boolean

        get_type -- boolean

    Return: list of lists of Python types
    &#34;&#34;&#34;
    if coord:
        x, y, z, t = self._translate_table_coordinates(coord)
    else:
        x = y = z = t = None
    data = []
    for row in self.traverse(start=y, end=t):
        if z is None:
            width = self.width
        else:
            width = min(z + 1, self.width)
        if x is not None:
            width -= x
        values = row.get_values(
            (x, z),
            cell_type=cell_type,
            complete=complete,
            get_type=get_type,
        )
        # complete row to match request width
        if complete:
            if get_type:
                values.extend([(None, None)] * (width - len(values)))
            else:
                values.extend([None] * (width - len(values)))
        if flat:
            data.extend(values)
        else:
            data.append(values)
    return data</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.insert_cell"><code class="name flex">
<span>def <span class="ident">insert_cell</span></span>(<span>self, coord: tuple | list | str, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert the given cell at the given coordinates. If no cell is
given, an empty one is created.</p>
<p>Coordinates are either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4".</p>
<p>Cells on the right are shifted. Other rows remain untouched.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str</p>
<p>cell &ndash; Cell</p>
<p>returns the cell with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_cell(
    self,
    coord: tuple | list | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Insert the given cell at the given coordinates. If no cell is
    given, an empty one is created.

    Coordinates are either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;.

    Cells on the right are shifted. Other rows remain untouched.

    Arguments:

        coord -- (int, int) or str

        cell -- Cell

    returns the cell with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    if clone:
        cell = cell.clone
    x, y = self._translate_cell_coordinates(coord)
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    row = self._get_row2(y, clone=True)
    row.y = y
    row.repeated = None
    cell_back = row.insert_cell(x, cell, clone=False)
    self.set_row(y, row, clone=False)
    # Update width if necessary
    self._update_width(row)
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.insert_column"><code class="name flex">
<span>def <span class="ident">insert_column</span></span>(<span>self, x: int | str, column: <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a> | None = None) ‑> <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert the column before the given "x" position. If no column is
given, an empty one is created.</p>
<p>ODF columns don't contain cells, only style information.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>column &ndash; Column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_column(
    self,
    x: int | str,
    column: Column | None = None,
) -&gt; Column:
    &#34;&#34;&#34;Insert the column before the given &#34;x&#34; position. If no column is
    given, an empty one is created.

    ODF columns don&#39;t contain cells, only style information.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    Arguments:

        x -- int or str

        column -- Column
    &#34;&#34;&#34;
    if column is None:
        column = Column()
    x = self._translate_x_from_any(x)
    diff = x - self.width
    if diff &lt; 0:
        column_back = _insert_item_in_vault(
            x, column, self, _xpath_column_idx, &#34;_cmap&#34;
        )
    elif diff == 0:
        column_back = self.append_column(column.clone)
    else:
        self.append_column(Column(repeated=diff), _repeated=diff)
        column_back = self.append_column(column.clone)
    column_back.x = x  # type: ignore
    # Repetitions are accepted
    repeated = column.repeated or 1
    # Update width on every row
    for row in self._get_rows():
        if row.width &gt; x:
            row.insert_cell(x, Cell(repeated=repeated))
        # Shorter rows don&#39;t need insert
        # Longer rows shouldn&#39;t exist!
    return column_back  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.insert_row"><code class="name flex">
<span>def <span class="ident">insert_row</span></span>(<span>self, y: str | int, row: <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert the row before the given "y" position. If no row is given,
an empty one is created.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<p>If row is None, a new empty row is created.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>row &ndash; Row</p>
<p>returns the row, with updated row.y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_row(
    self, y: str | int, row: Row | None = None, clone: bool = True
) -&gt; Row:
    &#34;&#34;&#34;Insert the row before the given &#34;y&#34; position. If no row is given,
    an empty one is created.

    Position start at 0. So cell A4 is on row 3.

    If row is None, a new empty row is created.

    Arguments:

        y -- int or str

        row -- Row

    returns the row, with updated row.y
    &#34;&#34;&#34;
    if row is None:
        row = Row()
        clone = False
    y = self._translate_y_from_any(y)
    diff = y - self.height
    if diff &lt; 0:
        row_back = _insert_item_in_vault(y, row, self, _xpath_row_idx, &#34;_tmap&#34;)
    elif diff == 0:
        row_back = self.append_row(row, clone=clone)
    else:
        self.append_row(Row(repeated=diff), _repeated=diff, clone=False)
        row_back = self.append_row(row, clone=clone)
    row_back.y = y  # type: ignore
    # Update width if necessary
    self._update_width(row_back)  # type: ignore
    return row_back  # type: ignore</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.is_column_empty"><code class="name flex">
<span>def <span class="ident">is_column_empty</span></span>(<span>self, x: int | str, aggressive: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return wether every cell in the column at "x" position has no value
or the value evaluates to False (empty string), and no style.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<p>If aggressive is True, empty cells with style are considered empty.</p>
<p>Return: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_column_empty(self, x: int | str, aggressive: bool = False) -&gt; bool:
    &#34;&#34;&#34;Return wether every cell in the column at &#34;x&#34; position has no value
    or the value evaluates to False (empty string), and no style.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    If aggressive is True, empty cells with style are considered empty.

    Return: bool
    &#34;&#34;&#34;
    for cell in self.get_column_cells(x):
        if cell is None:
            continue
        if not cell.is_empty(aggressive=aggressive):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self, aggressive: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether every cell in the table has no value or the value
evaluates to False (empty string), and no style.</p>
<p>If aggressive is True, empty cells with style are considered empty.</p>
<h2 id="arguments">Arguments</h2>
<p>aggressive &ndash; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self, aggressive: bool = False) -&gt; bool:
    &#34;&#34;&#34;Return whether every cell in the table has no value or the value
    evaluates to False (empty string), and no style.

    If aggressive is True, empty cells with style are considered empty.

    Arguments:

        aggressive -- bool
    &#34;&#34;&#34;
    return all(row.is_empty(aggressive=aggressive) for row in self._get_rows())</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.is_row_empty"><code class="name flex">
<span>def <span class="ident">is_row_empty</span></span>(<span>self, y: int | str, aggressive: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return wether every cell in the row at the given "y" position has
no value or the value evaluates to False (empty string), and no style.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<p>If aggressive is True, empty cells with style are considered empty.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>aggressive &ndash; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_row_empty(self, y: int | str, aggressive: bool = False) -&gt; bool:
    &#34;&#34;&#34;Return wether every cell in the row at the given &#34;y&#34; position has
    no value or the value evaluates to False (empty string), and no style.

    Position start at 0. So cell A4 is on row 3.

    If aggressive is True, empty cells with style are considered empty.

    Arguments:

        y -- int or str

        aggressive -- bool
    &#34;&#34;&#34;
    return self.get_row(y, clone=False).is_empty(aggressive=aggressive)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.iter_values"><code class="name flex">
<span>def <span class="ident">iter_values</span></span>(<span>self, coord: tuple | list | str | None = None, cell_type: str | None = None, complete: bool = True, get_type: bool = False) ‑> collections.abc.Iterator[list]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate through lines of Python values of the table.</p>
<p>Filter by coordinates will parse the area defined by the coordinates.</p>
<p>cell_type, complete, grt_type : see get_values()</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates of area</p>
<p>cell_type &ndash; 'boolean', 'float', 'date', 'string', 'time',
'currency', 'percentage' or 'all'</p>
<p>complete &ndash; boolean</p>
<p>get_type &ndash; boolean</p>
<p>Return: iterator of lists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_values(
    self,
    coord: tuple | list | str | None = None,
    cell_type: str | None = None,
    complete: bool = True,
    get_type: bool = False,
) -&gt; Iterator[list]:
    &#34;&#34;&#34;Iterate through lines of Python values of the table.

    Filter by coordinates will parse the area defined by the coordinates.

    cell_type, complete, grt_type : see get_values()



    Arguments:

        coord -- str or tuple of int : coordinates of area

        cell_type -- &#39;boolean&#39;, &#39;float&#39;, &#39;date&#39;, &#39;string&#39;, &#39;time&#39;,
                     &#39;currency&#39;, &#39;percentage&#39; or &#39;all&#39;

        complete -- boolean

        get_type -- boolean

    Return: iterator of lists
    &#34;&#34;&#34;
    if coord:
        x, y, z, t = self._translate_table_coordinates(coord)
    else:
        x = y = z = t = None
    for row in self.traverse(start=y, end=t):
        if z is None:
            width = self.width
        else:
            width = min(z + 1, self.width)
        if x is not None:
            width -= x
        values = row.get_values(
            (x, z),
            cell_type=cell_type,
            complete=complete,
            get_type=get_type,
        )
        # complete row to match column width
        if complete:
            if get_type:
                values.extend([(None, None)] * (width - len(values)))
            else:
                values.extend([None] * (width - len(values)))
        yield values</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.rstrip"><code class="name flex">
<span>def <span class="ident">rstrip</span></span>(<span>self, aggressive: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove <em>in-place</em> empty rows below and empty cells at the right of
the table. Cells are empty if they contain no value or it evaluates
to False, and no style.</p>
<p>If aggressive is True, empty cells with style are removed too.</p>
<h2 id="argument">Argument</h2>
<p>aggressive &ndash; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rstrip(self, aggressive: bool = False) -&gt; None:
    &#34;&#34;&#34;Remove *in-place* empty rows below and empty cells at the right of
    the table. Cells are empty if they contain no value or it evaluates
    to False, and no style.

    If aggressive is True, empty cells with style are removed too.

    Argument:

        aggressive -- bool
    &#34;&#34;&#34;
    # Step 1: remove empty rows below the table
    for row in reversed(self._get_rows()):
        if row.is_empty(aggressive=aggressive):
            row.parent.delete(row)  # type: ignore
        else:
            break
    # Step 2: rstrip remaining rows
    max_width = 0
    for row in self._get_rows():
        row.rstrip(aggressive=aggressive)
        # keep count of the biggest row
        max_width = max(max_width, row.width)
    # raz cache of rows
    self._indexes[&#34;_tmap&#34;] = {}
    # Step 3: trim columns to match max_width
    columns = self._get_columns()
    repeated_cols = self.xpath(&#34;table:table-column/@table:number-columns-repeated&#34;)
    if not isinstance(repeated_cols, list):
        raise TypeError
    unrepeated = len(columns) - len(repeated_cols)
    column_width = sum(int(r) for r in repeated_cols) + unrepeated  # type: ignore
    diff = column_width - max_width
    if diff &gt; 0:
        for column in reversed(columns):
            repeated = column.repeated or 1
            repeated = repeated - diff
            if repeated &gt; 0:
                column.repeated = repeated
                break
            else:
                column.parent.delete(column)
                diff = -repeated
                if diff == 0:
                    break
    # raz cache of columns
    self._indexes[&#34;_cmap&#34;] = {}
    self._compute_table_cache()</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_cell"><code class="name flex">
<span>def <span class="ident">set_cell</span></span>(<span>self, coord: tuple | list | str, cell: <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Replace a cell of the table at the given coordinates.</p>
<p>They are either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4".</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str : coordinate</p>
<p>cell &ndash; Cell</p>
<p>return the cell, with x and y updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell(
    self,
    coord: tuple | list | str,
    cell: Cell | None = None,
    clone: bool = True,
) -&gt; Cell:
    &#34;&#34;&#34;Replace a cell of the table at the given coordinates.

    They are either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;.

    Arguments:

        coord -- (int, int) or str : coordinate

        cell -- Cell

    return the cell, with x and y updated
    &#34;&#34;&#34;
    if cell is None:
        cell = Cell()
        clone = False
    x, y = self._translate_cell_coordinates(coord)
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    cell.x = x
    cell.y = y
    if y &gt;= self.height:
        row = Row()
        cell_back = row.set_cell(x, cell, clone=clone)
        self.set_row(y, row, clone=False)
    else:
        row_read = self._get_row2_base(y)
        if row_read is None:
            raise ValueError
        row = row_read
        row.y = y
        repeated = row.repeated or 1
        if repeated &gt; 1:
            row = row.clone
            row.repeated = None
            cell_back = row.set_cell(x, cell, clone=clone)
            self.set_row(y, row, clone=False)
        else:
            cell_back = row.set_cell(x, cell, clone=clone)
            # Update width if necessary, since we don&#39;t use set_row
            self._update_width(row)
    return cell_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_cell_image"><code class="name flex">
<span>def <span class="ident">set_cell_image</span></span>(<span>self, coord: tuple | list | str, image_frame: Frame, doc_type: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Do all the magic to display an image in the cell at the given
coordinates.</p>
<p>They are either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4".</p>
<p>The frame element must contain the expected image position and
dimensions.</p>
<p>DrawImage insertion depends on the document type, so the type must be
provided or the table element must be already attached to a document.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str</p>
<p>image_frame &ndash; Frame including an image</p>
<p>doc_type &ndash; 'spreadsheet' or 'text'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell_image(
    self,
    coord: tuple | list | str,
    image_frame: Frame,
    doc_type: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Do all the magic to display an image in the cell at the given
    coordinates.

    They are either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;.

    The frame element must contain the expected image position and
    dimensions.

    DrawImage insertion depends on the document type, so the type must be
    provided or the table element must be already attached to a document.

    Arguments:

        coord -- (int, int) or str

        image_frame -- Frame including an image

        doc_type -- &#39;spreadsheet&#39; or &#39;text&#39;
    &#34;&#34;&#34;
    # Test document type
    if doc_type is None:
        body = self.document_body
        if body is None:
            raise ValueError(&#34;document type not found&#34;)
        doc_type = {&#34;office:spreadsheet&#34;: &#34;spreadsheet&#34;, &#34;office:text&#34;: &#34;text&#34;}.get(
            body.tag
        )
        if doc_type is None:
            raise ValueError(&#34;document type not supported for images&#34;)
    # We need the end address of the image
    x, y = self._translate_cell_coordinates(coord)
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    cell = self.get_cell((x, y))
    image_frame = image_frame.clone  # type: ignore
    # Remove any previous paragraph, frame, etc.
    for child in cell.children:
        cell.delete(child)
    # Now it all depends on the document type
    if doc_type == &#34;spreadsheet&#34;:
        image_frame.anchor_type = &#34;char&#34;
        # The frame needs end coordinates
        width, height = image_frame.size
        image_frame.set_attribute(&#34;table:end-x&#34;, width)
        image_frame.set_attribute(&#34;table:end-y&#34;, height)
        # FIXME what happens when the address changes?
        address = f&#34;{self.name}.{_digit_to_alpha(x)}{y + 1}&#34;
        image_frame.set_attribute(&#34;table:end-cell-address&#34;, address)
        # The frame is directly in the cell
        cell.append(image_frame)
    elif doc_type == &#34;text&#34;:
        # The frame must be in a paragraph
        cell.set_value(&#34;&#34;)
        paragraph = cell.get_element(&#34;text:p&#34;)
        if paragraph is None:
            raise ValueError
        paragraph.append(image_frame)
    self.set_cell(coord, cell)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_cells"><code class="name flex">
<span>def <span class="ident">set_cells</span></span>(<span>self, cells: list[list[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>]] | list[tuple[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>]], coord: tuple | list | str | None = None, clone: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the cells in the table, from the 'coord' position.</p>
<p>'coord' is the coordinate of the upper left cell to be modified by
values. If 'coord' is None, default to the position (0,0) ("A1").
If 'coord' is an area (e.g. "A2:B5"), the upper left position of this
area is used as coordinate.</p>
<p>The table is <em>not</em> cleared before the operation, to reset the table
before setting cells, use table.clear().</p>
<p>A list of lists is expected, with as many lists as rows to be set, and
as many cell in each sublist as cells to be setted in the row.</p>
<h2 id="arguments">Arguments</h2>
<p>cells &ndash; list of list of cells</p>
<p>coord &ndash; tuple or str</p>
<p>values &ndash; list of lists of python types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cells(
    self,
    cells: list[list[Cell]] | list[tuple[Cell]],
    coord: tuple | list | str | None = None,
    clone: bool = True,
) -&gt; None:
    &#34;&#34;&#34;Set the cells in the table, from the &#39;coord&#39; position.

    &#39;coord&#39; is the coordinate of the upper left cell to be modified by
    values. If &#39;coord&#39; is None, default to the position (0,0) (&#34;A1&#34;).
    If &#39;coord&#39; is an area (e.g. &#34;A2:B5&#34;), the upper left position of this
    area is used as coordinate.

    The table is *not* cleared before the operation, to reset the table
    before setting cells, use table.clear().

    A list of lists is expected, with as many lists as rows to be set, and
    as many cell in each sublist as cells to be setted in the row.

    Arguments:

        cells -- list of list of cells

        coord -- tuple or str

        values -- list of lists of python types
    &#34;&#34;&#34;
    if coord:
        x, y = self._translate_cell_coordinates(coord)
    else:
        x = y = 0
    if y is None:
        y = 0
    if x is None:
        x = 0
    y -= 1
    for row_cells in cells:
        y += 1
        if not row_cells:
            continue
        row = self.get_row(y, clone=True)
        repeated = row.repeated or 1
        if repeated &gt;= 2:
            row.repeated = None
        row.set_cells(row_cells, start=x, clone=clone)
        self.set_row(y, row, clone=False)
        self._update_width(row)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_column"><code class="name flex">
<span>def <span class="ident">set_column</span></span>(<span>self, x: int | str, column: <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a> | None = None) ‑> <a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a></span>
</code></dt>
<dd>
<div class="desc"><p>Replace the column at the given "x" position.</p>
<p>ODF columns don't contain cells, only style information.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>column &ndash; Column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_column(
    self,
    x: int | str,
    column: Column | None = None,
) -&gt; Column:
    &#34;&#34;&#34;Replace the column at the given &#34;x&#34; position.

    ODF columns don&#39;t contain cells, only style information.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    Arguments:

        x -- int or str

        column -- Column
    &#34;&#34;&#34;
    x = self._translate_x_from_any(x)
    if column is None:
        column = Column()
        repeated = 1
    else:
        repeated = column.repeated or 1
    column.x = x
    # Outside the defined table ?
    diff = x - self.width
    if diff == 0:
        column_back = self.append_column(column, _repeated=repeated)
    elif diff &gt; 0:
        self.append_column(Column(repeated=diff), _repeated=diff)
        column_back = self.append_column(column, _repeated=repeated)
    else:
        # Inside the defined table
        column_back = _set_item_in_vault(  # type: ignore
            x, column, self, _xpath_column_idx, &#34;_cmap&#34;
        )
    return column_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_column_cells"><code class="name flex">
<span>def <span class="ident">set_column_cells</span></span>(<span>self, x: int | str, cells: list[<a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the list of cells at the given position.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<p>The list must have the same length than the table height.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>cells &ndash; list of Cell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_column_cells(self, x: int | str, cells: list[Cell]) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the list of cells at the given position.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    The list must have the same length than the table height.

    Arguments:

        x -- int or str

        cells -- list of Cell
    &#34;&#34;&#34;
    height = self.height
    if len(cells) != height:
        raise ValueError(f&#34;col mismatch: {height} cells expected&#34;)
    cells_iterator = iter(cells)
    for y, row in enumerate(self.traverse()):
        row.set_cell(x, next(cells_iterator))
        self.set_row(y, row)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_column_values"><code class="name flex">
<span>def <span class="ident">set_column_values</span></span>(<span>self, x: int | str, values: list, cell_type: str | None = None, currency: str | None = None, style: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the list of Python values of cells at the given
position.</p>
<p>Position start at 0. So cell C4 is on column 2. Alphabetical position
like "C" is accepted.</p>
<p>The list must have the same length than the table height.</p>
<h2 id="arguments">Arguments</h2>
<p>x &ndash; int or str</p>
<p>values &ndash; list of Python types</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_column_values(
    self,
    x: int | str,
    values: list,
    cell_type: str | None = None,
    currency: str | None = None,
    style: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Shortcut to set the list of Python values of cells at the given
    position.

    Position start at 0. So cell C4 is on column 2. Alphabetical position
    like &#34;C&#34; is accepted.

    The list must have the same length than the table height.

    Arguments:

        x -- int or str

        values -- list of Python types

        cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

        currency -- three-letter str

        style -- str
    &#34;&#34;&#34;
    cells = [
        Cell(value, cell_type=cell_type, currency=currency, style=style)
        for value in values
    ]
    self.set_column_cells(x, cells)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_named_range"><code class="name flex">
<span>def <span class="ident">set_named_range</span></span>(<span>self, name: str, crange: str | tuple | list, table_name: str | None = None, usage: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Named Range element and insert it in the document.
Beware : named ranges are stored at the body level, thus do not call
this method on a cloned table.</p>
<h2 id="arguments">Arguments</h2>
<p>name &ndash; str, name of the named range</p>
<p>crange &ndash; str or tuple of int, cell or area coordinate</p>
<p>table_name &ndash; str, name of the table</p>
<p>uage &ndash; None or 'print-range', 'filter', 'repeat-column', 'repeat-row'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_named_range(
    self,
    name: str,
    crange: str | tuple | list,
    table_name: str | None = None,
    usage: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Create a Named Range element and insert it in the document.
    Beware : named ranges are stored at the body level, thus do not call
    this method on a cloned table.

    Arguments:

        name -- str, name of the named range

        crange -- str or tuple of int, cell or area coordinate

        table_name -- str, name of the table

        uage -- None or &#39;print-range&#39;, &#39;filter&#39;, &#39;repeat-column&#39;, &#39;repeat-row&#39;
    &#34;&#34;&#34;
    body = self.document_body
    if not body:
        raise ValueError(&#34;Table is not inside a document&#34;)
    if not name:
        raise ValueError(&#34;Name required.&#34;)
    if table_name is None:
        table_name = self.name
    named_range = NamedRange(name, crange, table_name, usage)
    body.append_named_range(named_range)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_row"><code class="name flex">
<span>def <span class="ident">set_row</span></span>(<span>self, y: int | str, row: <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a> | None = None, clone: bool = True) ‑> <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></span>
</code></dt>
<dd>
<div class="desc"><p>Replace the row at the given position with the new one. Repetions of
the old row will be adjusted.</p>
<p>If row is None, a new empty row is created.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>row &ndash; Row</p>
<p>returns the row, with updated row.y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_row(self, y: int | str, row: Row | None = None, clone: bool = True) -&gt; Row:
    &#34;&#34;&#34;Replace the row at the given position with the new one. Repetions of
    the old row will be adjusted.

    If row is None, a new empty row is created.

    Position start at 0. So cell A4 is on row 3.

    Arguments:

        y -- int or str

        row -- Row

    returns the row, with updated row.y
    &#34;&#34;&#34;
    if row is None:
        row = Row()
        repeated = 1
        clone = False
    else:
        repeated = row.repeated or 1
    y = self._translate_y_from_any(y)
    row.y = y
    # Outside the defined table ?
    diff = y - self.height
    if diff == 0:
        row_back = self.append_row(row, _repeated=repeated, clone=clone)
    elif diff &gt; 0:
        self.append_row(Row(repeated=diff), _repeated=diff, clone=clone)
        row_back = self.append_row(row, _repeated=repeated, clone=clone)
    else:
        # Inside the defined table
        row_back = _set_item_in_vault(  # type: ignore
            y, row, self, _xpath_row_idx, &#34;_tmap&#34;, clone=clone
        )
    # print self.serialize(True)
    # Update width if necessary
    self._update_width(row_back)
    return row_back</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_row_cells"><code class="name flex">
<span>def <span class="ident">set_row_cells</span></span>(<span>self, y: int | str, cells: list | None = None) ‑> <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set <em>all</em> the cells of the row at the given
"y" position.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>cells &ndash; list of Python types</p>
<p>style &ndash; str</p>
<p>returns the row, with updated row.y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_row_cells(self, y: int | str, cells: list | None = None) -&gt; Row:
    &#34;&#34;&#34;Shortcut to set *all* the cells of the row at the given
    &#34;y&#34; position.

    Position start at 0. So cell A4 is on row 3.

    Arguments:

        y -- int or str

        cells -- list of Python types

        style -- str

    returns the row, with updated row.y
    &#34;&#34;&#34;
    if cells is None:
        cells = []
    row = Row()  # needed if clones rows
    row.extend_cells(cells)
    return self.set_row(y, row)  # needed if clones rows</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_row_values"><code class="name flex">
<span>def <span class="ident">set_row_values</span></span>(<span>self, y: int | str, values: list, cell_type: str | None = None, currency: str | None = None, style: str | None = None) ‑> <a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to set the values of <em>all</em> cells of the row at the given
"y" position.</p>
<p>Position start at 0. So cell A4 is on row 3.</p>
<h2 id="arguments">Arguments</h2>
<p>y &ndash; int or str</p>
<p>values &ndash; list of Python types</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; str</p>
<p>returns the row, with updated row.y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_row_values(
    self,
    y: int | str,
    values: list,
    cell_type: str | None = None,
    currency: str | None = None,
    style: str | None = None,
) -&gt; Row:
    &#34;&#34;&#34;Shortcut to set the values of *all* cells of the row at the given
    &#34;y&#34; position.

    Position start at 0. So cell A4 is on row 3.

    Arguments:

        y -- int or str

        values -- list of Python types

        cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

        currency -- three-letter str

        style -- str

    returns the row, with updated row.y
    &#34;&#34;&#34;
    row = Row()  # needed if clones rows
    row.set_values(values, style=style, cell_type=cell_type, currency=currency)
    return self.set_row(y, row)  # needed if clones rows</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_span"><code class="name flex">
<span>def <span class="ident">set_span</span></span>(<span>self, area: str | tuple | list, merge: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Cell Span : span the first cell of the area on several
columns and/or rows.
If merge is True, replace text of the cell by the concatenation of
existing text in covered cells.
Beware : if merge is True, old text is changed, if merge is False
(the default), old text in coverd cells is still present but not
displayed by most GUI.</p>
<p>If the area defines only one cell, the set span will do nothing.
It is not allowed to apply set span to an area whose one cell already
belongs to previous cell span.</p>
<p>Area can be either one cell (like 'A1') or an area ('A1:B2'). It can
be provided as an alpha numeric value like "A1:B2' or a tuple like
(0, 0, 1, 1) or (0, 0).</p>
<h2 id="arguments">Arguments</h2>
<p>area &ndash; str or tuple of int, cell or area coordinate</p>
<p>merge &ndash; boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_span(  # noqa: C901
    self,
    area: str | tuple | list,
    merge: bool = False,
) -&gt; bool:
    &#34;&#34;&#34;Create a Cell Span : span the first cell of the area on several
    columns and/or rows.
    If merge is True, replace text of the cell by the concatenation of
    existing text in covered cells.
    Beware : if merge is True, old text is changed, if merge is False
    (the default), old text in coverd cells is still present but not
    displayed by most GUI.

    If the area defines only one cell, the set span will do nothing.
    It is not allowed to apply set span to an area whose one cell already
    belongs to previous cell span.

    Area can be either one cell (like &#39;A1&#39;) or an area (&#39;A1:B2&#39;). It can
    be provided as an alpha numeric value like &#34;A1:B2&#39; or a tuple like
    (0, 0, 1, 1) or (0, 0).

    Arguments:

        area -- str or tuple of int, cell or area coordinate

        merge -- boolean
    &#34;&#34;&#34;
    # get area
    digits = _convert_coordinates(area)
    if len(digits) == 4:
        x, y, z, t = digits
    else:
        x, y = digits
        z, t = digits
    start = x, y
    end = z, t
    if start == end:
        # one cell : do nothing
        return False
    if x is None:
        raise ValueError
    if y is None:
        raise ValueError
    if z is None:
        raise ValueError
    if t is None:
        raise ValueError
    # check for previous span
    good = True
    # Check boundaries and empty cells : need to crate non existent cells
    # so don&#39;t use get_cells directly, but get_cell
    cells = []
    for yy in range(y, t + 1):
        row_cells = []
        for xx in range(x, z + 1):
            row_cells.append(
                self.get_cell((xx, yy), clone=True, keep_repeated=False)
            )
        cells.append(row_cells)
    for row in cells:
        for cell in row:
            if cell._is_spanned():
                good = False
                break
        if not good:
            break
    if not good:
        return False
    # Check boundaries
    # if z &gt;= self.width or t &gt;= self.height:
    #    self.set_cell(coord = end)
    #    print area, z, t
    #    cells = self.get_cells((x, y, z, t))
    #    print cells
    # do it:
    if merge:
        val_list = []
        for row in cells:
            for cell in row:
                if cell.is_empty(aggressive=True):
                    continue
                val = cell.get_value()
                if val is not None:
                    if isinstance(val, str):
                        val.strip()
                    if val != &#34;&#34;:
                        val_list.append(val)
                    cell.clear()
        if val_list:
            if len(val_list) == 1:
                cells[0][0].set_value(val_list[0])
            else:
                value = &#34; &#34;.join([str(v) for v in val_list if v])
                cells[0][0].set_value(value)
    cols = z - x + 1
    cells[0][0].set_attribute(&#34;table:number-columns-spanned&#34;, str(cols))
    rows = t - y + 1
    cells[0][0].set_attribute(&#34;table:number-rows-spanned&#34;, str(rows))
    for cell in cells[0][1:]:
        cell.tag = &#34;table:covered-table-cell&#34;
    for row in cells[1:]:
        for cell in row:
            cell.tag = &#34;table:covered-table-cell&#34;
    # replace cells in table
    self.set_cells(cells, coord=start, clone=False)
    return True</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, coord: tuple | list | str, value: Any, cell_type: str | None = None, currency: str | None = None, style: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the Python value of the cell at the given coordinates.</p>
<p>They are either a 2-uplet of (x, y) starting from 0, or a
human-readable position like "C4".</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; (int, int) or str</p>
<p>value &ndash; Python type</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(
    self,
    coord: tuple | list | str,
    value: Any,
    cell_type: str | None = None,
    currency: str | None = None,
    style: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Set the Python value of the cell at the given coordinates.

    They are either a 2-uplet of (x, y) starting from 0, or a
    human-readable position like &#34;C4&#34;.

    Arguments:

        coord -- (int, int) or str

        value -- Python type

        cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                 &#39;string&#39; or &#39;time&#39;

        currency -- three-letter str

        style -- str

    &#34;&#34;&#34;
    self.set_cell(
        coord,
        Cell(value, cell_type=cell_type, currency=currency, style=style),
        clone=False,
    )</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.set_values"><code class="name flex">
<span>def <span class="ident">set_values</span></span>(<span>self, values: list, coord: tuple | list | str | None = None, style: str | None = None, cell_type: str | None = None, currency: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of cells in the table, from the 'coord' position
with values.</p>
<p>'coord' is the coordinate of the upper left cell to be modified by
values. If 'coord' is None, default to the position (0,0) ("A1").
If 'coord' is an area (e.g. "A2:B5"), the upper left position of this
area is used as coordinate.</p>
<p>The table is <em>not</em> cleared before the operation, to reset the table
before setting values, use table.clear().</p>
<p>A list of lists is expected, with as many lists as rows, and as many
items in each sublist as cells to be setted. None values in the list
will create empty cells with no cell type (but eventually a style).</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; tuple or str</p>
<p>values &ndash; list of lists of python types</p>
<p>cell_type &ndash; 'boolean', 'currency', 'date', 'float', 'percentage',
'string' or 'time'</p>
<p>currency &ndash; three-letter str</p>
<p>style &ndash; str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values(
    self,
    values: list,
    coord: tuple | list | str | None = None,
    style: str | None = None,
    cell_type: str | None = None,
    currency: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Set the value of cells in the table, from the &#39;coord&#39; position
    with values.

    &#39;coord&#39; is the coordinate of the upper left cell to be modified by
    values. If &#39;coord&#39; is None, default to the position (0,0) (&#34;A1&#34;).
    If &#39;coord&#39; is an area (e.g. &#34;A2:B5&#34;), the upper left position of this
    area is used as coordinate.

    The table is *not* cleared before the operation, to reset the table
    before setting values, use table.clear().

    A list of lists is expected, with as many lists as rows, and as many
    items in each sublist as cells to be setted. None values in the list
    will create empty cells with no cell type (but eventually a style).

    Arguments:

        coord -- tuple or str

        values -- list of lists of python types

        cell_type -- &#39;boolean&#39;, &#39;currency&#39;, &#39;date&#39;, &#39;float&#39;, &#39;percentage&#39;,
                     &#39;string&#39; or &#39;time&#39;

        currency -- three-letter str

        style -- str
    &#34;&#34;&#34;
    if coord:
        x, y = self._translate_cell_coordinates(coord)
    else:
        x = y = 0
    if y is None:
        y = 0
    if x is None:
        x = 0
    y -= 1
    for row_values in values:
        y += 1
        if not row_values:
            continue
        row = self.get_row(y, clone=True)
        repeated = row.repeated or 1
        if repeated &gt;= 2:
            row.repeated = None
        row.set_values(
            row_values,
            start=x,
            cell_type=cell_type,
            currency=currency,
            style=style,
        )
        self.set_row(y, row, clone=False)
        self._update_width(row)</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, path_or_file: str | Path | None = None, dialect: str = 'excel') ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Write the table as CSV in the file.</p>
<p>If the file is a string, it is opened as a local path. Else an
opened file-like is expected.</p>
<h2 id="arguments">Arguments</h2>
<p>path_or_file &ndash; str or file-like</p>
<p>dialect &ndash; str, python csv.dialect, can be 'excel', 'unix'&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(
    self,
    path_or_file: str | Path | None = None,
    dialect: str = &#34;excel&#34;,
) -&gt; Any:
    &#34;&#34;&#34;Write the table as CSV in the file.

    If the file is a string, it is opened as a local path. Else an
    opened file-like is expected.

    Arguments:

        path_or_file -- str or file-like

        dialect -- str, python csv.dialect, can be &#39;excel&#39;, &#39;unix&#39;...
    &#34;&#34;&#34;

    def write_content(csv_writer: object) -&gt; None:
        for values in self.iter_values():
            line = []
            for value in values:
                if value is None:
                    value = &#34;&#34;
                if isinstance(value, str):
                    value = value.strip()
                line.append(value)
            csv_writer.writerow(line)  # type: ignore

    out = StringIO(newline=&#34;&#34;)
    csv_writer = csv.writer(out, dialect=dialect)
    write_content(csv_writer)
    if path_or_file is None:
        return out.getvalue()
    path = Path(path_or_file)
    path.write_text(out.getvalue())
    return None</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.transpose"><code class="name flex">
<span>def <span class="ident">transpose</span></span>(<span>self, coord: tuple | list | str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Swap <em>in-place</em> rows and columns of the table.</p>
<p>If 'coord' is not None, apply transpose only to the area defined by the
coordinates. Beware, if area is not square, some cells mays be over
written during the process.</p>
<h2 id="arguments">Arguments</h2>
<p>coord &ndash; str or tuple of int : coordinates of area</p>
<p>start &ndash; int or str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose(self, coord: tuple | list | str | None = None) -&gt; None:  # noqa: C901
    &#34;&#34;&#34;Swap *in-place* rows and columns of the table.

    If &#39;coord&#39; is not None, apply transpose only to the area defined by the
    coordinates. Beware, if area is not square, some cells mays be over
    written during the process.

    Arguments:

        coord -- str or tuple of int : coordinates of area

        start -- int or str
    &#34;&#34;&#34;
    data = []
    if coord is None:
        for row in self.traverse():
            data.append(list(row.traverse()))
        transposed_data = zip_longest(*data)
        self.clear()
        # new_rows = []
        for row_cells in transposed_data:
            if not isiterable(row_cells):
                row_cells = (row_cells,)
            row = Row()
            row.extend_cells(row_cells)
            self.append_row(row, clone=False)
        self._compute_table_cache()
    else:
        x, y, z, t = self._translate_table_coordinates(coord)
        if x is None:
            x = 0
        else:
            x = min(x, self.width - 1)
        if z is None:
            z = self.width - 1
        else:
            z = min(z, self.width - 1)
        if y is None:
            y = 0
        else:
            y = min(y, self.height - 1)
        if t is None:
            t = self.height - 1
        else:
            t = min(t, self.height - 1)
        for row in self.traverse(start=y, end=t):
            data.append(list(row.traverse(start=x, end=z)))
        transposed_data = zip_longest(*data)
        # clear locally
        w = z - x + 1
        h = t - y + 1
        if w != h:
            nones = [[None] * w for i in range(h)]
            self.set_values(nones, coord=(x, y, z, t))
        # put transposed
        filtered_data: list[tuple[Cell]] = []
        for row_cells in transposed_data:
            if isinstance(row_cells, (list, tuple)):
                filtered_data.append(row_cells)
            else:
                filtered_data.append((row_cells,))
        self.set_cells(filtered_data, (x, y, x + h - 1, y + w - 1))
        self._compute_table_cache()</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, start: int | None = None, end: int | None = None) ‑> collections.abc.Iterator[<a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Yield as many row elements as expected rows in the table, i.e.
expand repetitions by returning the same row as many times as
necessary.</p>
<pre><code>Arguments:

    start -- int

    end -- int
</code></pre>
<p>Copies are returned, use set_row() to push them back.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse(  # noqa: C901
    self,
    start: int | None = None,
    end: int | None = None,
) -&gt; Iterator[Row]:
    &#34;&#34;&#34;Yield as many row elements as expected rows in the table, i.e.
    expand repetitions by returning the same row as many times as
    necessary.

        Arguments:

            start -- int

            end -- int

    Copies are returned, use set_row() to push them back.
    &#34;&#34;&#34;
    idx = -1
    before = -1
    y = 0
    if start is None and end is None:
        for juska in self._tmap:
            idx += 1
            if idx in self._indexes[&#34;_tmap&#34;]:
                row = self._indexes[&#34;_tmap&#34;][idx]
            else:
                row = self._get_element_idx2(_xpath_row_idx, idx)
                self._indexes[&#34;_tmap&#34;][idx] = row
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                # Return a copy without the now obsolete repetition
                row = row.clone
                row.y = y
                y += 1
                if repeated &gt; 1:
                    row.repeated = None
                yield row
    else:
        if start is None:
            start = 0
        start = max(0, start)
        if end is None:
            try:
                end = self._tmap[-1]
            except Exception:
                end = -1
        start_map = _find_odf_idx(self._tmap, start)
        if start_map is None:
            return
        if start_map &gt; 0:
            before = self._tmap[start_map - 1]
        idx = start_map - 1
        before = start - 1
        y = start
        for juska in self._tmap[start_map:]:
            idx += 1
            if idx in self._indexes[&#34;_tmap&#34;]:
                row = self._indexes[&#34;_tmap&#34;][idx]
            else:
                row = self._get_element_idx2(_xpath_row_idx, idx)
                self._indexes[&#34;_tmap&#34;][idx] = row
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                if y &lt;= end:
                    row = row.clone
                    row.y = y
                    y += 1
                    if repeated &gt; 1 or (y == start and start &gt; 0):
                        row.repeated = None
                    yield row</code></pre>
</details>
</dd>
<dt id="odfdo.table.Table.traverse_columns"><code class="name flex">
<span>def <span class="ident">traverse_columns</span></span>(<span>self, start: int | None = None, end: int | None = None) ‑> collections.abc.Iterator[<a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Yield as many column elements as expected columns in the table,
i.e. expand repetitions by returning the same column as many times as
necessary.</p>
<pre><code>Arguments:

    start -- int

    end -- int
</code></pre>
<p>Copies are returned, use set_column() to push them back.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse_columns(  # noqa: C901
    self,
    start: int | None = None,
    end: int | None = None,
) -&gt; Iterator[Column]:
    &#34;&#34;&#34;Yield as many column elements as expected columns in the table,
    i.e. expand repetitions by returning the same column as many times as
    necessary.

        Arguments:

            start -- int

            end -- int

    Copies are returned, use set_column() to push them back.
    &#34;&#34;&#34;
    idx = -1
    before = -1
    x = 0
    if start is None and end is None:
        for juska in self._cmap:
            idx += 1
            if idx in self._indexes[&#34;_cmap&#34;]:
                column = self._indexes[&#34;_cmap&#34;][idx]
            else:
                column = self._get_element_idx2(_xpath_column_idx, idx)
                self._indexes[&#34;_cmap&#34;][idx] = column
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                # Return a copy without the now obsolete repetition
                column = column.clone
                column.x = x
                x += 1
                if repeated &gt; 1:
                    column.repeated = None
                yield column
    else:
        if start is None:
            start = 0
        start = max(0, start)
        if end is None:
            try:
                end = self._cmap[-1]
            except Exception:
                end = -1
        start_map = _find_odf_idx(self._cmap, start)
        if start_map is None:
            return
        if start_map &gt; 0:
            before = self._cmap[start_map - 1]
        idx = start_map - 1
        before = start - 1
        x = start
        for juska in self._cmap[start_map:]:
            idx += 1
            if idx in self._indexes[&#34;_cmap&#34;]:
                column = self._indexes[&#34;_cmap&#34;][idx]
            else:
                column = self._get_element_idx2(_xpath_column_idx, idx)
                self._indexes[&#34;_cmap&#34;][idx] = column
            repeated = juska - before
            before = juska
            for _i in range(repeated or 1):
                if x &lt;= end:
                    column = column.clone
                    column.x = x
                    x += 1
                    if repeated &gt; 1 or (x == start and start &gt; 0):
                        column.repeated = None
                    yield column</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odfdo.element.Element" href="element.html#odfdo.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="odfdo.element.Element.append_named_range" href="element.html#odfdo.element.Element.append_named_range">append_named_range</a></code></li>
<li><code><a title="odfdo.element.Element.clear" href="element.html#odfdo.element.Element.clear">clear</a></code></li>
<li><code><a title="odfdo.element.Element.dc_creator" href="element.html#odfdo.element.Element.dc_creator">dc_creator</a></code></li>
<li><code><a title="odfdo.element.Element.dc_date" href="element.html#odfdo.element.Element.dc_date">dc_date</a></code></li>
<li><code><a title="odfdo.element.Element.delete" href="element.html#odfdo.element.Element.delete">delete</a></code></li>
<li><code><a title="odfdo.element.Element.document_body" href="element.html#odfdo.element.Element.document_body">document_body</a></code></li>
<li><code><a title="odfdo.element.Element.elements_repeated_sequence" href="element.html#odfdo.element.Element.elements_repeated_sequence">elements_repeated_sequence</a></code></li>
<li><code><a title="odfdo.element.Element.extend" href="element.html#odfdo.element.Element.extend">extend</a></code></li>
<li><code><a title="odfdo.element.Element.from_tag" href="element.html#odfdo.element.Element.from_tag">from_tag</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation" href="element.html#odfdo.element.Element.get_annotation">get_annotation</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_end" href="element.html#odfdo.element.Element.get_annotation_end">get_annotation_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotation_ends" href="element.html#odfdo.element.Element.get_annotation_ends">get_annotation_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_annotations" href="element.html#odfdo.element.Element.get_annotations">get_annotations</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute" href="element.html#odfdo.element.Element.get_attribute">get_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_integer" href="element.html#odfdo.element.Element.get_attribute_integer">get_attribute_integer</a></code></li>
<li><code><a title="odfdo.element.Element.get_attribute_string" href="element.html#odfdo.element.Element.get_attribute_string">get_attribute_string</a></code></li>
<li><code><a title="odfdo.element.Element.get_between" href="element.html#odfdo.element.Element.get_between">get_between</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark" href="element.html#odfdo.element.Element.get_bookmark">get_bookmark</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_end" href="element.html#odfdo.element.Element.get_bookmark_end">get_bookmark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_ends" href="element.html#odfdo.element.Element.get_bookmark_ends">get_bookmark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_start" href="element.html#odfdo.element.Element.get_bookmark_start">get_bookmark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmark_starts" href="element.html#odfdo.element.Element.get_bookmark_starts">get_bookmark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_bookmarks" href="element.html#odfdo.element.Element.get_bookmarks">get_bookmarks</a></code></li>
<li><code><a title="odfdo.element.Element.get_changes_ids" href="element.html#odfdo.element.Element.get_changes_ids">get_changes_ids</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connector" href="element.html#odfdo.element.Element.get_draw_connector">get_draw_connector</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_connectors" href="element.html#odfdo.element.Element.get_draw_connectors">get_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipse" href="element.html#odfdo.element.Element.get_draw_ellipse">get_draw_ellipse</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_ellipses" href="element.html#odfdo.element.Element.get_draw_ellipses">get_draw_ellipses</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_line" href="element.html#odfdo.element.Element.get_draw_line">get_draw_line</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_lines" href="element.html#odfdo.element.Element.get_draw_lines">get_draw_lines</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_page" href="element.html#odfdo.element.Element.get_draw_page">get_draw_page</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_pages" href="element.html#odfdo.element.Element.get_draw_pages">get_draw_pages</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangle" href="element.html#odfdo.element.Element.get_draw_rectangle">get_draw_rectangle</a></code></li>
<li><code><a title="odfdo.element.Element.get_draw_rectangles" href="element.html#odfdo.element.Element.get_draw_rectangles">get_draw_rectangles</a></code></li>
<li><code><a title="odfdo.element.Element.get_formatted_text" href="element.html#odfdo.element.Element.get_formatted_text">get_formatted_text</a></code></li>
<li><code><a title="odfdo.element.Element.get_frame" href="element.html#odfdo.element.Element.get_frame">get_frame</a></code></li>
<li><code><a title="odfdo.element.Element.get_frames" href="element.html#odfdo.element.Element.get_frames">get_frames</a></code></li>
<li><code><a title="odfdo.element.Element.get_header" href="element.html#odfdo.element.Element.get_header">get_header</a></code></li>
<li><code><a title="odfdo.element.Element.get_headers" href="element.html#odfdo.element.Element.get_headers">get_headers</a></code></li>
<li><code><a title="odfdo.element.Element.get_image" href="element.html#odfdo.element.Element.get_image">get_image</a></code></li>
<li><code><a title="odfdo.element.Element.get_images" href="element.html#odfdo.element.Element.get_images">get_images</a></code></li>
<li><code><a title="odfdo.element.Element.get_link" href="element.html#odfdo.element.Element.get_link">get_link</a></code></li>
<li><code><a title="odfdo.element.Element.get_links" href="element.html#odfdo.element.Element.get_links">get_links</a></code></li>
<li><code><a title="odfdo.element.Element.get_list" href="element.html#odfdo.element.Element.get_list">get_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_lists" href="element.html#odfdo.element.Element.get_lists">get_lists</a></code></li>
<li><code><a title="odfdo.element.Element.get_note" href="element.html#odfdo.element.Element.get_note">get_note</a></code></li>
<li><code><a title="odfdo.element.Element.get_notes" href="element.html#odfdo.element.Element.get_notes">get_notes</a></code></li>
<li><code><a title="odfdo.element.Element.get_office_names" href="element.html#odfdo.element.Element.get_office_names">get_office_names</a></code></li>
<li><code><a title="odfdo.element.Element.get_orphan_draw_connectors" href="element.html#odfdo.element.Element.get_orphan_draw_connectors">get_orphan_draw_connectors</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraph" href="element.html#odfdo.element.Element.get_paragraph">get_paragraph</a></code></li>
<li><code><a title="odfdo.element.Element.get_paragraphs" href="element.html#odfdo.element.Element.get_paragraphs">get_paragraphs</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark" href="element.html#odfdo.element.Element.get_reference_mark">get_reference_mark</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_end" href="element.html#odfdo.element.Element.get_reference_mark_end">get_reference_mark_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_ends" href="element.html#odfdo.element.Element.get_reference_mark_ends">get_reference_mark_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_single" href="element.html#odfdo.element.Element.get_reference_mark_single">get_reference_mark_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_start" href="element.html#odfdo.element.Element.get_reference_mark_start">get_reference_mark_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_mark_starts" href="element.html#odfdo.element.Element.get_reference_mark_starts">get_reference_mark_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks" href="element.html#odfdo.element.Element.get_reference_marks">get_reference_marks</a></code></li>
<li><code><a title="odfdo.element.Element.get_reference_marks_single" href="element.html#odfdo.element.Element.get_reference_marks_single">get_reference_marks_single</a></code></li>
<li><code><a title="odfdo.element.Element.get_references" href="element.html#odfdo.element.Element.get_references">get_references</a></code></li>
<li><code><a title="odfdo.element.Element.get_section" href="element.html#odfdo.element.Element.get_section">get_section</a></code></li>
<li><code><a title="odfdo.element.Element.get_sections" href="element.html#odfdo.element.Element.get_sections">get_sections</a></code></li>
<li><code><a title="odfdo.element.Element.get_span" href="element.html#odfdo.element.Element.get_span">get_span</a></code></li>
<li><code><a title="odfdo.element.Element.get_spans" href="element.html#odfdo.element.Element.get_spans">get_spans</a></code></li>
<li><code><a title="odfdo.element.Element.get_style" href="element.html#odfdo.element.Element.get_style">get_style</a></code></li>
<li><code><a title="odfdo.element.Element.get_styled_elements" href="element.html#odfdo.element.Element.get_styled_elements">get_styled_elements</a></code></li>
<li><code><a title="odfdo.element.Element.get_table" href="element.html#odfdo.element.Element.get_table">get_table</a></code></li>
<li><code><a title="odfdo.element.Element.get_tables" href="element.html#odfdo.element.Element.get_tables">get_tables</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change" href="element.html#odfdo.element.Element.get_text_change">get_text_change</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletion" href="element.html#odfdo.element.Element.get_text_change_deletion">get_text_change_deletion</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_deletions" href="element.html#odfdo.element.Element.get_text_change_deletions">get_text_change_deletions</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_end" href="element.html#odfdo.element.Element.get_text_change_end">get_text_change_end</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_ends" href="element.html#odfdo.element.Element.get_text_change_ends">get_text_change_ends</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_start" href="element.html#odfdo.element.Element.get_text_change_start">get_text_change_start</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_change_starts" href="element.html#odfdo.element.Element.get_text_change_starts">get_text_change_starts</a></code></li>
<li><code><a title="odfdo.element.Element.get_text_changes" href="element.html#odfdo.element.Element.get_text_changes">get_text_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_toc" href="element.html#odfdo.element.Element.get_toc">get_toc</a></code></li>
<li><code><a title="odfdo.element.Element.get_tocs" href="element.html#odfdo.element.Element.get_tocs">get_tocs</a></code></li>
<li><code><a title="odfdo.element.Element.get_tracked_changes" href="element.html#odfdo.element.Element.get_tracked_changes">get_tracked_changes</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined" href="element.html#odfdo.element.Element.get_user_defined">get_user_defined</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_list" href="element.html#odfdo.element.Element.get_user_defined_list">get_user_defined_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_defined_value" href="element.html#odfdo.element.Element.get_user_defined_value">get_user_defined_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl" href="element.html#odfdo.element.Element.get_user_field_decl">get_user_field_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decl_list" href="element.html#odfdo.element.Element.get_user_field_decl_list">get_user_field_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_decls" href="element.html#odfdo.element.Element.get_user_field_decls">get_user_field_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_user_field_value" href="element.html#odfdo.element.Element.get_user_field_value">get_user_field_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl" href="element.html#odfdo.element.Element.get_variable_decl">get_variable_decl</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decl_list" href="element.html#odfdo.element.Element.get_variable_decl_list">get_variable_decl_list</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_decls" href="element.html#odfdo.element.Element.get_variable_decls">get_variable_decls</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set" href="element.html#odfdo.element.Element.get_variable_set">get_variable_set</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_set_value" href="element.html#odfdo.element.Element.get_variable_set_value">get_variable_set_value</a></code></li>
<li><code><a title="odfdo.element.Element.get_variable_sets" href="element.html#odfdo.element.Element.get_variable_sets">get_variable_sets</a></code></li>
<li><code><a title="odfdo.element.Element.index" href="element.html#odfdo.element.Element.index">index</a></code></li>
<li><code><a title="odfdo.element.Element.insert" href="element.html#odfdo.element.Element.insert">insert</a></code></li>
<li><code><a title="odfdo.element.Element.match" href="element.html#odfdo.element.Element.match">match</a></code></li>
<li><code><a title="odfdo.element.Element.replace" href="element.html#odfdo.element.Element.replace">replace</a></code></li>
<li><code><a title="odfdo.element.Element.replace_element" href="element.html#odfdo.element.Element.replace_element">replace_element</a></code></li>
<li><code><a title="odfdo.element.Element.search" href="element.html#odfdo.element.Element.search">search</a></code></li>
<li><code><a title="odfdo.element.Element.set_style_attribute" href="element.html#odfdo.element.Element.set_style_attribute">set_style_attribute</a></code></li>
<li><code><a title="odfdo.element.Element.strip_elements" href="element.html#odfdo.element.Element.strip_elements">strip_elements</a></code></li>
<li><code><a title="odfdo.element.Element.strip_tags" href="element.html#odfdo.element.Element.strip_tags">strip_tags</a></code></li>
<li><code><a title="odfdo.element.Element.tag" href="element.html#odfdo.element.Element.tag">tag</a></code></li>
<li><code><a title="odfdo.element.Element.tail" href="element.html#odfdo.element.Element.tail">tail</a></code></li>
<li><code><a title="odfdo.element.Element.text" href="element.html#odfdo.element.Element.text">text</a></code></li>
<li><code><a title="odfdo.element.Element.text_content" href="element.html#odfdo.element.Element.text_content">text_content</a></code></li>
<li><code><a title="odfdo.element.Element.xpath" href="element.html#odfdo.element.Element.xpath">xpath</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="odfdo" href="index.html">odfdo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="odfdo.table.import_from_csv" href="#odfdo.table.import_from_csv">import_from_csv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="odfdo.table.Cell" href="#odfdo.table.Cell">Cell</a></code></h4>
<ul class="two-column">
<li><code><a title="odfdo.table.Cell.clone" href="#odfdo.table.Cell.clone">clone</a></code></li>
<li><code><a title="odfdo.table.Cell.currency" href="#odfdo.table.Cell.currency">currency</a></code></li>
<li><code><a title="odfdo.table.Cell.float" href="#odfdo.table.Cell.float">float</a></code></li>
<li><code><a title="odfdo.table.Cell.formula" href="#odfdo.table.Cell.formula">formula</a></code></li>
<li><code><a title="odfdo.table.Cell.repeated" href="#odfdo.table.Cell.repeated">repeated</a></code></li>
<li><code><a title="odfdo.table.Cell.set_value" href="#odfdo.table.Cell.set_value">set_value</a></code></li>
<li><code><a title="odfdo.table.Cell.string" href="#odfdo.table.Cell.string">string</a></code></li>
<li><code><a title="odfdo.table.Cell.style" href="#odfdo.table.Cell.style">style</a></code></li>
<li><code><a title="odfdo.table.Cell.type" href="#odfdo.table.Cell.type">type</a></code></li>
<li><code><a title="odfdo.table.Cell.value" href="#odfdo.table.Cell.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odfdo.table.Column" href="#odfdo.table.Column">Column</a></code></h4>
<ul class="">
<li><code><a title="odfdo.table.Column.clone" href="#odfdo.table.Column.clone">clone</a></code></li>
<li><code><a title="odfdo.table.Column.get_default_cell_style" href="#odfdo.table.Column.get_default_cell_style">get_default_cell_style</a></code></li>
<li><code><a title="odfdo.table.Column.repeated" href="#odfdo.table.Column.repeated">repeated</a></code></li>
<li><code><a title="odfdo.table.Column.set_default_cell_style" href="#odfdo.table.Column.set_default_cell_style">set_default_cell_style</a></code></li>
<li><code><a title="odfdo.table.Column.style" href="#odfdo.table.Column.style">style</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odfdo.table.HeaderRows" href="#odfdo.table.HeaderRows">HeaderRows</a></code></h4>
</li>
<li>
<h4><code><a title="odfdo.table.NamedRange" href="#odfdo.table.NamedRange">NamedRange</a></code></h4>
<ul class="two-column">
<li><code><a title="odfdo.table.NamedRange.get_value" href="#odfdo.table.NamedRange.get_value">get_value</a></code></li>
<li><code><a title="odfdo.table.NamedRange.get_values" href="#odfdo.table.NamedRange.get_values">get_values</a></code></li>
<li><code><a title="odfdo.table.NamedRange.name" href="#odfdo.table.NamedRange.name">name</a></code></li>
<li><code><a title="odfdo.table.NamedRange.set_range" href="#odfdo.table.NamedRange.set_range">set_range</a></code></li>
<li><code><a title="odfdo.table.NamedRange.set_table_name" href="#odfdo.table.NamedRange.set_table_name">set_table_name</a></code></li>
<li><code><a title="odfdo.table.NamedRange.set_usage" href="#odfdo.table.NamedRange.set_usage">set_usage</a></code></li>
<li><code><a title="odfdo.table.NamedRange.set_value" href="#odfdo.table.NamedRange.set_value">set_value</a></code></li>
<li><code><a title="odfdo.table.NamedRange.set_values" href="#odfdo.table.NamedRange.set_values">set_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odfdo.table.Row" href="#odfdo.table.Row">Row</a></code></h4>
<ul class="two-column">
<li><code><a title="odfdo.table.Row.append" href="#odfdo.table.Row.append">append</a></code></li>
<li><code><a title="odfdo.table.Row.append_cell" href="#odfdo.table.Row.append_cell">append_cell</a></code></li>
<li><code><a title="odfdo.table.Row.clone" href="#odfdo.table.Row.clone">clone</a></code></li>
<li><code><a title="odfdo.table.Row.delete_cell" href="#odfdo.table.Row.delete_cell">delete_cell</a></code></li>
<li><code><a title="odfdo.table.Row.extend_cells" href="#odfdo.table.Row.extend_cells">extend_cells</a></code></li>
<li><code><a title="odfdo.table.Row.get_cell" href="#odfdo.table.Row.get_cell">get_cell</a></code></li>
<li><code><a title="odfdo.table.Row.get_cells" href="#odfdo.table.Row.get_cells">get_cells</a></code></li>
<li><code><a title="odfdo.table.Row.get_value" href="#odfdo.table.Row.get_value">get_value</a></code></li>
<li><code><a title="odfdo.table.Row.get_values" href="#odfdo.table.Row.get_values">get_values</a></code></li>
<li><code><a title="odfdo.table.Row.insert_cell" href="#odfdo.table.Row.insert_cell">insert_cell</a></code></li>
<li><code><a title="odfdo.table.Row.is_empty" href="#odfdo.table.Row.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.table.Row.repeated" href="#odfdo.table.Row.repeated">repeated</a></code></li>
<li><code><a title="odfdo.table.Row.rstrip" href="#odfdo.table.Row.rstrip">rstrip</a></code></li>
<li><code><a title="odfdo.table.Row.set_cell" href="#odfdo.table.Row.set_cell">set_cell</a></code></li>
<li><code><a title="odfdo.table.Row.set_cells" href="#odfdo.table.Row.set_cells">set_cells</a></code></li>
<li><code><a title="odfdo.table.Row.set_value" href="#odfdo.table.Row.set_value">set_value</a></code></li>
<li><code><a title="odfdo.table.Row.set_values" href="#odfdo.table.Row.set_values">set_values</a></code></li>
<li><code><a title="odfdo.table.Row.style" href="#odfdo.table.Row.style">style</a></code></li>
<li><code><a title="odfdo.table.Row.traverse" href="#odfdo.table.Row.traverse">traverse</a></code></li>
<li><code><a title="odfdo.table.Row.width" href="#odfdo.table.Row.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odfdo.table.RowGroup" href="#odfdo.table.RowGroup">RowGroup</a></code></h4>
</li>
<li>
<h4><code><a title="odfdo.table.Table" href="#odfdo.table.Table">Table</a></code></h4>
<ul class="two-column">
<li><code><a title="odfdo.table.Table.append" href="#odfdo.table.Table.append">append</a></code></li>
<li><code><a title="odfdo.table.Table.append_cell" href="#odfdo.table.Table.append_cell">append_cell</a></code></li>
<li><code><a title="odfdo.table.Table.append_column" href="#odfdo.table.Table.append_column">append_column</a></code></li>
<li><code><a title="odfdo.table.Table.append_row" href="#odfdo.table.Table.append_row">append_row</a></code></li>
<li><code><a title="odfdo.table.Table.del_span" href="#odfdo.table.Table.del_span">del_span</a></code></li>
<li><code><a title="odfdo.table.Table.delete_cell" href="#odfdo.table.Table.delete_cell">delete_cell</a></code></li>
<li><code><a title="odfdo.table.Table.delete_column" href="#odfdo.table.Table.delete_column">delete_column</a></code></li>
<li><code><a title="odfdo.table.Table.delete_named_range" href="#odfdo.table.Table.delete_named_range">delete_named_range</a></code></li>
<li><code><a title="odfdo.table.Table.delete_row" href="#odfdo.table.Table.delete_row">delete_row</a></code></li>
<li><code><a title="odfdo.table.Table.displayed" href="#odfdo.table.Table.displayed">displayed</a></code></li>
<li><code><a title="odfdo.table.Table.extend_rows" href="#odfdo.table.Table.extend_rows">extend_rows</a></code></li>
<li><code><a title="odfdo.table.Table.get_cell" href="#odfdo.table.Table.get_cell">get_cell</a></code></li>
<li><code><a title="odfdo.table.Table.get_cells" href="#odfdo.table.Table.get_cells">get_cells</a></code></li>
<li><code><a title="odfdo.table.Table.get_column" href="#odfdo.table.Table.get_column">get_column</a></code></li>
<li><code><a title="odfdo.table.Table.get_column_cells" href="#odfdo.table.Table.get_column_cells">get_column_cells</a></code></li>
<li><code><a title="odfdo.table.Table.get_column_values" href="#odfdo.table.Table.get_column_values">get_column_values</a></code></li>
<li><code><a title="odfdo.table.Table.get_columns" href="#odfdo.table.Table.get_columns">get_columns</a></code></li>
<li><code><a title="odfdo.table.Table.get_named_range" href="#odfdo.table.Table.get_named_range">get_named_range</a></code></li>
<li><code><a title="odfdo.table.Table.get_named_ranges" href="#odfdo.table.Table.get_named_ranges">get_named_ranges</a></code></li>
<li><code><a title="odfdo.table.Table.get_row" href="#odfdo.table.Table.get_row">get_row</a></code></li>
<li><code><a title="odfdo.table.Table.get_row_values" href="#odfdo.table.Table.get_row_values">get_row_values</a></code></li>
<li><code><a title="odfdo.table.Table.get_rows" href="#odfdo.table.Table.get_rows">get_rows</a></code></li>
<li><code><a title="odfdo.table.Table.get_value" href="#odfdo.table.Table.get_value">get_value</a></code></li>
<li><code><a title="odfdo.table.Table.get_values" href="#odfdo.table.Table.get_values">get_values</a></code></li>
<li><code><a title="odfdo.table.Table.height" href="#odfdo.table.Table.height">height</a></code></li>
<li><code><a title="odfdo.table.Table.insert_cell" href="#odfdo.table.Table.insert_cell">insert_cell</a></code></li>
<li><code><a title="odfdo.table.Table.insert_column" href="#odfdo.table.Table.insert_column">insert_column</a></code></li>
<li><code><a title="odfdo.table.Table.insert_row" href="#odfdo.table.Table.insert_row">insert_row</a></code></li>
<li><code><a title="odfdo.table.Table.is_column_empty" href="#odfdo.table.Table.is_column_empty">is_column_empty</a></code></li>
<li><code><a title="odfdo.table.Table.is_empty" href="#odfdo.table.Table.is_empty">is_empty</a></code></li>
<li><code><a title="odfdo.table.Table.is_row_empty" href="#odfdo.table.Table.is_row_empty">is_row_empty</a></code></li>
<li><code><a title="odfdo.table.Table.iter_values" href="#odfdo.table.Table.iter_values">iter_values</a></code></li>
<li><code><a title="odfdo.table.Table.name" href="#odfdo.table.Table.name">name</a></code></li>
<li><code><a title="odfdo.table.Table.print_ranges" href="#odfdo.table.Table.print_ranges">print_ranges</a></code></li>
<li><code><a title="odfdo.table.Table.printable" href="#odfdo.table.Table.printable">printable</a></code></li>
<li><code><a title="odfdo.table.Table.protected" href="#odfdo.table.Table.protected">protected</a></code></li>
<li><code><a title="odfdo.table.Table.protection_key" href="#odfdo.table.Table.protection_key">protection_key</a></code></li>
<li><code><a title="odfdo.table.Table.rstrip" href="#odfdo.table.Table.rstrip">rstrip</a></code></li>
<li><code><a title="odfdo.table.Table.set_cell" href="#odfdo.table.Table.set_cell">set_cell</a></code></li>
<li><code><a title="odfdo.table.Table.set_cell_image" href="#odfdo.table.Table.set_cell_image">set_cell_image</a></code></li>
<li><code><a title="odfdo.table.Table.set_cells" href="#odfdo.table.Table.set_cells">set_cells</a></code></li>
<li><code><a title="odfdo.table.Table.set_column" href="#odfdo.table.Table.set_column">set_column</a></code></li>
<li><code><a title="odfdo.table.Table.set_column_cells" href="#odfdo.table.Table.set_column_cells">set_column_cells</a></code></li>
<li><code><a title="odfdo.table.Table.set_column_values" href="#odfdo.table.Table.set_column_values">set_column_values</a></code></li>
<li><code><a title="odfdo.table.Table.set_named_range" href="#odfdo.table.Table.set_named_range">set_named_range</a></code></li>
<li><code><a title="odfdo.table.Table.set_row" href="#odfdo.table.Table.set_row">set_row</a></code></li>
<li><code><a title="odfdo.table.Table.set_row_cells" href="#odfdo.table.Table.set_row_cells">set_row_cells</a></code></li>
<li><code><a title="odfdo.table.Table.set_row_values" href="#odfdo.table.Table.set_row_values">set_row_values</a></code></li>
<li><code><a title="odfdo.table.Table.set_span" href="#odfdo.table.Table.set_span">set_span</a></code></li>
<li><code><a title="odfdo.table.Table.set_value" href="#odfdo.table.Table.set_value">set_value</a></code></li>
<li><code><a title="odfdo.table.Table.set_values" href="#odfdo.table.Table.set_values">set_values</a></code></li>
<li><code><a title="odfdo.table.Table.size" href="#odfdo.table.Table.size">size</a></code></li>
<li><code><a title="odfdo.table.Table.style" href="#odfdo.table.Table.style">style</a></code></li>
<li><code><a title="odfdo.table.Table.to_csv" href="#odfdo.table.Table.to_csv">to_csv</a></code></li>
<li><code><a title="odfdo.table.Table.transpose" href="#odfdo.table.Table.transpose">transpose</a></code></li>
<li><code><a title="odfdo.table.Table.traverse" href="#odfdo.table.Table.traverse">traverse</a></code></li>
<li><code><a title="odfdo.table.Table.traverse_columns" href="#odfdo.table.Table.traverse_columns">traverse_columns</a></code></li>
<li><code><a title="odfdo.table.Table.width" href="#odfdo.table.Table.width">width</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>